--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.5
-- Dumped by pg_dump version 9.6.20

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: asignar_unidad_id_tablas_dtalle(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.asignar_unidad_id_tablas_dtalle() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	fila record;
	fila2 record;
	fila3 record;
	fila4 record;
	fila5 record;
	fila6 record;
	fila7 record;
	
	cadena_sql character varying;
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;


	--Obtiene lista de de productos de la tabla poc_pedidos_detalle
	cadena_sql:='SELECT id, inv_prod_id, 0::integer AS unidad_id FROM poc_pedidos_detalle ORDER BY inv_prod_id;';
	FOR fila IN EXECUTE(cadena_sql) LOOP
		SELECT unidad_id FROM inv_prod WHERE id=fila.inv_prod_id INTO fila.unidad_id;
		IF fila.unidad_id IS NULL THEN fila.unidad_id:=0; END IF;
		UPDATE poc_pedidos_detalle SET inv_prod_unidad_id=fila.unidad_id WHERE id=fila.id;
	END LOOP;

	
	cadena_sql:='';
	--Obtiene lista de de productos de la tabla erp_prefacturas_detalles
	cadena_sql:='SELECT id, producto_id, 0::integer AS unidad_id FROM erp_prefacturas_detalles ORDER BY producto_id;';
	FOR fila2 IN EXECUTE(cadena_sql) LOOP
		SELECT unidad_id FROM inv_prod WHERE id=fila2.producto_id INTO fila2.unidad_id;
		IF fila2.unidad_id IS NULL THEN fila2.unidad_id:=0; END IF;
		UPDATE erp_prefacturas_detalles SET inv_prod_unidad_id=fila2.unidad_id WHERE id=fila2.id;
	END LOOP;
	
	cadena_sql:='';
	--Obtiene lista de de productos de la tabla fac_rems_detalles
	cadena_sql:='SELECT id, inv_prod_id, 0::integer AS unidad_id FROM fac_rems_detalles ORDER BY inv_prod_id;';
	FOR fila3 IN EXECUTE(cadena_sql) LOOP
		SELECT unidad_id FROM inv_prod WHERE id=fila3.inv_prod_id INTO fila3.unidad_id;
		IF fila3.unidad_id IS NULL THEN fila3.unidad_id:=0; END IF;
		UPDATE fac_rems_detalles SET inv_prod_unidad_id=fila3.unidad_id WHERE id=fila3.id;
	END LOOP;
	
	cadena_sql:='';
	--Obtiene lista de de productos de la tabla fac_docs_detalles
	cadena_sql:='SELECT id, inv_prod_id, 0::integer AS unidad_id FROM fac_docs_detalles ORDER BY inv_prod_id;';
	FOR fila4 IN EXECUTE(cadena_sql) LOOP
		SELECT unidad_id FROM inv_prod WHERE id=fila4.inv_prod_id INTO fila4.unidad_id;
		IF fila4.unidad_id IS NULL THEN fila4.unidad_id:=0; END IF;
		UPDATE fac_docs_detalles SET inv_prod_unidad_id=fila4.unidad_id WHERE id=fila4.id;
	END LOOP;

	
	cadena_sql:='';
	--Obtiene lista de de productos de la tabla fac_nota_credito_det
	cadena_sql:='SELECT id, inv_prod_id, 0::integer AS unidad_id FROM fac_nota_credito_det ORDER BY inv_prod_id;';
	FOR fila5 IN EXECUTE(cadena_sql) LOOP
		SELECT unidad_id FROM inv_prod WHERE id=fila5.inv_prod_id INTO fila5.unidad_id;
		IF fila5.unidad_id IS NULL THEN fila5.unidad_id:=0; END IF;
		UPDATE fac_nota_credito_det SET inv_prod_unidad_id=fila5.unidad_id WHERE id=fila5.id;
	END LOOP;
	
	
	cadena_sql:='';
	--Obtiene lista de de productos de la tabla inv_odev_detalle
	cadena_sql:='
	SELECT inv_odev_detalle.id, inv_osal_detalle.inv_prod_id, 0::integer AS unidad_id 
	FROM inv_odev_detalle 
	JOIN inv_osal_detalle ON inv_osal_detalle.id=inv_odev_detalle.inv_osal_detalle_id
	ORDER BY inv_osal_detalle.inv_prod_id;';
	FOR fila6 IN EXECUTE(cadena_sql) LOOP
		SELECT unidad_id FROM inv_prod WHERE id=fila6.inv_prod_id INTO fila6.unidad_id;
		IF fila6.unidad_id IS NULL THEN fila6.unidad_id:=0; END IF;
		UPDATE inv_odev_detalle SET inv_prod_unidad_id=fila6.unidad_id WHERE id=fila6.id;
	END LOOP;
	


	cadena_sql:='';
	--Obtiene lista de de productos de la tabla inv_osal_detalle
	cadena_sql:='SELECT id, inv_prod_id, 0::integer AS unidad_id FROM inv_osal_detalle ORDER BY inv_prod_id;';
	FOR fila7 IN EXECUTE(cadena_sql) LOOP
		SELECT unidad_id FROM inv_prod WHERE id=fila7.inv_prod_id INTO fila7.unidad_id;
		IF fila7.unidad_id IS NULL THEN fila7.unidad_id:=0; END IF;
		UPDATE inv_osal_detalle SET inv_prod_unidad_id=fila7.unidad_id WHERE id=fila7.id;
	END LOOP;




	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: calcula_importe_facturado(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calcula_importe_facturado(importe double precision, tc_facturado double precision, importe_facturado double precision) RETURNS double precision
    LANGUAGE plpgsql
    AS $$


BEGIN	


	importe_facturado := importe * tc_facturado;
	
	RETURN round(importe_facturado::numeric,2);
	
END;

$$;


--
-- Name: calcula_insoluto(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calcula_insoluto(saldo_factura double precision, total_pagos double precision, cantidad double precision, importe_insoluto double precision) RETURNS double precision
    LANGUAGE plpgsql
    AS $$


BEGIN	

	importe_insoluto := saldo_factura + total_pagos - cantidad;
	
	RETURN round(importe_insoluto::numeric,2);
	
END;

$$;


--
-- Name: calcula_monto_aplicado(integer, integer, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calcula_monto_aplicado(moneda_factura integer, moneda_pagos integer, tc_pagos double precision, importe_pagado double precision, monto_aplicado_mn double precision) RETURNS double precision
    LANGUAGE plpgsql
    AS $$


--DECLARE
--	importe_pagado double precision = 0.00;
--	monto_factura double precision = 0.00;
--	tc double precision = 1.0000;
BEGIN	

	if moneda_factura = 1 then
		if moneda_pagos = 1 then
			monto_aplicado_mn := importe_pagado;
		else
			monto_aplicado_mn := importe_pagado / tc_pagos;
		end if;
	else
		if moneda_pagos = 1 then
			monto_aplicado_mn := importe_pagado * tc_pagos;
		else
			monto_aplicado_mn := importe_pagado;
		end if;
	end if;
	
	RETURN round(monto_aplicado_mn::numeric,2);
	
END;

$$;


--
-- Name: calcula_tc_dr(double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calcula_tc_dr(importe_pagado double precision, monto_factura double precision, tipo_cambio_dr double precision) RETURNS double precision
    LANGUAGE plpgsql
    AS $$


--DECLARE
--	importe_pagado double precision = 0.00;
--	monto_factura double precision = 0.00;
--	tc double precision = 1.0000;
BEGIN	
	
	if importe_pagado is null or monto_factura is null then
		tipo_cambio_dr:=0;
	else	
		if monto_factura = 0 then 
			tipo_cambio_dr:=0;
		else 
			if importe_pagado = 0 then 
				tipo_cambio_dr:=0;
			else 
				tipo_cambio_dr := importe_pagado/monto_factura; 
			end if; 
		end if;	
	END if;

	
	
	RETURN round(tipo_cambio_dr::numeric,6);
	
END;

$$;


--
-- Name: carga_almacenes_inv_exi_con_productos(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.carga_almacenes_inv_exi_con_productos(id_empresa integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	espacio_tiempo_ejecucion timestamp with time zone := now();
	fila record;
	fila2 record;
	cadena_sql character varying;
	cadena_sql2 character varying;
	exis integer := 0;
	ano_actual integer := 0;
	mes_actual integer := 0;
BEGIN

	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	
	--obtiene lista de todos los prooductos
	cadena_sql:='SELECT DISTINCT inv_alm.id AS id_alm FROM inv_alm JOIN inv_suc_alm ON inv_suc_alm.almacen_id = inv_alm.id JOIN gral_suc ON gral_suc.id = inv_suc_alm.sucursal_id WHERE gral_suc.empresa_id='||id_empresa||' AND inv_alm.borrado_logico=FALSE;';
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		--obtiene lista de todos los prooductos
		cadena_sql2:='SELECT id AS id_prod FROM inv_prod WHERE empresa_id='||id_empresa||' AND borrado_logico=FALSE AND tipo_de_producto_id!=3 AND tipo_de_producto_id!=4 ORDER BY id';
		
		FOR fila2 IN EXECUTE(cadena_sql2) LOOP
			exis:=0;
			--Buscar si ya esxiste en inv_exi en el a√±o actual
			
			SELECT count(id) FROM inv_exi WHERE inv_prod_id = fila2.id_prod AND inv_alm_id = fila.id_alm AND ano=ano_actual INTO exis;
			
			IF exis<=0 THEN 
				--Crear registro en inv_exi
				INSERT INTO inv_exi(inv_prod_id, inv_alm_id, ano, exi_inicial, transito) VALUES(fila2.id_prod, fila.id_alm, ano_actual, 0, 0);
			END IF;
		END LOOP;
		
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: carga_inventario_kathion_kemikal(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.carga_inventario_kathion_kemikal(id_empresa integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	fila record;
	fila2 record;
	fila3 record;
	cadena_sql character varying;
	cadena_sql2 character varying;
	exis integer=0;
	--variables para generar consecutivos
	id_tipo_consecutivo integer=0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
	nuevo_lote character varying = '';
	gral_emp integer=0;
	gral_suc integer=0;
	id_almacen integer=0;
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;

	id_tipo_consecutivo:=25;--Consecutivo Numero de Lote
	gral_emp:=id_empresa;

	IF id_empresa=4 THEN 
		gral_suc:=1;
		id_almacen:=1;
	END IF;

	IF id_empresa=7 THEN 
		gral_suc:=2;
		id_almacen:=3;
	END IF;
	
	
	
	/*
	--Resetear existencias de Inventario
	UPDATE inv_exi SET exi_inicial=0, reservado=0, transito=0, entradas_1=0, entradas_2=0, entradas_3=0, entradas_4=0, entradas_5=0, entradas_6=0, entradas_7=0, entradas_8=0, entradas_9=0, entradas_10=0, entradas_11=0, entradas_12=0, salidas_1=0, salidas_2=0, salidas_3=0, salidas_4=0, salidas_5=0, salidas_6=0, salidas_7=0, salidas_8=0, salidas_9=0, salidas_10=0, salidas_11=0, salidas_12=0
	WHERE ano=ano_actual AND inv_alm_id=id_almacen;
	
	--inv_prod_id integer NOT NULL,
	--inv_alm_id integer NOT NULL,


	
	--Resetear existencias de LOTES
	--UPDATE inv_lote SET inicial=0, salidas=0,entradas=0, reservado=0 WHERE inv_alm_id=id_almacen;
	DELETE FROM inv_lote;
	
	--Resetear existencias de presentaciones
	--UPDATE inv_exi_pres SET inicial=0, reservado=0, entradas=0, salidas=0 WHERE inv_alm_id=id_almacen;
	DELETE FROM inv_exi_pres;
	*/


	/*
	--Obtiene lista de productos para cargar inv_exi
	cadena_sql:='
	SELECT 
		inv_prod.id AS id_prod,
		inv_prod.empresa_id,
		1::integer AS id_alm,
		sbt.inv_fisico
	FROM (SELECT codigo, inv_fisico::double precision FROM inv_kat_kem_sep2013  WHERE inv_fisico::double precision>0 AND id_empresa::integer='||id_empresa||') AS sbt
	JOIN inv_prod ON upper(inv_prod.sku)=sbt.codigo
	WHERE inv_prod.empresa_id='||id_empresa||'
	ORDER BY inv_prod.id';
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		fila.id_alm:=id_almacen;
		--Aqui se asignan existencias en INVENTARIO
		select count(id) from inv_exi where inv_prod_id=fila.id_prod AND ano=ano_actual AND inv_alm_id=fila.id_alm INTO exis;
		IF exis > 0 THEN 
			UPDATE inv_exi SET exi_inicial=fila.inv_fisico WHERE inv_prod_id=fila.id_prod AND ano=ano_actual AND inv_alm_id=fila.id_alm;
		ELSE
			INSERT INTO inv_exi (inv_prod_id, inv_alm_id, ano, exi_inicial) VALUES (fila.id_prod,fila.id_alm,ano_actual,fila.inv_fisico );
		END IF;
	END LOOP;
	

	--Obtener lista de productos para crear lotes
	cadena_sql2:='
	SELECT 
		inv_prod.id AS id_prod,
		inv_prod.empresa_id,
		1::integer AS id_alm,
		sbt.lote AS lote_prov,
		''''::character varying AS lote_interno,
		sbt.cant_lote
	FROM (SELECT codigo, lote, cant_lote::double precision FROM inv_kat_kem_sep2013 WHERE cant_lote::double precision>0 AND id_empresa::integer='||id_empresa||') AS sbt
	JOIN inv_prod ON upper(inv_prod.sku)=sbt.codigo
	WHERE inv_prod.empresa_id='||id_empresa||'
	ORDER BY inv_prod.id;';
	
	FOR fila2 IN EXECUTE(cadena_sql2) LOOP
		fila2.id_alm:=id_almacen;
		
		--Aqui se asignan existencias en a lotes
		
		--Aqui se genera Nuevo Lote
		--RAISE EXCEPTION '%',fila2.lote_interno;
		--aqui entra para tomar el consecutivo del folio  la sucursal actual
		UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
		WHERE gral_emp_id=gral_emp AND gral_suc_id=gral_suc AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
		
		--convertir a hexadecimal el nuevo consecutivo
		nuevo_lote=to_hex(nuevo_consecutivo);
		
		--agregar ceros a la izquierda para acompletar 10 caracteres con lpad y convertir a mayusculas con upper
		nuevo_lote := upper(lpad(nuevo_lote, 10, '0'));
		
		fila2.lote_interno:=nuevo_lote;
		
		INSERT INTO inv_lote (inv_prod_id, inv_alm_id, inicial, lote_int, lote_prov, caducidad)
		VALUES (fila2.id_prod,fila2.id_alm,fila2.cant_lote, fila2.lote_interno, fila2.lote_prov, '2999-12-31'::date);
	END LOOP;
	*/




	--Obtiene lista de productos para cargar inv_exi_pres
	cadena_sql:='
	SELECT 
		inv_prod.id AS id_prod,
		inv_prod.empresa_id,
		1::integer AS id_alm,
		sbt.id_pres,
		sum(sbt.cant_pres) AS cant_pres
	FROM (SELECT codigo, id_pres::integer, cant_pres::double precision FROM inv_kat_kem_sep2013 WHERE cant_pres::double precision>0 AND id_empresa::integer='||id_empresa||') AS sbt
	JOIN inv_prod ON upper(inv_prod.sku)=sbt.codigo
	WHERE inv_prod.empresa_id='||id_empresa||'
	GROUP BY inv_prod.id, inv_prod.empresa_id, sbt.id_pres
	ORDER BY inv_prod.id;';
	
	FOR fila3 IN EXECUTE(cadena_sql) LOOP
		fila3.id_alm:=id_almacen;
		--Aqui se asignan existencias en INVENTARIO
		select count(id) from inv_exi_pres where inv_prod_id=fila3.id_prod AND inv_prod_presentacion_id=fila3.id_pres AND inv_alm_id=fila3.id_alm 
		INTO exis;
		IF exis > 0 THEN 
			UPDATE inv_exi_pres SET inicial=fila3.cant_pres WHERE inv_prod_id=fila3.id_prod AND inv_prod_presentacion_id=fila3.id_pres AND inv_alm_id=fila3.id_alm;
		ELSE
			INSERT INTO inv_exi_pres (inv_prod_id, inv_alm_id, inv_prod_presentacion_id, inicial, momento_creacion) VALUES (fila3.id_prod,fila3.id_alm, fila3.id_pres, fila3.cant_pres, espacio_tiempo_ejecucion );
		END IF;
	END LOOP;


	


	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: carga_tabla_cost_prom_productos(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.carga_tabla_cost_prom_productos(id_empresa integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	fila record;
	fila_pres record;
	cadena_sql character varying;
	exis integer=0;
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--obtiene lista de todos los prooductos
	cadena_sql:='SELECT id AS id_prod FROM inv_prod WHERE empresa_id='||id_empresa||'  AND borrado_logico=FALSE AND tipo_de_producto_id !=3 AND tipo_de_producto_id !=4 ORDER BY id';
	
	FOR fila IN EXECUTE(cadena_sql) LOOP

		select count(id) from inv_prod_cost_prom where inv_prod_id=fila.id_prod AND ano=ano_actual  INTO exis;
		
		IF exis <= 0 THEN 
			INSERT INTO inv_prod_cost_prom (inv_prod_id, ano) VALUES (fila.id_prod,ano_actual);
		END IF;
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: carga_tabla_inv_prod_costos(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.carga_tabla_inv_prod_costos(id_empresa integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	fila record;
	fila_pres record;
	cadena_sql character varying;
	cadena_sql2 character varying;
BEGIN

	--obtiene lista de todos los prooductos
	cadena_sql:='SELECT id AS id_prod FROM inv_prod WHERE empresa_id='||id_empresa||' AND borrado_logico=FALSE AND tipo_de_producto_id !=3 AND tipo_de_producto_id !=4 ORDER BY id;';
	
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		--obtiene lista de presentaciones asignadas al producto
		cadena_sql2:='SELECT presentacion_id AS id_pres FROM inv_prod_pres_x_prod WHERE producto_id='||fila.id_prod||' ORDER BY id;';
		
		FOR fila_pres IN EXECUTE(cadena_sql2) LOOP
			INSERT INTO inv_prod_costos (ano, inv_prod_id, inv_prod_presentacion_id, gral_emp_id)VALUES (2013, fila.id_prod,fila_pres.id_pres, id_empresa );
		END LOOP;
		
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
END	
	
$$;


--
-- Name: com_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.com_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

	--estas  variables se utilizan en la mayoria de los catalogos
	str_data text[];
	app_selected integer;
	command_selected text;
	valor_retorno character varying;
	usuario_id integer;
	emp_id integer;
	suc_id integer;
	id_tipo_consecutivo integer=0;
	ultimo_id integer;
	ultimo_id2 integer;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	sql_select character varying = '';
	sql_update character varying = '';
	
	str_filas text[];
	total_filas integer;--total de elementos de arreglo
	cont_fila integer;--contador de filas o posiciones del arreglo

	--variable para orden compra
	ultimo_id_proceso integer = 0;
	id_proceso integer = 0;
	estado integer = 0;
	id_proceso_flujo integer =0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';

	importe_partida double precision = 0;
	impuesto_partida double precision = 0;
	monto_subtotal double precision = 0;
	suma_total double precision = 0;
	monto_impuesto double precision = 0;

	--variables autorizacion de pedidos
	pedido record;
	fila record;
	
	--variables devoluciones a poroveedores
	suma_pagos double precision = 0.0;
	suma_notas_credito  double precision = 0.0;
	saldo_fac_prov double precision = 0.0;
	moneda_factura integer=0;
	tipo_doc integer=0;
	oc character varying = '';
	ultimo_id_osal integer=0;
	identificador_nuevo_movimiento integer=0;
	cost_unitario double precision = 0.0;
	tip_cam double precision = 0.0;

	id_oc_detalle integer =0;

	idPres integer:=0;
	idUniProd integer:=0;
	noDecUnidad integer=0;--numero de decimales permitidos para la unidad
	exisActualPres double precision=0;--existencia actual de la presentacion
	equivalenciaPres double precision=0; --equivalencia de la presentacion en la unidad del producto
	cantPres double precision=0; --Cantidad que se esta Intentando traspasar
	cantPresAsignado double precision=0;
	
	controlExisPres boolean; --Variable que indica  si se debe controlar Existencias por Presentacion
BEGIN
	--convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	--aplicativo seleccionado
	app_selected := str_data[1]::integer;

	command_selected := str_data[2];--new, edit

	-- usuario que utiliza el aplicativo
	usuario_id := str_data[3]::integer;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id;

	--Query para verificar si la Empresa actual incluye control de Existencias por Presentacion
	SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;

	valor_retorno:='0';
	
	--aplicativo Orden de Compra
	IF app_selected = 90 THEN
		IF command_selected = 'new' THEN
			--str_data[3]	id_usuario            
			--str_data[4]	id_orden_compra              
			--str_data[5] 	id_proveedor             
			--str_data[6]	observaciones          
			--str_data[7]	moneda_id        
			--str_data[8]	tipo_cambio            
			--str_data[9]	grupo             
			--str_data[10]	cxcp_prov_credias_id             
			--str_data[11]  consignado a 
			--str_data[12]  tipo embarque_id
			--str_data[13]  fecha_entrega
			--str_data[14]  check_anexar_cert_hojas_seg
			--str_data[15]  tipo_oc
			--str_data[16]  check_lab
			
			INSERT INTO  com_proceso(com_proceso_flujo_id,gral_emp_id,gral_suc_id)VALUES(1,emp_id,suc_id) RETURNING id into ultimo_id_proceso;

			id_tipo_consecutivo:=19;--consecutivo de ORDEN DE COMPRA
			
			--aqui entra para tomar el consecutivo de la orden de compra de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO com_orden_compra(folio,proveedor_id, observaciones, moneda_id, tipo_cambio, grupo, cxp_prov_credias_id, consignado_a, tipo_embarque_id, com_proceso_id, cancelado, borrado_logico, gral_emp_id, gral_suc_id, momento_creacion, gral_usr_id_creacion, fecha_entrega, anexa_documentos, tipo_orden_compra, lab_destino)
			VALUES(nuevo_folio,str_data[5]::integer, str_data[6]::text,  str_data[7]::integer, str_data[8]::double precision, str_data[9]::character varying, str_data[10]::integer, str_data[11]::character varying, str_data[12]::integer, ultimo_id_proceso, false, false, emp_id, suc_id, espacio_tiempo_ejecucion, str_data[3]::integer, str_data[13]::timestamp with time zone, str_data[14]::boolean, str_data[15]::integer, str_data[16]::boolean)
			RETURNING id INTO ultimo_id;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer <> 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					--str_filas[8]	valor_impuesto
					--str_filas[9]	id_req
					--str_filas[10]	id_det_req

					ultimo_id2:=0;
					
					INSERT INTO com_orden_compra_detalle(com_orden_compra_id,inv_prod_id,presentacion_id,gral_imp_id,cantidad,precio_unitario,valor_imp)
					VALUES(ultimo_id, str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::integer,str_filas[6]::double precision,str_filas[7]::double precision,str_filas[8]::double precision )
					RETURNING id INTO ultimo_id2;
					
					importe_partida := str_filas[6]::double precision * str_filas[7]::double precision;
					impuesto_partida := importe_partida * str_filas[8]::double precision;
					monto_subtotal := monto_subtotal + importe_partida;
					monto_impuesto := monto_impuesto + impuesto_partida;
					
					IF trim(str_filas[9])<>'' THEN 
						IF str_filas[9]::integer >0 THEN 
							--Crear registro que relaciona la orden de Compra con la Requisicion si es que existe.
							INSERT INTO com_oc_requisicion(com_oc_req_id, com_oc_req_det_id, com_orden_compra_det_id) VALUES(str_filas[9]::integer, str_filas[10]::integer, ultimo_id2);
							
							UPDATE com_oc_req set status=1 where id=str_filas[9]::integer;
							UPDATE com_oc_req_detalle set com_oc_det_id=ultimo_id2, status=true where id=str_filas[10]::integer;
						END IF;
					END IF;
				END IF;
			END LOOP;
			--calcula el monto de la orden de compra
			suma_total:= monto_subtotal + monto_impuesto;  --   - total_retencion;
			
			--actualiza campos subtotal, impuesto, retencion, total de tabla com_orden_compra
			UPDATE com_orden_compra SET subtotal=monto_subtotal, impuesto=monto_impuesto, total=suma_total
			WHERE id=ultimo_id;
			
			valor_retorno := '1';
		END IF;--termina nuevo orden compra


		
		IF command_selected = 'edit' THEN
			SELECT com_orden_compra.status FROM  com_orden_compra WHERE com_orden_compra.id=str_data[4]::integer INTO estado;
			IF estado=0 THEN 
				UPDATE  com_orden_compra SET proveedor_id=str_data[5]::integer, observaciones=str_data[6]::character varying, moneda_id=str_data[7]::integer, tipo_cambio=str_data[8]::double precision, grupo=str_data[9]::character varying, cxp_prov_credias_id=str_data[10]::integer, consignado_a=str_data[11]::character varying, tipo_embarque_id=str_data[12]::integer, momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id, fecha_entrega=str_data[13]::timestamp with time zone, anexa_documentos=str_data[14]::boolean, lab_destino=str_data[16]::boolean 
				WHERE id=str_data[4]::integer;
				
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					
					--str_filas[1] eliminado
					IF str_filas[1]::integer != 0 THEN --  1: no esta eliminado, 0:eliminado
						--str_filas[2]	iddetalle
						--str_filas[3]	idproducto
						--str_filas[4]	id_presentacion
						--str_filas[5]	id_impuesto
						--str_filas[6]	cantidad
						--str_filas[7]	costo
						--str_filas[8]	valor_impuesto
						
						--crea registros para orden_compra_detalle el id de orden de compra se pasa a o.c_detalle
						IF str_filas[2]::integer = 0 THEN
							--crea registro 
							INSERT INTO com_orden_compra_detalle(com_orden_compra_id,inv_prod_id,presentacion_id,gral_imp_id,cantidad,precio_unitario,valor_imp)
							VALUES (str_data[4]::integer,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::integer,str_filas[6]::double precision,str_filas[7]::double precision,str_filas[8]::double precision );
						ELSE
							--actualiza registro       
							UPDATE com_orden_compra_detalle SET com_orden_compra_id=str_data[4]::integer,inv_prod_id=str_filas[3]::integer,presentacion_id=str_filas[4]::integer,gral_imp_id=str_filas[5]::integer,cantidad=str_filas[6]::double precision,precio_unitario=str_filas[7]::double precision,valor_imp=str_filas[8]::double precision
							WHERE id=str_filas[2]::integer AND com_orden_compra_id=str_data[4]::integer;
						END IF;
						
						importe_partida := str_filas[6]::double precision * str_filas[7]::double precision;
						
						impuesto_partida := importe_partida * str_filas[8]::double precision;
						
						monto_subtotal := monto_subtotal + importe_partida;
						monto_impuesto := monto_impuesto + impuesto_partida;
					ELSE
						--elimina registro que se elimino en el grid
						DELETE FROM com_orden_compra_detalle where id=str_filas[2]::integer  AND com_orden_compra_id=str_data[4]::integer;
					END IF;
				END LOOP;
				
				--calcula el monto 
				suma_total:= monto_subtotal + monto_impuesto; 
				
				--actualiza campos subtotal, impuesto, retencion, total
				UPDATE com_orden_compra SET subtotal=monto_subtotal, impuesto=monto_impuesto, total=suma_total
				WHERE id=str_data[4]::integer;
				valor_retorno := '1';
			ELSE
				IF status=1 THEN 
					valor_retorno := 'La Orden de Compra no pudo ser Actualizada, ya fue autorizada.';
				END IF;
				
				IF status=2 THEN 
					valor_retorno := 'La Orden de Compra no pudo ser Actualizada';
				END IF;
			END IF;
			
		END IF;--termina edit ORDEN DE COMPRA
		
		
		
		
		--Aqui entra cuando la persona que cancela es la misma que hizo 
		IF command_selected = 'cancelar' THEN
			SELECT com_orden_compra.status FROM com_orden_compra WHERE com_orden_compra.id=str_data[4]::integer INTO estado;
			IF estado=0 THEN 
				UPDATE com_orden_compra SET status=2,cancelado=true,momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancelacion=str_data[3]::integer 
				where id=str_data[4]::integer;

				UPDATE com_orden_compra_detalle SET estatus=3, surtir=false WHERE com_orden_compra_id=str_data[4]::integer;
				
				valor_retorno := '1';
			ELSE
				IF estado=1 THEN 
					valor_retorno := 'La Orden de Compra ya fue Autorizada. No se puede Cancelar.';
				END IF;
				
				IF estado=2 THEN 
					valor_retorno := 'La orden de Compra  No se puede Cancelar.';
				END IF;
			END IF;
		END IF;
		
		
		
		
		IF command_selected = 'autorizar' THEN
			SELECT com_orden_compra.status FROM com_orden_compra WHERE com_orden_compra.id=str_data[4]::integer INTO estado;
			IF estado=0 THEN 
				UPDATE com_orden_compra SET status=1,cancelado=false,momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_autoriza=str_data[3]::integer
				where id=str_data[4]::integer;
				valor_retorno := '1';
			ELSE
				IF estado=1 THEN 
					valor_retorno := 'La Orden de Compra ya fue Autorizada. No se puede Cancelar.';
				END IF;
				
				IF estado=2 THEN 
					valor_retorno := 'La Orden de Compra No se puede Cancelar .';
				END IF;
			END IF;
		END IF;
		

		IF command_selected = 'cancelar_partida' THEN
			UPDATE com_orden_compra_detalle SET estatus=3, surtir=false WHERE id=str_data[4]::integer;
			
			SELECT com_orden_compra_id FROM com_orden_compra_detalle WHERE id=str_data[4]::integer INTO ultimo_id;
			
			--Actualizar estatus de la Orden de compra
			IF (SELECT count(id) FROM com_orden_compra_detalle WHERE com_orden_compra_id=ultimo_id AND surtir=true AND estatus IN(0,1))>0 THEN 
				IF (SELECT sum(cant_surtido) FROM com_orden_compra_detalle WHERE com_orden_compra_id=ultimo_id)>0 THEN 
					--3=Surtido Parcial
					UPDATE com_orden_compra SET status=3 WHERE id=ultimo_id;
				END IF;
			ELSE 
				--4=Surtido Completo
				UPDATE com_orden_compra SET status=4 WHERE id=ultimo_id;
			END IF;
			
			IF (select count(id) from com_orden_compra_detalle where estatus<>3AND com_orden_compra_id=ultimo_id)<=0 THEN
				IF (SELECT sum(cant_surtido) FROM com_orden_compra_detalle WHERE com_orden_compra_id=ultimo_id)<=0 THEN 
					--2=Cancelado
					UPDATE com_orden_compra SET status=2, cancelado=true, momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancelacion=usuario_id WHERE id=ultimo_id;
				END IF;
			END IF;
			
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina aplicativo orden de Compra
	
	
	
	
	---aplicativo autorizacion orden compra
	IF app_selected = 91 THEN
		--aqui entra cuando la persona que cancela es la misma que hizo el pedido
		IF command_selected = 'cancelar' THEN
			SELECT com_orden_compra.status FROM com_orden_compra WHERE com_orden_compra.id=str_data[4]::integer INTO estado;
			IF estado=0 THEN 
				UPDATE com_orden_compra SET status=2,cancelado=true,momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancelacion=str_data[3]::integer
				where id=str_data[4]::integer;
				valor_retorno := '1';
			ELSE
				IF estado=1 THEN 
					valor_retorno := 'La Orden de Compra ya fue Autorizada. No se puede Cancelar.';
				END IF;
				
				IF estado=2 THEN 
					valor_retorno := 'La orden de Compra tiene e AUTORIZADA. No se puede Cancelar.';
				END IF;
			END IF;
		END IF;
		---aqui entra cuando la persona autoriza la orden de compra

		IF command_selected = 'autorizar' THEN
			SELECT com_orden_compra.status FROM com_orden_compra WHERE com_orden_compra.id=str_data[4]::integer INTO estado;
			IF estado=0 THEN 
				UPDATE com_orden_compra SET status=1,cancelado=false,momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_autoriza=str_data[3]::integer 
				where id=str_data[4]::integer;
				valor_retorno := '1';
			ELSE
				IF estado=1 THEN 
					valor_retorno := 'La Orden de Compra ya fue Autorizada. No se puede Cancelar.';
				END IF;
				
				IF estado=2 THEN 
					valor_retorno := 'La Orden de Compra ya ha sido AUTORIZADA. No se puede Cancelar.';
				END IF;
			END IF;
		END IF;
		
	END IF;
	--fin autorizacion orden compra
	
	
	
	
	---Aplicativo Devoluciones a Proveedores
	IF app_selected = 102 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id_nota_credito
			--str_data[5]	id_proveedor
			--str_data[6]	id_impuesto
			--str_data[7]	valor_impuesto
			--str_data[8]	observaciones
			--str_data[9]	select_moneda
			--str_data[10]	concepto
			--str_data[11]	tipo_cambio
			--str_data[12]	importe
			--str_data[13]	impuesto
			--str_data[14]	total
			--str_data[15]	factura
			--str_data[16]	fac_saldado
			--str_data[17]	folio_nota_credito
			--str_data[18]	fecha_expedicion
			--str_data[19]	select_tipo_movimiento
			--str_data[20]	select_tipo_nota
			--str_data[21]	select_almacen
			--str_data[22]	ieps
			
			id_tipo_consecutivo:=28;--Folio registro Notas de Credito Proveedores
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			
			INSERT INTO cxp_nota_credito(
				folio,--nuevo_folio,
				cxp_prov_id,--str_data[5]::integer,
				gral_impto_id,--str_data[6]::integer,
				valor_impuesto,--str_data[7]::double precision,
				observaciones,--str_data[8],
				moneda_id,--str_data[9]::integer,
				concepto,--str_data[10],
				tipo_cambio,--str_data[11]::double precision,
				subtotal,--str_data[12]::double precision,
				impuesto,--str_data[13]::double precision,
				total,--str_data[14]::double precision,
				factura,--str_data[15],
				serie_folio,--str_data[17],
				fecha_expedicion,--str_data[18]::date,
				tipo,--str_data[20]::smallint,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion,--usuario_id,
				gral_emp_id,--emp_id,
				gral_suc_id,--suc_id,
				gral_app_id_creacion,--app_selected,
				inv_mov_tipo_id,--str_data[19]::integer,
				inv_alm_id,--str_data[21]::integer
				monto_ieps--str_data[22]::double precision 
			) VALUES (nuevo_folio,str_data[5]::integer,str_data[6]::integer,str_data[7]::double precision,str_data[8],str_data[9]::integer,str_data[10],str_data[11]::double precision,str_data[12]::double precision,str_data[13]::double precision,str_data[14]::double precision,str_data[15],str_data[17],str_data[18]::date,str_data[20]::smallint,espacio_tiempo_ejecucion,usuario_id,emp_id,suc_id,app_selected, str_data[19]::integer, str_data[21]::integer, str_data[22]::double precision)
			RETURNING id INTO ultimo_id;
			
			--***************************************************************************************************************************
			--INICIA CALCULO DE NUEVO SALDO DE LA FACTURA
			--***************************************************************************************************************************
			
			--obtiene suma de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(cxp_pagos_detalles.cantidad) FROM cxp_pagos JOIN cxp_pagos_detalles ON cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id WHERE cxp_pagos_detalles.serie_folio=str_data[15] AND cxp_pagos_detalles.cancelacion=FALSE AND cxp_pagos.cxp_prov_id=str_data[5]::integer ) AS sbt  
			INTO suma_pagos;
			
			--obtiene suma de las notas de credito para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(total) FROM cxp_nota_credito WHERE factura=str_data[15] AND cancelado=FALSE AND cxp_prov_id=str_data[5]::integer ) AS sbt2
			INTO suma_notas_credito;
			
			SELECT saldo_factura  FROM cxp_facturas WHERE serie_folio=str_data[15] AND cxc_prov_id=str_data[5]::integer INTO saldo_fac_prov;
			
			saldo_fac_prov := round((saldo_fac_prov)::numeric,2);
			
			--actualiza pagos de la factura
			IF str_data[14]::double precision < saldo_fac_prov THEN
				--RAISE EXCEPTION '%' ,'Pagado: false '||saldo_fac_prov;
				UPDATE cxp_facturas SET 
					total_pagos=suma_pagos, 
					total_notas_creditos=suma_notas_credito, 
					pagado=false, 
					saldo_factura=round((monto_total - suma_pagos - suma_notas_credito)::numeric,2)::double precision
				WHERE serie_folio=str_data[15] AND cxc_prov_id=str_data[5]::integer;
			ELSE
				--RAISE EXCEPTION '%' ,'Pagado: true '||saldo_fac_prov;
				UPDATE cxp_facturas SET 
					total_pagos=suma_pagos, 
					total_notas_creditos=suma_notas_credito, 
					pagado=true, 
					saldo_factura=0
				WHERE serie_folio=str_data[15] AND cxc_prov_id=str_data[5]::integer;
			END IF;
			
			--TERMINA CALCULO DE SALDO DE LA FACTURA
			--***************************************************************************************************************************
			
			
			--CREA REGISTRO EN TABLA INV_MOV
			INSERT INTO inv_mov(observacion, momento_creacion, gral_usr_id, gral_app_id, inv_mov_tipo_id, referencia, fecha_mov ) 
			VALUES(str_data[10], espacio_tiempo_ejecucion, usuario_id, app_selected, str_data[19]::integer, str_data[17], str_data[18]::timestamp with time zone) 
			RETURNING id INTO identificador_nuevo_movimiento;
			
			
			--***************************************************************************************************************************
			--INICIA CREACION DE REGISTRO EN INV_OSAL
			
			id_tipo_consecutivo:=21; --Folio Orden de Salida
			tipo_doc = 5;--Nota de Credito de proveedor
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--Obtener la Orden de Compra de la factura del proveedor
			SELECT orden_compra, moneda_id FROM cxp_facturas WHERE cxp_facturas.cxc_prov_id=str_data[5]::integer AND cxp_facturas.serie_folio=str_data[15] AND cxp_facturas.tipo_factura_proveedor=1 
			INTO oc, moneda_factura;

			IF moneda_factura=1 THEN 
				tip_cam:=1;
			ELSE
				tip_cam:=str_data[11]::double precision;
			END IF;
			
			
			--Genera registro en tabla inv_osal(Orden de Salida)
			INSERT INTO inv_osal(
				folio,--nuevo_folio,
				estatus,--0,
				erp_proceso_id,--0,
				inv_mov_tipo_id,--str_data[19]::integer,
				tipo_documento,--tipo_doc,
				folio_documento,--str_data[17],
				fecha_exp,--str_data[18]::date,
				gral_app_id,--app_selected,
				cxp_prov_id,--str_data[5]::integer,
				inv_alm_id,--str_data[21]::integer,
				orden_compra,--oc,
				moneda_id,--str_data[9]::integer,
				tipo_cambio,--str_data[11]::double precision,
				subtotal,--str_data[12]::double precision,
				monto_iva,--str_data[13]::double precision,
				monto_total,--str_data[14]::double precision,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion,--usuario_id
				gral_emp_id,--emp_id
				gral_suc_id,--suc_id
				monto_ieps--str_data[22]::double precision
			)
			VALUES(nuevo_folio, 0, 0, str_data[19]::integer, tipo_doc, str_data[17], str_data[18]::date, app_selected, str_data[5]::integer, str_data[21]::integer, oc, str_data[9]::integer, str_data[11]::double precision, str_data[12]::double precision, str_data[13]::double precision,str_data[14]::double precision,espacio_tiempo_ejecucion, usuario_id,emp_id,suc_id, str_data[22]::double precision)
			RETURNING id INTO ultimo_id_osal;
			--TERMINA CREACION DE REGISTRO EN INV_OSAL 
			--***************************************************************************************************************************
			
			
			--***************************************************************************************************************************
			--INICIA DESCUENTO DE EXISTENCIAS EN INV_EXI 
			--CREAR REGISTROS EN COM_FAC_DETALLE_DEV(Detalles de devoluciones), INV_MOV_DETALLE, INV_OSAL_DETALLE
			--***************************************************************************************************************************

			total_filas:= array_length(extra_data,1);
			cont_fila:=1;
			IF extra_data[1] != 'sin datos' THEN
				
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	idproducto
					--str_filas[2]	cantidad
					--str_filas[3]	cant_devuelto
					--str_filas[4]	cant_dev
					--str_filas[5]	notr
					--str_filas[6]	iddetalle
					--str_filas[7]	tasa_imp
					--str_filas[8]	idIeps
					--str_filas[9]	tasaIeps
					
					noDecUnidad:=0;
					idUniProd:=0;
					idPres:=0;
					
					IF trim(str_filas[9])='' THEN 
						str_filas[9]='0';
					ELSE
						IF trim(str_filas[9])::double precision>0 THEN 
							str_filas[9]:=str_filas[9]::double precision/100;
						ELSE
							str_filas[9]='0';
						END IF;
					END IF;
					
					--actualizar suma de devoluciones
					UPDATE com_fac_detalle SET cantidad_devolucion=(cantidad_devolucion + str_filas[4]::double precision) WHERE id=str_filas[6]::integer
					RETURNING costo_unitario, presentacion_id INTO cost_unitario, idPres;

					IF idPres IS NULL THEN idPres:=0; END IF;

					--Obtener el Id de la Unidad de medida del Producto
					SELECT inv_prod.unidad_id,(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec 
					FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=str_filas[1]::integer INTO idUniProd, noDecUnidad;
					
					IF idUniProd IS NULL THEN idUniProd:=0; END IF;
					IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
					
					--cost_unitario := tip_cam * cost_unitario;
					
					--Crear registro en tabla detalle de devoluciones
					INSERT INTO com_fac_detalle_dev(id_cxp_nota_credito,id_com_fac_detalle,cant_dev,tasa_imp, presentacion_id, gral_ieps_id, valor_ieps) 
					VALUES (ultimo_id,str_filas[6]::integer,str_filas[4]::double precision,str_filas[7]::double precision, idPres, str_filas[8]::integer, str_filas[9]::double precision);
					
					--crear registro en INV_MOV_DETALLE
					INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad,costo, inv_prod_presentacion_id)
					VALUES(identificador_nuevo_movimiento,str_data[21]::integer,0,str_filas[1]::integer,str_filas[4]::double precision,cost_unitario, idPres);
					
					--query para descontar existencia de este producto
					sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||str_filas[4]||'),momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
					WHERE inv_alm_id='||str_data[21]||' AND inv_prod_id='||str_filas[1]||' AND ano='||ano_actual;
					EXECUTE sql_update;
					
					--genera registro en INV_OSAL_DETALLE(Ordenes de Salida)
					INSERT INTO inv_osal_detalle(inv_osal_id, inv_prod_id, inv_prod_presentacion_id, cantidad, precio_unitario, inv_prod_unidad_id, gral_ieps_id, valor_ieps)
					VALUES(ultimo_id_osal,str_filas[1]::double precision, idPres, str_filas[4]::double precision,cost_unitario, idUniProd, str_filas[8]::integer, str_filas[9]::double precision);
					
					
					----------------------------------------------------------------------------------------
					--***** INICIA DESCONTAR EXISTENCIA DE PRESENTACIONES ******************************
					--revisar si la configuracion incluye control de Existencias por Presentacion
					IF controlExisPres=TRUE THEN 
						--inicializar valor a cero
						equivalenciaPres:=0;
						cantPres:=0;
						
						--buscar la equivalencia de la Presentacion Origen en la Unidad del Producto
						SELECT cantidad AS equiv_pres FROM inv_prod_presentaciones WHERE id=idPres 
						INTO equivalenciaPres;
						
						IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
						
						--Convertir la Cantidad de Unidades a su equivalencia en Cantidad de Presentaciones
						cantPres := round(str_filas[4]::numeric, noDecUnidad)::double precision / equivalenciaPres::double precision;
						
						--redondear la Cantidad de la Presentacion
						cantPres := round(cantPres::numeric,noDecUnidad)::double precision;
						
						--Descontar existencia de las presentaciones
						UPDATE inv_exi_pres SET salidas=(salidas::double precision + cantPres::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id  
						WHERE inv_alm_id=str_data[21]::integer AND inv_prod_id=str_filas[1]::integer  AND inv_prod_presentacion_id=idPres;
					END IF;
					--Termina descontar existencia de presentaciones
					---------------------------------------------------------------------------------------------------------------------
					
				END LOOP;
				
			END IF;
			--TERMINA DESCUENTO DE EXISTENCIAS EN INV_EXI
			--***************************************************************************************************************************
			
			valor_retorno := '1';

		END IF;
		
	END IF;--termina aplicativo Devoluciones a Proveedores





	--Comienza la Requisicion 
	IF app_selected = 104 THEN
		IF command_selected = 'new' THEN
			--str_data[3]	id_usuario            
			--str_data[4]	id_requisicion              
			--str_data[5]   fecha_compromiso
			--str_data[6]   observaciones
			--str_data[7]   empleado
			--str_data[8]   departamento
			--str_data[9]   folio_pedido
			
			id_tipo_consecutivo:=32;--consecutivo de Requisicion
			
			--aqui entra para tomar el consecutivo de la Requisicion de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

			---- Tipo 1=Requisiciones creadas manualmente, 2=Requisiciones generadas desde un pedido.
			INSERT INTO com_oc_req(folio,fecha_compromiso, observaciones, cancelado, borrado_logico, gral_emp_id, gral_suc_id, momento_creacion, gral_usr_id_creacion, gral_empleado_id, gral_depto_id, folio_pedido, tipo)
			VALUES(nuevo_folio,str_data[5]::timestamp with time zone, str_data[6]::text, false, false, emp_id, suc_id, espacio_tiempo_ejecucion, str_data[3]::integer, str_data[7]::integer, str_data[8]::integer, str_data[9], 1) 
			RETURNING id INTO ultimo_id;
			
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN   --1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	cantidad
					INSERT INTO com_oc_req_detalle(com_oc_req_id,inv_prod_id,presentacion_id,cantidad)
					VALUES(ultimo_id, str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::double precision);
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			SELECT com_oc_req.status FROM  com_oc_req WHERE com_oc_req.id=str_data[4]::integer INTO estado;
			IF estado=0 THEN 
				UPDATE com_oc_req SET fecha_compromiso=str_data[5]:: timestamp with time zone, 
				observaciones=str_data[6]::character varying, momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualizacion=usuario_id,gral_empleado_id=str_data[7]::integer, gral_depto_id=str_data[8]::integer
				WHERE id=str_data[4]::integer;
			
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					
					--str_filas[1] eliminado
					IF str_filas[1]::integer != 0 THEN --  1: no esta eliminado, 0:eliminado
						--str_filas[2]	iddetalle
						--str_filas[3]	idproducto
						--str_filas[4]	id_presentacion
						--str_filas[5]	cantidad
						
						--crea registros para com_oc_req_detalle el id de com_oc_req se pasa a com_oc_req_detalle
						IF str_filas[2]::integer = 0 THEN
							--crea registro 
							INSERT INTO com_oc_req_detalle(com_oc_req_id,inv_prod_id,presentacion_id,cantidad)
							VALUES (str_data[4]::integer,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::double precision);
						ELSE
							--actualiza registro       
							UPDATE com_oc_req_detalle SET com_oc_req_id=str_data[4]::integer,inv_prod_id=str_filas[3]::integer,presentacion_id=str_filas[4]::integer,cantidad=str_filas[5]::double precision
							WHERE id=str_filas[2]::integer AND com_oc_req_id=str_data[4]::integer;
						END IF;
						
					ELSE
						--elimina registro que se elimino en el grid
						DELETE FROM com_oc_req_detalle where id=str_filas[2]::integer  AND com_oc_req_id=str_data[4]::integer;
					END IF;
				END LOOP;
				
				valor_retorno := '1';
				
			ELSE
				IF status=1 THEN 
					valor_retorno := 'La REquisicion de Orden de Compra no pudo ser Actualizada, ya fue autorizada.';
				END IF;
				
				IF status=2 THEN 
					valor_retorno := 'La Requisicion de Orden de Compra no pudo ser Actualizada,ya fue cancelada';
				END IF;
			END IF;
			
		END IF;--termina edit REQUISICION DE ORDEN DE COMPRA
		
		
		
		
		--aqui entra cuando la persona que cancela es la misma que hizo 
		IF command_selected = 'cancelar' THEN
			SELECT com_oc_req.status FROM com_oc_req WHERE com_oc_req.id= str_data[4]::integer INTO estado;
			--0 no se ha cancelado  la  requisicion
			--1    se ha cancelado  la  requisicion
			--3    se ha autorizado la  requisicion
			IF estado=0 THEN 
				UPDATE com_oc_req  SET status=1,cancelado=true,momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancelacion=str_data[3]::integer
				where id=str_data[4]::integer;
				valor_retorno := '1';
			ELSE
				IF estado=1 THEN 
					valor_retorno := 'La Requisicion de  Orden de Compra ya fue cancelada. No se puede Cancelar.';
				END IF;
				
				IF estado=3 THEN 
					valor_retorno := 'La Requisicion de  Orden de Compra ya fue Autorizada. No se puede Cancelar.';
				END IF;
			END IF;
		END IF;
		
		
	END IF;
	--termina aplicativo Requisicion  orden de Compra



	--aplicativo que Autoriza las requisiciones (las convierte en orden de compra).....
	IF app_selected = 107 THEN
		IF command_selected = 'new' THEN
			--str_data[3]	id_usuario            
			--str_data[4]	id_orden_compra              
			--str_data[5] 	id_proveedor         154           
			--str_data[6]	observaciones        AQUI SE ESTAN CONVIERTIENDO LAS REQUISICIONES EN ORDEN DE COMPRA  
			--str_data[7]	moneda_id             1
			--str_data[8]	tipo_cambio           12.2948 
			--str_data[9]	grupo                   a
			--str_data[10]	cxcp_prov_credias_id    1         
			--str_data[11]  consignado a            nosotros mismos
			--str_data[12]  tipo embarque_id         2
			--str_data[13]  subtotal
			--str_data[14]  impuesto                       154___CONVIRTIENDO REQUISICIONES EN ORDEN DE COMPRA___1___12.2948___a___1___nosotrosmismos___2
			--str_data[15]  total                          154 AQUI SE ESTAN CONVIERTIENDO LAS REQUISICIONES EN ORDEN DE COMPRA112.2948a1nosotros mismos1
			--RAISE EXCEPTION '%' ,'datos de de la cadena'||str_data[5]||'___'||str_data[6]||'___'||str_data[7]||'___'||str_data[8]||'___'||str_data[9]||'___'||str_data[10]||'___'||str_data[11]||'___'||str_data[12];
			INSERT INTO  com_proceso(com_proceso_flujo_id,gral_emp_id,gral_suc_id)VALUES(1,emp_id,suc_id) RETURNING id into ultimo_id_proceso;

			id_tipo_consecutivo:=19;--consecutivo de ORDEN DE COMPRA
			
			--aqui entra para tomar el consecutivo de la orden de compra de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;

			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO com_orden_compra(folio,proveedor_id,observaciones, moneda_id, tipo_cambio, grupo, cxp_prov_credias_id,consignado_a,tipo_embarque_id ,com_proceso_id ,cancelado ,borrado_logico ,gral_emp_id ,gral_suc_id ,momento_creacion ,gral_usr_id_creacion,tipo_orden_compra)
			VALUES(nuevo_folio,str_data[5]::integer,str_data[6]::text,str_data[7]::integer,str_data[8]::double precision,str_data[9]::character varying,str_data[10]::integer,str_data[11]::character varying,str_data[12]::integer,ultimo_id_proceso,false,false,emp_id,suc_id,espacio_tiempo_ejecucion,str_data[3]::integer,1) 
			RETURNING id INTO ultimo_id;
			--  0  = orden de compra generada directa  1 = orden generada a partir de una o varias requisiciones
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					--str_filas[8]	valor_impuesto
					
					INSERT INTO com_orden_compra_detalle(com_orden_compra_id,inv_prod_id,presentacion_id,gral_imp_id,cantidad,precio_unitario,valor_imp)
					VALUES(ultimo_id, str_filas[2]::integer,str_filas[3]::integer,0,str_filas[4]::double precision,str_filas[5]::double precision,str_filas[6]::double precision ) 
					RETURNING id into id_oc_detalle;
					
					UPDATE com_oc_req_detalle set com_oc_det_id = id_oc_detalle, status = true
					WHERE inv_prod_id=str_filas[2]::integer and com_oc_req_detalle.com_oc_det_id = 0;
					
					importe_partida := str_filas[4]::double precision * str_filas[5]::double precision;
					
					impuesto_partida := importe_partida * str_filas[6]::double precision;
					monto_subtotal := monto_subtotal + importe_partida;
					monto_impuesto := monto_impuesto + impuesto_partida;
				END IF;
			END LOOP;
			
			--calcula el monto de la orden de compra
			suma_total:= monto_subtotal + monto_impuesto;  -- total_retencion;
			
			--actualiza campos subtotal, impuesto, retencion, total de tabla com_orden_compra
			UPDATE com_orden_compra SET subtotal=monto_subtotal, 
						    impuesto=monto_impuesto, 
						    --monto_retencion=total_retencion, 
						    total=suma_total
			WHERE id=ultimo_id;
			
			valor_retorno := '1';
		END IF;--termina nuevo.
	END IF;--termina aplicativo que pasa una o varias Requisiones a una Orden de Compra
		


















	
	RETURN valor_retorno;
	
END;$$;


--
-- Name: conversion_costo_para_lista_precio(double precision, double precision, double precision, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.conversion_costo_para_lista_precio(costo double precision, tc_usd double precision, tc_eur double precision, moneda_lista integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

--costo: El costo siempre debe venir en M.N.
--tc_usd: √âste es el tipo de cambio para convertir el costo en USD si la moneda_lista=2
--tc_eur: √âste es el tipo de cambio para convertir el costo en EUR si la moneda_lista=3
--moneda_lista: √âste es la moneda de la Lista de Precio

DECLARE
	costo_convertido double precision = 0.0;
	tc double precision = 1.0000;
BEGIN	
	
	IF moneda_lista != 0 THEN 
		IF moneda_lista = 2 THEN tc := tc_usd; END IF;
		IF moneda_lista = 3 THEN tc := tc_eur; END IF;
	END IF;
	
	costo_convertido := costo/tc; 
	
	RETURN costo_convertido;
	
END;

$$;


--
-- Name: copiar_costos_feb2013_ene2013(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.copiar_costos_feb2013_ene2013(id_empresa integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	fila record;
	cadena_sql character varying;
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--obtiene lista de todos los prooductos
	cadena_sql:='
	SELECT 
		inv_prod_cost_prom.ano,
		inv_prod_cost_prom.inv_prod_id,
		inv_prod_cost_prom.costo_ultimo_2,
		(CASE WHEN inv_prod_cost_prom.gral_mon_id_2=0 THEN 1 WHEN inv_prod_cost_prom.gral_mon_id_2=1 THEN 1 WHEN inv_prod_cost_prom.gral_mon_id_2=2 THEN (CASE WHEN inv_prod_cost_prom.tipo_cambio_2>0 THEN inv_prod_cost_prom.tipo_cambio_2 ELSE 12.7408 END) ELSE 0 END) AS tipo_cambio_2,
		(CASE WHEN inv_prod_cost_prom.gral_mon_id_2=0 THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_2 END) AS gral_mon_id_2
	FROM inv_prod_cost_prom
	JOIN inv_prod ON inv_prod.id=inv_prod_cost_prom.inv_prod_id
	WHERE inv_prod.empresa_id='||id_empresa||' AND inv_prod_cost_prom.ano=2013';
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		UPDATE inv_prod_cost_prom SET costo_ultimo_1=fila.costo_ultimo_2,tipo_cambio_1=fila.tipo_cambio_2, gral_mon_id_1=fila.gral_mon_id_2 
		WHERE ano=fila.ano AND inv_prod_id=fila.inv_prod_id;
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;

	--Ejecutar con esta linea
	--select * from copiar_costos_feb2013_ene2013(4);
END	
	
$$;


--
-- Name: crear_historial_subensambles(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.crear_historial_subensambles(id_empresa integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	fila record;
	fila_pres record;
	cadena_sql character varying;
	cadena_sql2 character varying;
	exis integer=0;
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;

	--Actualizar registros de la tabla
	update inv_ord_subensamble_detalle set inv_prod_unidad_id=(select inv_prod_unidades.id from inv_prod_unidades where inv_prod_unidades.titulo ilike '%KILO%' limit 1) where inv_prod_unidad_id=0 or inv_prod_unidad_id is null;
	update inv_ord_subensamble_detalle set densidad=(select inv_prod.densidad from inv_prod where inv_prod.id=inv_ord_subensamble_detalle.inv_prod_id_subensamble limit 1) where densidad=0 or densidad is null;
	
	--Obtiene los datos de las formulas de las OP generadas de subensambles
	cadena_sql:='
	select 
		inv_ord_subensamble.id as inv_ord_subensamble_id,
		inv_ord_subensamble_detalle.id as detalle_id,
		inv_kit.producto_elemento_id, 
		inv_prod.inv_prod_presentacion_id as pres_def_id,
		inv_prod.densidad,
		inv_kit.cantidad 
	from inv_ord_subensamble 
	join inv_ord_subensamble_detalle on inv_ord_subensamble_detalle.inv_ord_subensamble_id=inv_ord_subensamble.id 
	join inv_kit on inv_kit.producto_kit_id=inv_ord_subensamble_detalle.inv_prod_id_subensamble 
	join inv_prod on inv_prod.id=inv_kit.producto_elemento_id 
	where inv_ord_subensamble.gral_emp_id='||id_empresa||' 
	order by inv_ord_subensamble.id, inv_ord_subensamble_detalle.id, inv_kit.id;';
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		select count(id) from inv_ord_subensamble_detalle_formula where inv_ord_subensamble_id=fila.inv_ord_subensamble_id and inv_ord_subensamble_detalle_id=fila.detalle_id and inv_prod_id=fila.producto_elemento_id 
		INTO exis;
		
		IF exis <= 0 THEN 
			--Guardar historico de la formula utilizada
			insert into inv_ord_subensamble_detalle_formula(inv_ord_subensamble_id, inv_ord_subensamble_detalle_id,inv_prod_id,inv_prod_presentacion_id,densidad,cantidad_kg)
			values(fila.inv_ord_subensamble_id, fila.detalle_id,fila.producto_elemento_id,fila.pres_def_id,fila.densidad,fila.cantidad);
		END IF;
		
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: crear_presentaciones_unidad_producto(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.crear_presentaciones_unidad_producto(id_empresa integer, id_suc integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	fila record;
	fila_pres record;
	fila_uni record;
	cadena_sql character varying;
	cadena_sql_producto character varying;
	cadena_sql_unidad character varying;
	exis integer=0;
	id_pres integer=0;
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;

	/*
	--query para buscar unidades
	cadena_sql_unidad:='SELECT inv_prod_unidades.titulo AS unidad FROM inv_prod_unidades WHERE inv_prod_unidades.borrado_logico=false;';
	
	FOR fila_uni IN EXECUTE(cadena_sql_unidad) LOOP
		select count(id) from inv_prod_presentaciones where titulo ILIKE '%'||fila_uni.unidad||'%' AND  borrado_logico=FALSE  AND gral_emp_id=id_empresa 
		INTO exis; 
		
		IF exis <= 0 THEN 
			--aqui se crean presentaciones con el mismo nombre de cada unidad de Medida
			INSERT INTO inv_prod_presentaciones(titulo, cantidad, momento_creacion, gral_emp_id)
			VALUES (fila_uni.unidad, 1, espacio_tiempo_ejecucion,id_empresa  );
		END IF;
	END LOOP;
	*/
	
	--obtiene lista de todos los prooductos
	cadena_sql_producto:='
	SELECT inv_prod.id AS id_prod, inv_prod_unidades.titulo AS unidad
	FROM inv_prod 
	JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
	WHERE inv_prod.empresa_id='||id_empresa||'  
	AND inv_prod.borrado_logico=FALSE 
	AND inv_prod.tipo_de_producto_id !=3 
	AND inv_prod.tipo_de_producto_id !=4 ORDER BY inv_prod.id';
	
	FOR fila IN EXECUTE(cadena_sql_producto) LOOP
		--buscar si una presentacion con el mismo nombre que la Unidad ya esta Asignada al Producto
		SELECT count(inv_prod_pres_x_prod.presentacion_id)
		FROM inv_prod_pres_x_prod
		JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
		WHERE  inv_prod_pres_x_prod.producto_id=fila.id_prod
		AND inv_prod_presentaciones.titulo ILIKE '%'||fila.unidad||'%' 
		INTO exis;

		--obtener el id de la presentacion que se llama igual que la Unidad
		SELECT id FROM inv_prod_presentaciones 
		WHERE titulo ILIKE '%'||fila.unidad||'%' AND  borrado_logico=FALSE
		--  AND gral_emp_id=id_empresa 
		INTO id_pres;
		
		IF exis <= 0 THEN 
			--si exis=0, entonces  hay que asignar esa presentacion que se llama igual que la unidad de medida
			IF id_pres IS NOT NULL THEN
				INSERT INTO inv_prod_pres_x_prod (producto_id, presentacion_id) VALUES (fila.id_prod,id_pres);
			END IF;
		END IF;
		
		IF id_pres IS NOT NULL THEN
			--asignar la presentacion default
			UPDATE inv_prod SET inv_prod_presentacion_id=id_pres WHERE id=fila.id_prod;
		END IF;
		
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: crm_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.crm_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$


DECLARE
	app_selected integer;
	command_selected text;
	usuario_ejecutor integer;
	emp_id integer;
	suc_id integer;
	str_data text[];
	str_filas text[];
	valor_retorno character varying := ''; 
	iter_y integer;--contador de filas o posiciones del arreglo (iterador eje y del arreglo iterado)
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	ultimo_id integer :=0;
	id_caso integer :=0;
	fecha1 date;
	fecha2 date;
	
	id_tipo_consecutivo integer := 0;
	prefijo_consecutivo character varying := '';
	nuevo_consecutivo bigint:=0;
	nuevo_folio character varying := '';
BEGIN
	
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- aplicativo que manda a llamar este procedimiento almacenado
	app_selected := str_data[1]::integer;
	
	-- comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	-- usuario que utiliza el aplicativo
	usuario_ejecutor := str_data[3]::integer;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	INTO emp_id, suc_id;


	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;


	--catalogo de registro de llamadas
	IF app_selected = 114 THEN
		/*app_selected//1 --str_data[1]
		+"___"+command_selected//2 --str_data[2]
		+"___"+id_usuario//3 --str_data[3]
		+"___"+identificador//4 --str_data[4]
		+"___"+select_agente//5 --str_data[5]
		+"___"+id_contacto//6 --str_data[6]
		+"___"+fecha_registro//7 --str_data[7]
		+"___"+hora_registro//8 --str_data[8]
		+"___"+duracion_llamada//9 --str_data[9]
		+"___"+select_motivo_llamada//10 --str_data[10]
		+"___"+calificacion//11 --str_data[11]
		+"___"+select_tipo_seguimiento//12 --str_data[12]
		+"___"+select_consiguio_cita//13 --str_data[13]
		+"___"+select_llamada_completa//14 --str_data[14]
		+"___"+select_llamada_planeada//15 --str_data[15]
		+"___"+select_tipo_llamada//16 --str_data[16]
		+"___"+resultado_llamada//17 --str_data[17]
		+"___"+comentarios//18  --str_data[18]
		+"___"+observaciones//19 --str_data[19]
		+"___"+fecha_cita_proxima//20 --str_data[20]
		+"___"+hora_prox_cita;//21 --str_data[21]
		*/
		IF command_selected = 'new' THEN
			
			id_tipo_consecutivo:=37;--Folio Registro Visitas(CRM)
			
			--aqui entra para tomar el consecutivo del folio de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO crm_registro_llamadas(
				  folio,--nuevo_folio,
				  gral_empleado_id,--str_data[5]
				  fecha,--str_data[7]
				  hora ,--str_data[8]
				  duracion,  --str_data[9]
				  crm_motivos_llamda_id ,--str_data[10]
				  crm_contacto_id,--str_data[6]
				  crm_calificacion_llamada_id,--str_data[11]
				  crm_tipos_seguimiento_llamada_id ,--str_data[12]
				  deteccion_oportunidad, --str_data[13]
				  llamada_completada,--str_data[14]
				  llamada_planeada ,--str_data[15]
				  tipo_llamada,--str_data[16]
				  resultado ,--str_data[17]
				  observaciones ,--str_data[18]
				  fecha_sig_llamada ,--str_data[20]
				  hora_sig_llamada ,--str_data[21]
				  comentarios_sig_llamada ,--str_data[19]
				  
				  borrado_logico,--false,
				  momento_creacion,--espacio_tiempo_ejecucion,
				  gral_usr_id_creacion,--usuario_ejecutor,
				  gral_emp_id,--emp_id,
				  gral_suc_id--suc_id
			)
			VALUES(
				nuevo_folio,
				str_data[5]::integer,
				str_data[7]::date,
				str_data[8]::time with time zone,
				str_data[9]::time with time zone,
				str_data[10]::integer,
				str_data[6]::integer,
				str_data[11]::integer,
				str_data[12]::integer,
				str_data[13]::smallint,
				str_data[14]::smallint,
				str_data[15]::smallint,
				str_data[16]::smallint,
				str_data[17]::character varying,
				str_data[18]::character varying,
				(CASE WHEN str_data[20]='' THEN '2999-12-31' ELSE str_data[20]::date END), 
				str_data[21]::time with time zone,
				str_data[19]::character varying,
				false,
				espacio_tiempo_ejecucion,
				usuario_ejecutor,
				emp_id,
				suc_id
			);
			
			valor_retorno := '1';
		END IF;--termina nuevo
		
		
		IF command_selected = 'edit' THEN
			UPDATE crm_registro_llamadas SET 
				gral_empleado_id=str_data[5]::integer,
				  fecha=str_data[7]::date,
				  hora =str_data[8]::time with time zone,
				  duracion=str_data[9]::time with time zone,
				  crm_motivos_llamda_id=str_data[10]::integer,
				  crm_contacto_id=str_data[6]::integer,
				  crm_calificacion_llamada_id=str_data[11]::integer,
				  crm_tipos_seguimiento_llamada_id=str_data[12]::integer,
				  deteccion_oportunidad=str_data[13]::smallint,
				  llamada_completada=str_data[14]::smallint,
				  llamada_planeada=str_data[15]::smallint,
				  tipo_llamada=str_data[16]::smallint,
				  resultado=str_data[17],
				  observaciones=str_data[18],
				  fecha_sig_llamada=(CASE WHEN str_data[20]='' THEN '2999-12-31' ELSE str_data[20]::date END),
				  hora_sig_llamada=str_data[21]::time with time zone,
				  comentarios_sig_llamada=str_data[19],
				  momento_actualizacion=espacio_tiempo_ejecucion,
				  gral_usr_id_actualizacion=usuario_ejecutor
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;--termina editar
		
		IF command_selected = 'delete' THEN
			UPDATE crm_registro_llamadas SET momento_baja=espacio_tiempo_ejecucion,borrado_logico=true, gral_usr_id_baja=usuario_ejecutor
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		  

	END IF; -- Fin Aplicativo de Registro LLamadas (CRM)


	
	-- Aplicativo Registro de Visitas(CRM)
	IF app_selected = 115 THEN
		
		IF command_selected = 'new' THEN
			
			id_tipo_consecutivo:=36;--Folio Registro Visitas(CRM)
			
			--aqui entra para tomar el consecutivo del folio de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO crm_registro_visitas(
				folio,--nuevo_folio,
				gral_empleado_id,--str_data[5]::integer,
				crm_contacto_id,--str_data[6]::integer,
				fecha,--str_data[7]::date,
				hora,--str_data[8]::time with time zone,
				duracion,--str_data[9]::time with time zone,
				crm_motivos_visita_id,--str_data[10]::integer,
				crm_calificacion_visita_id,--str_data[11]::integer,
				crm_tipos_seguimiento_visita_id,--str_data[12]::integer,
				deteccion_oportunidad,--str_data[13]::smallint,
				recursos_utilizados,--str_data[14],
				resultado,--str_data[15],
				observaciones,--str_data[16],
				fecha_sig_visita,--str_data[17]::date,
				hora_sig_visita,--str_data[18]::time with time zone,
				comentarios_sig_visita,--str_data[19],
				productos,--str_data[20],
				fecha_sig_llamada,--str_data[21]::date,
				hora_sig_llamada,--str_data[22]::time with time zone,
				comentarios_sig_llamada,--str_data[23],
				borrado_logico,--false,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion,--usuario_ejecutor,
				gral_emp_id,--emp_id,
				gral_suc_id--suc_id
			)
			VALUES(
				nuevo_folio,
				str_data[5]::integer,
				str_data[6]::integer,
				str_data[7]::date,
				str_data[8]::time with time zone,
				str_data[9]::time with time zone,
				str_data[10]::integer,
				str_data[11]::integer,
				str_data[12]::integer,
				str_data[13]::smallint,
				str_data[14],
				str_data[15],
				str_data[16],
				(CASE WHEN trim(str_data[17])='' THEN '2999-12-31'::date ELSE str_data[17]::date END),
				str_data[18]::time with time zone,
				str_data[19],
				str_data[20],
				(CASE WHEN trim(str_data[21])='' THEN '2999-12-31'::date ELSE str_data[21]::date END),
				str_data[22]::time with time zone,
				str_data[23],
				false,
				espacio_tiempo_ejecucion,
				usuario_ejecutor,
				emp_id,
				suc_id
			);
			
			valor_retorno := '1';
		END IF;--termina nuevo
		
		
		IF command_selected = 'edit' THEN
			UPDATE crm_registro_visitas SET 
				gral_empleado_id=str_data[5]::integer,
				crm_contacto_id=str_data[6]::integer,
				fecha=str_data[7]::date,
				hora=str_data[8]::time with time zone,
				duracion=str_data[9]::time with time zone,
				crm_motivos_visita_id=str_data[10]::integer,
				crm_calificacion_visita_id=str_data[11]::integer,
				crm_tipos_seguimiento_visita_id=str_data[12]::integer,
				deteccion_oportunidad=str_data[13]::smallint,
				recursos_utilizados=str_data[14],
				resultado=str_data[15],
				observaciones=str_data[16],
				fecha_sig_visita=(CASE WHEN trim(str_data[17])='' THEN '2999-12-31'::date ELSE str_data[17]::date END),
				hora_sig_visita=str_data[18]::time with time zone,
				comentarios_sig_visita=str_data[19],
				productos=str_data[20],
				fecha_sig_llamada=(CASE WHEN trim(str_data[21])='' THEN '2999-12-31'::date ELSE str_data[21]::date END),
				hora_sig_llamada=str_data[22]::time with time zone,
				comentarios_sig_llamada=str_data[23],
				momento_actualizacion=espacio_tiempo_ejecucion,
				gral_usr_id_actualizacion=usuario_ejecutor 
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;--termina editar
		
		IF command_selected = 'delete' THEN
			UPDATE crm_registro_visitas SET momento_baja=espacio_tiempo_ejecucion,borrado_logico=true, gral_usr_id_baja=usuario_ejecutor
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--Termina Aplicativo Registro de Visitas(CRM)
	
	
	
	-- Catalogo de Oportunidades
	IF app_selected = 120 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]	contacto_id
			--str_data[6]	fecha_oportunidad
			--str_data[7]	fecha_cotizacion
			--str_data[8]	fecha_cierre
			--str_data[9]	monto
			--str_data[10]	empleado
			--str_data[11]	tipo_oportunidad
			--str_data[12]	etapa_venta
			--str_data[13]	estatus
			--str_data[14]	cierre_oportunidad
			--id+"___"+contacto_id+"___"+fecha_oportunidad+"___"+fecha_cotizacion
			--+"___"+fecha_cierre+"___"+monto+"___"+empleado+"___"+tipo_oportunidad+"___"+etapa_venta+"___"+
			--estatus+"___"+cierre_oportunidad;//6
			
			
			INSERT INTO crm_oportunidades (fecha_oportunidad,
						crm_contactos_id,
						crm_tipos_oportunidad_id, 
						monto , 
						fecha_cotizar,
						fecha_cierre,
						gral_empleados_id,
						cierre_oportunidad,
						crm_etapas_venta_id,
						estatus,
						borrado_logico,
						momento_creacion,
						gral_usr_id_creacion,
						gral_emp_id, 
						gral_suc_id) 
						
					VALUES ( str_data[6]::character varying,
						str_data[5]::integer,
						str_data[11]::integer,
						str_data[9]::double precision,
						str_data[7]::character varying,
						str_data[8]::character varying,
						str_data[10]::integer,
						str_data[14]::smallint,
						str_data[12]::integer,
						str_data[13]::boolean,
						false,          
						now(),            
						usuario_ejecutor,           
						emp_id,      
						suc_id);
			valor_retorno := '1';
		END IF;	
		IF command_selected = 'edit' THEN
			
		        UPDATE crm_oportunidades set fecha_oportunidad=str_data[6]::character varying,
						crm_contactos_id=str_data[5]::integer,
						crm_tipos_oportunidad_id=str_data[11]::integer, 
						monto =str_data[9]::double precision, 
						fecha_cotizar=str_data[7]::character varying,
						fecha_cierre=str_data[8]::character varying,
						gral_empleados_id=str_data[10]::integer,
						cierre_oportunidad=str_data[14]::smallint,
						crm_etapas_venta_id=str_data[12]::integer,
						estatus=str_data[13]::boolean,
						momento_actualizacion=now(),
						gral_usr_id_actualizacion=usuario_ejecutor 
						WHERE id = str_data[4]::integer;
						
			valor_retorno := '0';
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_oportunidades SET momento_baja=now(),borrado_logico=true, gral_usr_id_baja =usuario_ejecutor 
			WHERE crm_oportunidades.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Oportunidades
	
	


	-- Catalogo de Metas
	IF app_selected = 123 THEN
		IF command_selected = 'new' THEN
			/*app_selected//1
			+"___"+command_selected//2
			+"___"+id_usuario//3
			+"___"+identificador//4
			+"___"+select_agente//5 str_data[5]
			+"___"+opciones//6 str_data[6]
			+"___"+cant_llamadas//7 str_data[7]
			+"___"+cant_visitas//8 str_data[8]
			+"___"+cant_prospectos//9 str_data[9]
			+"___"+ano//10 str_data[10]
			+"___"+mes//11 str_data[11]
			+"___"+cant_cotizaciones	//12 str_data[12]
			+"___"+cant_cotizaciones2//13 str_data[13]
			+"___"+cant_oportunidades//14 str_data[14]
			+"___"+cant_oportunidades2//15 str_data[15]
			+"___"+monto_cotizaciones//16 str_data[16]
			+"___"+monto_cotizaciones2//17 str_data[17]
			+"___"+monto_oportunidades//18 str_data[18]
			+"___"+monto_oportunidades2//19 str_data[19]
			+"___"+ventas_clientes//20 str_data[20]
			+"___"+ventas_opor_clientes//21 str_data[21]
			+"___"+ventas_prospecto;//22 str_data[22]	*/ 
			
			id_tipo_consecutivo:=40;--Folio Registro Metas (CRM)
			
			--aqui entra para tomar el consecutivo del folio de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			INSERT INTO crm_metas (folio,
							  gral_empleado_id ,--str_data[5]
							  ano,--str_data[10]
							  mes,--str_data[11]
							  cantidad_visitas,--str_data[8]
							  cantidad_llamadas,--str_data[7]
							  cantidad_prospectos,--str_data[9]
							  cantidad_cotizaciones,--str_data[12]
							  cantidad_oportunidades,--str_data[14]
							  monto_cotizaciones,--str_data[16]
							  monto_oportunidades,--str_data[18]
							  ventas_prospectos,--str_data[22]
							  cantidad_cotizaciones2,--str_data[13]
							  cantidad_oportunidades2,--str_data[15]
							  monto_cotizaciones2,--str_data[17]
							  monto_oportunidades2,--str_data[19]
							  ventas_clientes,--str_data[20]
							  ventas_oportunidades_clientes,--str_data[21]

							  borrado_logico,
							  momento_creacion,
							  gral_usr_id_creacion,
							  gral_emp_id, 
							  gral_suc_id) 
						
						VALUES ( nuevo_folio,

							/*
							  ano,--str_data[10]
							  mes,--str_data[11]
							  cantidad_visitas,--str_data[8]
							  cantidad_llamadas,--str_data[7]
							  cantidad_prospectos,--str_data[9]
							  cantidad_cotizaciones,--str_data[12]
							  cantidad_oportunidades,--str_data[14]
							  monto_cotizaciones,--str_data[16]
							  monto_oportunidades,--str_data[18]
							  ventas_prospectos,--str_data[22]
							  cantidad_cotizaciones2,--str_data[13]
							  cantidad_oportunidades2,--str_data[15]
							  monto_cotizaciones2,--str_data[17]
							  monto_oportunidades2,--str_data[19]
							  ventas_clientes,--str_data[20]
							  ventas_oportunidades_clientes,--str_data[21]*/
							
							str_data[5]::integer,--empleado_id
							str_data[10]::smallint,
							str_data[11]::smallint,
							str_data[8]::integer,
							str_data[7]::integer,
							str_data[9]::integer,
							str_data[12]::integer,
							str_data[14]::integer,
							str_data[16]::double precision,
							str_data[18]::double precision,
							str_data[22]::integer,
							str_data[13]::integer,
							str_data[15]::integer,
							str_data[17]::double precision,
							str_data[19]::double precision,
							str_data[20]::integer,
							str_data[21]::integer,
							false,          
							now(),            
							usuario_ejecutor,           
							emp_id,      
							suc_id);
				valor_retorno := '1';
		END IF;	
		IF command_selected = 'edit' THEN
			
		        UPDATE crm_metas set 
					ano=str_data[10]::smallint,
					mes=str_data[11]::smallint,
					cantidad_visitas=str_data[8]::integer,
					cantidad_llamadas=str_data[7]::integer,
					cantidad_prospectos=str_data[9]::integer,
					cantidad_cotizaciones=str_data[12]::integer,
					cantidad_oportunidades=str_data[14]::integer,
					monto_cotizaciones=str_data[16]::double precision,
					monto_oportunidades=str_data[18]::double precision,
					ventas_prospectos=str_data[22]::integer,
					cantidad_cotizaciones2=str_data[13]::integer,
					cantidad_oportunidades2=str_data[15]::integer,
					monto_cotizaciones2=str_data[17]::double precision,
					monto_oportunidades2=str_data[19]::double precision,
					ventas_clientes=str_data[20]::integer,
					ventas_oportunidades_clientes=str_data[21]::integer,
					momento_actualizacion=now(),
					gral_usr_id_actualizacion=usuario_ejecutor 
					WHERE id = str_data[4]::integer;
						
			valor_retorno := '0';
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_metas SET momento_baja=now(),borrado_logico=true, gral_usr_id_baja =usuario_ejecutor 
			WHERE crm_metas.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina de Metas
	


	-- CATALOGO DE REGISTRO DE CASOS..
	IF app_selected = 124 THEN
		IF command_selected = 'new' THEN
			/*     str_data[1] app_selected
			+"___"+str_data[2]command_selected
			+"___"+str_data[3]id_usuario
			+"___"+str_data[4]identificador
			+"___"+str_data[5]id_cliente_prospecto
			+"___"+str_data[6]select_estatus
			+"___"+str_data[7]select_prioridad
			+"___"+str_data[8]select_tipo_caso
			+"___"+str_data[9]fecha_cierre
			+"___"+str_data[10]descripcion.toUpperCase()
			+"___"+str_data[11]resolucion.toUpperCase()
			+"___"+str_data[12]observacion_agente.toUpperCase();*/
			
			id_tipo_consecutivo:=41;--Folio Registro Casos (CRM)
			
			--aqui entra para tomar el consecutivo del folio de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			INSERT INTO crm_registro_casos (folio,
						   gral_empleado_id, --str_data[14]
						   tipo ,    -- --str_data[13]
						   estatus,    --str_data[6]
						   prioridad,  --str_data[7]
						   tipo_caso,  --str_data[8]
						   fecha_cierre,--str_data[9]
						   descripcion, --str_data[10]
						   resolucion,  --str_data[11]
						   observacion_agente, --str_data[12]

						   borrado_logico,         --false
						   momento_creacion,       --espacio_tiempo_ejecucion
						   --momento_actualizacion, --espacio_tiempo_ejecucion
						   --momento_baja,
						   gral_usr_id_creacion,    --usuario_ejecutor
						   --gral_usr_id_actualizacion,
						   --gral_usr_id_baja,
						   gral_emp_id, --  emp_id
						   gral_suc_id) --suc_id
					VALUES ( nuevo_folio,
						 str_data[14]::integer,
						 str_data[13]::integer,
						 str_data[6]::integer,
						 str_data[7]::integer,
						 str_data[8]::integer,
						 str_data[9]::timestamp with time zone,
						 str_data[10],
						 str_data[11],
						 str_data[12],

						 false,          
						 espacio_tiempo_ejecucion,
						 usuario_ejecutor,
						 emp_id,
						 suc_id) returning id into id_caso ;
						if str_data[13]::integer = 1 then  
							INSERT INTO crm_registro_casos_clie (id_crm_registro_casos,id_cliente)
							VALUES ( id_caso::integer,str_data[5]::integer);
						else
							INSERT INTO crm_registro_casos_prospectos (id_crm_registro_casos,id_prospecto)
							VALUES ( id_caso::integer,str_data[5]::integer);
						end if;
					 
			valor_retorno := '1';
		END IF;
		IF command_selected = 'edit' THEN
				UPDATE 	crm_registro_casos SET gral_empleado_id=str_data[14]::integer,
								tipo=str_data[13]::integer,
						             estatus=str_data[6]::integer,
						           prioridad=str_data[7]::integer,
						           tipo_caso=str_data[8]::integer,
						        fecha_cierre=str_data[9]::timestamp with time zone,
						         descripcion=str_data[10],
						          resolucion=str_data[11],
						  observacion_agente=str_data[12],
					       momento_actualizacion=espacio_tiempo_ejecucion,
					   gral_usr_id_actualizacion=usuario_ejecutor
					     WHERE crm_registro_casos.id = str_data[4]::integer;

				    --RAISE EXCEPTION '%','tipo a editar::    '||str_data[13]||'___'||str_data[4]||'___'||str_data[5];

					if str_data[13]::integer = 1 then 
						select id from  crm_registro_casos_clie
						where crm_registro_casos_clie.id_crm_registro_casos=str_data[4]::integer 
						--and  crm_registro_casos_clie.id_cliente=str_data[5]::integer
						into id_caso;

						update crm_registro_casos_clie set id_cliente=str_data[5]::integer 
						where crm_registro_casos_clie.id_crm_registro_casos=id_caso;
					end if;
						
					 
					if str_data[13]::integer = 2 then  
						select id from  crm_registro_casos_prospectos
						where crm_registro_casos_prospectos.id_crm_registro_casos=str_data[4]::integer 
						--and  crm_registro_casos_prospectos.id_prospecto=str_data[5]::integer 
						into id_caso;
						
						update crm_registro_casos_prospectos set id_prospecto=str_data[5]::integer 
						where crm_registro_casos_prospectos.id_crm_registro_casos=id_caso;
					end if;
						  
		valor_retorno := '1';
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_registro_casos SET momento_baja=espacio_tiempo_ejecucion,borrado_logico=true, gral_usr_id_baja =usuario_ejecutor 
			WHERE crm_reg_casos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--TERMNA EL REGISTRO DE CASOS.
	
	
	
	-- Catalogo de Contactos
	IF app_selected = 127 THEN
		IF command_selected = 'new' THEN
			--str_data[4]-- id
			--str_data[5]--tipo_contacto
			--str_data[6]--folio
			--str_data[7]--id_cliente
			--str_data[8]--nombre
			--str_data[9]--apellido_paterno
			--str_data[10]--apellido_materno
			--str_data[11]--telefono_1
			--str_data[12]--telefono_2
			--str_data[13]--fax
			--str_data[14--telefono_directo
			--str_data[15]--correo_1
			--str_data[16]--correo_2
			--str_data[17]--observaciones
			--str_data[18]--agente
			--str_data[19]--departamento
			--str_data[20]--puesto
			--str_data[21]--check_decisor
			
			id_tipo_consecutivo:=39;--Folio Catalogo de Contactos(CRM)
			
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

			
			INSERT INTO crm_contactos (
				folio, -- character varying,
				  nombre,-- character varying NOT NULL DEFAULT ''::character varying,
				  apellido_paterno,-- character varying NOT NULL DEFAULT ''::character varying,
				  apellido_materno,-- character varying NOT NULL DEFAULT ''::character varying,
				  telefono1,-- character varying DEFAULT ''::character varying,
				  telefono2,-- character varying DEFAULT ''::character varying,
				  fax,-- character varying DEFAULT ''::character varying,
				  telefono_directo,-- character varying DEFAULT ''::character varying,
				  email,-- character varying DEFAULT ''::character varying,
				  email2,-- character varying DEFAULT ''::character varying,
				  tipo_contacto,-- integer DEFAULT 0, -- 1->Cliente....
				  observaciones,-- text DEFAULT ''::text,
				  gral_emp_id,-- integer DEFAULT 0,
				  gral_suc_id,-- integer DEFAULT 0,
				  borrado_logico,-- boolean NOT NULL DEFAULT false,
				  momento_creacion,-- timestamp with time zone,
				  gral_usr_creacion,-- integer DEFAULT 0,
				  gral_empleado_id,-- integer DEFAULT 0,
				  departamento,
				  puesto,
				  decisor
				) 
				VALUES (nuevo_folio ,str_data[8]::character varying,
					str_data[9]::character varying,
					str_data[10]::character varying,
					str_data[11]::character varying,
					str_data[12]::character varying,
					str_data[13]::character varying,
					str_data[14]::character varying,
					str_data[15]::character varying,
					str_data[16]::character varying,
					str_data[5]::integer,
					str_data[17]::character varying,
					emp_id,
					suc_id, 
					false,          
					now(), 
					usuario_ejecutor,
					str_data[18]::integer,
					str_data[19],
					str_data[20],
					str_data[21]::boolean 
				) RETURNING id INTO ultimo_id;
					
				--RAISE EXCEPTION '%','ultimo_id: '||ultimo_id;
				
				IF str_data[5]::integer = 1 THEN 
					--contacto para cliente
					--contacto para prospecto
					INSERT INTO crm_contacto_cli(cxc_clie_id, crm_contactos_id) 
					VALUES(str_data[7]::integer, ultimo_id);
				ELSE
					--contacto para prospecto
					INSERT INTO crm_contacto_pro(crm_prospectos_id, crm_contactos_id) 
					VALUES(str_data[7]::integer, ultimo_id);
				END IF;
				
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE crm_contactos SET 
				nombre=str_data[8],
				apellido_paterno=str_data[9],
				apellido_materno=str_data[10],
				telefono1=str_data[11]::character varying,-- character varying DEFAULT ''::character varying,
				telefono2=str_data[12]::character varying,-- character varying DEFAULT ''::character varying,
				fax=str_data[13]::character varying,-- character varying DEFAULT ''::character varying,
				telefono_directo=str_data[14]::character varying,-- character varying DEFAULT ''::character varying,
				email=str_data[15]::character varying,-- character varying DEFAULT ''::character varying,
				email2=str_data[16]::character varying,-- character varying DEFAULT ''::character varying,
				observaciones=str_data[17]::character varying,-- text DEFAULT ''::text,
				momento_actualizacion=now(),
				gral_usr_actualizacion=usuario_ejecutor, 
				gral_empleado_id=str_data[18]::integer,
				departamento=str_data[19],
				puesto=str_data[20],
				decisor=str_data[21]::boolean 
			WHERE id=str_data[4]::integer;
			
			IF str_data[5]::integer = 1 THEN 
				if (select count(id) from crm_contactos where id=str_data[4]::integer and tipo_contacto=str_data[5]::integer)<=0 then 
					--Si cambio de tipo de contacto entonces hay que eliminar la relacion anterior
					delete from crm_contacto_pro where crm_contactos_id=str_data[4]::integer;
				end if;
				
				--Contacto para cliente
				if (select count(id) from crm_contacto_cli where crm_contactos_id=str_data[4]::integer)>0 then 
					update crm_contacto_cli set cxc_clie_id=str_data[7]::integer where crm_contactos_id=str_data[4]::integer;
				else
					INSERT INTO crm_contacto_cli(cxc_clie_id, crm_contactos_id) VALUES(str_data[7]::integer, str_data[4]::integer);
				end if;
			ELSE 
				if (select count(id) from crm_contactos where id=str_data[4]::integer and tipo_contacto=str_data[5]::integer)<=0 then 
					--Si cambio de tipo de contacto entonces hay que eliminar la relacion anterior
					delete from crm_contacto_cli where crm_contactos_id=str_data[4]::integer;
				end if;
				
				--Contacto para prospecto
				if (select count(id) from crm_contacto_pro where crm_contactos_id=str_data[4]::integer)>0 then 
					update crm_contacto_pro set crm_prospectos_id=str_data[7]::integer where crm_contactos_id=str_data[4]::integer;
				else
					INSERT INTO crm_contacto_pro(crm_prospectos_id, crm_contactos_id) VALUES(str_data[7]::integer, str_data[4]::integer);
				end if;
			END IF;
			
			UPDATE crm_contactos SET tipo_contacto=str_data[5]::integer WHERE id=str_data[4]::integer;
			
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_contactos SET momento_baja=now(),borrado_logico=true, gral_usr_baja=usuario_ejecutor 
			WHERE crm_contactos.id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;--termina Contactos
	
	
	-- Catalogo  CONFIGURACON DE CONSULTAS
	IF app_selected = 130 THEN
		IF command_selected = 'new' THEN
			/*
			app_selected+"___"+--1
			command_selected+"___"+--2
			id_usuario+"___"+--3
			id+"___"+--4
			metas_visita+"___"+//5 str_data[5]
			totales_visita+"___"+//6 str_data[6]
			cumplido_visita+"___"+//7 str_data[7]
			conexito_visita+"___"+//8 str_data[8]
			conoportunidad_visita+"___"+//9 str_data[9]
			seguimiento_visita+"___"+//10 str_data[10]
			efectividad_visita+"___"+//11 str_data[11]
			gestion_visita+"___"+//12 str_data[12]
			avance_visita+"___"+//13 str_data[13]
			metas_llamadas+"___"+//14 str_data[14]
			total_llamadas+"___"+//15 str_data[15]
			cumplido_llamadas+"___"+//16 str_data[16]
			entrantes_llamadas+"___"+//17 str_data[17]
			salientes_llamadas+"___"+//18 str_data[18]
			planeadas_llamadas+"___"+//19 str_data[19]
			con_exito_llamadas+"___"+//20 str_data[20]
			con_cita_llamadas+"___"+//21 str_data[21]
			conseguimiento_llamadas+"___"+//22 str_data[22]
			efectividad_llamadas+"___"+//23 str_data[23]
			gesti√≥n_llamadas+"___"+//24 str_data[24]
			avance_llamadas+"___"+//25 str_data[25]
			planeaci√≥n_llamadas+"___"+//26 str_data[26]
			facturacion_casos+"___"+//27 str_data[27]
			producto_casos+"___"+//28 str_data[28]
			garantia_casos+"___"+//29 str_data[29]
			distribucion_casos+"___"+//30 str_data[30]
			danos_casos+"___"+//31 str_data[31]
			devoluciones_casos+"___"+//32 str_data[32]
			cobranza_casos+"___"+//33 str_data[33]
			varios_casos+"___"+//34 str_data[34]
			metas_oportunidades+"___"+//35 str_data[35]
			total_metas_oportunidades+"___"+//36 str_data[36]
			montos_meta_oportunidades+"___"+//37 str_data[37]
			total_montos_oportunidades+"___"+//38 str_data[38]
			metas_cumplidas_oportunidades+"___"+//39 str_data[39]
			montos_cumplidas_oportunidades+"___"+//40 str_data[40]
			inicial_oportunidades+"___"+//41 str_data[41]
			seguimiento_oportunidades+"___"+//42 str_data[42]
			visitas_oportunidades+"___"+//43 str_data[43]
			cotizacion_oportunidades+"___"+//44 str_data[44]
			negociacion_oportunidades+"___"+//45 str_data[45]
			cierre_oportunidades+"___"+//46 str_data[46]
			ganados_oportunidades;//47 str_data[47]
			*/
			
			INSERT INTO crm_config_consultas(
				metas_visita,
				totales_visita,
				cumplido_visita,
				conexito_visita,
				conoportunidad_visita,
				seguimiento_visita,
				efectividad_visita,
				gestion_visita,
				avance_visita,
				metas_llamadas,
				total_llamadas,
				cumplido_llamadas,
				entrantes_llamadas,
				salientes_llamadas,
				planeadas_llamadas,
				con_exito_llamadas,
				con_cita_llamadas,
				conseguimiento_llamadas,
				efectividad_llamadas,
				gestion_llamadas,
				avance_llamadas,
				planeacion_llamadas,
				facturacion_casos,
				producto_casos,
				garantia_casos,
				distribucion_casos,
				danos_casos,
				devoluciones_casos,
				cobranza_casos,
				varios_casos,
				metas_oportunidades,
				total_metas_oportunidades,
				montos_meta_oportunidades,
				total_montos_oportunidades,
				metas_cumplidas_oportunidades,
				montos_cumplidas_oportunidades,
				inicial_oportunidades,
				seguimiento_oportunidades,
				visitas_oportunidades,
				cotizacion_oportunidades,
				negociacion_oportunidades,
				cierre_oportunidades,
				ganados_oportunidades,
				perdidos_oportunidades,
				borrado_logico,          
				momento_creacion,            
				gral_usr_id_creacion,           
				gral_emp_id,      
				gral_suc_id) 		
			VALUES ( 
				str_data[5]::boolean,--empleado_id
				str_data[6]::boolean,
				str_data[7]::boolean,
				str_data[8]::boolean,
				str_data[9]::boolean,
				str_data[10]::boolean,
				str_data[11]::boolean,
				str_data[12]::boolean,
				str_data[13]::boolean,
				str_data[14]::boolean,
				str_data[15]::boolean,
				str_data[16]::boolean,
				str_data[17]::boolean,
				str_data[18]::boolean,
				str_data[19]::boolean,
				str_data[20]::boolean,
				str_data[21]::boolean,
				str_data[22]::boolean,
				str_data[23]::boolean,
				str_data[24]::boolean,
				str_data[25]::boolean,
				str_data[26]::boolean,
				str_data[27]::boolean,
				str_data[28]::boolean,
				str_data[29]::boolean,
				str_data[30]::boolean,
				str_data[31]::boolean,
				str_data[32]::boolean,
				str_data[33]::boolean,
				str_data[34]::boolean,
				str_data[35]::boolean,
				str_data[36]::boolean,
				str_data[37]::boolean,
				str_data[38]::boolean,
				str_data[39]::boolean,
				str_data[40]::boolean,
				str_data[41]::boolean,
				str_data[42]::boolean,
				str_data[43]::boolean,
				str_data[44]::boolean,
				str_data[45]::boolean,
				str_data[46]::boolean,
				str_data[47]::boolean,
				str_data[48]::boolean,
				false,
				now(),
				usuario_ejecutor,
				emp_id,
				suc_id);
				
				valor_retorno := '1';
		END IF;	
		IF command_selected = 'edit' THEN
		
			UPDATE crm_config_consultas SET 
				metas_visita=str_data[5]::boolean,
				totales_visita=str_data[6]::boolean,
				cumplido_visita=str_data[7]::boolean,
				conexito_visita=str_data[8]::boolean,
				conoportunidad_visita=str_data[9]::boolean,
				seguimiento_visita=str_data[10]::boolean,
				efectividad_visita=str_data[11]::boolean,
				gestion_visita=str_data[12]::boolean,
				avance_visita=str_data[13]::boolean,
				metas_llamadas=str_data[14]::boolean,
				total_llamadas=str_data[15]::boolean,
				cumplido_llamadas=str_data[16]::boolean,
				entrantes_llamadas=str_data[17]::boolean,
				salientes_llamadas=str_data[18]::boolean,
				planeadas_llamadas=str_data[19]::boolean,
				con_exito_llamadas=str_data[20]::boolean,
				con_cita_llamadas=str_data[21]::boolean,
				conseguimiento_llamadas=str_data[22]::boolean,
				efectividad_llamadas=str_data[23]::boolean,
				gestion_llamadas=str_data[24]::boolean,
				avance_llamadas=str_data[25]::boolean,
				planeacion_llamadas=str_data[26]::boolean,
				facturacion_casos=str_data[27]::boolean,
				producto_casos=str_data[28]::boolean,
				garantia_casos=str_data[29]::boolean,
				distribucion_casos=str_data[30]::boolean,
				danos_casos=str_data[31]::boolean,
				devoluciones_casos=str_data[32]::boolean,
				cobranza_casos=str_data[33]::boolean,
				varios_casos=str_data[34]::boolean,
				metas_oportunidades=str_data[35]::boolean,
				total_metas_oportunidades=str_data[36]::boolean,
				montos_meta_oportunidades=str_data[37]::boolean,
				total_montos_oportunidades=str_data[38]::boolean,
				metas_cumplidas_oportunidades=str_data[39]::boolean,
				montos_cumplidas_oportunidades=str_data[40]::boolean,
				inicial_oportunidades=str_data[41]::boolean,
				seguimiento_oportunidades=str_data[42]::boolean,
				visitas_oportunidades=str_data[43]::boolean,
				cotizacion_oportunidades=str_data[44]::boolean,
				negociacion_oportunidades=str_data[45]::boolean,
				cierre_oportunidades=str_data[46]::boolean,
				ganados_oportunidades=str_data[47]::boolean,
				perdidos_oportunidades=str_data[48]::boolean,
				momento_actualizacion=now(),
				gral_usr_id_actualizacion =usuario_ejecutor 
				WHERE id = str_data[4]::integer;
				
			valor_retorno := '0';
			
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_config_consultas SET momento_baja=now(),borrado_logico=true, gral_usr_id_baja =usuario_ejecutor 
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;--termina CONFIGURACON DE CONSULTAS


	
	-- Aplicativo Registro de Proyectos(CRM)
	IF app_selected = 207 THEN 
		--str_data[1]	app_selected 
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	nombre
		--str_data[6]	descripcion
		--str_data[7]	select_agente
		--str_data[8]	id_contacto
		--str_data[9]	id_prov
		--str_data[10]	fecha_inicio
		--str_data[11]	fecha_fin
		--str_data[12]	select_estatus
		--str_data[13]	select_prioridad
		--str_data[14]	select_muestra
		--str_data[15]	observaciones
		--str_data[16]	monto
		--str_data[17]	select_moneda
		--str_data[18]	select_periodicidad
		--str_data[19]	kilogramos
		--str_data[20]	select_segmento
		--str_data[21]	select_mercado
		
		IF command_selected = 'new' THEN
			--Folio Registro de Proyectos(CRM)
			id_tipo_consecutivo:=58;
			
			if (select count(id) from gral_cons_tipos where id=id_tipo_consecutivo)<=0 then 
				insert into gral_cons_tipos(id,titulo,borrado_logico) values(id_tipo_consecutivo,'Folio Registro de Proyectos(CRM)',false);
			end if;
			
			if (select count(id) from gral_cons where gral_emp_id=emp_id and gral_suc_id=suc_id and gral_cons_tipo_id=id_tipo_consecutivo)<=0 then 
				insert into gral_cons(gral_emp_id,gral_suc_id,gral_cons_tipo_id,prefijo,consecutivo,borrado_logico) 
				values(emp_id,suc_id,id_tipo_consecutivo,'',0,false);
			end if;
			
			--Aqui entra para tomar el consecutivo del folio de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

			if trim(str_data[10])<>'' then 
				fecha1=str_data[10];
			end if;

			if trim(str_data[11])<>'' then 
				fecha2=str_data[11];
			end if;
			
			INSERT INTO crm_registro_proyecto(
				folio,--nuevo_folio,
				titulo,--str_data[5],
				descripcion,--str_data[6],
				gral_empleado_id,--str_data[7]::integer,
				crm_contacto_id,--str_data[8]::integer,
				cxp_prov_id,--str_data[9]::integer,
				fecha_inicio,--fecha1,
				fecha_fin,--fecha2,
				crm_proyecto_estatus_id,--str_data[12]::integer,
				prioridad,--str_data[13]::smallint,
				muestra,--str_data[14]::smallint,
				observaciones,--str_data[15],
				monto,--str_data[16]::double precision,
				gral_mon_id,--str_data[17]::integer,
				periodicidad,--str_data[18]::integer,
				kg,--str_data[19]::double precision,
				cxc_clie_clas1_id,--str_data[20]::integer,
				cxc_clie_clas2_id,--str_data[21]::integer,
				--precio, --str_data[22],
				borrado_logico,--false,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion,--usuario_ejecutor,
				gral_emp_id,--emp_id,
				gral_suc_id--suc_id
			)
			VALUES(nuevo_folio,str_data[5],str_data[6],str_data[7]::integer,str_data[8]::integer,str_data[9]::integer,fecha1,fecha2,str_data[12]::integer,str_data[13]::smallint,str_data[14]::smallint,str_data[15],str_data[16]::double precision,str_data[17]::integer,str_data[18]::integer,str_data[19]::double precision,str_data[20]::integer,str_data[21]::integer,false,espacio_tiempo_ejecucion,usuario_ejecutor,emp_id,suc_id)
			returning id into ultimo_id;

			--RAISE EXCEPTION '%' ,'extra_data: '||extra_data;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--iddet 	str_filas[1]
				--competidor	str_filas[2]
				--precio	str_filas[3]
				--proveedor	str_filas[4]

				if str_filas[1]::integer<=0 then 
					if trim(str_filas[2])<>'' or trim(str_filas[4])<>'' then 
						insert into crm_registro_proyecto_competidor(crm_registro_proyecto_id,nombre,precio,proveedor)
						values(ultimo_id,str_filas[2],str_filas[3]::double precision,str_filas[4]);
					end if;
				end if;
			END LOOP;
			
			valor_retorno := '1';
		END IF;--termina nuevo
		
		
		IF command_selected = 'edit' THEN

			if trim(str_data[10])<>'' then 
				fecha1=str_data[10];
			end if;
			
			if trim(str_data[11])<>'' then 
				fecha2=str_data[11];
			end if;
			
			UPDATE crm_registro_proyecto SET 
				titulo=str_data[5],
				descripcion=str_data[6],
				gral_empleado_id=str_data[7]::integer,
				crm_contacto_id=str_data[8]::integer,
				cxp_prov_id=str_data[9]::integer,
				fecha_inicio=fecha1,
				fecha_fin=fecha2,
				crm_proyecto_estatus_id=str_data[12]::integer,
				prioridad=str_data[13]::smallint,
				muestra=str_data[14]::smallint,
				observaciones=str_data[15],
				monto=str_data[16]::double precision,
				gral_mon_id=str_data[17]::integer,
				periodicidad=str_data[18]::integer,
				kg=str_data[19]::double precision,
				cxc_clie_clas1_id=str_data[20]::integer,
				cxc_clie_clas2_id=str_data[21]::integer,
				--precio=str_data[22]::double precision,
				momento_actualizacion=espacio_tiempo_ejecucion,
				gral_usr_id_actualiza=usuario_ejecutor
			WHERE id = str_data[4]::integer;

			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--iddet 	str_filas[1]
				--competidor	str_filas[2]
				--precio	str_filas[3]
				--proveedor	str_filas[4]
				
				if str_filas[1]::integer>0 then 
					update crm_registro_proyecto_competidor set nombre=str_filas[2],precio=str_filas[3]::double precision,proveedor=str_filas[4] 
					where id=str_filas[1]::integer;
				else 
					if trim(str_filas[2])<>'' or trim(str_filas[4])<>'' then 
						insert into crm_registro_proyecto_competidor(crm_registro_proyecto_id,nombre,precio,proveedor)
						values(str_data[4]::integer,str_filas[2],str_filas[3]::double precision,str_filas[4]);
					end if;
				end if;
			END LOOP;
			
			valor_retorno := '1';
		END IF;--termina editar
		
		IF command_selected = 'delete' THEN
			UPDATE crm_registro_proyecto SET momento_baja=espacio_tiempo_ejecucion,borrado_logico=true, gral_usr_id_baja=usuario_ejecutor
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--Termina Aplicativo Registro de Proyectos(CRM)
	

	-- Catalogo de Tipos de Seguimiento de Visitas
	IF app_selected =208 THEN
		IF command_selected = 'new' THEN
			--str_data[4]-- id
			--str_data[5]--titulo
			
			INSERT INTO crm_tipos_seguimiento_visita (titulo,borrado_logico,gral_emp_id,momento_crea,gral_usr_id_crea,gral_suc_id) 
			VALUES (str_data[5],false,emp_id,espacio_tiempo_ejecucion,usuario_ejecutor,suc_id );
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE crm_tipos_seguimiento_visita SET titulo=str_data[5],momento_actualiza=espacio_tiempo_ejecucion,gral_usr_id_actualiza=usuario_ejecutor 
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_tipos_seguimiento_visita SET momento_baja=now(),borrado_logico=true, gral_usr_id_baja=usuario_ejecutor 
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo de Tipos de Seguimiento de Visitas













	
	RETURN valor_retorno; 

END;
$$;


--
-- Name: crm_consultas(integer, integer, integer, integer, integer, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.crm_consultas(id integer, agente integer, tipo_seleccion integer, status integer, etapa integer, fecha_inicial character varying, fecha_final character varying, id_empresa integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE


	cadena_sql text = '';
	cadena_where text ='';
	tipo_consulta  integer =0;
	sql_execution text='';

	fila record;
	/**#########################Variables para el Registro de Llamadas##################*/
	--variables
	llamadas_meta integer=0;
	llamadas_totales integer =0;
	porcentaje_cumplido double precision =0;
	llamadas_entrantes integer=0;
	llamadas_salientes integer =0;
	llamadas_planeadas integer =0;
	llam_con_exito integer =0;
	llam_con_cita integer =0;
	llam_con_seguimiento integer =0;

	--operaciones
	efectividad double precision =0;
	avance double precision =0;
	gestion double precision =0;
	planeacion double precision =0;

	/**#########################FIN Variables para el Registro de Llamadas##################*/

	/**################ Variables para el registro de Visitas ######################*/
	--variables
	visitas_meta integer=0;
	visitas_totales integer =0;
	porcentaje_cumplido_visitas double precision =0;
	
	visita_con_exito integer =0;
	visita_con_cita integer =0;
	visita_con_seguimiento integer =0;

	--operaciones
	efectividad_visitas double precision =0;
	avance_visitas double precision =0;
	gestion_visitas double precision =0;
	
	--varios
	contacto_meta integer =0;
	total_contacto integer =0;
	
	--oportunidades
	ganados integer=0;
	perdidos integer =0;
	cierre integer =0;
	
	
	--variables para registro de casos
	casos_totales integer=0;
	casos_facturacion double precision =0;
	casos_producto double precision =0;
	casos_garantia double precision =0;
	casos_distribucion double precision =0;
	casos_danos double precision =0;
	casos_devoluciones double precision =0;
	casos_cobranza double precision =0;
	casos_varios double precision =0;
	
	--oportunidades
	metas_oport integer=0;
	monto_metas_oport double precision =0;
	total_metas_oport integer=0;
	total_montos_oport double precision =0;
	metas_cumplidas double precision =0;
	montos_cumplidos double precision =0;
	oport_inicial double precision =0;
	oport_seguimiento double precision =0;
	oport_visitas double precision =0;
	oport_cotizacion double precision =0;
	oport_negociacion double precision =0;
	oport_cierre double precision =0;
	oport_ganados double precision =0;
	oport_perdidos double precision =0;
	
	
	--varios
	metas_prospectos integer=0;
	total_prospectos integer=0;
	porciento_cumplido double precision =0;
	cantidad_contactos integer=0;
	
	/***##############################Fin de variables#######################################*/

	
BEGIN
	
	cadena_where:='';
	
	IF tipo_seleccion = 0 THEN 
		cadena_where := cadena_where || ' AND crm_contactos.tipo_contacto='||tipo_seleccion;
	END IF;
	
	IF tipo_seleccion =1 THEN 
		cadena_where := cadena_where || ' AND crm_contactos.tipo_contacto ='||tipo_seleccion;
	END IF;

	IF tipo_seleccion =2 THEN 
		cadena_where :=cadena_where ||' AND crm_contactos.tipo_contacto ='||tipo_seleccion;
	END IF;

	
	
	
	

	
	
	


	--llamadas
	IF id = 1 THEN
		
		/**##################################### Variables para el Buscador de Registro de Llamadas################## */
		
		--sacando las llamadas totales de un agente
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution:='select count(crm_registro_llamadas.gral_empleado_id)
			from crm_registro_llamadas 
			where crm_registro_llamadas.gral_empleado_id ='||agente||'
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		EXECUTE sql_execution INTO llamadas_totales;
		--RAISE EXCEPTION '%',llamadas_totales;
		
		
		--sacando la cantidad de llamadas meta 
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND (
				(ano||''''||lpad(mes::character varying, 2, ''0''))::integer between 
				((select to_char('''||fecha_inicial||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_inicial||'''::timestamp with time zone,''MM'')) )::integer 
				AND 
				 ((select to_char('''||fecha_final||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_final||'''::timestamp with time zone,''MM'')) )::integer
				)';
		END IF;
		sql_execution:='select sum(crm_metas.cantidad_llamadas) 
		from crm_metas 
		where crm_metas.gral_empleado_id='||agente||' 
		and crm_metas.gral_emp_id='||id_empresa||' '||cadena_where;
		
		EXECUTE sql_execution INTO llamadas_meta;
		--RAISE EXCEPTION '%',llamadas_meta;
		
		
		--sacando las cantidades de llamadas entrantes
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution:='select count(crm_registro_llamadas.tipo_llamada)
			from crm_registro_llamadas 
			where crm_registro_llamadas.gral_empleado_id ='||agente||'
			and crm_registro_llamadas.tipo_llamada =1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE  sql_execution INTO llamadas_entrantes;
		--RAISE EXCEPTION '%',sql_execution;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas salientes
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution:='select count(crm_registro_llamadas.tipo_llamada)
			from crm_registro_llamadas 
			where crm_registro_llamadas.gral_empleado_id ='||agente||' 
			and crm_registro_llamadas.tipo_llamada =2 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE  sql_execution INTO llamadas_salientes;
		--RAISE EXCEPTION '%',llamadas_salientes;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas planeadas
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution:='select count(crm_registro_llamadas.llamada_planeada)
			from crm_registro_llamadas 
			where crm_registro_llamadas.gral_empleado_id ='||agente||'
			and crm_registro_llamadas.llamada_planeada=1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO llamadas_planeadas;
		--RAISE EXCEPTION '%',llamadas_planeadas;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas exitosas
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution :='select count(crm_registro_llamadas.llamada_completada)
			from crm_registro_llamadas 
			where crm_registro_llamadas.gral_empleado_id ='||agente||' 
			and crm_registro_llamadas.llamada_completada =1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO llam_con_exito;
		--RAISE EXCEPTION '%',llam_con_exito;		
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas con cita
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution :='select count(crm_registro_llamadas.deteccion_oportunidad)as con_cita 
			from crm_registro_llamadas 
			where crm_registro_llamadas.gral_empleado_id ='||agente||'
			and crm_registro_llamadas.deteccion_oportunidad =1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO llam_con_cita;
		--RAISE EXCEPTION '%',llam_con_cita;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas con seguimiento
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution :='select count(crm_registro_llamadas.crm_tipos_seguimiento_llamada_id)
			from crm_registro_llamadas 
			where crm_registro_llamadas.gral_empleado_id ='||agente||' 
			and crm_registro_llamadas.crm_tipos_seguimiento_llamada_id=1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO llam_con_seguimiento;
		--RAISE EXCEPTION '%',llam_con_seguimiento;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando el porcentaje de cumplido
		IF llamadas_totales=0 THEN
			porcentaje_cumplido := 0;
		ELSE
			porcentaje_cumplido := ((llamadas_totales::double precision / llamadas_meta::double precision) * 100)::double precision;
		END IF;
		--RAISE EXCEPTION '%',llamadas_meta;
		--llamadas_meta
		--sacando la porciento de efectividad
		IF llam_con_exito=0 THEN
			efectividad := 0;
		ELSE
			efectividad := ((llam_con_exito::double precision / llamadas_totales::double precision) * 100)::double precision;
		END IF;
		--efectividad :=(llamadas_totales/ llam_con_exito)::double precision;
		
		--sacando el porciento de avance 
		IF llam_con_cita=0 THEN
			avance := 0;
		ELSE
			avance := ((llam_con_cita::double precision / llamadas_totales::double precision) * 100)::double precision;
		END IF;
		--avance :=( llamadas_totales / llam_con_cita) ::double precision;
		
		--sacando el porciento de gestion
		IF llamadas_salientes=0 THEN
			gestion := 0;
		ELSE
			gestion := ((llamadas_salientes::double precision / llamadas_totales::double precision) * 100)::double precision;
		END IF;
		--gestion := (llamadas_totales/ llamadas_salientes)::double precision;
		
		--sacando el porciento de planeacion
		IF llamadas_planeadas=0 THEN
			planeacion := 0;
		ELSE
			planeacion := ((llamadas_planeadas::double precision / llamadas_totales::double precision) * 100)::double precision;
		END IF;
		--planeacion := (llamadas_totales / llamadas_planeadas)::double precision;
		/**##################################### FIN Variables para el Buscador de Registro de Llamadas################## */
		
		IF llamadas_meta is null THEN
			llamadas_meta:=0;
		END IF;
		IF llamadas_totales is null THEN
			llamadas_totales:=0;
		END IF;
		IF llamadas_entrantes is null THEN
			llamadas_entrantes:=0;
		END IF;
		IF llamadas_salientes is null THEN
			llamadas_salientes:=0;
		END IF;
		IF llamadas_planeadas is null THEN
			llamadas_planeadas:=0;
		END IF;
		IF llam_con_exito is null THEN
			llam_con_exito:=0;
		END IF;
		IF llam_con_cita is null THEN
			llam_con_cita:=0;
		END IF;
		IF llam_con_seguimiento is null THEN
			llam_con_seguimiento:=0;
		END IF;
		IF porcentaje_cumplido is null THEN
			porcentaje_cumplido:=0;
		END IF;
		IF efectividad is null THEN
			efectividad:=0;
		END IF;
		IF avance is null THEN
			avance:=0;
		END IF;
		IF gestion is null THEN
			gestion:=0;
		END IF;
		IF planeacion is null THEN
			planeacion:=0;
		END IF;
		
		cadena_where := '';
		cadena_where := cadena_where || ' AND crm_contactos.tipo_contacto ='||tipo_seleccion;
		cadena_sql:= 'select 
			'||llamadas_meta||'::integer as cantidad_llamadas,
			'||llamadas_totales||'::integer as llamadas_totales,
			'||llamadas_entrantes||'::integer as llamadas_entrantes,
			'||llamadas_salientes||'::integer as llamadas_salientes,
			'||llamadas_planeadas||'::integer as llamadas_planeadas,
			'||llam_con_exito||'::integer as llamadas_con_exito,
			'||llam_con_cita||'::integer as llamadas_con_cita,
			'||llam_con_seguimiento||'::integer as llamadas_con_seguimiento,
			'||porcentaje_cumplido|| '::double precision as porcentaje_llamadas,
			'||efectividad||'::double precision as efectividad,
			'||avance||'::double precision as avance,
			'||gestion||'::double precision as gestion,
			'||planeacion||':: double precision  as  planeacion
			from crm_metas 
			join crm_registro_llamadas on crm_registro_llamadas.gral_empleado_id = crm_metas.gral_empleado_id 
			join crm_contactos on crm_contactos.id = crm_registro_llamadas.crm_contacto_id 
			where crm_registro_llamadas.gral_empleado_id='||agente||' 
			and crm_registro_llamadas.gral_emp_id='||id_empresa||' 
			group by crm_metas.cantidad_llamadas';
			--'||cadena_where||' 
		--RAISE EXCEPTION '%',llamadas_meta;
		
	END IF;
	
	--visitas
	IF id = 2 THEN 
		/**##################################### Variables para el Buscador de Registro de Visitas################## */
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_visitas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		
		--sacando las visitas totales de un agente
		sql_execution:='select count(crm_registro_visitas.gral_empleado_id) 
				from crm_registro_visitas 
				where crm_registro_visitas.gral_empleado_id ='||agente||' 
				and crm_registro_visitas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_visitas.crm_contacto_id 
		EXECUTE sql_execution INTO visitas_totales;
		--RAISE EXCEPTION '%',visitas_totales;
		/*
		--sacando la cantidad de visitas meta 
		sql_execution:='select sum(crm_metas.cantidad_visitas)
			from crm_metas
			where crm_metas.gral_empleado_id ='||agente||' 
			and crm_metas.gral_emp_id ='||id_empresa ||'
			';
			*/
		
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND (
				(ano||''''||lpad(mes::character varying, 2, ''0''))::integer between 
				((select to_char('''||fecha_inicial||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_inicial||'''::timestamp with time zone,''MM'')) )::integer 
				AND 
				 ((select to_char('''||fecha_final||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_final||'''::timestamp with time zone,''MM'')) )::integer
				)';
		END IF;
		sql_execution:='select sum(crm_metas.cantidad_visitas) 
		from crm_metas 
		where crm_metas.gral_empleado_id='||agente||' 
		and crm_metas.gral_emp_id='||id_empresa||' '||cadena_where;
		
		EXECUTE sql_execution INTO visitas_meta;
		--RAISE EXCEPTION '%',visitas_meta;
		
		
		/*Aqiu voy*/
		--sacando las cantidades de visitas exitosas
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_visitas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution :='select count(crm_registro_visitas.crm_calificacion_visita_id)
			from crm_registro_visitas 
			where crm_registro_visitas.gral_empleado_id ='||agente||' 
			and crm_registro_visitas.crm_calificacion_visita_id =1 
			and crm_registro_visitas.gral_emp_id ='||id_empresa ||' '||cadena_where;
			--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_visitas.crm_contacto_id 
		EXECUTE sql_execution INTO visita_con_exito;
		--RAISE EXCEPTION '%',visita_con_exito;
		
		
		--sacando las cantidades de visitas con cita (oportunidad)
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_visitas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution :='select count(crm_registro_visitas.deteccion_oportunidad)as con_cita 
			from crm_registro_visitas 
			where crm_registro_visitas.gral_empleado_id ='||agente||'
			and crm_registro_visitas.deteccion_oportunidad =1 
			and crm_registro_visitas.gral_emp_id ='||id_empresa ||' '||cadena_where;
			--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_visitas.crm_contacto_id 
		EXECUTE sql_execution INTO visita_con_cita;
		--RAISE EXCEPTION '%',visita_con_cita;
		
		--sacando las cantidades de visitas con seguimiento
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_visitas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution :='select count(crm_registro_visitas.crm_tipos_seguimiento_visita_id)
			from crm_registro_visitas 
			where crm_registro_visitas.gral_empleado_id ='||agente||'
			and crm_registro_visitas.crm_tipos_seguimiento_visita_id =1 
			and crm_registro_visitas.gral_emp_id ='||id_empresa ||' '||cadena_where;
			--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_visitas.crm_contacto_id 
		EXECUTE sql_execution INTO visita_con_seguimiento;
		--RAISE EXCEPTION '%',visita_con_seguimiento;
		
		--sacando el porcentaje cumplido
		IF visitas_totales=0 THEN
			porcentaje_cumplido_visitas := 0;
		ELSE
			porcentaje_cumplido_visitas := ((visitas_totales::double precision / visitas_meta::double precision) * 100)::double precision;
		END IF;
		--RAISE EXCEPTION '%',porcentaje_cumplido_visitas;
		--sacando el porcentaje de efectividad
		IF visitas_totales=0 THEN
			efectividad_visitas := 0;
		ELSE
			efectividad_visitas := ((visita_con_exito::double precision  / visitas_totales::double precision) * 100)::double precision;
		END IF;
		
		--RAISE EXCEPTION '%',efectividad_visitas;
		
		--sacando el porciento de avance 
		IF visitas_totales=0 THEN
			avance_visitas :=0;
		ELSE
			avance_visitas :=((visita_con_seguimiento::double precision / visitas_totales::double precision) * 100) ::double precision;
		END IF;
		--RAISE EXCEPTION '%',avance_visitas;
		
		--sacando el porciento de gestion
		IF visitas_totales=0 THEN
			gestion_visitas :=0;
		ELSE
			gestion_visitas := ((visita_con_cita::double precision / visitas_totales::double precision) * 100)::double precision;
		END IF;
		--RAISE EXCEPTION '%',gestion_visitas;
		
	/**##################################### FIN Variables para el Buscador de Registro de Visitas################## */
		
		IF visitas_meta is null THEN
			visitas_meta:= 0;
		END IF;
		IF visitas_totales is null THEN
			visitas_totales:= 0;
		END IF;
		IF visita_con_exito is null THEN
			visita_con_exito:= 0;
		END IF;
		IF visita_con_cita is null THEN
			visita_con_cita:= 0;
		END IF;
		IF visita_con_seguimiento is null THEN
			visita_con_seguimiento:= 0;
		END IF;
		IF porcentaje_cumplido_visitas is null THEN
			porcentaje_cumplido_visitas:= 0;
		END IF;
		IF efectividad_visitas is null THEN
			efectividad_visitas:= 0;
		END IF;
		IF avance_visitas is null THEN
			avance_visitas:= 0;
		END IF;
		IF gestion_visitas is null THEN
			gestion_visitas:= 0;
		END IF;
		
		cadena_where := '';
		cadena_where := cadena_where || ' AND crm_contactos.tipo_contacto ='||tipo_seleccion;
		cadena_sql:= 'select 
			'||visitas_meta||'::integer as visita_meta,
			'||visitas_totales||'::integer as visitas_totales,
			
			'||visita_con_exito||'::integer as visitas_con_exito,
			'||visita_con_cita||'::integer as visitas_con_cita,
			'||visita_con_seguimiento||'::integer as visitas_con_seguimiento,
			'||porcentaje_cumplido_visitas||'::double precision as porcentaje_visitas,
			'||efectividad_visitas||'::double precision as efectividad,
			'||avance_visitas||'::double precision as avance,
			'||gestion_visitas||'::double precision as gestion
			
			from crm_metas
			join crm_registro_visitas on crm_registro_visitas.gral_empleado_id = crm_metas.gral_empleado_id 
			join crm_contactos on crm_contactos.id = crm_registro_visitas.crm_contacto_id
			where crm_registro_visitas.gral_empleado_id='||agente|| '
			and crm_registro_visitas.gral_emp_id='||id_empresa||' 
			group by crm_metas.cantidad_visitas';
			
		--RAISE EXCEPTION '%',cadena_sql;
	END IF;
	
	--casos
	IF id=3 THEN
		/**##################################### Variables para el Buscador de Registro de Casos################## */
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_casos.momento_creacion, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		
		--sacando las visitas totales de casos
		sql_execution:='select count(crm_registro_casos.gral_empleado_id) 
				from crm_registro_casos 
				where crm_registro_casos.gral_empleado_id ='||agente||' 
				and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
		
		EXECUTE sql_execution INTO casos_totales;
		--RAISE EXCEPTION '%',sql_execution;
		
		--sacando totales de casos por facturacion
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where crm_registro_casos.gral_empleado_id ='||agente||'
			and crm_registro_casos.tipo_caso =1 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_facturacion;
		--RAISE EXCEPTION '%',porciento_facturacion;
		
		--sacando totales de casos por Producto
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where crm_registro_casos.gral_empleado_id ='||agente||'
			and crm_registro_casos.tipo_caso =2 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_producto;
		--RAISE EXCEPTION '%',porciento_producto;
		
		--sacando totales de casos por Garantia
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where crm_registro_casos.gral_empleado_id ='||agente||' 
			and crm_registro_casos.tipo_caso =3 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_garantia;
		--RAISE EXCEPTION '%',porciento_garantia;
		
		--sacando totales de casos por Distribucion
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where crm_registro_casos.gral_empleado_id ='||agente||'
			and crm_registro_casos.tipo_caso =4 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_distribucion;
		--RAISE EXCEPTION '%',porciento_distribucion;
		
		--sacando totales de casos por Danos
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where crm_registro_casos.gral_empleado_id ='||agente||'
			and crm_registro_casos.tipo_caso =5 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_danos;
		--RAISE EXCEPTION '%',porciento_danos;
		
		--sacando totales de casos por Devoluciones
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where crm_registro_casos.gral_empleado_id ='||agente||'
			and crm_registro_casos.tipo_caso =6 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_devoluciones;
		--RAISE EXCEPTION '%',porciento_devoluciones;
		
		--sacando totales de casos por Cobranza
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where crm_registro_casos.gral_empleado_id ='||agente||'
			and crm_registro_casos.tipo_caso =7 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_cobranza;
		--RAISE EXCEPTION '%',porciento_cobranza;
		
		--sacando totales de casos por Varios
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where crm_registro_casos.gral_empleado_id ='||agente||'
			and crm_registro_casos.tipo_caso=8 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_varios;
		--RAISE EXCEPTION '%',sql_execution;

		--RAISE EXCEPTION '%',casos_totales;
		--sacando el porciento de facturacion 
		IF casos_facturacion=0 OR casos_totales=0 THEN
			casos_facturacion :=0;
		ELSE
			casos_facturacion :=((casos_facturacion::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de producto 
		IF casos_producto=0 OR casos_totales=0  THEN
			casos_producto :=0;
		ELSE
			casos_producto :=((casos_producto::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de garantia 
		IF casos_facturacion=0 OR casos_totales=0  THEN
			casos_garantia :=0;
		ELSE
			casos_garantia :=((casos_garantia::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de distribucion 
		IF casos_distribucion=0 OR casos_totales=0  THEN
			casos_distribucion :=0;
		ELSE
			casos_distribucion :=((casos_distribucion::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de da√±os 
		IF casos_danos=0 OR casos_totales=0  THEN
			casos_danos :=0;
		ELSE
			casos_danos:=((casos_danos::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de devoluciones 
		IF casos_devoluciones=0 OR casos_totales=0  THEN
			casos_devoluciones :=0;
		ELSE
			casos_devoluciones:=((casos_devoluciones::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de cobranza 
		IF casos_cobranza=0 OR casos_totales=0  THEN
			casos_cobranza :=0;
		ELSE
			casos_danos:=((casos_cobranza::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de varios 
		IF casos_varios=0 OR casos_totales=0  THEN
			casos_varios :=0;
		ELSE
			casos_varios:=((casos_varios::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;
		
		IF casos_totales is null THEN
			casos_totales:= 0;
		END IF;
		IF casos_facturacion is null THEN
			casos_facturacion:= 0;
		END IF;
		IF casos_producto is null THEN
			casos_producto:= 0;
		END IF;
		IF casos_garantia is null THEN
			casos_garantia:= 0;
		END IF;
		
		IF casos_distribucion is null THEN
			casos_distribucion:= 0;
		END IF;
		IF casos_danos is null THEN
			casos_danos:= 0;
		END IF;
		IF casos_devoluciones is null THEN
			casos_devoluciones:= 0;
		END IF;
		IF casos_cobranza is null THEN
			casos_cobranza:= 0;
		END IF;
		IF casos_varios is null THEN
			casos_varios:= 0;
		END IF;
		
		cadena_sql:= 'select 
			'||casos_totales||'::integer as casos_totales,
			'||casos_facturacion||'::double precision as casos_facturacion,
			
			'||casos_producto||'::double precision as casos_producto,
			'||casos_garantia||'::double precision as casos_garantia,
			'||casos_distribucion||'::double precision as casos_distribucion,
			'||casos_danos||'::double precision as casos_danos,
			'||casos_devoluciones||'::double precision as casos_devoluciones,
			'||casos_cobranza||'::double precision as casos_cobranza,
			'||casos_varios||'::double precision as casos_varios 
			
			from crm_registro_casos  WHERE 
			crm_registro_casos.gral_empleado_id='||agente|| '
			and crm_registro_casos.gral_emp_id='||id_empresa||' '||cadena_where
			||'  limit 1';
			
			--RAISE EXCEPTION '%',cadena_sql;
	END IF;
	
	--oportunidades
	IF id=4 THEN
		
		/**##################################### Variables para el Buscador de Registro de Visitas################## */
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_oportunidades.fecha_oportunidad::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		
		--sacando las oportunidades totales de un agente
		sql_execution:='select count(id), sum(monto) from crm_oportunidades  
				where crm_oportunidades.gral_empleados_id ='||agente||' 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO total_metas_oport, total_montos_oport;
		--RAISE EXCEPTION '%',visitas_totales;
		
		
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND (
				(ano||''''||lpad(mes::character varying, 2, ''0''))::integer between 
				((select to_char('''||fecha_inicial||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_inicial||'''::timestamp with time zone,''MM'')) )::integer 
				AND 
				 ((select to_char('''||fecha_final||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_final||'''::timestamp with time zone,''MM'')) )::integer
				)';
		END IF;
		sql_execution:='select sum(crm_metas.cantidad_oportunidades),  
		sum(crm_metas.monto_oportunidades) from crm_metas 
		where crm_metas.gral_empleado_id='||agente||' 
		and crm_metas.gral_emp_id='||id_empresa||' '||cadena_where;
		
		EXECUTE sql_execution INTO metas_oport, monto_metas_oport;
		--RAISE EXCEPTION '%',visitas_meta;
		
		
		--sacando las oportunidades totales inicio
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_oportunidades.fecha_oportunidad::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution:='select count(id) from crm_oportunidades  
				where crm_oportunidades.gral_empleados_id ='||agente||' 
				AND crm_oportunidades.crm_etapas_venta_id=1 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_inicial;
		--RAISE EXCEPTION '%',visitas_totales;
		
		
		--sacando las oportunidades totales con seguimiento
		sql_execution:='select count(id) from crm_oportunidades  
				where crm_oportunidades.gral_empleados_id ='||agente||' 
				AND crm_oportunidades.crm_etapas_venta_id=2 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_seguimiento;
		--RAISE EXCEPTION '%',visitas_totales;
		
		--sacando las oportunidades totales con visitas
		sql_execution:='select count(id) from crm_oportunidades  
				where crm_oportunidades.gral_empleados_id ='||agente||' 
				AND crm_oportunidades.crm_etapas_venta_id=3 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_visitas;
		--RAISE EXCEPTION '%',visitas_totales;

		--sacando las oportunidades totales con cotizacion
		sql_execution:='select count(id) from crm_oportunidades  
				where crm_oportunidades.gral_empleados_id ='||agente||' 
				AND crm_oportunidades.crm_etapas_venta_id=4 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_cotizacion;
		--RAISE EXCEPTION '%',oport_cotizacion;
		
		--sacando las oportunidades totales con negociacion
		sql_execution:='select count(id) from crm_oportunidades  
				where crm_oportunidades.gral_empleados_id ='||agente||' 
				AND crm_oportunidades.crm_etapas_venta_id=5 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_negociacion;
		--RAISE EXCEPTION '%',oport_negociacion;
		
		--sacando las oportunidades totales con cierre
		sql_execution:='select count(id) from crm_oportunidades  
				where crm_oportunidades.gral_empleados_id ='||agente||' 
				AND (crm_oportunidades.crm_etapas_venta_id=6 OR crm_oportunidades.crm_etapas_venta_id=7 ) 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_cierre;
		--RAISE EXCEPTION '%',oport_cierre;
		
		--sacando las oportunidades totales con ganados
		sql_execution:='select count(id) from crm_oportunidades  
				where crm_oportunidades.gral_empleados_id ='||agente||' 
				AND crm_oportunidades.crm_etapas_venta_id=6 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_ganados;
		--RAISE EXCEPTION '%',oport_ganados;
		
		--sacando las oportunidades totales con perdidos
		sql_execution:='select count(id) from crm_oportunidades  
				where crm_oportunidades.gral_empleados_id ='||agente||' 
				AND crm_oportunidades.crm_etapas_venta_id=7 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_perdidos;
		--RAISE EXCEPTION '%',oport_perdidos;
		
		
		--sacando el porciento metas cumplidas
		IF metas_oport=0 OR total_metas_oport=0 THEN
			metas_cumplidas :=0;
		ELSE
			metas_cumplidas :=((total_metas_oport::double precision / metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos cumplidas
		IF total_montos_oport=0 OR monto_metas_oport=0 THEN
			montos_cumplidos :=0;
		ELSE
			montos_cumplidos :=((total_montos_oport::double precision / monto_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_inicial
		IF oport_inicial=0 OR total_metas_oport=0 THEN
			oport_inicial :=0;
		ELSE
			oport_inicial :=((oport_inicial::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_seguimiento
		IF oport_seguimiento=0 OR total_metas_oport=0 THEN
			oport_seguimiento :=0;
		ELSE
			oport_seguimiento :=((oport_seguimiento::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_visitas
		IF oport_visitas=0 OR total_metas_oport=0 THEN
			oport_visitas :=0;
		ELSE
			oport_visitas :=((oport_visitas::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_cotizacion=0 OR total_metas_oport=0 THEN
			oport_cotizacion :=0;
		ELSE
			oport_cotizacion :=((oport_cotizacion::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_negociacion=0 OR total_metas_oport=0 THEN
			oport_negociacion :=0;
		ELSE
			oport_negociacion :=((oport_negociacion::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_cierre=0 OR total_metas_oport=0 THEN
			oport_cierre :=0;
		ELSE
			oport_cierre :=((oport_cierre::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_ganados=0 OR total_metas_oport=0 THEN
			oport_ganados :=0;
		ELSE
			oport_ganados :=((oport_ganados::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_perdidos=0 OR total_metas_oport=0 THEN
			oport_perdidos :=0;
		ELSE
			oport_perdidos :=((oport_perdidos::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		IF metas_oport is null THEN
			metas_oport:= 0;
		END IF;
		IF monto_metas_oport is null THEN
			monto_metas_oport:= 0;
		END IF;
		IF total_metas_oport is null THEN
			total_metas_oport:= 0;
		END IF;
		IF total_montos_oport is null THEN
			total_montos_oport:= 0;
		END IF;
		IF metas_cumplidas is null THEN
			metas_cumplidas:= 0;
		END IF;
		IF montos_cumplidos is null THEN
			montos_cumplidos:= 0;
		END IF;
		IF oport_inicial is null THEN
			oport_inicial:= 0;
		END IF;
		IF oport_seguimiento is null THEN
			oport_seguimiento:= 0;
		END IF;
		IF oport_visitas is null THEN
			oport_visitas:= 0;
		END IF;
		IF oport_cotizacion is null THEN
			oport_cotizacion:= 0;
		END IF;
		IF oport_negociacion is null THEN
			oport_negociacion:= 0;
		END IF;
		IF oport_cierre is null THEN
			oport_cierre:= 0;
		END IF;
		IF oport_ganados is null THEN
			oport_ganados:= 0;
		END IF;
		IF oport_perdidos is null THEN
			oport_perdidos:= 0;
		END IF;
		
		cadena_sql:='select 
			'||metas_oport||'::integer as metas_oport,
			'||total_metas_oport||'::integer as total_metas_oport,
			'||monto_metas_oport||'::double precision as monto_metas_oport,
			'||total_montos_oport||'::double precision as total_montos_oport,
			'||metas_cumplidas||'::double precision as metas_cumplidas,
			'||montos_cumplidos||'::double precision as montos_cumplidos,
			'||oport_inicial||'::double precision as oport_inicial,
			'||oport_seguimiento||'::double precision as oport_seguimiento,
			'||oport_visitas||'::double precision as oport_visitas,
			'||oport_cotizacion||'::double precision as oport_cotizacion,
			'||oport_negociacion||'::double precision as oport_negociacion,
			'||oport_cierre||'::double precision as oport_cierre,
			'||oport_ganados||'::double precision as oport_ganados,
			'||oport_perdidos||'::double precision as oport_perdidos 
			from crm_oportunidades 
			where crm_oportunidades.gral_empleados_id ='||agente||' 
			and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where||' limit 1';
			
		--RAISE EXCEPTION '%',sql_execution;
	END IF;
	
	
	
	IF id=5 THEN
		/*--varios
		contacto_meta integer =0;
		total_contacto integer =0;*/
		--RAISE EXCEPTION '%',0;
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND (
				(ano||''''||lpad(mes::character varying, 2, ''0''))::integer between 
				((select to_char('''||fecha_inicial||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_inicial||'''::timestamp with time zone,''MM'')) )::integer 
				AND 
				 ((select to_char('''||fecha_final||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_final||'''::timestamp with time zone,''MM'')) )::integer
				)';
		END IF;
		sql_execution:='select sum(crm_metas.cantidad_prospectos) from crm_metas 
		where crm_metas.gral_empleado_id='||agente||' 
		and crm_metas.gral_emp_id='||id_empresa||' '||cadena_where;
		
		EXECUTE sql_execution INTO metas_prospectos;
		--RAISE EXCEPTION '%',visitas_meta;
		
		
		--sacando las oportunidades totales inicio
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_contactos.momento_creacion, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution:='select count(id) from crm_contactos 
				where crm_contactos.gral_usr_creacion='||agente||' 
				and crm_contactos.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO cantidad_contactos;
		--RAISE EXCEPTION '%',cantidad_contactos;
		
		--sacando las oportunidades totales inicio
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_prospectos.momento_creacion, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		sql_execution:='select count(id) from crm_prospectos 
				where crm_prospectos.gral_usr_id_creacion ='||agente||' 
				and crm_prospectos.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO total_prospectos;
		--RAISE EXCEPTION '%',visitas_totales;
		
		--sacando el porciento de montos oport_cotizacion
		IF total_prospectos=0 OR metas_prospectos=0 THEN
			porciento_cumplido :=0;
		ELSE
			porciento_cumplido :=((total_prospectos::double precision / metas_prospectos::double precision) * 100) ::double precision;
		END IF;
		
		IF total_prospectos is null THEN
			total_prospectos:= 0;
		END IF;
		IF metas_prospectos is null THEN
			metas_prospectos:= 0;
		END IF;
		IF porciento_cumplido is null THEN
			porciento_cumplido:= 0;
		END IF;
		IF cantidad_contactos is null THEN
			cantidad_contactos:= 0;
		END IF;
		
		
		cadena_sql:='select 
			'||metas_prospectos||'::integer as metas_prospectos,
			'||total_prospectos||'::integer as total_prospectos,
			'||porciento_cumplido||'::double precision as porciento_cumplido,
			'||cantidad_contactos||'::integer as cantidad_contactos 
			from crm_prospectos 
			where crm_prospectos.gral_usr_id_creacion ='||agente||' 
			and crm_prospectos.gral_emp_id ='||id_empresa ||' '||cadena_where||' limit 1';
			
		RAISE EXCEPTION '%',cadena_sql;
		
	END IF;
	
	
	FOR fila IN EXECUTE (cadena_sql) LOOP
		RETURN NEXT fila;
	END LOOP;
	
	
	/*
	select * from repventasnetasproductofactura(4,'','','2012-05-01','2012-06-05',4) as foo(
	numero_control character varying,
	 razon_social character varying,
	 codigo character varying,
	 producto character varying,
	 factura character varying ,
	 unidad character varying ,
	--cantidad double precision,
	precio_unitario double precision,
	moneda text,
	tipo_cambio double precision,
	total_pesos double precision,
	fecha_factura text
	);*/

END;

$$;


--
-- Name: crm_consultas_bigpicture(integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.crm_consultas_bigpicture(usuario integer, agente integer, id_empresa integer, fecha_inicial character varying, fecha_final character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE


	cadena_sql text = '';
	cadena_where text ='';
	cadena_where2 text ='';
	tipo_consulta  integer =0;
	sql_execution text='';

	fila record;
	/**#########################Variables para el Registro de Llamadas##################*/
	--variables
	llamadas_meta integer=0;
	llamadas_totales integer =0;
	porcentaje_cumplido double precision =0;
	llamadas_entrantes integer=0;
	llamadas_salientes integer =0;
	llamadas_planeadas integer =0;
	llam_con_exito integer =0;
	llam_con_cita integer =0;
	llam_con_seguimiento integer =0;

	--operaciones
	efectividad double precision =0;
	avance double precision =0;
	gestion double precision =0;
	planeacion double precision =0;
	
	/**#########################FIN Variables para el Registro de Llamadas##################*/
	
	/**################ Variables para el registro de Visitas ######################*/
	--variables
	visitas_meta integer=0;
	visitas_totales integer =0;
	porcentaje_cumplido_visitas double precision =0;
	
	visita_con_exito integer =0;
	visita_con_cita integer =0;
	visita_con_seguimiento integer =0;
	
	--operaciones
	efectividad_visitas double precision =0;
	avance_visitas double precision =0;
	gestion_visitas double precision =0;
	
	--varios
	contacto_meta integer =0;
	total_contacto integer =0;
	
	--oportunidades
	ganados integer=0;
	perdidos integer =0;
	cierre integer =0;
	
	
	--variables para registro de casos
	casos_totales integer=0;
	casos_facturacion double precision =0;
	casos_producto double precision =0;
	casos_garantia double precision =0;
	casos_distribucion double precision =0;
	casos_danos double precision =0;
	casos_devoluciones double precision =0;
	casos_cobranza double precision =0;
	casos_varios double precision =0;
	
	--oportunidades
	metas_oport integer=0;
	monto_metas_oport double precision =0;
	total_metas_oport integer=0;
	total_montos_oport double precision =0;
	metas_cumplidas double precision =0;
	montos_cumplidos double precision =0;
	oport_inicial double precision =0;
	oport_seguimiento double precision =0;
	oport_visitas double precision =0;
	oport_cotizacion double precision =0;
	oport_negociacion double precision =0;
	oport_cierre double precision =0;
	oport_ganados double precision =0;
	oport_perdidos double precision =0;
	
	
	--varios
	metas_prospectos integer=0;
	total_prospectos integer=0;
	porciento_cumplido double precision =0;
	cantidad_contactos integer=0;
	parametro_ano integer=0;
	parametro_mes integer=0;


	--Metas de Cotizaciones para Clientes y Prospectos
	cant_cotiza_prospecto double precision=0;
	monto_cotiza_prospecto double precision=0;
	cant_cotiza_cliente double precision=0;
	monto_cotiza_cliente double precision=0;

	cant_meta_cotiza_prospecto double precision=0;
	monto_meta_cotiza_prospecto double precision=0;
	cant_meta_cotiza_cliente double precision=0;
	monto_meta_cotiza_cliente double precision=0;

	porcentaje_cant_cotiza_prospecto double precision=0;
	porcentaje_monto_cotiza_prospecto double precision=0;
	porcentaje_cant_cotiza_cliente double precision=0;
	porcentaje_monto_cotiza_cliente double precision=0;
	
	/***##############################Fin de variables#######################################*/
	
	
BEGIN
	/*
	--Para este tipo de consulta, no se utiliza
	cadena_where:='';
	
	IF tipo_seleccion = 0 THEN 
		cadena_where := cadena_where || ' AND crm_contactos.tipo_contacto='||tipo_seleccion;
	END IF;
	
	IF tipo_seleccion =1 THEN 
		cadena_where := cadena_where || ' AND crm_contactos.tipo_contacto ='||tipo_seleccion;
	END IF;
	
	IF tipo_seleccion =2 THEN 
		cadena_where :=cadena_where ||' AND crm_contactos.tipo_contacto ='||tipo_seleccion;
	END IF;
	*/
	
	
	
	
	
	--select * from crm_config_consultas where gral_usr_id_creacion=1 AND borrado_logico=false AND gral_emp_id=1
	
	
	

	--llamadas
	--IF id = 1 THEN
		
		/**##################################### Variables para el Buscador de Registro de Llamadas################## */
		
		--sacando las llamadas totales de un agente
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_llamadas.gral_empleado_id ='||agente||' AND ';
		END IF;
		
		sql_execution:='select count(crm_registro_llamadas.gral_empleado_id)
			from crm_registro_llamadas 
			where '||cadena_where2||' 
			 crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		EXECUTE sql_execution INTO llamadas_totales;
		--RAISE EXCEPTION '%',llamadas_totales;
		
		
		--sacando la cantidad de llamadas meta 
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND (
				(ano||''''||lpad(mes::character varying, 2, ''0''))::integer between 
				((select to_char('''||fecha_inicial||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_inicial||'''::timestamp with time zone,''MM'')) )::integer 
				AND 
				 ((select to_char('''||fecha_final||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_final||'''::timestamp with time zone,''MM'')) )::integer
				)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_metas.gral_empleado_id='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select sum(crm_metas.cantidad_llamadas) 
		from crm_metas 
		where '||cadena_where2||' 
		 crm_metas.gral_emp_id='||id_empresa||' '||cadena_where;
		
		EXECUTE sql_execution INTO llamadas_meta;
		--RAISE EXCEPTION '%',llamadas_meta;
		
		
		--sacando las cantidades de llamadas entrantes
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_llamadas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(crm_registro_llamadas.tipo_llamada)
			from crm_registro_llamadas 
			where '||cadena_where2||' 
			 crm_registro_llamadas.tipo_llamada =1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE  sql_execution INTO llamadas_entrantes;
		--RAISE EXCEPTION '%',sql_execution;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas salientes
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_llamadas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(crm_registro_llamadas.tipo_llamada)
			from crm_registro_llamadas 
			where '||cadena_where2||'  
			crm_registro_llamadas.tipo_llamada =2 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE  sql_execution INTO llamadas_salientes;
		--RAISE EXCEPTION '%',llamadas_salientes;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas planeadas
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_llamadas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(crm_registro_llamadas.llamada_planeada)
			from crm_registro_llamadas 
			where '||cadena_where2||'
			 crm_registro_llamadas.llamada_planeada=1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO llamadas_planeadas;
		--RAISE EXCEPTION '%',llamadas_planeadas;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas exitosas
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_llamadas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_llamadas.llamada_completada)
			from crm_registro_llamadas 
			where '||cadena_where2||' 
			 crm_registro_llamadas.llamada_completada =1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO llam_con_exito;
		--RAISE EXCEPTION '%',llam_con_exito;		
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas con cita
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_llamadas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_llamadas.deteccion_oportunidad)as con_cita 
			from crm_registro_llamadas 
			where '||cadena_where2||' 
			 crm_registro_llamadas.deteccion_oportunidad =1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO llam_con_cita;
		--RAISE EXCEPTION '%',llam_con_cita;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando las cantidades de llamadas con seguimiento
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_llamadas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_llamadas.crm_tipos_seguimiento_llamada_id)
			from crm_registro_llamadas 
			where '||cadena_where2||' 
			 crm_registro_llamadas.crm_tipos_seguimiento_llamada_id=1 
			and crm_registro_llamadas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO llam_con_seguimiento;
		--RAISE EXCEPTION '%',llam_con_seguimiento;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_llamadas.crm_contacto_id 
		
		--sacando el porcentaje de cumplido
		IF llamadas_totales=0 THEN
			porcentaje_cumplido := 0;
		ELSE
			porcentaje_cumplido := ((llamadas_totales::double precision / llamadas_meta::double precision) * 100)::double precision;
		END IF;
		--RAISE EXCEPTION '%',llamadas_meta;
		--llamadas_meta
		--sacando la porciento de efectividad
		IF llam_con_exito=0 THEN
			efectividad := 0;
		ELSE
			efectividad := ((llam_con_exito::double precision / llamadas_totales::double precision) * 100)::double precision;
		END IF;
		--efectividad :=(llamadas_totales/ llam_con_exito)::double precision;
		
		--sacando el porciento de avance 
		IF llam_con_cita=0 THEN
			avance := 0;
		ELSE
			avance := ((llam_con_cita::double precision / llamadas_totales::double precision) * 100)::double precision;
		END IF;
		--avance :=( llamadas_totales / llam_con_cita) ::double precision;
		
		--sacando el porciento de gestion
		IF llamadas_salientes=0 THEN
			gestion := 0;
		ELSE
			gestion := ((llamadas_salientes::double precision / llamadas_totales::double precision) * 100)::double precision;
		END IF;
		--gestion := (llamadas_totales/ llamadas_salientes)::double precision;
		
		--sacando el porciento de planeacion
		IF llamadas_planeadas=0 THEN
			planeacion := 0;
		ELSE
			planeacion := ((llamadas_planeadas::double precision / llamadas_totales::double precision) * 100)::double precision;
		END IF;
		--planeacion := (llamadas_totales / llamadas_planeadas)::double precision;
		/**##################################### FIN Variables para el Buscador de Registro de Llamadas################## */
		
		IF llamadas_meta is null THEN
			llamadas_meta:=0;
		END IF;
		IF llamadas_totales is null THEN
			llamadas_totales:=0;
		END IF;
		IF llamadas_entrantes is null THEN
			llamadas_entrantes:=0;
		END IF;
		IF llamadas_salientes is null THEN
			llamadas_salientes:=0;
		END IF;
		IF llamadas_planeadas is null THEN
			llamadas_planeadas:=0;
		END IF;
		IF llam_con_exito is null THEN
			llam_con_exito:=0;
		END IF;
		IF llam_con_cita is null THEN
			llam_con_cita:=0;
		END IF;
		IF llam_con_seguimiento is null THEN
			llam_con_seguimiento:=0;
		END IF;
		IF porcentaje_cumplido is null THEN
			porcentaje_cumplido:=0;
		END IF;
		IF efectividad is null THEN
			efectividad:=0;
		END IF;
		IF avance is null THEN
			avance:=0;
		END IF;
		IF gestion is null THEN
			gestion:=0;
		END IF;
		IF planeacion is null THEN
			planeacion:=0;
		END IF;
		/*
		--Esto se quitara 
		cadena_where := '';
		cadena_where := cadena_where || ' AND crm_contactos.tipo_contacto ='||tipo_seleccion;
		cadena_sql:= 'select 
			'||llamadas_meta||'::integer as cantidad_llamadas,
			'||llamadas_totales||'::integer as llamadas_totales,
			'||llamadas_entrantes||'::integer as llamadas_entrantes,
			'||llamadas_salientes||'::integer as llamadas_salientes,
			'||llamadas_planeadas||'::integer as llamadas_planeadas,
			'||llam_con_exito||'::integer as llamadas_con_exito,
			'||llam_con_cita||'::integer as llamadas_con_cita,
			'||llam_con_seguimiento||'::integer as llamadas_con_seguimiento,
			'||porcentaje_cumplido|| '::double precision as porcentaje_llamadas,
			'||efectividad||'::double precision as efectividad,
			'||avance||'::double precision as avance,
			'||gestion||'::double precision as gestion,
			'||planeacion||':: double precision  as  planeacion
			from crm_metas 
			join crm_registro_llamadas on crm_registro_llamadas.gral_empleado_id = crm_metas.gral_empleado_id 
			join crm_contactos on crm_contactos.id = crm_registro_llamadas.crm_contacto_id 
			where crm_registro_llamadas.gral_empleado_id='||agente||' 
			and crm_registro_llamadas.gral_emp_id='||id_empresa||' 
			group by crm_metas.cantidad_llamadas';
			--'||cadena_where||' 
		--RAISE EXCEPTION '%',llamadas_meta;
		*/
		
	--END IF;
	
	--visitas
	--IF id = 2 THEN 
		/**##################################### Variables para el Buscador de Registro de Visitas################## */
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_visitas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_visitas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		--sacando las visitas totales de un agente
		sql_execution:='select count(crm_registro_visitas.gral_empleado_id) 
				from crm_registro_visitas 
				where '||cadena_where2||' 
				 crm_registro_visitas.gral_emp_id ='||id_empresa ||' '||cadena_where;
		--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_visitas.crm_contacto_id 
		EXECUTE sql_execution INTO visitas_totales;
		--RAISE EXCEPTION '%',visitas_totales;
		/*
		--sacando la cantidad de visitas meta 
		sql_execution:='select sum(crm_metas.cantidad_visitas)
			from crm_metas
			where crm_metas.gral_empleado_id ='||agente||' 
			and crm_metas.gral_emp_id ='||id_empresa ||'
			';
			*/
		
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND (
				(ano||''''||lpad(mes::character varying, 2, ''0''))::integer between 
				((select to_char('''||fecha_inicial||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_inicial||'''::timestamp with time zone,''MM'')) )::integer 
				AND 
				 ((select to_char('''||fecha_final||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_final||'''::timestamp with time zone,''MM'')) )::integer
				)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_metas.gral_empleado_id='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select sum(crm_metas.cantidad_visitas) 
		from crm_metas 
		where '||cadena_where2||'  
		 crm_metas.gral_emp_id='||id_empresa||' '||cadena_where;
		
		EXECUTE sql_execution INTO visitas_meta;
		--RAISE EXCEPTION '%',visitas_meta;
		
		
		/*Aqiu voy*/
		--sacando las cantidades de visitas exitosas
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_visitas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_visitas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_visitas.crm_calificacion_visita_id)
			from crm_registro_visitas 
			where '||cadena_where2||' 
			 crm_registro_visitas.crm_calificacion_visita_id =1 
			and crm_registro_visitas.gral_emp_id ='||id_empresa ||' '||cadena_where;
			--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_visitas.crm_contacto_id 
		EXECUTE sql_execution INTO visita_con_exito;
		--RAISE EXCEPTION '%',visita_con_exito;
		
		
		--sacando las cantidades de visitas con cita (oportunidad)
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_visitas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_visitas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_visitas.deteccion_oportunidad)as con_cita 
			from crm_registro_visitas 
			where '||cadena_where2||' 
			 crm_registro_visitas.deteccion_oportunidad =1 
			and crm_registro_visitas.gral_emp_id ='||id_empresa ||' '||cadena_where;
			--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_visitas.crm_contacto_id 
		EXECUTE sql_execution INTO visita_con_cita;
		--RAISE EXCEPTION '%',visita_con_cita;
		
		--sacando las cantidades de visitas con seguimiento
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_visitas.fecha::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_visitas.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_visitas.crm_tipos_seguimiento_visita_id)
			from crm_registro_visitas 
			where '||cadena_where2||'
			 crm_registro_visitas.crm_tipos_seguimiento_visita_id =1 
			and crm_registro_visitas.gral_emp_id ='||id_empresa ||' '||cadena_where;
			--join (select id from crm_contactos where tipo_contacto='||tipo_seleccion||') as cont_tmp on cont_tmp.id = crm_registro_visitas.crm_contacto_id 
		EXECUTE sql_execution INTO visita_con_seguimiento;
		--RAISE EXCEPTION '%',visita_con_seguimiento;
		
		--sacando el porcentaje cumplido
		IF visitas_totales=0 THEN
			porcentaje_cumplido_visitas := 0;
		ELSE
			porcentaje_cumplido_visitas := ((visitas_totales::double precision / visitas_meta::double precision) * 100)::double precision;
		END IF;
		--RAISE EXCEPTION '%',porcentaje_cumplido_visitas;
		--sacando el porcentaje de efectividad
		IF visitas_totales=0 THEN
			efectividad_visitas := 0;
		ELSE
			efectividad_visitas := ((visita_con_exito::double precision  / visitas_totales::double precision) * 100)::double precision;
		END IF;
		
		--RAISE EXCEPTION '%',efectividad_visitas;
		
		--sacando el porciento de avance 
		IF visitas_totales=0 THEN
			avance_visitas :=0;
		ELSE
			avance_visitas :=((visita_con_seguimiento::double precision / visitas_totales::double precision) * 100) ::double precision;
		END IF;
		--RAISE EXCEPTION '%',avance_visitas;
		
		--sacando el porciento de gestion
		IF visitas_totales=0 THEN
			gestion_visitas :=0;
		ELSE
			gestion_visitas := ((visita_con_cita::double precision / visitas_totales::double precision) * 100)::double precision;
		END IF;
		--RAISE EXCEPTION '%',gestion_visitas;
		
	/**##################################### FIN Variables para el Buscador de Registro de Visitas################## */
		
		IF visitas_meta is null THEN
			visitas_meta:= 0;
		END IF;
		IF visitas_totales is null THEN
			visitas_totales:= 0;
		END IF;
		IF visita_con_exito is null THEN
			visita_con_exito:= 0;
		END IF;
		IF visita_con_cita is null THEN
			visita_con_cita:= 0;
		END IF;
		IF visita_con_seguimiento is null THEN
			visita_con_seguimiento:= 0;
		END IF;
		IF porcentaje_cumplido_visitas is null THEN
			porcentaje_cumplido_visitas:= 0;
		END IF;
		IF efectividad_visitas is null THEN
			efectividad_visitas:= 0;
		END IF;
		IF avance_visitas is null THEN
			avance_visitas:= 0;
		END IF;
		IF gestion_visitas is null THEN
			gestion_visitas:= 0;
		END IF;
		/*
		--Esto se va a quitar
		cadena_where := '';
		cadena_where := cadena_where || ' AND crm_contactos.tipo_contacto ='||tipo_seleccion;
		cadena_sql:= 'select 
			'||visitas_meta||'::integer as visita_meta,
			'||visitas_totales||'::integer as visitas_totales,
			
			'||visita_con_exito||'::integer as visitas_con_exito,
			'||visita_con_cita||'::integer as visitas_con_cita,
			'||visita_con_seguimiento||'::integer as visitas_con_seguimiento,
			'||porcentaje_cumplido_visitas||'::double precision as porcentaje_visitas,
			'||efectividad_visitas||'::double precision as efectividad,
			'||avance_visitas||'::double precision as avance,
			'||gestion_visitas||'::double precision as gestion
			
			from crm_metas
			join crm_registro_visitas on crm_registro_visitas.gral_empleado_id = crm_metas.gral_empleado_id 
			join crm_contactos on crm_contactos.id = crm_registro_visitas.crm_contacto_id
			where crm_registro_visitas.gral_empleado_id='||agente|| '
			and crm_registro_visitas.gral_emp_id='||id_empresa||' 
			group by crm_metas.cantidad_visitas';
			
		--RAISE EXCEPTION '%',cadena_sql;
		*/
	--END IF;
	
	--casos
	--IF id=3 THEN
		/**##################################### Variables para el Buscador de Registro de Casos################## */
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_registro_casos.momento_creacion, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_casos.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		--sacando las visitas totales de casos
		sql_execution:='select count(crm_registro_casos.gral_empleado_id) 
				from crm_registro_casos 
				where '||cadena_where2||' 
				 crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
		
		EXECUTE sql_execution INTO casos_totales;
		--RAISE EXCEPTION '%',sql_execution;

		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_casos.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		--sacando totales de casos por facturacion
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where '||cadena_where2||' 
			 crm_registro_casos.tipo_caso =1 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_facturacion;
		--RAISE EXCEPTION '%',porciento_facturacion;
		
		--sacando totales de casos por Producto
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_casos.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where '||cadena_where2||' 
			 crm_registro_casos.tipo_caso =2 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_producto;
		--RAISE EXCEPTION '%',porciento_producto;
		
		--sacando totales de casos por Garantia
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_casos.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where '||cadena_where2||' 
			 crm_registro_casos.tipo_caso =3 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_garantia;
		--RAISE EXCEPTION '%',porciento_garantia;
		
		--sacando totales de casos por Distribucion
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_casos.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where '||cadena_where2||' 
			 crm_registro_casos.tipo_caso =4 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_distribucion;
		--RAISE EXCEPTION '%',porciento_distribucion;
		
		--sacando totales de casos por Danos
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_casos.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where '||cadena_where2||'
			 crm_registro_casos.tipo_caso =5 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_danos;
		--RAISE EXCEPTION '%',porciento_danos;
		
		--sacando totales de casos por Devoluciones
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_casos.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where '||cadena_where2||' 
			 crm_registro_casos.tipo_caso =6 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_devoluciones;
		--RAISE EXCEPTION '%',porciento_devoluciones;
		
		--sacando totales de casos por Cobranza
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_casos.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where '||cadena_where2||'
			 crm_registro_casos.tipo_caso =7 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_cobranza;
		--RAISE EXCEPTION '%',porciento_cobranza;
		
		--sacando totales de casos por Varios
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_registro_casos.gral_empleado_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution :='select count(crm_registro_casos.gral_empleado_id)
			from crm_registro_casos 
			where '||cadena_where2||' 
			 crm_registro_casos.tipo_caso=8 
			and crm_registro_casos.gral_emp_id ='||id_empresa ||' '||cadena_where;
			
		EXECUTE sql_execution INTO casos_varios;
		--RAISE EXCEPTION '%',sql_execution;

		--RAISE EXCEPTION '%',casos_totales;
		--sacando el porciento de facturacion 
		IF casos_facturacion=0 OR casos_totales=0 THEN
			casos_facturacion :=0;
		ELSE
			casos_facturacion :=((casos_facturacion::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de producto 
		IF casos_producto=0 OR casos_totales=0  THEN
			casos_producto :=0;
		ELSE
			casos_producto :=((casos_producto::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de garantia 
		IF casos_facturacion=0 OR casos_totales=0  THEN
			casos_garantia :=0;
		ELSE
			casos_garantia :=((casos_garantia::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de distribucion 
		IF casos_distribucion=0 OR casos_totales=0  THEN
			casos_distribucion :=0;
		ELSE
			casos_distribucion :=((casos_distribucion::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de da√±os 
		IF casos_danos=0 OR casos_totales=0  THEN
			casos_danos :=0;
		ELSE
			casos_danos:=((casos_danos::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;

		--sacando el porciento de devoluciones 
		IF casos_devoluciones=0 OR casos_totales=0  THEN
			casos_devoluciones :=0;
		ELSE
			casos_devoluciones:=((casos_devoluciones::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de cobranza 
		IF casos_cobranza=0 OR casos_totales=0  THEN
			casos_cobranza :=0;
		ELSE
			casos_danos:=((casos_cobranza::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de varios 
		IF casos_varios=0 OR casos_totales=0  THEN
			casos_varios :=0;
		ELSE
			casos_varios:=((casos_varios::double precision / casos_totales::double precision) * 100) ::double precision;
		END IF;
		
		IF casos_totales is null THEN
			casos_totales:= 0;
		END IF;
		IF casos_facturacion is null THEN
			casos_facturacion:= 0;
		END IF;
		IF casos_producto is null THEN
			casos_producto:= 0;
		END IF;
		IF casos_garantia is null THEN
			casos_garantia:= 0;
		END IF;
		
		IF casos_distribucion is null THEN
			casos_distribucion:= 0;
		END IF;
		IF casos_danos is null THEN
			casos_danos:= 0;
		END IF;
		IF casos_devoluciones is null THEN
			casos_devoluciones:= 0;
		END IF;
		IF casos_cobranza is null THEN
			casos_cobranza:= 0;
		END IF;
		IF casos_varios is null THEN
			casos_varios:= 0;
		END IF;
		
		/*
		cadena_sql:= 'select 
			'||casos_totales||'::integer as casos_totales,
			'||casos_facturacion||'::double precision as casos_facturacion,
			
			'||casos_producto||'::double precision as casos_producto,
			'||casos_garantia||'::double precision as casos_garantia,
			'||casos_distribucion||'::double precision as casos_distribucion,
			'||casos_danos||'::double precision as casos_danos,
			'||casos_devoluciones||'::double precision as casos_devoluciones,
			'||casos_cobranza||'::double precision as casos_cobranza,
			'||casos_varios||'::double precision as casos_varios 
			
			from crm_registro_casos  WHERE 
			crm_registro_casos.gral_empleado_id='||agente|| '
			and crm_registro_casos.gral_emp_id='||id_empresa||' '||cadena_where
			||'  limit 1';
			*/
			--RAISE EXCEPTION '%',cadena_sql;
	--END IF;
	
	--oportunidades
	--IF id=4 THEN
		
		/**##################################### Variables para el Buscador de Registro de Visitas################## */
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_oportunidades.fecha_oportunidad::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_oportunidades.gral_empleados_id ='||agente||'  AND ';
		END IF;
		
		--'||cadena_where2||'
		--sacando las oportunidades totales de un agente
		sql_execution:='select count(id), sum(monto) from crm_oportunidades  
				where '||cadena_where2||'
				 crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO total_metas_oport, total_montos_oport;
		--RAISE EXCEPTION '%',visitas_totales;
		
		
		cadena_where := '';
		IF trim(fecha_inicial)!='' AND trim(fecha_final)!='' THEN
			cadena_where :=' AND (
				(ano||''''||lpad(mes::character varying, 2, ''0''))::integer between 
				((select to_char('''||fecha_inicial||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_inicial||'''::timestamp with time zone,''MM'')) )::integer 
				AND 
				 ((select to_char('''||fecha_final||'''::timestamp with time zone,''YYYY'')::integer)||''''|| 
				(select to_char('''||fecha_final||'''::timestamp with time zone,''MM'')) )::integer
				)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_metas.gral_empleado_id='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select sum(crm_metas.cantidad_oportunidades),  
		sum(crm_metas.monto_oportunidades) from crm_metas 
		where '||cadena_where2||' 
		 crm_metas.gral_emp_id='||id_empresa||' '||cadena_where;
		
		EXECUTE sql_execution INTO metas_oport, monto_metas_oport;
		--RAISE EXCEPTION '%',visitas_meta;
		
		
		--sacando las oportunidades totales inicio
		cadena_where := '';
		IF fecha_inicial != '' AND fecha_inicial != ' ' AND fecha_final != '' AND fecha_final != ' ' THEN
			cadena_where :=' AND to_char(crm_oportunidades.fecha_oportunidad::timestamp with time zone, ''yyyymm'')::integer 
				between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymm'')::integer) 
				and (to_char('''||fecha_final||'''::timestamp with time zone,''yyyymm'')::integer)';
		END IF;
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_oportunidades.gral_empleados_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(id) from crm_oportunidades  
				where '||cadena_where2||'
				 crm_oportunidades.crm_etapas_venta_id=1 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_inicial;
		--RAISE EXCEPTION '%',visitas_totales;
		
		
		--sacando las oportunidades totales con seguimiento
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_oportunidades.gral_empleados_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(id) from crm_oportunidades  
				where '||cadena_where2||' 
				 crm_oportunidades.crm_etapas_venta_id=2 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_seguimiento;
		--RAISE EXCEPTION '%',visitas_totales;
		
		--sacando las oportunidades totales con visitas
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_oportunidades.gral_empleados_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(id) from crm_oportunidades  
				where '||cadena_where2||' 
				 crm_oportunidades.crm_etapas_venta_id=3 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_visitas;
		--RAISE EXCEPTION '%',visitas_totales;

		--sacando las oportunidades totales con cotizacion
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_oportunidades.gral_empleados_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(id) from crm_oportunidades  
				where '||cadena_where2||' 
				 crm_oportunidades.crm_etapas_venta_id=4 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_cotizacion;
		--RAISE EXCEPTION '%',oport_cotizacion;
		
		--sacando las oportunidades totales con negociacion
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_oportunidades.gral_empleados_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(id) from crm_oportunidades  
				where '||cadena_where2||' 
				 crm_oportunidades.crm_etapas_venta_id=5 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_negociacion;
		--RAISE EXCEPTION '%',oport_negociacion;
		
		--sacando las oportunidades totales con cierre
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_oportunidades.gral_empleados_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(id) from crm_oportunidades  
				where '||cadena_where2||'  
				 (crm_oportunidades.crm_etapas_venta_id=6 OR crm_oportunidades.crm_etapas_venta_id=7 ) 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_cierre;
		--RAISE EXCEPTION '%',oport_cierre;
		
		--sacando las oportunidades totales con ganados
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_oportunidades.gral_empleados_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(id) from crm_oportunidades  
				where '||cadena_where2||' 
				 crm_oportunidades.crm_etapas_venta_id=6 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_ganados;
		--RAISE EXCEPTION '%',oport_ganados;
		
		--sacando las oportunidades totales con perdidos
		cadena_where2 := ''; 
		IF agente != 0 THEN
			cadena_where2 := ' crm_oportunidades.gral_empleados_id ='||agente||' AND ';
		END IF;
		--'||cadena_where2||'
		sql_execution:='select count(id) from crm_oportunidades  
				where '||cadena_where2||'  
				 crm_oportunidades.crm_etapas_venta_id=7 
				and crm_oportunidades.gral_emp_id ='||id_empresa ||' '||cadena_where;
		EXECUTE sql_execution INTO oport_perdidos;
		--RAISE EXCEPTION '%',oport_perdidos;
		
		
		--sacando el porciento metas cumplidas
		IF metas_oport=0 OR total_metas_oport=0 THEN
			metas_cumplidas :=0;
		ELSE
			metas_cumplidas :=((total_metas_oport::double precision / metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos cumplidas
		IF total_montos_oport=0 OR monto_metas_oport=0 THEN
			montos_cumplidos :=0;
		ELSE
			montos_cumplidos :=((total_montos_oport::double precision / monto_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_inicial
		IF oport_inicial=0 OR total_metas_oport=0 THEN
			oport_inicial :=0;
		ELSE
			oport_inicial :=((oport_inicial::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_seguimiento
		IF oport_seguimiento=0 OR total_metas_oport=0 THEN
			oport_seguimiento :=0;
		ELSE
			oport_seguimiento :=((oport_seguimiento::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_visitas
		IF oport_visitas=0 OR total_metas_oport=0 THEN
			oport_visitas :=0;
		ELSE
			oport_visitas :=((oport_visitas::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_cotizacion=0 OR total_metas_oport=0 THEN
			oport_cotizacion :=0;
		ELSE
			oport_cotizacion :=((oport_cotizacion::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_negociacion=0 OR total_metas_oport=0 THEN
			oport_negociacion :=0;
		ELSE
			oport_negociacion :=((oport_negociacion::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_cierre=0 OR total_metas_oport=0 THEN
			oport_cierre :=0;
		ELSE
			oport_cierre :=((oport_cierre::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_ganados=0 OR total_metas_oport=0 THEN
			oport_ganados :=0;
		ELSE
			oport_ganados :=((oport_ganados::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		--sacando el porciento de montos oport_cotizacion
		IF oport_perdidos=0 OR total_metas_oport=0 THEN
			oport_perdidos :=0;
		ELSE
			oport_perdidos :=((oport_perdidos::double precision / total_metas_oport::double precision) * 100) ::double precision;
		END IF;
		
		IF metas_oport is null THEN metas_oport:=0; END IF;
		IF monto_metas_oport is null THEN monto_metas_oport:=0; END IF;
		IF total_metas_oport is null THEN total_metas_oport:=0; END IF;
		IF total_montos_oport is null THEN total_montos_oport:=0; END IF;
		IF metas_cumplidas is null THEN metas_cumplidas:=0; END IF;
		IF montos_cumplidos is null THEN montos_cumplidos:=0; END IF;
		IF oport_inicial is null THEN oport_inicial:=0; END IF;
		IF oport_seguimiento is null THEN oport_seguimiento:=0; END IF;
		IF oport_visitas is null THEN oport_visitas:=0; END IF;
		IF oport_cotizacion is null THEN oport_cotizacion:=0; END IF;
		IF oport_negociacion is null THEN oport_negociacion:=0; END IF;
		IF oport_cierre is null THEN oport_cierre:=0; END IF;
		IF oport_ganados is null THEN oport_ganados:=0; END IF;
		IF oport_perdidos is null THEN oport_perdidos:=0; END IF;

	
	
	
	
	--COTIZACIONES
	/**#####METAS DE COTIZACIONES PARA CLIENTES Y PROSPECTOS################## */
	IF trim(fecha_inicial)!='' AND trim(fecha_final)!='' THEN
		parametro_ano:= EXTRACT(YEAR FROM fecha_inicial::timestamp with time zone);
		parametro_mes:= EXTRACT(MONTH FROM fecha_inicial::timestamp with time zone);
	END IF;
	
	cadena_where := '';
	cadena_where2 := ''; 
	IF trim(fecha_inicial)!='' AND trim(fecha_final)!='' THEN
		cadena_where :='AND (crm_metas.mes  BETWEEN '||parametro_mes||' AND '||parametro_mes||')
				AND (crm_metas.ano  BETWEEN '||parametro_ano||' AND '||parametro_ano||')';
	END IF;
	
	IF agente != 0 THEN
		cadena_where2 := 'AND crm_metas.gral_empleado_id ='||agente||' ';
	END IF;
	
	--Obteniendo cantidades y montos de metas para clientes y Prospectos
	sql_execution:='
		SELECT sum(cantidad_cotizaciones), sum(monto_cotizaciones), sum(cantidad_cotizaciones2), sum(monto_cotizaciones2) 
		FROM crm_metas  
		WHERE crm_metas.gral_emp_id ='||id_empresa ||' '||cadena_where||' '||cadena_where2||' ';
	
	--RAISE EXCEPTION '%',sql_execution;
	
	EXECUTE sql_execution INTO cant_meta_cotiza_prospecto, monto_meta_cotiza_prospecto, cant_meta_cotiza_cliente, monto_meta_cotiza_cliente;
	
	IF cant_meta_cotiza_prospecto is null THEN cant_meta_cotiza_prospecto:= 0; END IF;
	IF monto_meta_cotiza_prospecto is null THEN monto_meta_cotiza_prospecto:= 0; END IF;
	IF cant_meta_cotiza_cliente is null THEN cant_meta_cotiza_cliente:= 0; END IF;
	IF monto_meta_cotiza_cliente is null THEN monto_meta_cotiza_cliente:= 0; END IF;
	
	
	--Inicializar variables
	cadena_where := '';
	cadena_where2 := ''; 
	sql_execution:='';
	IF trim(fecha_inicial)!='' AND trim(fecha_final)!='' THEN
		cadena_where :='AND (EXTRACT(MONTH FROM poc_cot.fecha::timestamp with time zone)  BETWEEN '||parametro_mes||' AND '||parametro_mes||')
				AND (EXTRACT(YEAR FROM poc_cot.fecha::timestamp with time zone)  BETWEEN '||parametro_ano||' AND '||parametro_ano||')';
	END IF;
	
	IF agente != 0 THEN
		cadena_where2 := 'AND poc_cot.cxc_agen_id ='||agente||' ';
	END IF;
	
	
	--Obtener la Cantidad y Monto de cotizaciones hechas para Prospectos
	sql_execution:='SELECT count(id), sum((total * tipo_cambio)) AS monto FROM poc_cot WHERE tipo=2 '||cadena_where||' '||cadena_where2||';';
	EXECUTE sql_execution INTO cant_cotiza_prospecto, monto_cotiza_prospecto;

	
	--Obtener la Cantidad y Monto de cotizaciones hechas para clientes
	sql_execution:='';
	sql_execution:='SELECT count(id), sum((total * tipo_cambio)) AS monto FROM poc_cot WHERE tipo=1 '||cadena_where||' '||cadena_where2||';';
	EXECUTE sql_execution INTO cant_cotiza_cliente, monto_cotiza_cliente;

	IF cant_cotiza_prospecto is null THEN cant_cotiza_prospecto:= 0; END IF;
	IF monto_cotiza_prospecto is null THEN monto_cotiza_prospecto:= 0; END IF;
	IF cant_cotiza_cliente is null THEN cant_cotiza_cliente:= 0; END IF;
	IF monto_cotiza_cliente is null THEN monto_cotiza_cliente:= 0; END IF;
	
	
	--Sacando el porcentaje de cotizaciones para prospecto de acuerdo a la Cantidad fijada en la meta
	IF cant_cotiza_prospecto=0 OR cant_meta_cotiza_prospecto=0 THEN
		porcentaje_cant_cotiza_prospecto :=0;
	ELSE
		porcentaje_cant_cotiza_prospecto := (cant_cotiza_prospecto::double precision *100)::double precision / cant_meta_cotiza_prospecto::double precision;
	END IF;

	--Sacando el porcentaje de cotizaciones para prospecto de acuerdo al Monto fijada en la meta
	IF monto_cotiza_prospecto=0 OR monto_meta_cotiza_prospecto=0 THEN
		porcentaje_monto_cotiza_prospecto :=0;
	ELSE
		porcentaje_monto_cotiza_prospecto := (monto_cotiza_prospecto::double precision *100)::double precision / monto_meta_cotiza_prospecto::double precision;
	END IF;



	--Sacando el porcentaje de cotizaciones para Cliente de acuerdo a la Cantidad fijada en la meta
	IF cant_cotiza_cliente=0 OR cant_meta_cotiza_cliente=0 THEN
		porcentaje_cant_cotiza_cliente :=0;
	ELSE
		porcentaje_cant_cotiza_cliente := (cant_cotiza_cliente::double precision *100)::double precision / cant_meta_cotiza_cliente::double precision;
	END IF;

	--Sacando el porcentaje de cotizaciones para Cliente de acuerdo al Monto fijada en la meta
	IF monto_cotiza_cliente=0 OR monto_meta_cotiza_cliente=0 THEN
		porcentaje_monto_cotiza_cliente :=0;
	ELSE
		porcentaje_monto_cotiza_cliente := (monto_cotiza_cliente::double precision *100)::double precision / monto_meta_cotiza_cliente::double precision;
	END IF;
	
	/**#####TERMINA COTIZACIONES PARA CLIENTES Y PROSPECTOS CONTRA METAS################## */



	
	--round(CAST(porcentaje_llamadas AS numeric), 4)::double precision,
	--select round(CAST(222.2222333332 AS numeric), 4)::double precision
	cadena_sql:= 'select 
			'||llamadas_meta||'::integer as cantidad_llamadas,
			'||llamadas_totales||'::integer as llamadas_totales,
			'||llamadas_entrantes||'::integer as llamadas_entrantes,
			'||llamadas_salientes||'::integer as llamadas_salientes,
			'||llamadas_planeadas||'::integer as llamadas_planeadas,
			'||llam_con_exito||'::integer as llamadas_con_exito,
			'||llam_con_cita||'::integer as llamadas_con_cita,
			'||llam_con_seguimiento||'::integer as llamadas_con_seguimiento,
			round(CAST('||porcentaje_cumplido|| ' AS numeric), 4)::double precision as porcentaje_llamadas,
			round(CAST('||efectividad||' AS numeric), 4)::double precision as efectividad_llamadas,
			round(CAST('||avance||' AS numeric), 4)::double precision as avance_llamadas,
			round(CAST('||gestion||' AS numeric), 4)::double precision as gestion_llamadas,
			round(CAST('||planeacion||' AS numeric), 4):: double precision  as  planeacion,
			'||visitas_meta||'::integer as visita_meta,
			'||visitas_totales||'::integer as visitas_totales,
			
			'||visita_con_exito||'::integer as visitas_con_exito,
			'||visita_con_cita||'::integer as visitas_con_cita,
			'||visita_con_seguimiento||'::integer as visitas_con_seguimiento,
			round(CAST('||porcentaje_cumplido_visitas||' AS numeric), 4)::double precision as porcentaje_visitas,
			round(CAST('||efectividad_visitas||' AS numeric), 4)::double precision as efectividad_visitas,
			round(CAST('||avance_visitas||' AS numeric), 4)::double precision as avance_visitas,
			round(CAST('||gestion_visitas||' AS numeric), 4)::double precision as gestion_visitas,
			'||casos_totales||'::integer as casos_totales,
			round(CAST('||casos_facturacion||' AS numeric), 4)::double precision as casos_facturacion,
			
			round(CAST('||casos_producto||' AS numeric), 4)::double precision as casos_producto,
			round(CAST('||casos_garantia||' AS numeric), 4)::double precision as casos_garantia,
			round(CAST('||casos_distribucion||' AS numeric), 4)::double precision as casos_distribucion,
			round(CAST('||casos_danos||' AS numeric), 4)::double precision as casos_danos,
			round(CAST('||casos_devoluciones||' AS numeric), 4)::double precision as casos_devoluciones,
			round(CAST('||casos_cobranza||' AS numeric), 4)::double precision as casos_cobranza,
			round(CAST('||casos_varios||' AS numeric), 4)::double precision as casos_varios,
			
			'||metas_oport||'::integer as metas_oport,
			'||total_metas_oport||'::integer as total_metas_oport,
			round(CAST('||monto_metas_oport||' AS numeric), 4)::double precision as monto_metas_oport,
			round(CAST('||total_montos_oport||' AS numeric), 4)::double precision as total_montos_oport,
			round(CAST('||metas_cumplidas||' AS numeric), 4)::double precision as metas_cumplidas,
			round(CAST('||montos_cumplidos||' AS numeric), 4)::double precision as montos_cumplidos,
			round(CAST('||oport_inicial||' AS numeric), 4)::double precision as oport_inicial,
			round(CAST('||oport_seguimiento||' AS numeric), 4)::double precision as oport_seguimiento,
			round(CAST('||oport_visitas||' AS numeric), 4)::double precision as oport_visitas,
			round(CAST('||oport_cotizacion||' AS numeric), 4)::double precision as oport_cotizacion,
			round(CAST('||oport_negociacion||' AS numeric), 4)::double precision as oport_negociacion,
			round(CAST('||oport_cierre||' AS numeric), 4)::double precision as oport_cierre,
			round(CAST('||oport_ganados||' AS numeric), 4)::double precision as oport_ganados,
			round(CAST('||oport_perdidos||' AS numeric), 4)::double precision as oport_perdidos,
			
			round(CAST('||cant_cotiza_prospecto||' AS numeric), 4)::double precision as monto_metas_oport,
			round(CAST('||monto_cotiza_prospecto||' AS numeric), 4)::double precision as total_montos_oport,
			round(CAST('||cant_cotiza_cliente||' AS numeric), 4)::double precision as metas_cumplidas,
			round(CAST('||monto_cotiza_cliente||' AS numeric), 4)::double precision as montos_cumplidos,
			round(CAST('||cant_meta_cotiza_prospecto||' AS numeric), 4)::double precision as oport_inicial,
			round(CAST('||monto_meta_cotiza_prospecto||' AS numeric), 4)::double precision as oport_seguimiento,
			round(CAST('||cant_meta_cotiza_cliente||' AS numeric), 4)::double precision as oport_visitas,
			round(CAST('||monto_meta_cotiza_cliente||' AS numeric), 4)::double precision as oport_cotizacion,
			round(CAST('||porcentaje_cant_cotiza_prospecto||' AS numeric), 4)::double precision as oport_negociacion,
			round(CAST('||porcentaje_monto_cotiza_prospecto||' AS numeric), 4)::double precision as oport_cierre,
			round(CAST('||porcentaje_cant_cotiza_cliente||' AS numeric), 4)::double precision as oport_ganados,
			round(CAST('||porcentaje_monto_cotiza_cliente||' AS numeric), 4)::double precision as oport_perdidos
			
			from crm_metas limit 1';
	
	
	
	FOR fila IN EXECUTE (cadena_sql) LOOP
		RETURN NEXT fila;
	END LOOP;
	
	
	/*
	select * from repventasnetasproductofactura(4,'','','2012-05-01','2012-06-05',4) as foo(
	numero_control character varying,
	 razon_social character varying,
	 codigo character varying,
	 producto character varying,
	 factura character varying ,
	 unidad character varying ,
	--cantidad double precision,
	precio_unitario double precision,
	moneda text,
	tipo_cambio double precision,
	total_pesos double precision,
	fecha_factura text
	);*/

END;

$$;


--
-- Name: ctb_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.ctb_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$


DECLARE 
	app_selected integer;
	command_selected text;
	usuario_ejecutor integer;
	emp_id integer;
	suc_id integer;
	str_data text[];
	str_filas text[];
	valor_retorno character varying = ''; 
	
	iter_y integer;--contador de filas o posiciones del arreglo (iterador eje y del arreglo iterado)
	ultimo_id integer:=0;
	ultimo_id2 integer:=0;
	espacio_tiempo_ejecucion timestamp with time zone := now();
	ano_actual integer;
	mes_actual integer;
	exis integer = 0;
	sql_select character varying:='';
	sql_select2 character varying:='';
	sql_select3 character varying:='';
	fila record;
	fila2 record;
	fila3 record;
	fila4 record;
	campo_valor double precision:=0;

	id_tipo_consecutivo integer:=0;
	prefijo_consecutivo character varying:='';
	nuevo_consecutivo bigint:=0;
	nuevo_folio character varying:='';

	titulo1 character varying:='';
	titulo2 character varying:='';
	titulo3 character varying:='';
	
	numero_cta_may smallint = 0;
	clasif_cta_may smallint = 0;
	nivel_cuenta smallint = 0;

	tipo_asiento integer := 0;
	ctb_param record;
	--Variable que indica el numero de digitos que debe tener el consecutivo de la poliza
	no_digitos_cons_pol integer := 0;
BEGIN
	
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- aplicativo que manda a llamar este procedimiento almacenado
	app_selected := str_data[1]::integer;
	
	-- comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	-- usuario que utiliza el aplicativo
	usuario_ejecutor := str_data[3]::integer;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	INTO emp_id, suc_id;
	
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--Catalogo de Cuentas Contables
	IF app_selected = 106 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id
		--str_data[5]	cuenta
		--str_data[6]	scuenta
		--str_data[7]	sscuenta
		--str_data[8]	ssscuenta
		--str_data[9]	sssscuenta
		--str_data[10]	cuenta_mayor
		--str_data[11]	estatus
		--str_data[12]	cta_detalle
		--str_data[13]	descripcion_es
		--str_data[14]	descripcion_in
		--str_data[15]	descripcion_otro
		--str_data[16]	select_centro_costo
		--str_data[17]	select_sucursal
		--str_data[18]	select_nivel
		--str_data[19]	select_naturaleza
		--str_data[20]	select_tipo_cta
		--str_data[21]	select_agrupador
		--str_data[22]	ctasat_id
		
		IF command_selected = 'new' THEN
			
			SELECT ctb_may_clase_id, clasificacion FROM ctb_may WHERE id=str_data[10]::integer INTO numero_cta_may, clasif_cta_may;
			
			IF str_data[5]<>'' THEN
				nivel_cuenta=1;
			ELSE
				str_data[5]:='0';
			END IF;
			
			IF str_data[6]<>'' THEN
				nivel_cuenta=2;
			ELSE
				str_data[6]:='0';
			END IF;
			
			IF str_data[7]<>'' THEN
				nivel_cuenta=3;
			ELSE
				str_data[7]:='0';
			END IF;
			
			IF str_data[8]<>'' THEN
				nivel_cuenta=4;
			ELSE
				str_data[8]:='0';
			END IF;
			
			IF str_data[9]<>'' THEN
				nivel_cuenta=5;
			ELSE
				str_data[9]:='0';
			END IF;
			
			INSERT INTO ctb_cta (
				cuenta, --lpad(str_data[5], 4, '0')||lpad(str_data[6], 4, '0')||lpad(str_data[7], 4, '0')||lpad(str_data[8], 4, '0')||lpad(str_data[9], 4, '0')
				cta, --str_data[5]::integer,
				subcta,--str_data[6]::integer,
				ssubcta,--str_data[7]::integer,
				sssubcta,--str_data[8]::integer,
				ssssubcta,--str_data[9]::integer,
				cta_mayor, --numero_cta_may,
				clasifica, --clasif_cta_may,
				detalle, --str_data[12]::smallint,
				descripcion, --str_data[13],
				descripcion_ing, --str_data[14],
				descripcion_otr, --str_data[15],
				ctb_cc_id, --str_data[16]::integer,
				gral_suc_id, --str_data[17]::integer,
				nivel, --str_data[18]::integer,
				tipo, --str_data[20]::integer,
				naturaleza, --str_data[19]::integer,
				ctb_app_id, --str_data[21]::integer,
				ctb_cta_sat_id, --str_data[22]::integer,
				nivel_cta, --nivel_cuenta,
				consolida,-- 0,
				estatus, --str_data[11]::smallint,
				momento_creacion, --espacio_tiempo_ejecucion,
				gral_usr_id_creacion, --usuario_ejecutor,
				gral_emp_id --emp_id
			)
			VALUES (
				lpad(str_data[5], 4, '0')||lpad(str_data[6], 4, '0')||lpad(str_data[7], 4, '0')||lpad(str_data[8], 4, '0')||lpad(str_data[9], 4, '0'),str_data[5]::integer,str_data[6]::integer,str_data[7]::integer,str_data[8]::integer,str_data[9]::integer,numero_cta_may,clasif_cta_may,str_data[12]::smallint,str_data[13],str_data[14],str_data[15],str_data[16]::integer,str_data[17]::integer, str_data[18]::integer, str_data[20]::integer, str_data[19]::integer,str_data[21]::integer, str_data[22]::integer,
				nivel_cuenta,0,str_data[11]::smallint,espacio_tiempo_ejecucion,usuario_ejecutor,emp_id);
			
			valor_retorno := '1';
		END IF;--termina nueva factura
		
		
		
		
		IF command_selected = 'edit' THEN
			SELECT ctb_may_clase_id, clasificacion FROM ctb_may WHERE id=str_data[10]::integer INTO numero_cta_may, clasif_cta_may;
			
			IF str_data[5]<>'' THEN
				nivel_cuenta=1;
			ELSE
				str_data[5]:='0';
			END IF;
			
			IF str_data[6]<>'' THEN
				nivel_cuenta=2;
			ELSE
				str_data[6]:='0';
			END IF;
			
			IF str_data[7]<>'' THEN
				nivel_cuenta=3;
			ELSE
				str_data[7]:='0';
			END IF;
			
			IF str_data[8]<>'' THEN
				nivel_cuenta=4;
			ELSE
				str_data[8]:='0';
			END IF;
			
			IF str_data[9]<>'' THEN
				nivel_cuenta=5;
			ELSE
				str_data[9]:='0';
			END IF;
			
			UPDATE ctb_cta SET 
				cuenta=lpad(str_data[5], 4, '0')||lpad(str_data[6], 4, '0')||lpad(str_data[7], 4, '0')||lpad(str_data[8], 4, '0')||lpad(str_data[9], 4, '0'),
				cta=str_data[5]::integer,subcta=str_data[6]::integer,ssubcta=str_data[7]::integer,sssubcta=str_data[8]::integer,ssssubcta=str_data[9]::integer,cta_mayor=numero_cta_may,clasifica=clasif_cta_may,detalle=str_data[12]::smallint,descripcion=str_data[13],descripcion_ing=str_data[14],descripcion_otr=str_data[15],ctb_cc_id=str_data[16]::integer, gral_suc_id=str_data[17]::integer, nivel=str_data[18]::integer, tipo=str_data[20]::integer, naturaleza=str_data[19]::integer, ctb_app_id=str_data[21]::integer,ctb_cta_sat_id=str_data[22]::integer,
				nivel_cta=nivel_cuenta,consolida= 0,estatus=str_data[11]::smallint,momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualizacion=usuario_ejecutor
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		--termina editar factura
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_cta SET borrado_logico=true, momento_baja=espacio_tiempo_ejecucion, gral_usr_id_baja=usuario_ejecutor
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
	END IF;--Termina Catalogo de Cuentas Contables
	




	--Aplicativo de Polizas Contables
	IF app_selected = 179 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	select_sucursal
		--str_data[6]	select_mes
		--str_data[7]	select_anio
		--str_data[8]	select_tipo
		--str_data[9]	select_moneda
		--str_data[10]	select_concepto
		--str_data[11]	fecha
		--str_data[12]	descripcion_poliza
		--str_data[13]	referencia
		
		IF command_selected = 'new' THEN
			
			prefijo_consecutivo:='';
			
			id_tipo_consecutivo:=50;--Folio Numero de Poliza Contable
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			--UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			--WHERE gral_emp_id=emp_id AND gral_suc_id=str_data[5]::integer AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Obtener los parametros de la sucursal
			SELECT * FROM ctb_par WHERE gral_emp_id=emp_id AND gral_suc_id=str_data[5]::integer LIMIT 1 INTO ctb_param;
			
			--Obtener la clave de la sucursal para utilizar de prefijo para el consecutivo de poliza
			select (CASE WHEN clave IS NULL THEN '' ELSE clave END) AS clave from gral_suc where id=ctb_param.gral_suc_id_cons LIMIT 1 INTO prefijo_consecutivo;
			
			IF prefijo_consecutivo IS NULL THEN prefijo_consecutivo:=''; END IF;
			
			if (select count(id) from ctb_pol_cons WHERE gral_emp_id=emp_id AND gral_suc_id=ctb_param.gral_suc_id_cons AND anio=str_data[7]::integer AND mes=str_data[6]::integer)<=0 then 
				--Si no existe el cosecutivo en el mes y a√±o  hay que crearlo
				insert into ctb_pol_cons(gral_emp_id, gral_suc_id, anio, mes, consecutivo, no_digitos)values(emp_id, ctb_param.gral_suc_id_cons, str_data[7]::integer, str_data[6]::integer, 0, 4);
			end if;
			
			--select count(id) as exis_consecutivo from ctb_pol_cons WHERE gral_emp_id=4 AND gral_suc_id=1 AND anio=2014 AND mes=12
			
			UPDATE 	ctb_pol_cons SET consecutivo=(consecutivo + 1)
			WHERE gral_emp_id=emp_id AND gral_suc_id=ctb_param.gral_suc_id_cons AND anio=str_data[7]::integer AND mes=str_data[6]::integer
			RETURNING consecutivo, no_digitos INTO nuevo_consecutivo, no_digitos_cons_pol;
			
			IF ctb_param.incluye_prefijo_clave_suc THEN 
				--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				nuevo_folio := prefijo_consecutivo || upper(lpad(nuevo_consecutivo::character varying, no_digitos_cons_pol, '0'));
			ELSE 
				--Aqui NO se concatena prefijo al nuevo consecutivo de numero de poliza
				nuevo_folio := upper(lpad(nuevo_consecutivo::character varying, no_digitos_cons_pol, '0'));
			END IF;
			
			
			--Obtener el titulo del tipo de poliza
			select titulo from ctb_tpol where id=str_data[8]::integer INTO titulo1;

			--Obtener el titulo del Concepto Contable
			select titulo from ctb_con where id=str_data[10]::integer INTO titulo2;

			--Obtener el nombre abreviado de la moneda
			select descripcion_abr from gral_mon where id=str_data[9]::integer INTO titulo3;
			
			--ESTATUS 1:"No afectana", 2:"Afectada", 3:"Cancelada"
			
			INSERT INTO ctb_pol (
				gral_emp_id, --emp_id,
				gral_suc_id, --str_data[5]::integer,
				ano, --str_data[7]::integer,
				mes,--str_data[6]::smallint,
				poliza,--nuevo_folio,
				ctb_tpol_id, --str_data[8]::integer,
				tipo, --titulo1,
				ctb_con_id, --str_data[10]::integer,
				concepto,--titulo2,
				fecha, --str_data[11]::timestamp with time zone,
				descripcion, --str_data[12]
				referencia, --str_data[13],
				gral_mon_id, --str_data[9]::integer,
				moneda, --titulo3,
				status, --1,
				modulo_origen,--0,
				fecha_cap, --now(),
				gral_usr_id_cap, --usuario_ejecutor,
				borrado_logico--false
			)
			VALUES (emp_id,str_data[5]::integer,str_data[7]::integer,str_data[6]::smallint,nuevo_folio,str_data[8]::integer,titulo1,str_data[10]::integer,titulo2,str_data[11]::timestamp with time zone,str_data[12],str_data[13],str_data[9]::integer,titulo3,1,0,now(),usuario_ejecutor,false)
			RETURNING id INTO ultimo_id;


			
			IF extra_data[1]<>'sin datos' THEN
			
				FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
					--str_filas[1]	eliminado
					--str_filas[2]	id_det
					--str_filas[3]	select_tmov
					--str_filas[4]	id_cta
					--str_filas[5]	select_cc
					--str_filas[6]	debe
					--str_filas[7]	haber
					--str_filas[8]	cta
					--str_filas[9]	no_tr

					IF str_filas[6]::double precision > 0 THEN 
						tipo_asiento:=1;--DEBE
					END IF; 
					
					IF str_filas[7]::double precision > 0 THEN 
						tipo_asiento:=2;--HABER
						str_filas[6] := str_filas[7];
					END IF; 
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						INSERT INTO ctb_pol_mov(
							ctb_pol_id,--ultimo_id,
							ctb_tmov_id,--str_filas[3]::integer,
							ctb_cta_id,--str_filas[4]::integer,
							ctb_cc_id,--str_filas[5]::integer,
							cta,--str_filas[8],
							tipo,--tipo_asiento,
							cantidad--str_filas[6]::double precision
						)VALUES(
							ultimo_id,
							str_filas[3]::integer,
							str_filas[4]::integer,
							str_filas[5]::integer,
							str_filas[8],
							tipo_asiento,
							str_filas[6]::double precision
						);
					END IF;
				END LOOP;
			END IF;
			
			
			valor_retorno := '1';
		END IF;
		--Termina nueva Poliza Contable
		
		
		
		
		IF command_selected = 'edit' THEN
			--Obtener el titulo del tipo de poliza
			select titulo from ctb_tpol where id=str_data[8]::integer INTO titulo1;
			
			--Obtener el titulo del Concepto Contable
			select titulo from ctb_con where id=str_data[10]::integer INTO titulo2;
			
			--Obtener el nombre abreviado de la moneda
			select descripcion_abr from gral_mon where id=str_data[9]::integer INTO titulo3;
			
			UPDATE ctb_pol SET gral_suc_id=str_data[5]::integer, ano=str_data[7]::integer, mes=str_data[6]::smallint, ctb_tpol_id=str_data[8]::integer, tipo=titulo1, ctb_con_id=str_data[10]::integer, concepto=titulo2, gral_mon_id=str_data[9]::integer, moneda=titulo3, descripcion=str_data[12], referencia=str_data[13], status=1, modulo_origen=0, fecha=str_data[11]::timestamp with time zone, gral_usr_id_mod=usuario_ejecutor, fecha_mod=now() 
			WHERE id=str_data[4]::integer;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
					--str_filas[1]	eliminado
					--str_filas[2]	id_det
					--str_filas[3]	select_tmov
					--str_filas[4]	id_cta
					--str_filas[5]	select_cc
					--str_filas[6]	debe
					--str_filas[7]	haber
					--str_filas[8]	cta
					--str_filas[9]	no_tr

					IF trim(str_filas[6]) <> '' THEN 
						IF str_filas[6]::double precision > 0 THEN 
							tipo_asiento:=1;--DEBE
						END IF; 
					END IF;

					IF trim(str_filas[7]) <> '' THEN 
						IF str_filas[7]::double precision > 0 THEN 
							tipo_asiento:=2;--HABER
							str_filas[6] := str_filas[7];
						END IF;
					END IF;
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						IF str_filas[2]::integer > 0 then
							--Aqui entra para actualizar los datos de los registros ya creados
							UPDATE ctb_pol_mov SET 
								ctb_tmov_id=str_filas[3]::integer,
								ctb_cta_id=str_filas[4]::integer,
								ctb_cc_id=str_filas[5]::integer,
								cta=str_filas[8],
								tipo=tipo_asiento,
								cantidad=str_filas[6]::double precision
							WHERE id=str_filas[2]::integer and ctb_pol_id=str_data[4]::integer;
						ELSE
							--Aqui entra para crear un registro nuevo que se haya agregado desde el grid de la vista
							INSERT INTO ctb_pol_mov(
								ctb_pol_id,--ultimo_id,
								ctb_tmov_id,--str_filas[3]::integer,
								ctb_cta_id,--str_filas[4]::integer,
								ctb_cc_id,--str_filas[5]::integer,
								cta,--str_filas[8],
								tipo,--tipo_asiento,
								cantidad--str_filas[6]::double precision
							)VALUES(
								str_data[4]::integer,
								str_filas[3]::integer,
								str_filas[4]::integer,
								str_filas[5]::integer,
								str_filas[8],
								tipo_asiento,
								str_filas[6]::double precision
							);
						END IF;
					ELSE
						--Aqui entra para eliminar un registro que se elimino en el grid de la vista 
						DELETE FROM ctb_pol_mov WHERE id=str_filas[2]::integer;
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;--termina editar Poliza
		
		
		
		IF command_selected = 'contabilizar' THEN
			/*
			Aqui entra para contabilizar la poliza y actualiza los datos del registro
			*/
		
			--Obtener el titulo del tipo de poliza
			select titulo from ctb_tpol where id=str_data[8]::integer INTO titulo1;
			
			--Obtener el titulo del Concepto Contable
			select titulo from ctb_con where id=str_data[10]::integer INTO titulo2;
			
			--Obtener el nombre abreviado de la moneda
			select descripcion_abr from gral_mon where id=str_data[9]::integer INTO titulo3;

			--status 1:"No afectana", 2:"Afectada", 3:"Cancelada"
			
			UPDATE ctb_pol SET gral_suc_id=str_data[5]::integer, ano=str_data[7]::integer, mes=str_data[6]::smallint, ctb_tpol_id=str_data[8]::integer, tipo=titulo1, ctb_con_id=str_data[10]::integer, concepto=titulo2, gral_mon_id=str_data[9]::integer, moneda=titulo3, descripcion=str_data[12], referencia=str_data[13], status=2, modulo_origen=0, gral_usr_id_afe=usuario_ejecutor, fecha_afe=now()
			WHERE id=str_data[4]::integer;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
					--str_filas[1]	eliminado
					--str_filas[2]	id_det
					--str_filas[3]	select_tmov
					--str_filas[4]	id_cta
					--str_filas[5]	select_cc
					--str_filas[6]	debe
					--str_filas[7]	haber
					--str_filas[8]	cta
					--str_filas[9]	no_tr

					IF trim(str_filas[6]) <> '' THEN 
						IF str_filas[6]::double precision > 0 THEN 
							tipo_asiento:=1;--DEBE
						END IF; 
					END IF;

					IF trim(str_filas[7]) <> '' THEN 
						IF str_filas[7]::double precision > 0 THEN 
							tipo_asiento:=2;--HABER
							str_filas[6] := str_filas[7];
						END IF;
					END IF;
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						IF str_filas[2]::integer > 0 then
							--Aqui entra para actualizar los datos de los registros ya creados
							UPDATE ctb_pol_mov SET ctb_tmov_id=str_filas[3]::integer,ctb_cta_id=str_filas[4]::integer,ctb_cc_id=str_filas[5]::integer,cta=str_filas[8],tipo=tipo_asiento,cantidad=str_filas[6]::double precision
							WHERE id=str_filas[2]::integer and ctb_pol_id=str_data[4]::integer;
						ELSE
							--Aqui entra para crear un registro nuevo que se haya agregado desde el grid de la vista
							INSERT INTO ctb_pol_mov(
								ctb_pol_id,--ultimo_id,
								ctb_tmov_id,--str_filas[3]::integer,
								ctb_cta_id,--str_filas[4]::integer,
								ctb_cc_id,--str_filas[5]::integer,
								cta,--str_filas[8],
								tipo,--tipo_asiento,
								cantidad--str_filas[6]::double precision
							)VALUES(str_data[4]::integer,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::integer,str_filas[8],tipo_asiento,str_filas[6]::double precision);
						END IF;
					ELSE
						--Aqui entra para eliminar un registro que se elimino en el grid de la vista 
						DELETE FROM ctb_pol_mov WHERE id=str_filas[2]::integer;
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;--termina Contabilizar Poliza



		IF command_selected = 'cancelar' THEN
			/*
			Aqui entra para CANCELAR la poliza
			*/
			--status 1:"No afectana", 2:"Afectada", 3:"Cancelada"
			
			UPDATE ctb_pol SET status=3, modulo_origen=0, gral_usr_id_can=usuario_ejecutor, fecha_can=now()
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;--termina Cancelar Poliza
		
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_pol SET borrado_logico=true, momento_baja=espacio_tiempo_ejecucion, gral_usr_id_baja=usuario_ejecutor
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
	END IF;--Termina Aplicativo de Polizas Contables







	--Aplicativo Definicion de Asientos Contables(CTB)
	IF app_selected = 203 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	nombre
		--str_data[6]	select_fecha
		--str_data[7]	select_pol_num
		--str_data[8]	select_tipo
		--str_data[9]	select_app
		
		IF command_selected = 'new' THEN 
			id_tipo_consecutivo:=57;--Folio Definicion de Asientos Contables

			select * from gral_cons where gral_emp_id=emp_id and borrado_logico=false and gral_cons_tipo_id=id_tipo_consecutivo order by id asc limit 1 into ultimo_id2;

			if ultimo_id2 is null then 
				ultimo_id2:=0;
			end if;
			
			update gral_cons set consecutivo=(select sbt.consecutivo + 1  from gral_cons AS sbt where sbt.id=gral_cons.id)
			where id=ultimo_id2 returning prefijo,consecutivo into prefijo_consecutivo,nuevo_consecutivo;
			
			--Nuevo consecutivo de Definicion de Asiento Contable
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
						
			insert into ctb_tmov(folio, titulo, fecha, pol_num, ctb_tpol_id,ctb_app_id, borrado_logico, momento_creacion, gral_usr_id_crea, gral_emp_id,gral_suc_id)
			values(nuevo_folio,str_data[5],str_data[6]::integer,str_data[7]::integer,str_data[8]::integer,str_data[9]::integer,false,espacio_tiempo_ejecucion,usuario_ejecutor,emp_id,suc_id)
			RETURNING id INTO ultimo_id;
			
			if trim(extra_data[1])<>'sin_datos' then 
				FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
					--str_filas[1]	eliminado
					--str_filas[2]	id_det
					--str_filas[3]	id_cta
					--str_filas[4]	select_mov
					--str_filas[5]	detalle
					--str_filas[6]	campo_importe
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						--Aqui entra para crear un registro nuevo que se haya agregado desde el grid de la vista
						INSERT INTO ctb_tmov_det(ctb_tmov_id,ctb_cta_id,mov_tipo,detalle,campo) VALUES(ultimo_id,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::boolean, str_filas[6]::smallint);
					END IF;
				END LOOP;
			else
				--RAISE EXCEPTION '%','extra_data: '||extra_data[1];
			end if;
			
			valor_retorno := '1';
		END IF;--Termina New
		
		
		
		
		IF command_selected = 'edit' THEN
			
			UPDATE ctb_tmov SET titulo=str_data[5],fecha=str_data[6]::integer,pol_num=str_data[7]::integer,ctb_tpol_id=str_data[8]::integer,ctb_app_id=str_data[9]::integer,momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualiza=usuario_ejecutor 
			WHERE id=str_data[4]::integer;
			
			if trim(extra_data[1])<>'sin_datos' then 
				FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
					--str_filas[1]	eliminado
					--str_filas[2]	id_det
					--str_filas[3]	id_cta
					--str_filas[4]	select_mov
					--str_filas[5]	detalle
					--str_filas[6]	campo_importe
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						IF str_filas[2]::integer > 0 then
							--Aqui entra para actualizar los datos de los registros ya creados
							UPDATE ctb_tmov_det SET ctb_cta_id=str_filas[3]::integer, mov_tipo=str_filas[4]::integer, detalle=str_filas[5]::boolean, campo=str_filas[6]::smallint
							WHERE id=str_filas[2]::integer and ctb_tmov_id=str_data[4]::integer;
						ELSE
							--Aqui entra para crear un registro nuevo que se haya agregado desde el grid de la vista
							INSERT INTO ctb_tmov_det(ctb_tmov_id,ctb_cta_id,mov_tipo,detalle,campo) VALUES(str_data[4]::integer,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::boolean, str_filas[6]::smallint);
						END IF;
					ELSE
						--Aqui entra para eliminar un registro que se elimino en el grid de la vista 
						DELETE FROM ctb_tmov_det WHERE id=str_filas[2]::integer;
					END IF;
				END LOOP;
			else
				--RAISE EXCEPTION '%','extra_data: '||extra_data[1];
			end if;
			
			valor_retorno := '1';
		END IF;
		--termina editar factura
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_tmov SET borrado_logico=true, momento_baja=espacio_tiempo_ejecucion, gral_usr_id_baja=usuario_ejecutor
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
	END IF;
	--Termina Aplicativo Definicion de Asientos Contables(CTB)
	


	
	--Aplicativo Generacion de Polizas Contables(CTB)
	IF app_selected = 206 THEN 
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	fecha_ini
		--str_data[6]	fecha_fin
		--str_data[7]	select_tipo_mov
		
		IF command_selected = 'new' THEN 
			prefijo_consecutivo:='';
			--Folio Numero de Poliza Contable
			id_tipo_consecutivo:=50;


			--Obtener los parametros de la sucursal
			SELECT * FROM ctb_par WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id LIMIT 1 INTO ctb_param;
			
			--Obtener la clave de la sucursal para utilizar de prefijo para el consecutivo de poliza
			select (CASE WHEN clave IS NULL THEN '' ELSE clave END) AS clave from gral_suc where id=ctb_param.gral_suc_id_cons LIMIT 1 INTO prefijo_consecutivo;
			
			IF prefijo_consecutivo IS NULL THEN prefijo_consecutivo:=''; END IF;
			


			
			--Obtener los movimientos
			sql_select := 'select * from ctb_reporte('''||app_selected||'___'||str_data[3]||'___busqueda___'||str_data[5]||'___'||str_data[6]||'___'||str_data[7]||''') 
			as foo(fecha date, ref_id integer, referencia character varying, descripcion character varying, total character varying, tmov_id integer, tipo_mov character varying, app_id integer) order by tmov_id, fecha;';

			
			--RAISE EXCEPTION '%','sql_select= '||sql_select;
			FOR fila IN EXECUTE (sql_select) LOOP 
				--RAISE EXCEPTION '%','fecha='||fila.fecha||'|ref_id='||fila.ref_id||'|referencia='||fila.referencia||'|descripcion='||fila.descripcion||'|total='||fila.total||'|tmov_id='||fila.tmov_id||'|tipo_mov='||fila.tipo_mov||'|app_id='||fila.app_id;
				
				select extract(year from fila.fecha) into ano_actual;
				select extract(month from fila.fecha) into mes_actual;
				
				if (select count(id) from ctb_pol_cons WHERE gral_emp_id=emp_id AND gral_suc_id=ctb_param.gral_suc_id_cons AND anio=ano_actual AND mes=mes_actual)<=0 then 
					--Si no existe el cosecutivo en el mes y a√±o  hay que crearlo
					insert into ctb_pol_cons(gral_emp_id, gral_suc_id, anio, mes, consecutivo, no_digitos)values(emp_id, ctb_param.gral_suc_id_cons, ano_actual, mes_actual, 0, 4);
				end if;
				
				UPDATE 	ctb_pol_cons SET consecutivo=(consecutivo + 1)
				WHERE gral_emp_id=emp_id AND gral_suc_id=ctb_param.gral_suc_id_cons AND anio=ano_actual AND mes=mes_actual 
				RETURNING consecutivo, no_digitos INTO nuevo_consecutivo, no_digitos_cons_pol;
				
				if ctb_param.incluye_prefijo_clave_suc then 
					--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
					nuevo_folio := prefijo_consecutivo || upper(lpad(nuevo_consecutivo::character varying, no_digitos_cons_pol, '0'));
				else 
					--Aqui NO se concatena prefijo al nuevo consecutivo de numero de poliza
					nuevo_folio := upper(lpad(nuevo_consecutivo::character varying, no_digitos_cons_pol, '0'));
				end if;
				
				
				for fila2 in select titulo,ctb_tpol_id,fecha,pol_num from ctb_tmov where id=fila.tmov_id loop 
					--Obtener el titulo del tipo de poliza
					select titulo from ctb_tpol where id=fila2.ctb_tpol_id INTO titulo1;
					
					--Obtener el titulo del Concepto Contable
					--select titulo from ctb_con where id=str_data[10]::integer INTO titulo2;
					
					--Obtener el nombre abreviado de la moneda
					select descripcion_abr from gral_mon where id=1 INTO titulo3;
					
					--ESTATUS 1:"No afectana", 2:"Afectada", 3:"Cancelada"
					insert into ctb_pol (
						gral_emp_id, --emp_id,
						gral_suc_id, --suc_id,
						ano, --ano_actual,
						mes,--mes_actual,
						poliza,--nuevo_folio,
						ctb_tpol_id, --fila2.ctb_tpol_id,
						tipo,--titulo1,
						ctb_con_id, --0,
						concepto,--titulo2,
						fecha,--fila.fecha,
						descripcion, --fola2.titulo,
						referencia, --fila.referencia,
						gral_mon_id, --1,
						moneda, --titulo3,
						status, --1,
						modulo_origen,--fil.app_id,
						fecha_cap, --espacio_tiempo_ejecucion,
						gral_usr_id_cap, --usuario_ejecutor,
						borrado_logico--false
					)
					values(emp_id,suc_id,ano_actual,mes_actual,nuevo_folio,fila2.ctb_tpol_id,titulo1,0,titulo2,fila.fecha,fila2.titulo,fila.referencia,1,titulo3,1,fila.app_id,espacio_tiempo_ejecucion,usuario_ejecutor,false) 
					returning id into ultimo_id;


					sql_select2 := '
					select 
						fac_docs.serie_folio,
						fac_docs.cxc_clie_id,
						cxc_clie.razon_social as cliente,
						fac_docs.subtotal * fac_docs.tipo_cambio::double precision as subtotal,
						fac_docs.impuesto * fac_docs.tipo_cambio::double precision as impuesto,
						fac_docs.total * fac_docs.tipo_cambio::double precision as total, 
						fac_docs.monto_retencion * fac_docs.tipo_cambio::double precision as retencion,
						fac_docs.monto_ieps * fac_docs.tipo_cambio::double precision as monto_ieps,
						cxc_clie.ctb_cta_id_activo,
						(CASE WHEN nivel_cta=1 THEN lpad(ctb_cta.cta::character varying,4,''0'') 
						WHEN ctb_cta.nivel_cta=2 THEN lpad(ctb_cta.cta::character varying,4,''0'')||''-''||lpad(ctb_cta.subcta::character varying,4,''0'') 
						WHEN ctb_cta.nivel_cta=3 THEN lpad(ctb_cta.cta::character varying,4,''0'')||''-''||lpad(ctb_cta.subcta::character varying,4,''0'')||''-''||lpad(ctb_cta.ssubcta::character varying,4,''0'') 
						WHEN ctb_cta.nivel_cta=4 THEN lpad(ctb_cta.cta::character varying,4,''0'')||''-''||lpad(ctb_cta.subcta::character varying,4,''0'')||''-''||lpad(ctb_cta.ssubcta::character varying,4,''0'')||''-''||lpad(ctb_cta.sssubcta::character varying,4,''0'') 
						WHEN ctb_cta.nivel_cta=5 THEN lpad(ctb_cta.cta::character varying,4,''0'')||''-''||lpad(ctb_cta.subcta::character varying,4,''0'')||''-''||lpad(ctb_cta.ssubcta::character varying,4,''0'')||''-''||lpad(ctb_cta.sssubcta::character varying,4,''0'')||''-''||lpad(ctb_cta.ssssubcta::character varying,4,''0'') 
						ELSE '''' 
						END) AS cuenta 
					from fac_docs 
					join cxc_clie on cxc_clie.id=fac_docs.cxc_clie_id 
					left join ctb_cta on ctb_cta.id=cxc_clie.ctb_cta_id_activo  
					where fac_docs.id='||fila.ref_id||' limit 1;';
					
					--RAISE EXCEPTION '%','sql_select= '||sql_select;
					
					for fila3 in execute sql_select2 loop 
						sql_select3 := '
						select 
							ctb_tmov_det.ctb_cta_id,
							(CASE WHEN nivel_cta=1 THEN lpad(ctb_cta.cta::character varying,4,''0'') 
							WHEN ctb_cta.nivel_cta=2 THEN lpad(ctb_cta.cta::character varying,4,''0'')||''-''||lpad(ctb_cta.subcta::character varying,4,''0'') 
							WHEN ctb_cta.nivel_cta=3 THEN lpad(ctb_cta.cta::character varying,4,''0'')||''-''||lpad(ctb_cta.subcta::character varying,4,''0'')||''-''||lpad(ctb_cta.ssubcta::character varying,4,''0'') 
							WHEN ctb_cta.nivel_cta=4 THEN lpad(ctb_cta.cta::character varying,4,''0'')||''-''||lpad(ctb_cta.subcta::character varying,4,''0'')||''-''||lpad(ctb_cta.ssubcta::character varying,4,''0'')||''-''||lpad(ctb_cta.sssubcta::character varying,4,''0'') 
							WHEN ctb_cta.nivel_cta=5 THEN lpad(ctb_cta.cta::character varying,4,''0'')||''-''||lpad(ctb_cta.subcta::character varying,4,''0'')||''-''||lpad(ctb_cta.ssubcta::character varying,4,''0'')||''-''||lpad(ctb_cta.sssubcta::character varying,4,''0'')||''-''||lpad(ctb_cta.ssssubcta::character varying,4,''0'') 
							ELSE '''' 
							END) AS cuenta, 
							ctb_cta.ctb_cc_id,
							ctb_tmov_det.mov_tipo,
							ctb_tmov_det.detalle,
							ctb_tmov_det.campo,
							ctb_cta.ctb_app_id,
							(case when ctb_app.gral_app_id is null then 0 else ctb_app.gral_app_id end) as gral_app_id 
						from ctb_tmov_det 
						join ctb_cta on ctb_cta.id=ctb_tmov_det.ctb_cta_id 
						left join ctb_app on ctb_app.id=ctb_cta.ctb_app_id 
						where ctb_tmov_det.ctb_tmov_id='||fila.tmov_id||' order by ctb_tmov_det.id;';
						
						--RAISE EXCEPTION '%','sql_select= '||sql_select;
						
						--mov_tipo 1=Debe, 2=Haber
						for fila4 in execute sql_select3 loop 
							campo_valor:=0;
							
							--2;"Proveedores"
							--8;"Productos"
							--59;"Chequeras"
							--167;"IEPS"
							
							--1=Subtotal, 2=Total, 3=I.V.A., 4=Retenci√≥n I.V.A., 5=I.E.P.S., 6=I.S.R.
							if fila3.campo=1 then 
								campo_valor:=fila3.subtotal;
							end if;
							
							if fila3.campo=2 then 
								campo_valor:=fila3.total;
							end if;

							if fila3.campo=3 then 
								campo_valor:=fila3.impuesto;
							end if;

							if fila3.campo=4 then 
								campo_valor:=fila3.retencion;
							end if;
							
							if fila3.campo=5 then 
								campo_valor:=fila3.monto_ieps;
							end if;
							
							if fila3.campo=6 then 
								--campo_valor:=fila3.total;
							end if;
							
							--5;"Clientes"
							if fila4.gral_app_id=5 then 
								if fila3.detalle then 
									insert into ctb_pol_mov(ctb_pol_id,ctb_tmov_id,ctb_cc_id,ctb_cta_id,cta,tipo,cantidad)
									VALUES(ultimo_id,fila.tmov_id,fila4.ctb_cc_id,fila3.ctb_cta_id_activo,fila3.cuenta,fila4.mov_tipo,campo_valor);
								else 
									insert into ctb_pol_mov(ctb_pol_id,ctb_tmov_id,ctb_cc_id,ctb_cta_id,cta,tipo,cantidad)
									VALUES(ultimo_id,fila.tmov_id,fila4.ctb_cc_id,fila4.ctb_cta_id,fila4.cuenta,fila4.mov_tipo,campo_valor);
								end if;
							end if;
							
							--204;"IVA Trasladado"
							if fila4.gral_app_id=204 then 
								if fila3.detalle then 
									
								else
									insert into ctb_pol_mov(ctb_pol_id,ctb_tmov_id,ctb_cc_id,ctb_cta_id,cta,tipo,cantidad)
									values(ultimo_id,fila.tmov_id,fila4.ctb_cc_id,fila4.ctb_cta_id,fila4.cuenta,fila4.mov_tipo,campo_valor);
								end if;
							end if;
							
							--205;"IVA Retenido"
							if fila4.gral_app_id=205 then 
								if fila3.detalle then 
									
								else
									insert into ctb_pol_mov(ctb_pol_id,ctb_tmov_id,ctb_cc_id,ctb_cta_id,cta,tipo,cantidad)
									values(ultimo_id,fila.tmov_id,fila4.ctb_cc_id,fila4.ctb_cta_id,fila4.cuenta,fila4.mov_tipo,campo_valor);
								end if;
							end if;
							
							if fila4.gral_app_id<=0 then 
								insert into ctb_pol_mov(ctb_pol_id,ctb_tmov_id,ctb_cc_id,ctb_cta_id,cta,tipo,cantidad)
								values(ultimo_id,fila.tmov_id,fila4.ctb_cc_id,fila4.ctb_cta_id,fila4.cuenta,fila4.mov_tipo,campo_valor);
							end if;
						end loop;
					end loop;
				end loop;

				--Actualizar registro de factura para indicar que ya se gener√≥ poliza
				update fac_docs set procesado=true, fecha_procesa=espacio_tiempo_ejecucion, gral_usr_id_procesa=usuario_ejecutor 
				where id=fila.ref_id;
				
			END LOOP;
			
			valor_retorno := '1';
		END IF;--Termina New
		
	END IF;
	--Termina Aplicativo Generacion de Polizas Contables(CTB)
















	
	
	
	RETURN valor_retorno; 

END;
$$;


--
-- Name: ctb_reporte(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.ctb_reporte(campos_data character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
	app_selected integer;
	command_selected character varying;
	usuario_ejecutor integer;
	emp_id integer;
	suc_id integer;
	aplicacion_id integer := 0;
	
	cadena_where character varying = '';
	cadena_where2 character varying = '';
	cadena_where3 character varying = '';
	cadena_sql character varying = '';
	returnrecord record;
	valor1 character varying:='';
	valor2 character varying:='';
	cadena1 character varying:='';
	desc_cta_may_clases character varying:='';
	desc_cta_may character varying:='';
	
	str_data text[];
	exis integer=0;
	
	
	cadena_sql2 character varying='';
	
	cadena_campos text = '';
	ano_actual integer;
	mes_actual integer;
	id_almacen integer;
	incrementa int:=1;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	existencia double precision;
	fila record;
	fila2 record;
	fila3 record;
	fila4 record;
	equivalenciaPres double precision=0;
	suma1 double precision:=0.0;
	suma2 double precision:=0.0;
	suma3 double precision:=0.0;
BEGIN	
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	app_selected:=str_data[1]::integer;--app_selected
	usuario_ejecutor:=str_data[2]::integer;--id_usuario
	command_selected = str_data[3];
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--Obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	INTO emp_id, suc_id;
	
	
	--Reporte Auxiliar de Cuentas
	IF app_selected = 157 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_user
		--str_data[3]	command_selected
		--str_data[4]	tipo_reporte
		--str_data[5]	ano
		--str_data[6]	mes
		--str_data[7]	cuentas
		--str_data[8]	cta
		--str_data[9]	scta
		--str_data[10]	sscta
		--str_data[11]	ssscta
		--str_data[12]	sssscta
		--str_data[13]	tipo_documento
		
		
		BEGIN 
			--Crear tabla temporal
			CREATE TEMPORARY TABLE tmpRepCtb(cuenta character varying, descripcion character varying, saldo_inicial character varying, debe character varying, haber character varying, saldo_final character varying);
			EXCEPTION WHEN OTHERS THEN
			TRUNCATE TABLE tmpRepCtb; -- TRUNCATE if the table already exists within the session.
		END;
		
		--BUSQUEDA PARA EL REPORTE-------------
		IF command_selected='reporte' THEN 
			--tipo de reporte
			IF str_data[4]::integer=1 THEN
				--Mensual
				cadena_where2:=' and ctb_pol.ano='||str_data[5]||' and ctb_pol.mes='||str_data[6]||'';
				cadena_where3:=' and ctb_sdo_cta.ano='||str_data[5]||' and ctb_sdo_cta.mes='||str_data[6]||'';
			ELSE
				--Anual
				cadena_where2:=' and ctb_pol.ano='||str_data[5]||'';
				cadena_where3:=' and ctb_sdo_cta.ano='||str_data[5]||'';
			END IF;
			
			--Cuuntas
			IF str_data[7]::integer=1 THEN
				--Todas
				cadena_where:=cadena_where||' ';
			ELSE
				--Una cuenta
				IF str_data[8]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.cta='||str_data[8]; END IF;
				IF str_data[9]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.subcta='||str_data[9]; END IF;
				IF str_data[10]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.ssubcta='||str_data[10]; END IF;
				IF str_data[11]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.sssubcta='||str_data[11]; END IF;
				IF str_data[12]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.ssssubcta='||str_data[12]; END IF;
			END IF;
			
			--Cadena para espacios en blanco cuando es para mostrar el resultado en el navegador
			cadena1:='&nbsp;';
			IF trim(str_data[13])='pdf' THEN 
				--Cadena para espacios en blanco cuando es para mostrar el resultado en pdf
				cadena1:=' ';
			END IF;
			
			cadena_sql:= '
			SELECT 
				cta_mayor,
				clasifica,
				(CASE WHEN cta>0 THEN cta::character varying ELSE '''' END)||(CASE WHEN subcta>0 THEN lpad(subcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ssubcta>0 THEN lpad(ssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN sssubcta>0 THEN lpad(sssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ssssubcta>0 THEN lpad(ssssubcta::character varying,4,''0'') ELSE '''' END) AS cta1,
				cta_mayor||'' ''||clasifica||'' ''||(CASE WHEN cta>0 THEN cta::character varying ELSE '''' END)||(CASE WHEN subcta>0 THEN ''-''||lpad(subcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ssubcta>0 THEN ''-''||lpad(ssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN sssubcta>0 THEN ''-''||lpad(sssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ssssubcta>0 THEN ''-''||lpad(ssssubcta::character varying, 4, ''0'') ELSE '''' END) AS cta,
				(CASE WHEN (cta>0 AND subcta=0 AND ssubcta=0 AND sssubcta=0 AND ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||'''
				      WHEN (cta>0 AND subcta>0 AND ssubcta=0 AND sssubcta=0 AND ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
				      WHEN (cta>0 AND subcta>0 AND ssubcta>0 AND sssubcta=0 AND ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
				      WHEN (cta>0 AND subcta>0 AND ssubcta>0 AND sssubcta>0 AND ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
				      WHEN (cta>0 AND subcta>0 AND ssubcta>0 AND sssubcta>0 AND ssssubcta>0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
				 ELSE '''' END)||ctb_cta.descripcion AS descripcion,
				 ctb_cta.naturaleza,
				 ctb_cta.nivel 
			FROM ctb_cta 
			WHERE borrado_logico=false AND gral_emp_id='||emp_id||' '||cadena_where||' 
			ORDER BY cta_mayor, clasifica, cta;';
			
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP 
				IF valor1<>fila.cta_mayor::character varying THEN 
					valor1:=fila.cta_mayor::character varying;
					valor2:=fila.clasifica::character varying;
					
					--Obtener la descripcion de la clase de cuenta de Mayor
					SELECT titulo FROM ctb_may_clases WHERE id=fila.cta_mayor::integer LIMIT 1
					INTO desc_cta_may_clases;

					--Agregar la clase de la Cuenta de mayor
					INSERT INTO tmpRepCtb (cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(fila.cta_mayor||' 0 0000', desc_cta_may_clases, '','', '', '');
					
					SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint
					INTO desc_cta_may;
					
					--Agregar la clasificacion de la Cuenta de Mayor
					INSERT INTO tmpRepCtb (cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(fila.cta_mayor||' '||fila.clasifica||' 0000', cadena1||cadena1||cadena1||desc_cta_may, '','', '', '');
					
					--Agregar la cuenta contable
					--INSERT INTO tmpRepCtb (nivel, cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(0, fila.cta, fila.descripcion, '0','0', '0', '0');
					
					cadena_sql2:='
					select 
						ctb_pol.poliza,
						to_char(ctb_pol.fecha,''dd/mm/yyyy'') as fecha,
						ctb_pol.observacion,
						(case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, 
						(case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber
					from ctb_pol 
					join ctb_pol_mov on ctb_pol_mov.ctb_pol_id=ctb_pol.id 
					where replace(ctb_pol_mov.cta,''-'','''') ilike '''||fila.cta1||'%'' '||cadena_where2||' ';
					
					FOR fila2 IN EXECUTE (cadena_sql2) LOOP 
						--Agregar la movimientos de la cuenta contable
						INSERT INTO tmpRepCtb (cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(fila.cta, fila.descripcion, '0','0', '0', '0');
					END LOOP;
				ELSE
					
					IF valor2<>fila.clasifica::character varying THEN 
						valor2:=fila.clasifica::character varying;
						SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint 
						INTO desc_cta_may;
						
						--Agregar la clasificacion de la Cuenta de Mayor
						INSERT INTO tmpRepCtb (cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(fila.cta_mayor||' '||fila.clasifica||' 0000', cadena1||cadena1||cadena1||desc_cta_may, '','', '', '');
					END IF;
					
					--Agregar la cuenta contable
					INSERT INTO tmpRepCtb (cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(fila.cta, fila.descripcion, '0','0', '0', '0');
				END IF;
				
			END LOOP;
			
		END IF;--termina command reporte

		--Recorriendo la tabla temporal y retornando sus filas
		FOR returnrecord IN SELECT * FROM tmpRepCtb LOOP
			RETURN NEXT returnrecord;
		END LOOP;
	END IF;
	--Termina Reporte Auxiliar de Cuentas



	--Reporte  de Balanza de Comprobacion
	IF app_selected = 158 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_user
		--str_data[3]	command_selected
		--str_data[4]	suc
		--str_data[5]	fecha_ini
		--str_data[6]	fecha_fin
		--str_data[7]	cuentas
		--str_data[8]	cta
		--str_data[9]	scta
		--str_data[10]	sscta
		--str_data[11]	ssscta
		--str_data[12]	sssscta
		--str_data[13]	tipo_documento
		
		
		BEGIN 
			--Crear tabla temporal
			CREATE TEMPORARY TABLE tmpRepCtbBalanzaComp(nivel integer, cuenta1 character varying, cuenta character varying, descripcion character varying, saldo_inicial character varying, debe character varying, haber character varying, saldo_final character varying);
			EXCEPTION WHEN OTHERS THEN
			TRUNCATE TABLE tmpRepCtbBalanzaComp; -- TRUNCATE if the table already exists within the session.
		END;
		
		--BUSQUEDA PARA EL REPORTE-------------
		IF command_selected='reporte' THEN 
			
			--RAISE EXCEPTION '%',cadena_where2;
			
			--Cuentas
			IF str_data[7]::integer=1 THEN
				--Todas
				cadena_where:=cadena_where||' ';
			ELSE
				--Una cuenta
				IF str_data[8]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.cta='||str_data[8]; END IF;
				IF str_data[9]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.subcta='||str_data[9]; END IF;
				IF str_data[10]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.ssubcta='||str_data[10]; END IF;
				IF str_data[11]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.sssubcta='||str_data[11]; END IF;
				IF str_data[12]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.ssssubcta='||str_data[12]; END IF;
			END IF;
			
			--Cadena para espacios en blanco cuando es para mostrar el resultado en el navegador
			cadena1:='&nbsp;';
			IF trim(str_data[13])='pdf' THEN 
				--Cadena para espacios en blanco cuando es para mostrar el resultado en pdf
				cadena1:=' ';
			END IF;
			
			cadena_sql:= '
			select sbt3.cta_mayor, sbt3.clasifica, sbt3.cuenta, sbt3.cta1, sbt3.cta, sbt3.descripcion, sbt3.naturaleza, sbt3.nivel, sbt3.saldo_ini, sbt3.saldo_fin, sbt3.ini_debe, sbt3.ini_haber, sum(case when pol_mov.debe is null then 0 else pol_mov.debe end) as debe, sum(case when pol_mov.haber is null then 0 else pol_mov.haber end) as haber 
			from (
				select sbt2.cta_mayor, sbt2.clasifica, sbt2.cuenta, sbt2.cta1, sbt2.cta, sbt2.descripcion, sbt2.naturaleza, sbt2.nivel, sbt2.saldo_ini, sbt2.saldo_fin, sum(case when pol_mov_ini.debe is null then 0 else pol_mov_ini.debe end) as ini_debe, sum(case when pol_mov_ini.haber is null then 0 else pol_mov_ini.haber end) as ini_haber 
				from(
					select sbt1.cta_mayor, sbt1.clasifica, sbt1.cuenta, sbt1.cta1, sbt1.cta, sbt1.descripcion, sbt1.naturaleza, sbt1.nivel, sum(case when ctb_sdo.saldo_ini is null then 0 else ctb_sdo.saldo_ini end) as saldo_ini, sum(case when ctb_sdo.saldo_fin is null then 0 else ctb_sdo.saldo_fin end) as saldo_fin 
					from (
						SELECT 
							ctb_cta.cta_mayor,
							ctb_cta.clasifica,
							ctb_cta.cta as cuenta,
							(CASE WHEN ctb_cta.cta>0 THEN ctb_cta.cta::character varying ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN lpad(ctb_cta.subcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN lpad(ctb_cta.ssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN lpad(ctb_cta.sssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssssubcta>0 THEN lpad(ctb_cta.ssssubcta::character varying,4,''0'') ELSE '''' END) AS cta1,
							ctb_cta.cta_mayor||'' ''||ctb_cta.clasifica||'' ''||(CASE WHEN ctb_cta.cta>0 THEN ctb_cta.cta::character varying ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN ''-''||lpad(ctb_cta.subcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN ''-''||lpad(ctb_cta.ssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN ''-''||lpad(ctb_cta.sssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssssubcta>0 THEN ''-''||lpad(ctb_cta.ssssubcta::character varying, 4, ''0'') ELSE '''' END) AS cta,
							(CASE WHEN (ctb_cta.cta>0 AND ctb_cta.subcta=0 AND ctb_cta.ssubcta=0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||'''
							      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta=0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
							      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
							      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta>0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
							      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta>0 AND ctb_cta.ssssubcta>0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
							 ELSE '''' END)||ctb_cta.descripcion AS descripcion,
							 ctb_cta.naturaleza,
							 ctb_cta.nivel 
						FROM ctb_cta 
						WHERE ctb_cta.borrado_logico=false AND ctb_cta.gral_emp_id='||emp_id||' '||cadena_where||' 
					) as sbt1 
					left join (
						select replace(ctb_sdo_cta.cta,''-'','''') as cta, sum(case when ctb_sdo_cta.saldo_ini is null then 0 else ctb_sdo_cta.saldo_ini end) as saldo_ini, sum(case when ctb_sdo_cta.saldo_fin is null then 0 else ctb_sdo_cta.saldo_fin end) as saldo_fin 
						from ctb_sdo_cta where ctb_sdo_cta.ano=extract(year from '''||str_data[5]||'''::timestamp with time zone) 
						group by ctb_sdo_cta.cta 
					) as ctb_sdo on ctb_sdo.cta ilike sbt1.cta1||''%'' 
					group by sbt1.cta_mayor, sbt1.clasifica, sbt1.cuenta, sbt1.cta1, sbt1.cta, sbt1.descripcion, sbt1.naturaleza, sbt1.nivel 
				) as sbt2 
				left join (
					select replace(ctb_pol_mov.cta,''-'','''') as cta, sum(case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, sum(case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber 
					from ctb_pol_mov join ctb_pol on ctb_pol.id=ctb_pol_mov.ctb_pol_id where to_char(ctb_pol.fecha,''yyyymmdd'')::integer >= (extract(year from '''||str_data[5]||'''::timestamp with time zone)||''0101'')::integer  and to_char(ctb_pol.fecha,''yyyymmdd'')::integer < to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer 
					group by ctb_pol_mov.cta 
				) as pol_mov_ini on pol_mov_ini.cta ilike sbt2.cta1||''%'' 
				group by sbt2.cta_mayor, sbt2.clasifica, sbt2.cuenta, sbt2.cta1, sbt2.cta, sbt2.descripcion, sbt2.naturaleza, sbt2.nivel, sbt2.saldo_ini, sbt2.saldo_fin 
			) as sbt3 
			left join (
				select replace(ctb_pol_mov.cta,''-'','''') as cta, sum(case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, sum(case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber 
				from ctb_pol_mov join ctb_pol on ctb_pol.id=ctb_pol_mov.ctb_pol_id where to_char(ctb_pol.fecha,''yyyymmdd'')::integer BETWEEN to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer AND to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer
				group by ctb_pol_mov.cta 
			) as pol_mov on pol_mov.cta ilike sbt3.cta1||''%'' 
			group by sbt3.cta_mayor, sbt3.clasifica, sbt3.cuenta, sbt3.cta1, sbt3.cta, sbt3.descripcion, sbt3.naturaleza, sbt3.nivel, sbt3.ini_debe, sbt3.ini_haber, sbt3.saldo_ini, sbt3.saldo_fin 
			ORDER BY sbt3.cta_mayor, sbt3.clasifica, sbt3.cuenta;';
			
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP
				IF valor1<>fila.cta_mayor::character varying THEN 
					valor1:=fila.cta_mayor::character varying;
					valor2:=fila.clasifica::character varying;

					if fila.saldo_ini is null then fila.saldo_ini:=0; end if;
					if fila.saldo_fin is null then fila.saldo_fin:=0; end if;
					if fila.ini_debe is null then fila.ini_debe:=0; end if;
					if fila.ini_haber is null then fila.ini_haber:=0; end if;
					if fila.debe is null then fila.debe:=0; end if;
					if fila.haber is null then fila.haber:=0; end if;
					
					--fila.nivel  1=Auxiliar, 2=Mayor
					
					--Obtener la descripcion de la clase de cuenta de Mayor
					SELECT titulo FROM ctb_may_clases WHERE id=fila.cta_mayor::integer LIMIT 1
					INTO desc_cta_may_clases;
					
					--Agregar la clase de la Cuenta de mayor
					INSERT INTO tmpRepCtbBalanzaComp(nivel, cuenta1, cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(0, '0000', fila.cta_mayor||' 0 0000', desc_cta_may_clases, '','', '', '');
					--INSERT INTO tmpRepCtb (cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(fila.cta_mayor||' 0 0000', desc_cta_may_clases, '0','0', '0', '0');
					
					SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint
					INTO desc_cta_may;
					
					--Agregar la clasificacion de la Cuenta de Mayor
					INSERT INTO tmpRepCtbBalanzaComp(nivel, cuenta1, cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(0,  '0000', fila.cta_mayor||' '||fila.clasifica||' 0000', cadena1||cadena1||cadena1||desc_cta_may, '','', '', '');
					
					--1=Deudora, 2=Acreedora
					if fila.naturaleza=1 then 
						--Calcular el saldo inicial a la fecha inicial del reporte
						fila.saldo_ini:= fila.saldo_ini + fila.ini_debe - fila.ini_haber;
						
						fila.saldo_fin:=fila.saldo_ini + fila.debe - fila.haber;
					else
						--Calcular el saldo inicial a la fecha inicial del reporte
						fila.saldo_ini:= fila.saldo_ini - fila.ini_debe + fila.ini_haber;
						
						fila.saldo_fin:=fila.saldo_ini - fila.debe + fila.haber;
					end if;
					
					--Agregar la cuenta contable
					INSERT INTO tmpRepCtbBalanzaComp(nivel, cuenta1,cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(fila.nivel, fila.cta1, fila.cta, fila.descripcion, fila.saldo_ini, fila.debe::character varying, fila.haber::character varying, fila.saldo_fin::character varying);
				ELSE
					
					IF valor2<>fila.clasifica::character varying THEN 
						valor2:=fila.clasifica::character varying;
						SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint 
						INTO desc_cta_may;
						
						--Agregar la clasificacion de la Cuenta de Mayor
						INSERT INTO tmpRepCtbBalanzaComp(nivel, cuenta1,cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(0, '0000',fila.cta_mayor||' '||fila.clasifica||' 0000', cadena1||cadena1||cadena1||desc_cta_may, '','', '', '');
					END IF;
					
					/*
					--Obtener sumas de la cuenta en el periodo indicado por Fecha Inicial y Fecha Final
					execute 'select sum(debe) as debe, sum(haber) as haber 
					from(
						select (case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, (case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber 
						from ctb_pol_mov 
						join ctb_pol on (ctb_pol.id=ctb_pol_mov.ctb_pol_id and (to_char(ctb_pol.fecha,''yyyymmdd'')::integer BETWEEN  to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer AND to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer))
						where replace(ctb_pol_mov.cta,''-'','''') ilike '''||fila.cta1||'%'' 
					) as sbt' into fila2;
					
					
					if fila2.debe is null then fila2.debe:=0; end if;
					if fila2.haber is null then fila2.haber:=0; end if;
					
					
					--Obtener el saldo inicial de la cuenta en el a√±o que indique la Fecha Inicial del periodo de la consulta
					execute 'select sum(saldo_ini) as saldo_ini, sum(debe) as debe, sum(haber) as haber, sum(saldo_fin) as saldo_fin 
					from(
						select (case when ctb_sdo_cta.saldo_ini is null then 0 else ctb_sdo_cta.saldo_ini end) as saldo_ini, 
							(case when ctb_sdo_cta.debe is null then 0 else ctb_sdo_cta.debe end) as debe, 
							(case when ctb_sdo_cta.haber is null then 0 else ctb_sdo_cta.haber end) as haber,
							(case when ctb_sdo_cta.saldo_fin is null then 0 else ctb_sdo_cta.saldo_fin end) as saldo_fin 
						from ctb_sdo_cta 
						where replace(ctb_sdo_cta.cta,''-'','''') ilike '''||fila.cta1||'%'' and ctb_sdo_cta.ano=extract(year from '''||str_data[5]||'''::timestamp with time zone) 
					) as sbt' into fila3;

					if fila3.debe is null then fila3.debe:=0; end if;
					if fila3.haber is null then fila3.haber:=0; end if;
					if fila3.saldo_ini is null then fila3.saldo_ini:=0; end if;
					if fila3.saldo_fin is null then fila3.saldo_fin:=0; end if;


					--Obtener la suma de los movimientos desde el comienzo del a√±o a un d√≠a antes de la Fecha Inicial del periodo de la consulta
					execute 'select sum(debe) as debe, sum(haber) as haber 
					from(
						select (case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, (case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber 
						from ctb_pol_mov 
						join ctb_pol on (ctb_pol.id=ctb_pol_mov.ctb_pol_id and to_char(ctb_pol.fecha,''yyyymmdd'')::integer >= (extract(year from '''||str_data[5]||'''::timestamp with time zone)||''0101'')::integer  and to_char(ctb_pol.fecha,''yyyymmdd'')::integer < to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer)
						where replace(ctb_pol_mov.cta,''-'','''') ilike '''||fila.cta1||'%'' 
					) as sbt' into fila4;
					
					if fila4.debe is null then fila4.debe:=0; end if;
					if fila4.haber is null then fila4.haber:=0; end if;
					*/

					--1=Deudora, 2=Acreedora
					if fila.naturaleza=1 then 
						--Calcular el saldo inicial a la fecha inicial del reporte
						fila.saldo_ini:= fila.saldo_ini + fila.ini_debe - fila.ini_haber;
						
						fila.saldo_fin:=fila.saldo_ini + fila.debe - fila.haber;
					else
						--Calcular el saldo inicial a la fecha inicial del reporte
						fila.saldo_ini:= fila.saldo_ini - fila.ini_debe + fila.ini_haber;
						
						fila.saldo_fin:=fila.saldo_ini - fila.debe + fila.haber;
					end if;
					
					--Agregar la cuenta contable
					INSERT INTO tmpRepCtbBalanzaComp(nivel, cuenta1,cuenta, descripcion, saldo_inicial, debe, haber, saldo_final) VALUES(fila.nivel, fila.cta1,fila.cta, fila.descripcion, fila.saldo_ini, fila.debe::character varying, fila.haber::character varying, fila.saldo_fin::character varying);
				END IF;
				
			END LOOP;
			
		END IF;--termina command reporte

		--Recorriendo la tabla temporal y retornando sus filas
		FOR returnrecord IN SELECT * FROM tmpRepCtbBalanzaComp LOOP
			RETURN NEXT returnrecord;
		END LOOP;
	END IF;
	--Termina Reporte de Balanza de Comprobacion














	
	--Reporte Auxiliar de Movimientos de Cuentas(CTB)
	IF app_selected = 159 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_user
		--str_data[3]	command_selected
		--str_data[4]	suc
		--str_data[5]	fecha_ini
		--str_data[6]	fecha_fin
		--str_data[7]	cuentas
		--str_data[8]	cta
		--str_data[9]	scta
		--str_data[10]	sscta
		--str_data[11]	ssscta
		--str_data[12]	sssscta
		--str_data[13]	tipo_documento
		
		BEGIN 
			/*
			tipo_reg character varying,
			suc character varying,
			cta character varying,
			descrip_cta character varying,
			poliza character varying,
			orig character varying,
			tipo_pol character varying,
			fecha character varying,
			referencia character varying,
			cc character varying,
			descrip_mov character varying,
			saldo_ini character varying,
			debe character varying,
			haber character varying,
			saldo_fin character varying
			*/
			--Crear tabla temporal
			CREATE TEMPORARY TABLE tmpRepCtbAuxMov(tipo_reg character varying, suc character varying, cta character varying, descrip_cta character varying, poliza character varying, orig character varying, tipo_pol character varying, fecha character varying, referencia character varying, cc character varying, descrip_mov character varying, saldo_ini character varying, debe character varying, haber character varying, saldo_fin character varying);
			EXCEPTION WHEN OTHERS THEN
			TRUNCATE TABLE tmpRepCtbAuxMov; -- TRUNCATE if the table already exists within the session.
		END;
		
		--BUSQUEDA PARA EL REPORTE-------------
		IF command_selected='reporte' THEN 
			
			--Cuentas
			IF str_data[7]::integer=1 THEN
				--Todas
				cadena_where:=cadena_where||' ';
			ELSE
				--Una cuenta
				IF str_data[8]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.cta='||str_data[8]; END IF;
				IF str_data[9]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.subcta='||str_data[9]; END IF;
				IF str_data[10]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.ssubcta='||str_data[10]; END IF;
				IF str_data[11]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.sssubcta='||str_data[11]; END IF;
				IF str_data[12]::integer>0 THEN cadena_where:=cadena_where||' AND ctb_cta.ssssubcta='||str_data[12]; END IF;
			END IF;
			
			--Cadena para espacios en blanco cuando es para mostrar el resultado en el navegador
			cadena1:='&nbsp;';
			IF trim(str_data[13])='pdf' THEN 
				--Cadena para espacios en blanco cuando es para mostrar el resultado en pdf
				cadena1:=' ';
			END IF;
			
			cadena_sql:= '
			select sbt3.cta_mayor, sbt3.clasifica, sbt3.cuenta, sbt3.cta1, sbt3.cta, sbt3.descripcion, sbt3.naturaleza, sbt3.nivel, sbt3.saldo_ini, sbt3.saldo_fin, sbt3.ini_debe, sbt3.ini_haber, sum(case when pol_mov.debe is null then 0 else pol_mov.debe end) as debe, sum(case when pol_mov.haber is null then 0 else pol_mov.haber end) as haber 
			from (
				select sbt2.cta_mayor, sbt2.clasifica, sbt2.cuenta, sbt2.cta1, sbt2.cta, sbt2.descripcion, sbt2.naturaleza, sbt2.nivel, sbt2.saldo_ini, sbt2.saldo_fin, sum(case when pol_mov_ini.debe is null then 0 else pol_mov_ini.debe end) as ini_debe, sum(case when pol_mov_ini.haber is null then 0 else pol_mov_ini.haber end) as ini_haber 
				from(
					select sbt1.cta_mayor, sbt1.clasifica, sbt1.cuenta, sbt1.cta1, sbt1.cta, sbt1.descripcion, sbt1.naturaleza, sbt1.nivel, sum(case when ctb_sdo.saldo_ini is null then 0 else ctb_sdo.saldo_ini end) as saldo_ini, sum(case when ctb_sdo.saldo_fin is null then 0 else ctb_sdo.saldo_fin end) as saldo_fin 
					from (
						SELECT 
							ctb_cta.cta_mayor,
							ctb_cta.clasifica,
							ctb_cta.cta as cuenta,
							(CASE WHEN ctb_cta.cta>0 THEN ctb_cta.cta::character varying ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN lpad(ctb_cta.subcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN lpad(ctb_cta.ssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN lpad(ctb_cta.sssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssssubcta>0 THEN lpad(ctb_cta.ssssubcta::character varying,4,''0'') ELSE '''' END) AS cta1,
							ctb_cta.cta_mayor||'' ''||ctb_cta.clasifica||'' ''||(CASE WHEN ctb_cta.cta>0 THEN ctb_cta.cta::character varying ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN ''-''||lpad(ctb_cta.subcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN ''-''||lpad(ctb_cta.ssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN ''-''||lpad(ctb_cta.sssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssssubcta>0 THEN ''-''||lpad(ctb_cta.ssssubcta::character varying, 4, ''0'') ELSE '''' END) AS cta,
							(CASE WHEN (ctb_cta.cta>0 AND ctb_cta.subcta=0 AND ctb_cta.ssubcta=0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||'''
							      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta=0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
							      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
							      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta>0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
							      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta>0 AND ctb_cta.ssssubcta>0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
							 ELSE '''' END)||ctb_cta.descripcion AS descripcion,
							 ctb_cta.naturaleza,
							 ctb_cta.nivel 
						FROM ctb_cta 
						WHERE ctb_cta.borrado_logico=false AND ctb_cta.gral_emp_id='||emp_id||' '||cadena_where||' 
					) as sbt1 
					left join (
						select replace(ctb_sdo_cta.cta,''-'','''') as cta, sum(case when ctb_sdo_cta.saldo_ini is null then 0 else ctb_sdo_cta.saldo_ini end) as saldo_ini, sum(case when ctb_sdo_cta.saldo_fin is null then 0 else ctb_sdo_cta.saldo_fin end) as saldo_fin 
						from ctb_sdo_cta where ctb_sdo_cta.ano=extract(year from '''||str_data[5]||'''::timestamp with time zone) 
						group by ctb_sdo_cta.cta 
					) as ctb_sdo on ctb_sdo.cta ilike sbt1.cta1||''%'' 
					group by sbt1.cta_mayor, sbt1.clasifica, sbt1.cuenta, sbt1.cta1, sbt1.cta, sbt1.descripcion, sbt1.naturaleza, sbt1.nivel 
				) as sbt2 
				left join (
					select replace(ctb_pol_mov.cta,''-'','''') as cta, sum(case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, sum(case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber 
					from ctb_pol_mov join ctb_pol on ctb_pol.id=ctb_pol_mov.ctb_pol_id where to_char(ctb_pol.fecha,''yyyymmdd'')::integer >= (extract(year from '''||str_data[5]||'''::timestamp with time zone)||''0101'')::integer  and to_char(ctb_pol.fecha,''yyyymmdd'')::integer < to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer 
					group by ctb_pol_mov.cta 
				) as pol_mov_ini on pol_mov_ini.cta ilike sbt2.cta1||''%'' 
				group by sbt2.cta_mayor, sbt2.clasifica, sbt2.cuenta, sbt2.cta1, sbt2.cta, sbt2.descripcion, sbt2.naturaleza, sbt2.nivel, sbt2.saldo_ini, sbt2.saldo_fin 
			) as sbt3 
			left join (
				select replace(ctb_pol_mov.cta,''-'','''') as cta, sum(case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, sum(case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber 
				from ctb_pol_mov join ctb_pol on ctb_pol.id=ctb_pol_mov.ctb_pol_id where to_char(ctb_pol.fecha,''yyyymmdd'')::integer BETWEEN to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer AND to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer 
				group by ctb_pol_mov.cta 
			) as pol_mov on pol_mov.cta ilike sbt3.cta1||''%'' 
			group by sbt3.cta_mayor, sbt3.clasifica, sbt3.cuenta, sbt3.cta1, sbt3.cta, sbt3.descripcion, sbt3.naturaleza, sbt3.nivel, sbt3.ini_debe, sbt3.ini_haber, sbt3.saldo_ini, sbt3.saldo_fin 
			ORDER BY sbt3.cta_mayor, sbt3.clasifica, sbt3.cuenta;';
			
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP
				IF valor1<>fila.cta_mayor::character varying THEN 
					valor1:=fila.cta_mayor::character varying;
					valor2:=fila.clasifica::character varying;
					
					if fila.saldo_ini is null then fila.saldo_ini:=0; end if;
					if fila.saldo_fin is null then fila.saldo_fin:=0; end if;
					if fila.ini_debe is null then fila.ini_debe:=0; end if;
					if fila.ini_haber is null then fila.ini_haber:=0; end if;
					if fila.debe is null then fila.debe:=0; end if;
					if fila.haber is null then fila.haber:=0; end if;
					
					--fila.nivel  1=Auxiliar, 2=Mayor
					
					--Obtener la descripcion de la clase de cuenta de Mayor
					SELECT titulo FROM ctb_may_clases WHERE id=fila.cta_mayor::integer LIMIT 1
					INTO desc_cta_may_clases;
					
					--Agregar la clase de la Cuenta de mayor
					INSERT INTO tmpRepCtbAuxMov(tipo_reg, suc, cta , descrip_cta, poliza, orig, tipo_pol, fecha, referencia, cc, descrip_mov, saldo_ini, debe, haber, saldo_fin)
					values('cta', '', fila.cta_mayor||' 0 0000', desc_cta_may_clases, '', '', '', '', '', '', '', '', '', '', '');
					
					SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint
					INTO desc_cta_may;
					
					--Agregar la clasificacion de la Cuenta de Mayor
					INSERT INTO tmpRepCtbAuxMov(tipo_reg, suc, cta , descrip_cta, poliza, orig, tipo_pol, fecha, referencia, cc, descrip_mov, saldo_ini, debe, haber, saldo_fin)
					values('cta', '', fila.cta_mayor||' '||fila.clasifica||' 0000', cadena1||cadena1||cadena1||desc_cta_may, '', '', '', '', '', '', '', '', '', '', '');
					
					--1=Deudora, 2=Acreedora
					if fila.naturaleza=1 then 
						--Calcular el saldo inicial a la fecha inicial del reporte
						fila.saldo_ini:= fila.saldo_ini + fila.ini_debe - fila.ini_haber;
						
						fila.saldo_fin:=fila.saldo_ini + fila.debe - fila.haber;
					else
						--Calcular el saldo inicial a la fecha inicial del reporte
						fila.saldo_ini:= fila.saldo_ini - fila.ini_debe + fila.ini_haber;
						
						fila.saldo_fin:=fila.saldo_ini - fila.debe + fila.haber;
					end if;
					
					
					--Agregar la cuenta contable
					INSERT INTO tmpRepCtbAuxMov(tipo_reg, suc, cta , descrip_cta, poliza, orig, tipo_pol, fecha, referencia, cc, descrip_mov, saldo_ini, debe, haber, saldo_fin)
					values('cta', '', fila.cta, fila.descripcion, '', '', '', '', '', '', '', fila.saldo_ini::character varying, fila.debe::character varying, fila.haber::character varying, fila.saldo_fin::character varying);
					
					
					--Obtener movimientos de la cuenta 
					cadena_sql2:='
					select 
						(case when gral_suc.clave is null then '''' else gral_suc.clave end) as suc,
						to_char(ctb_pol.fecha,''dd/mm/yyyy'') as fecha, 
						ctb_pol.poliza,
						(case when ctb_tpol_grupos.titulo is null then '''' else ctb_tpol_grupos.titulo end) as tipo_pol,
						ctb_pol.referencia, 
						ctb_pol.descripcion as descripcion_mov, 
						(case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, 
						(case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber,
						0::double precision as saldo_fin 
					from ctb_pol 
					join ctb_pol_mov on ctb_pol_mov.ctb_pol_id=ctb_pol.id 
					join gral_suc on gral_suc.id=ctb_pol.gral_suc_id 
					left join ctb_tpol on ctb_tpol.id=ctb_pol.ctb_tpol_id 
					left join ctb_tpol_grupos on ctb_tpol_grupos.id=ctb_tpol.ctb_tpol_grupo_id 
					where replace(ctb_pol_mov.cta,''-'','''')='''||fila.cta1||''' and (to_char(ctb_pol.fecha,''yyyymmdd'')::integer BETWEEN to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer AND to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer)';
					--where replace(ctb_pol_mov.cta,''-'','''') ilike '''||fila.cta1||'%'' '||cadena_where2||' ';
					
					FOR fila2 IN EXECUTE (cadena_sql2) LOOP 
						--1=Deudora, 2=Acreedora
						if fila.naturaleza=1 then 
							--fila2.saldo_fin:=fila2.saldo_ini + fila2.debe - fila2.haber;
							fila2.saldo_fin:= fila.saldo_ini + fila2.debe - fila2.haber;
						else 
							--fila2.saldo_fin:=fila2.saldo_ini - fila2.debe + fila2.haber;
							fila2.saldo_fin:= fila.saldo_ini - fila2.debe + fila2.haber;
						end if;
						
						--Agregar la movimientos de la cuenta contable
						INSERT INTO tmpRepCtbAuxMov(tipo_reg, suc, cta, descrip_cta, poliza, orig, tipo_pol, fecha, referencia, cc, descrip_mov, saldo_ini, debe, haber, saldo_fin)
						values('mov', fila2.suc, fila.cta, '', fila2.poliza, '', fila2.tipo_pol, fila2.fecha, fila2.referencia, '', fila2.descripcion_mov, '0', fila2.debe::character varying, fila2.haber::character varying, fila2.saldo_fin::character varying);
						
						--Tomar el ultimo saldo final de la cuenta contable como nuevo saldo inicial
						fila.saldo_ini := fila2.saldo_fin;
					END LOOP;
					
				ELSE
					
					IF valor2<>fila.clasifica::character varying THEN 
						valor2:=fila.clasifica::character varying;
						SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint 
						INTO desc_cta_may;
						
						--Agregar la clasificacion de la Cuenta de Mayor
						INSERT INTO tmpRepCtbAuxMov(tipo_reg, suc, cta , descrip_cta, poliza, orig, tipo_pol, fecha, referencia, cc, descrip_mov, saldo_ini, debe, haber, saldo_fin)
						values('cta', '', fila.cta_mayor||' '||fila.clasifica||' 0000', cadena1||cadena1||cadena1||desc_cta_may, '', '', '', '', '', '', '', '', '', '', '');
					END IF;

					
					--1=Deudora, 2=Acreedora
					if fila.naturaleza=1 then 
						--Calcular el saldo inicial a la fecha inicial del reporte
						fila.saldo_ini:= fila.saldo_ini + fila.ini_debe - fila.ini_haber;
						
						fila.saldo_fin:=fila.saldo_ini + fila.debe - fila.haber;
					else
						--Calcular el saldo inicial a la fecha inicial del reporte
						fila.saldo_ini:= fila.saldo_ini - fila.ini_debe + fila.ini_haber;
						
						fila.saldo_fin:=fila.saldo_ini - fila.debe + fila.haber;
					end if;
					
					
					--Agregar la cuenta contable
					INSERT INTO tmpRepCtbAuxMov(tipo_reg, suc, cta , descrip_cta, poliza, orig, tipo_pol, fecha, referencia, cc, descrip_mov, saldo_ini, debe, haber, saldo_fin)
					values('cta', '', fila.cta, fila.descripcion, '', '', '', '', '', '', '', fila.saldo_ini::character varying, fila.debe::character varying, fila.haber::character varying, fila.saldo_fin::character varying);
					
					
					--Obtener movimientos de la cuenta 
					cadena_sql2:='
					select 
						(case when gral_suc.clave is null then '''' else gral_suc.clave end) as suc,
						to_char(ctb_pol.fecha,''dd/mm/yyyy'') as fecha, 
						ctb_pol.poliza,
						(case when ctb_tpol_grupos.titulo is null then '''' else ctb_tpol_grupos.titulo end) as tipo_pol,
						ctb_pol.referencia, 
						(case when ctb_cc.titulo is null then '''' else ctb_cc.titulo end) as cc,
						ctb_pol.descripcion as descripcion_mov, 
						(case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, 
						(case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber,
						0::double precision as saldo_fin 
					from ctb_pol 
					join ctb_pol_mov on ctb_pol_mov.ctb_pol_id=ctb_pol.id 
					join gral_suc on gral_suc.id=ctb_pol.gral_suc_id 
					left join ctb_cta on ctb_cta.id=ctb_pol_mov.ctb_cta_id 
					left join ctb_cc on ctb_cc.id=ctb_cta.ctb_cc_id 
					left join ctb_tpol on ctb_tpol.id=ctb_pol.ctb_tpol_id 
					left join ctb_tpol_grupos on ctb_tpol_grupos.id=ctb_tpol.ctb_tpol_grupo_id 
					where replace(ctb_pol_mov.cta,''-'','''')='''||fila.cta1||''' and (to_char(ctb_pol.fecha,''yyyymmdd'')::integer BETWEEN to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer AND to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer)';
					--where replace(ctb_pol_mov.cta,''-'','''') ilike '''||fila.cta1||'%'' '||cadena_where2||' ';
					
					FOR fila2 IN EXECUTE (cadena_sql2) LOOP 
						--1=Deudora, 2=Acreedora
						if fila.naturaleza=1 then 
							--fila2.saldo_fin:=fila2.saldo_ini + fila2.debe - fila2.haber;
							fila2.saldo_fin:= fila.saldo_ini + fila2.debe - fila2.haber;
						else 
							--fila2.saldo_fin:=fila2.saldo_ini - fila2.debe + fila2.haber;
							fila2.saldo_fin:= fila.saldo_ini - fila2.debe + fila2.haber;
						end if;
						
						--Agregar la movimientos de la cuenta contable
						INSERT INTO tmpRepCtbAuxMov(tipo_reg, suc, cta, descrip_cta, poliza, orig, tipo_pol, fecha, referencia, cc, descrip_mov, saldo_ini, debe, haber, saldo_fin)
						values('mov', fila2.suc, fila.cta, '', fila2.poliza, '', fila2.tipo_pol, fila2.fecha, fila2.referencia, fila2.cc, fila2.descripcion_mov, '0', fila2.debe::character varying, fila2.haber::character varying, fila2.saldo_fin::character varying);
						
						--Tomar el ultimo saldo final de la cuenta contable como nuevo saldo inicial
						fila.saldo_ini := fila2.saldo_fin;
					END LOOP;
					
				END IF;
				
			END LOOP;
			
		END IF;--termina command reporte

		
		
		--Recorriendo la tabla temporal y retornando sus filas
		FOR returnrecord IN SELECT * FROM tmpRepCtbAuxMov LOOP
			RETURN NEXT returnrecord;
		END LOOP;
	END IF;
	--Termina Reporte Auxiliar de Movimientos de Cuentas(CTB)






	--Reporte  de Balance General
	IF app_selected = 160 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_user
		--str_data[3]	command_selected
		--str_data[4]	tipo_doc
		--str_data[5]	suc
		--str_data[6]	fecha_corte
		
		BEGIN 
			--tipo_reg=1 -> Registro de clase mayor
			--tipo_reg=2 -> Registro para clasificacion(Rubro)
			--tipo_reg=3 -> Registro de cuenta mayor
			--tipo_reg=4 -> Registro para Pasivo + Capital
			
			--Crear tabla temporal
			CREATE TEMPORARY TABLE tmpRepBalanceGeneral(tipo_reg integer, mayor integer, clasifica integer, descripcion character varying, saldo_final character varying);
			EXCEPTION WHEN OTHERS THEN
			TRUNCATE TABLE tmpRepBalanceGeneral; -- TRUNCATE if the table already exists within the session.
		END;
		
		--BUSQUEDA PARA EL REPORTE-------------
		IF command_selected='reporte' THEN 
			
			--RAISE EXCEPTION '%',cadena_where2;
			
			--Cadena para espacios en blanco cuando es para mostrar el resultado en el navegador
			cadena1:='&nbsp;';
			IF trim(str_data[4])='pdf' THEN 
				--Cadena para espacios en blanco cuando es para mostrar el resultado en pdf
				cadena1:=' ';
			END IF;
			
			cadena_sql:= '
			select sbt2.cta_mayor, 
				sbt2.clasifica, 
				sbt2.cuenta, 
				sbt2.cta1, 
				sbt2.cta, 
				sbt2.descripcion, 
				sbt2.naturaleza, 
				sbt2.nivel, 
				sbt2.saldo_ini, 
				sbt2.saldo_fin, 
				sum(case when pol_mov.debe is null then 0 else pol_mov.debe end) as debe, 
				sum(case when pol_mov.haber is null then 0 else pol_mov.haber end) as haber 
			from(
				select sbt1.cta_mayor, sbt1.clasifica, sbt1.cuenta, sbt1.cta1, sbt1.cta, sbt1.descripcion, sbt1.naturaleza, sbt1.nivel, sum(case when ctb_sdo.saldo_ini is null then 0 else ctb_sdo.saldo_ini end) as saldo_ini, sum(case when ctb_sdo.saldo_fin is null then 0 else ctb_sdo.saldo_fin end) as saldo_fin 
				from (
					SELECT 
						ctb_cta.cta_mayor,
						ctb_cta.clasifica,
						ctb_cta.cta as cuenta,
						(CASE WHEN ctb_cta.cta>0 THEN ctb_cta.cta::character varying ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN lpad(ctb_cta.subcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN lpad(ctb_cta.ssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN lpad(ctb_cta.sssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssssubcta>0 THEN lpad(ctb_cta.ssssubcta::character varying,4,''0'') ELSE '''' END) AS cta1,
						ctb_cta.cta_mayor||'' ''||ctb_cta.clasifica||'' ''||(CASE WHEN ctb_cta.cta>0 THEN ctb_cta.cta::character varying ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN ''-''||lpad(ctb_cta.subcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN ''-''||lpad(ctb_cta.ssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN ''-''||lpad(ctb_cta.sssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssssubcta>0 THEN ''-''||lpad(ctb_cta.ssssubcta::character varying, 4, ''0'') ELSE '''' END) AS cta,
						(CASE WHEN (ctb_cta.cta>0 AND ctb_cta.subcta=0 AND ctb_cta.ssubcta=0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||'''
						      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta=0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
						      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
						      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta>0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
						      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta>0 AND ctb_cta.ssssubcta>0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
						 ELSE '''' END)||upper(ctb_cta.descripcion) AS descripcion,
						 ctb_cta.naturaleza,
						 ctb_cta.nivel 
					FROM ctb_cta 
					WHERE ctb_cta.borrado_logico=false and ctb_cta.tipo=1 and ctb_cta.nivel=2 and ctb_cta.gral_emp_id='||emp_id||'  
				) as sbt1 
				left join (
					select replace(ctb_sdo_cta.cta,''-'','''') as cta, sum(case when ctb_sdo_cta.saldo_ini is null then 0 else ctb_sdo_cta.saldo_ini end) as saldo_ini, sum(case when ctb_sdo_cta.saldo_fin is null then 0 else ctb_sdo_cta.saldo_fin end) as saldo_fin 
					from ctb_sdo_cta where ctb_sdo_cta.ano=extract(year from '''||str_data[6]||'''::timestamp with time zone) 
					group by ctb_sdo_cta.cta 
				) as ctb_sdo on ctb_sdo.cta ilike sbt1.cta1||''%'' 
				group by sbt1.cta_mayor, sbt1.clasifica, sbt1.cuenta, sbt1.cta1, sbt1.cta, sbt1.descripcion, sbt1.naturaleza, sbt1.nivel 
			) as sbt2 
			left join (
				select replace(ctb_pol_mov.cta,''-'','''') as cta, sum(case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, sum(case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber 
				from ctb_pol_mov join ctb_pol on ctb_pol.id=ctb_pol_mov.ctb_pol_id where to_char(ctb_pol.fecha,''yyyymmdd'')::integer >= (extract(year from '''||str_data[6]||'''::timestamp with time zone)||''0101'')::integer  and to_char(ctb_pol.fecha,''yyyymmdd'')::integer <= to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer 
				group by ctb_pol_mov.cta 
			) as pol_mov on pol_mov.cta ilike sbt2.cta1||''%'' 
			group by sbt2.cta_mayor, sbt2.clasifica, sbt2.cuenta, sbt2.cta1, sbt2.cta, sbt2.descripcion, sbt2.naturaleza, sbt2.nivel, sbt2.saldo_ini, sbt2.saldo_fin 
			ORDER BY sbt2.cta_mayor, sbt2.clasifica, sbt2.cuenta;';
			
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP
				IF valor1<>fila.cta_mayor::character varying THEN 
					valor1:=fila.cta_mayor::character varying;
					valor2:=fila.clasifica::character varying;
					
					if fila.saldo_ini is null then fila.saldo_ini:=0; end if;
					if fila.saldo_fin is null then fila.saldo_fin:=0; end if;
					if fila.debe is null then fila.debe:=0; end if;
					if fila.haber is null then fila.haber:=0; end if;
					
					--Obtener la descripcion de la clase de cuenta de Mayor
					SELECT titulo FROM ctb_may_clases WHERE id=fila.cta_mayor::integer LIMIT 1
					INTO desc_cta_may_clases;
					
					--Agregar la clase de la Cuenta de mayor
					INSERT INTO tmpRepBalanceGeneral(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(1, fila.cta_mayor, 0, desc_cta_may_clases, '');
					
					SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint
					INTO desc_cta_may;
					
					--Agregar la clasificacion de la Cuenta de Mayor
					INSERT INTO tmpRepBalanceGeneral(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, fila.cta_mayor, fila.clasifica, cadena1||cadena1||cadena1||desc_cta_may, '');
					
					--1=Deudora, 2=Acreedora
					if fila.naturaleza=1 then 
						fila.saldo_fin:=fila.saldo_ini + fila.debe - fila.haber;
					else
						fila.saldo_fin:=fila.saldo_ini - fila.debe + fila.haber;
					end if;
					
					--Agregar la cuenta contable(ctb_cta.tipo=1 and ctb_cta.nivel=2)
					INSERT INTO tmpRepBalanceGeneral(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(3, fila.cta_mayor, fila.clasifica, fila.descripcion, fila.saldo_fin::character varying);
				ELSE
					
					IF valor2<>fila.clasifica::character varying THEN 
						valor2:=fila.clasifica::character varying;
						SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint 
						INTO desc_cta_may;
						
						--Agregar la clasificacion de la Cuenta de Mayor
						INSERT INTO tmpRepBalanceGeneral(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, fila.cta_mayor, fila.clasifica, cadena1||cadena1||cadena1||desc_cta_may, '');
					END IF;
					
					
					--1=Deudora, 2=Acreedora
					if fila.naturaleza=1 then 
						fila.saldo_fin:=fila.saldo_ini + fila.debe - fila.haber;
					else
						fila.saldo_fin:=fila.saldo_ini - fila.debe + fila.haber;
					end if;
					
					--Agregar la cuenta contable
					INSERT INTO tmpRepBalanceGeneral(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(3, fila.cta_mayor, fila.clasifica, fila.descripcion, fila.saldo_fin::character varying);
				END IF;
				
			END LOOP;

			--Agregar registro para guardar PASIVO + CAPITAL
			INSERT INTO tmpRepBalanceGeneral(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(4, 0, fila.clasifica, 'PASIVO + CAPITAL', '0');
			
		END IF;--termina command reporte
		
		
		--Inicializar valores
		valor1:='';
		valor2:='';
		suma1:=0.0;
		suma2:=0.0;
		
		--Recorriendo la tabla temporal y retornando sus filas
		FOR returnrecord IN SELECT * FROM tmpRepBalanceGeneral LOOP 
			IF valor1<>returnrecord.mayor::character varying THEN 
				valor1:=returnrecord.mayor::character varying;
				valor2:='';
				suma1:=0.0;
				
				FOR fila2 IN SELECT * FROM tmpRepBalanceGeneral LOOP 
					IF valor1::integer=fila2.mayor THEN 
						if trim(fila2.saldo_final)<>'' then 
							--suma1:=suma1 + fila2.saldo_final::double precision;
							
							if replace(replace(fila2.descripcion,' ',''),'√ì','O') ilike '%DEPRECIACIONACUMULADA%' and fila2.mayor=returnrecord.mayor then 
								--Restar la depreciacion si existe
								suma1:=suma1 - fila2.saldo_final::double precision;
							else 
								suma1:=suma1 + fila2.saldo_final::double precision;
							end if;
						end if;
					END IF;
				END LOOP;
				
				--Asigna suma de clase mayor
				returnrecord.saldo_final:=suma1::character varying;
				
				--Suma pasivo y capital
				if returnrecord.mayor=2 or returnrecord.mayor=3 then 
					suma2:=suma2 + suma1::double precision;
				end if;
			ELSE 
				IF valor2<>returnrecord.clasifica::character varying AND valor1=returnrecord.mayor::character varying THEN 
					valor2:=returnrecord.clasifica::character varying;
					suma1:=0.0;
					suma3:=0.0;
					
					for fila2 in select * from tmpRepBalanceGeneral LOOP 
						if valor1::integer=fila2.mayor and valor2::integer=fila2.clasifica then 
							if trim(fila2.saldo_final)<>'' then 
								if replace(replace(fila2.descripcion,' ',''),'√ì','O') ilike '%DEPRECIACIONACUMULADA%' and fila2.clasifica=returnrecord.clasifica and fila2.mayor=returnrecord.mayor then 
									--Restar la depreciacion si existe
									suma1:=suma1 - fila2.saldo_final::double precision;
								else 
									suma1:=suma1 + fila2.saldo_final::double precision;
								end if;
							end if;
						end if;
					end loop;
					
					/*
					--Buscar suma de la depreciacion
					select sum(saldo_final::double precision) as saldo from tmpRepBalanceGeneral where mayor=returnrecord.mayor and clasifica=returnrecord.clasifica and tipo_reg=3
					and  replace(descripcion,' ','') ilike '%DEPRECIACIONACUMULADA%' into suma3;
					
					if suma3 is not null then 

						--RAISE EXCEPTION '%','suma1='||suma1||'   suma3='||suma3;
						
						if suma3 > 0 then 
							--Restar la depreciacion si existe
							suma1:= suma1 - suma3::double precision;
						end if;

						--RAISE EXCEPTION '%','suma1='||suma1||'   suma3='||suma3;
					end if;
					*/

					
					--Asigna sumas de los rubros(clasificacion de cuenta)
					returnrecord.saldo_final:=suma1::character varying;
				END IF;
			END IF;
			
			
			--Agregar el total para Pasivo y Capital
			IF returnrecord.tipo_reg=4 THEN 
				returnrecord.saldo_final:=suma2::character varying;
			END IF;
			
			RETURN NEXT returnrecord;
		END LOOP;
	END IF;
	--Termina Reporte de Balance General



	--Reporte  de Estado de Resultados
	IF app_selected = 161 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_user
		--str_data[3]	command_selected
		--str_data[4]	tipo_doc
		--str_data[5]	suc
		--str_data[6]	fecha_corte
		
		BEGIN 
			--tipo_reg=1 -> Registro de clase mayor
			--tipo_reg=2 -> Registro para clasificacion(Rubro)
			--tipo_reg=3 -> Registro de cuenta mayor
			--tipo_reg=4 -> Registro para Pasivo + Capital
			
			--Crear tabla temporal
			CREATE TEMPORARY TABLE tmpRepEdoRes(tipo_reg integer, mayor integer, clasifica integer, descripcion character varying, saldo_final character varying);
			EXCEPTION WHEN OTHERS THEN
			TRUNCATE TABLE tmpRepEdoRes; -- TRUNCATE if the table already exists within the session.
		END;

		BEGIN 
			--tipo_reg=1 -> Registro de clase mayor
			--tipo_reg=2 -> Registro para clasificacion(Rubro)
			--tipo_reg=3 -> Registro de cuenta mayor
			--tipo_reg=4 -> Registro para Pasivo + Capital
			--Crear tabla temporal2
			CREATE TEMPORARY TABLE tmpRepEdoRes2(tipo_reg integer, mayor integer, clasifica integer, descripcion character varying, saldo_final character varying);
			EXCEPTION WHEN OTHERS THEN
			TRUNCATE TABLE tmpRepEdoRes2; -- TRUNCATE if the table already exists within the session.
		END;
		
		--BUSQUEDA PARA EL REPORTE-------------
		IF command_selected='reporte' THEN 
			
			--RAISE EXCEPTION '%',cadena_where2;
			
			--Cadena para espacios en blanco cuando es para mostrar el resultado en el navegador
			cadena1:='&nbsp;';
			IF trim(str_data[4])='pdf' THEN 
				--Cadena para espacios en blanco cuando es para mostrar el resultado en pdf
				cadena1:=' ';
			END IF;
			
			cadena_sql:= '
			select sbt1.cta_mayor, 
				sbt1.clasifica, 
				sbt1.cuenta, 
				sbt1.cta1, 
				sbt1.cta, 
				sbt1.descripcion, 
				sbt1.naturaleza, 
				sbt1.nivel, 
				0::double precision as saldo_ini, 
				0::double precision as saldo_fin, 
				sum(case when pol_mov.debe is null then 0 else pol_mov.debe end) as debe, 
				sum(case when pol_mov.haber is null then 0 else pol_mov.haber end) as haber 
			from (
				SELECT 
					ctb_cta.cta_mayor,
					ctb_cta.clasifica,
					ctb_cta.cta as cuenta,
					(CASE WHEN ctb_cta.cta>0 THEN ctb_cta.cta::character varying ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN lpad(ctb_cta.subcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN lpad(ctb_cta.ssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN lpad(ctb_cta.sssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssssubcta>0 THEN lpad(ctb_cta.ssssubcta::character varying,4,''0'') ELSE '''' END) AS cta1,
					ctb_cta.cta_mayor||'' ''||ctb_cta.clasifica||'' ''||(CASE WHEN ctb_cta.cta>0 THEN ctb_cta.cta::character varying ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN ''-''||lpad(ctb_cta.subcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN ''-''||lpad(ctb_cta.ssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN ''-''||lpad(ctb_cta.sssubcta::character varying, 4, ''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssssubcta>0 THEN ''-''||lpad(ctb_cta.ssssubcta::character varying, 4, ''0'') ELSE '''' END) AS cta,
					(CASE WHEN (ctb_cta.cta>0 AND ctb_cta.subcta=0 AND ctb_cta.ssubcta=0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||'''
					      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta=0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
					      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta=0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
					      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta>0 AND ctb_cta.ssssubcta=0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
					      WHEN (ctb_cta.cta>0 AND ctb_cta.subcta>0 AND ctb_cta.ssubcta>0 AND ctb_cta.sssubcta>0 AND ctb_cta.ssssubcta>0) THEN '''||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||cadena1||'''
					 ELSE '''' END)||upper(ctb_cta.descripcion) AS descripcion,
					 ctb_cta.naturaleza,
					 ctb_cta.nivel 
				FROM ctb_cta 
				WHERE ctb_cta.borrado_logico=false and ctb_cta.tipo=2 and ctb_cta.nivel=2 and ctb_cta.gral_emp_id='||emp_id||'  
			) as sbt1 
			left join (
				select replace(ctb_pol_mov.cta,''-'','''') as cta, sum(case when ctb_pol_mov.tipo=1 then ctb_pol_mov.cantidad else 0 end) as debe, sum(case when ctb_pol_mov.tipo=2 then ctb_pol_mov.cantidad else 0 end) as haber 
				from ctb_pol_mov join ctb_pol on ctb_pol.id=ctb_pol_mov.ctb_pol_id where to_char(ctb_pol.fecha,''yyyymmdd'')::integer >= (extract(year from '''||str_data[6]||'''::timestamp with time zone)||''0101'')::integer  and to_char(ctb_pol.fecha,''yyyymmdd'')::integer <= to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer 
				group by ctb_pol_mov.cta 
			) as pol_mov on pol_mov.cta ilike sbt1.cta1||''%'' 
			group by sbt1.cta_mayor, sbt1.clasifica, sbt1.cuenta, sbt1.cta1, sbt1.cta, sbt1.descripcion, sbt1.naturaleza, sbt1.nivel, saldo_ini, saldo_fin 
			ORDER BY sbt1.cta_mayor, sbt1.clasifica, sbt1.cuenta;';
		
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP
				IF valor1<>fila.cta_mayor::character varying THEN 
					valor1:=fila.cta_mayor::character varying;
					valor2:=fila.clasifica::character varying;
					
					if fila.saldo_ini is null then fila.saldo_ini:=0; end if;
					if fila.saldo_fin is null then fila.saldo_fin:=0; end if;
					if fila.debe is null then fila.debe:=0; end if;
					if fila.haber is null then fila.haber:=0; end if;

					--Obtener la descripcion de la clase de cuenta de Mayor
					SELECT titulo FROM ctb_may_clases WHERE id=fila.cta_mayor::integer LIMIT 1 INTO desc_cta_may_clases;
					
					--Agregar la clase de la Cuenta de mayor
					INSERT INTO tmpRepEdoRes(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(1, fila.cta_mayor, 0, desc_cta_may_clases, '');
					
					SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint
					INTO desc_cta_may;
					
					--Agregar la clasificacion de la Cuenta de Mayor
					INSERT INTO tmpRepEdoRes(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, fila.cta_mayor, fila.clasifica, cadena1||cadena1||cadena1||desc_cta_may, '');
					
					
					--1=Deudora, 2=Acreedora
					if fila.naturaleza=1 then 
						fila.saldo_fin:=fila.saldo_ini + fila.debe - fila.haber;
					else
						fila.saldo_fin:=fila.saldo_ini - fila.debe + fila.haber;
					end if;
					
					--Agregar la cuenta contable(ctb_cta.tipo=1 and ctb_cta.nivel=2)
					INSERT INTO tmpRepEdoRes(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(3, fila.cta_mayor, fila.clasifica, fila.descripcion, fila.saldo_fin::character varying);
				ELSE
					
					IF valor2<>fila.clasifica::character varying THEN 
						valor2:=fila.clasifica::character varying;
						
						SELECT descripcion FROM ctb_may WHERE ctb_may_clase_id=fila.cta_mayor::integer AND clasificacion=fila.clasifica::smallint 
						INTO desc_cta_may;
					
						--Agregar la clasificacion de la Cuenta de Mayor
						INSERT INTO tmpRepEdoRes(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, fila.cta_mayor, fila.clasifica, cadena1||cadena1||cadena1||desc_cta_may, '');
						
					END IF;
					
					--1=Deudora, 2=Acreedora
					if fila.naturaleza=1 then 
						fila.saldo_fin:=fila.saldo_ini + fila.debe - fila.haber;
					else
						fila.saldo_fin:=fila.saldo_ini - fila.debe + fila.haber;
					end if;
					
					--Agregar la cuenta contable
					INSERT INTO tmpRepEdoRes(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(3, fila.cta_mayor, fila.clasifica, fila.descripcion, fila.saldo_fin::character varying);
					
				END IF;
				
			END LOOP;
			
		END IF;--termina command reporte
		
		
		--Inicializar valores
		valor1:='';
		valor2:='';
		suma1:=0.0;
		suma2:=0.0;
		
		
		FOR returnrecord IN select * from ctb_par_er where gral_emp_id=emp_id order by orden, cta_mayor, clasifica LOOP 
			
			IF returnrecord.cta_mayor<>0  THEN 
				if returnrecord.detalle then 
					--Aqui entra cuendo incluye detalle

					suma2:=0.0;

					--Para gastos de operecion no lleva monto, solo en las cuentas de mayor
					INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(3, returnrecord.cta_mayor, returnrecord.clasifica, returnrecord.descripcion, '');
					
					if returnrecord.clasifica=0 then 
						FOR fila2 IN select * from tmpRepEdoRes where mayor=returnrecord.cta_mayor LOOP 
							if trim(fila2.saldo_final)<>'' then 
								suma2:=suma2 + fila2.saldo_final::double precision;

								--Operacion 2=Resta
								IF returnrecord.operacion=2 then 
									fila2.descripcion:='(-)'||fila2.descripcion;
								end if;
								
								INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(3, fila2.mayor, fila2.clasifica, fila2.descripcion, fila2.saldo_final);
							end if;
						END LOOP;
					else
						FOR fila2 IN select * from tmpRepEdoRes where mayor=returnrecord.cta_mayor and clasifica=returnrecord.clasifica LOOP 
							if trim(fila2.saldo_final)<>'' then 
								suma2:=suma2 + fila2.saldo_final::double precision;
								
								--Operacion 2=Resta
								IF returnrecord.operacion=2 then 
									fila2.descripcion:='(-)'||fila2.descripcion;
								end if;


								INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(3, fila2.mayor, fila2.clasifica, fila2.descripcion, fila2.saldo_final);
							end if;
						END LOOP;
					end if;


					--Operacion 1=suma
					IF returnrecord.operacion=1 then 
						suma1:=suma1 + suma2::double precision;
					end if;

					--Operacion 2=Resta
					IF returnrecord.operacion=2 then 
						suma1:=suma1 - suma2::double precision;
					end if;

					
					--RAISE EXCEPTION '%','suma2='||suma2;
				else
					--Aqui entra cuando No incluye detalle
					suma2:=0.0;
					
					--RAISE EXCEPTION '%','cta_mayor='||returnrecord.cta_mayor||'   clasifica='||returnrecord.clasifica;
					
					if returnrecord.clasifica=0 then 
						FOR fila2 IN select * from tmpRepEdoRes where mayor=returnrecord.cta_mayor LOOP 
							if trim(fila2.saldo_final)<>'' then 
								suma2:=suma2 + fila2.saldo_final::double precision;
							end if;
						END LOOP;
					else
						FOR fila2 IN select * from tmpRepEdoRes where mayor=returnrecord.cta_mayor and clasifica=returnrecord.clasifica LOOP 
							if trim(fila2.saldo_final)<>'' then 
								suma2:=suma2 + fila2.saldo_final::double precision;
							end if;
						END LOOP;
					end if;
					
					--Operacion 1=suma
					IF returnrecord.operacion=1 then 
						suma1:=suma1 + suma2::double precision;
					end if;

					--Operacion 2=Resta
					IF returnrecord.operacion=2 then 
						suma1:=suma1 - suma2::double precision;
						returnrecord.descripcion:= '(-)'||fila2.descripcion;
					end if;
					
					INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(3, returnrecord.cta_mayor, returnrecord.clasifica, returnrecord.descripcion, suma2::character varying);
					suma2:=0;
				end if;
				
			else
				--Operacion 3=Resultado operacion
				IF returnrecord.operacion=3 then 
					if suma2 > 0 then 
						INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(1, returnrecord.cta_mayor, returnrecord.clasifica, returnrecord.descripcion, suma2::character varying);
					else
						INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(1, returnrecord.cta_mayor, returnrecord.clasifica, returnrecord.descripcion, suma1::character varying);
					end if;
					
				end if;
			end if;
		END LOOP;
		
		/*
		--Recorriendo la tabla temporal y retornando sus filas
		FOR returnrecord IN SELECT * FROM tmpRepEdoRes LOOP 
			
			IF valor1<>returnrecord.mayor::character varying THEN 
				valor1:=returnrecord.mayor::character varying;
				valor2:='';
				
				--Solo suma y agregar el de INGRESOS
				if returnrecord.mayor=4 then 
					suma1:=0.0;
					
					FOR fila2 IN SELECT * FROM tmpRepEdoRes LOOP 
						IF valor1::integer=fila2.mayor THEN 
							if trim(fila2.saldo_final)<>'' then 
								suma1:=suma1 + fila2.saldo_final::double precision;
							end if;
						END IF;
					END LOOP;
					
					--Asigna suma de clase mayor
					returnrecord.saldo_final:=suma1::character varying;

					INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, returnrecord.mayor, returnrecord.clasifica,returnrecord.descripcion, returnrecord.saldo_final);
				end if;
				
				--Suma pasivo y capital
				--if returnrecord.mayor=2 or returnrecord.mayor=3 then 
				--	suma2:=suma2 + suma1::double precision;
				--end if;
			ELSE 
				--Solo suma y agregar el de EGRESOS
				if returnrecord.mayor=5 then 
					--Solo agregar cuando es COSTO DE VENTAS
					if returnrecord.clasifica=1 then 
						--tipo_reg=2 Es un rubro, no una cuenta
						if returnrecord.tipo_reg=2 then 
							suma2:=0.0;
							for fila2 in select * from tmpRepEdoRes LOOP 
								if returnrecord.mayor=fila2.mayor and returnrecord.clasifica=fila2.clasifica then 
									if trim(fila2.saldo_final)<>'' then 
										suma2:=suma2 + fila2.saldo_final::double precision;
									end if;
								end if;
							end loop;
							
							returnrecord.saldo_final:=suma2::character varying;
							
							--Agregar COSTO DE VENTAS
							INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, returnrecord.mayor, returnrecord.clasifica,'(-) '||returnrecord.descripcion, returnrecord.saldo_final);
							
							--Restar INGRESOS - COSTO DE VENTAS

							suma1 := suma1 - suma2::double precision;
							
							returnrecord.saldo_final:= suma1::character varying;
							
							INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, returnrecord.mayor, returnrecord.clasifica,'UTILIDAD BRUTA', returnrecord.saldo_final);
						end if;
					end if;
					
					--Agregar cuentas de mayor de GASTOS DE OPERACION
					if returnrecord.clasifica=2 then 
						--tipo_reg=2 Es un rubro, no una cuenta
						if returnrecord.tipo_reg=2 then 
							--Agregar GASTOS DE OPERACION

							--El saldo final se agrega vacio
							returnrecord.saldo_final:='';
							INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, returnrecord.mayor, returnrecord.clasifica,returnrecord.descripcion, returnrecord.saldo_final);
						end if;
						
						--tipo_reg=3 Es una cuenta de mayor
						if returnrecord.tipo_reg=3 then 
							--Agregar COSTO DE VENTAS
							INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, returnrecord.mayor, returnrecord.clasifica,'(-) '||returnrecord.descripcion, returnrecord.saldo_final);

							suma1 := suma1 - returnrecord.saldo_final::double precision;
						end if;
					end if;


					--Solo agregar cuando es OTROS EGRESOS
					if returnrecord.clasifica=3 then 
						--tipo_reg=2 Es un rubro, no una cuenta
						if returnrecord.tipo_reg=2 then 
							suma2:=0.0;
							for fila2 in select * from tmpRepEdoRes LOOP 
								if returnrecord.mayor=fila2.mayor and returnrecord.clasifica=fila2.clasifica then 
									if trim(fila2.saldo_final)<>'' then 
										suma2:=suma2 + fila2.saldo_final::double precision;
									end if;
								end if;
							end loop;
							
							returnrecord.saldo_final:=suma2::character varying;
							
							--Agregar COSTO DE VENTAS
							INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, returnrecord.mayor, returnrecord.clasifica,'(-) '||returnrecord.descripcion, returnrecord.saldo_final);
							
							--Restar INGRESOS - COSTO DE VENTAS

							suma1 := suma1 - suma2::double precision;
						end if;
					end if;
					
				end if;
			END IF;
		END LOOP;
		*/
		
		--INSERT INTO tmpRepEdoRes2(tipo_reg, mayor, clasifica, descripcion, saldo_final) VALUES(2, returnrecord.mayor, returnrecord.clasifica,'UTILIDAD O PERDIDA ANTES DE IMPUESTOS', suma1::character varying);
		
		--Recorriendo la tabla temporal y retornando sus filas
		FOR fila3 IN SELECT * FROM tmpRepEdoRes2 LOOP
			RETURN NEXT fila3;
		END LOOP;
	END IF;
	--Termina repore de Estado de Resultados




	
	--Busqueda para programa de Generacion de Polizas
	IF app_selected = 206 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_user
		--str_data[3]	command_selected
		--str_data[4]	fecha_ini
		--str_data[5]	fecha_fin
		--str_data[6]	tipo_mov
		
		BEGIN 
			--Crear tabla temporal
			CREATE TEMPORARY TABLE tmpBusquedaMovimientos(fecha date, ref_id integer, referencia character varying, descripcion character varying, total character varying, tmov_id integer, tipo_mov character varying, app_id integer);
			EXCEPTION WHEN OTHERS THEN
			TRUNCATE TABLE tmpBusquedaMovimientos; -- TRUNCATE if the table already exists within the session.
		END;
		
		--BUSQUEDA
		IF command_selected='busqueda' THEN 
			--Existe filtro por movimiento
			if str_data[6]::integer>0 then 
				select ctb_app.gral_app_id from ctb_tmov join ctb_app on ctb_app.id=ctb_tmov.ctb_app_id where ctb_tmov.id=str_data[6]::integer limit 1 
				into aplicacion_id;
				
				--Facturacion
				if aplicacion_id=13 then 
					cadena_sql:= '
					select fac_docs.momento_creacion::date as fecha, fac_docs.id as ref_id, fac_docs.serie_folio as referencia, cxc_clie.razon_social as descripcion, fac_docs.total::character varying as total, ctb_tmov.id as tmov_id, ctb_tmov.titulo as tipo_mov 
					from fac_docs 
					join erp_proceso on (erp_proceso.id=fac_docs.proceso_id and erp_proceso.empresa_id='||emp_id||') 
					join cxc_clie on cxc_clie.id=fac_docs.cxc_clie_id 
					join ctb_tmov on ctb_tmov.id=fac_docs.ctb_tmov_id  
					where fac_docs.ctb_tmov_id='||str_data[6]||' and fac_docs.procesado=false 
					and to_char(fac_docs.momento_creacion,''yyyymmdd'')::integer between (to_char('''||str_data[4]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer);';
				end if;
				
				--RAISE EXCEPTION '%',cadena_sql;
				FOR fila IN EXECUTE (cadena_sql) LOOP 
					--Agregar movimiento a la tabla temporal
					INSERT INTO tmpBusquedaMovimientos (fecha, ref_id, referencia, descripcion, total, tmov_id, tipo_mov, app_id) 
					VALUES(fila.fecha, fila.ref_id, fila.referencia, fila.descripcion, fila.total, fila.tmov_id, fila.tipo_mov, aplicacion_id);
				END LOOP;
			else
				--No existe filtro por movimiento
				
			end if;
			
		END IF;--termina command reporte

		--Recorriendo la tabla temporal y retornando sus filas
		FOR returnrecord IN SELECT * FROM tmpBusquedaMovimientos LOOP
			RETURN NEXT returnrecord;
		END LOOP;
	END IF;
	--Termina Busqueda para programa de Generacion de Polizas



	/*
	SELECT 
		cta_mayor||' '||clasifica||' '||(CASE WHEN cta>0 THEN cta::character varying ELSE '' END)||' '||(CASE WHEN subcta>0 THEN lpad(subcta::character varying, 4, '0') ELSE '' END)||' '||(CASE WHEN ssubcta>0 THEN lpad(ssubcta::character varying, 4, '0') ELSE '' END)||' '||(CASE WHEN sssubcta>0 THEN lpad(sssubcta::character varying, 4, '0') ELSE '' END)||' '||(CASE WHEN ssssubcta>0 THEN lpad(ssssubcta::character varying, 4, '0') ELSE '' END) AS cta,
		ctb_may_clases.titulo AS mayor,
		ctb_may.descripcion AS clasificacion,
		ctb_cta.descripcion AS descripcion
	FROM ctb_cta
	JOIN ctb_may_clases ON ctb_may_clases.id=ctb_cta.cta_mayor
	JOIN ctb_may ON (ctb_may.ctb_may_clase_id=ctb_may_clases.id AND ctb_cta.clasifica=ctb_may.clasificacion)
	ORDER BY ctb_cta
	*/
	/*
	--Recorriendo la tabla temporal y retornando sus filas
	FOR returnrecord IN SELECT * FROM tmpRepCtb LOOP
		RETURN NEXT returnrecord;
	END LOOP;
	*/






	--106=Catalogo de cuentas contables
	--Obtiene la lista de cuentas para el xml de Cuentas contables
	IF app_selected = 106 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_user
		--str_data[3]	command_selected
		
		--BUSQUEDA PARA EL REPORTE-------------
		IF command_selected='reporte' THEN 
			
			cadena_sql:= '
			SELECT 
				(case when ctb_cta_sat.codigo is null then '''' else ctb_cta_sat.codigo end) as codagrup,
				(CASE WHEN ctb_cta.cta>0 THEN lpad(ctb_cta.cta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN lpad(ctb_cta.subcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN lpad(ctb_cta.ssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN lpad(ctb_cta.sssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssssubcta>0 THEN lpad(ctb_cta.ssssubcta::character varying,4,''0'') ELSE '''' END) AS numcta,
				(case when ctb_cta.ssssubcta=0 then 
					(case when ctb_cta.sssubcta=0 then 
						(case when ctb_cta.ssubcta=0 then 
							(case when ctb_cta.subcta=0 then 
								(case when ctb_cta.cta=0 then '''' else '''' end) 
							else 
								(CASE WHEN ctb_cta.cta>0 THEN lpad(ctb_cta.cta::character varying,4,''0'') ELSE '''' END) 
							end) 
						else 
							(CASE WHEN ctb_cta.cta>0 THEN lpad(ctb_cta.cta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN lpad(ctb_cta.subcta::character varying,4,''0'') ELSE '''' END)
						end) 
					else
						(CASE WHEN ctb_cta.cta>0 THEN lpad(ctb_cta.cta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.subcta>0 THEN lpad(ctb_cta.subcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN lpad(ctb_cta.ssubcta::character varying,4,''0'') ELSE '''' END) 
					end)
				else
					(CASE WHEN ctb_cta.cta>0 THEN lpad(ctb_cta.cta::character varying,4,''0'') END)||(CASE WHEN ctb_cta.subcta>0 THEN lpad(ctb_cta.subcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.ssubcta>0 THEN lpad(ctb_cta.ssubcta::character varying,4,''0'') ELSE '''' END)||(CASE WHEN ctb_cta.sssubcta>0 THEN lpad(ctb_cta.sssubcta::character varying,4,''0'') ELSE '''' END) 
				end) as subctade,
				ctb_cta.descripcion,
				(case when ctb_cta.naturaleza=1 then ''D'' when ctb_cta.naturaleza=2 then ''A'' else '''' end) as natur,
				(case when ctb_cta.nivel=0 then '''' else ctb_cta.nivel::character varying end) as nivel 
			FROM ctb_cta 
			left join ctb_cta_sat on ctb_cta_sat.id=ctb_cta.ctb_cta_sat_id 
			WHERE ctb_cta.borrado_logico=false AND ctb_cta.gral_emp_id='||emp_id||' 
			ORDER BY ctb_cta.cta_mayor,ctb_cta.clasifica,ctb_cta.cta,ctb_cta.subcta,ctb_cta.ssubcta,ctb_cta.sssubcta,ctb_cta.ssssubcta';
			
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP 
				RETURN NEXT fila;
			END LOOP;
			
		END IF;--termina command reporte
	END IF;
	--Termina Reporte Auxiliar de Cuentas






	
END;$$;


--
-- Name: cxc_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cxc_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$


DECLARE
	app_selected integer;
	command_selected text;
	usuario_ejecutor integer;
	emp_id integer;
	suc_id integer;
	str_data text[];
	str_filas text[];
	valor_retorno character varying = ''; 
	iter_y integer;--contador de filas o posiciones del arreglo (iterador eje y del arreglo iterado)
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	ultimo_id integer:=0;
	exis integer:=0;

	
	id_tipo_consecutivo integer = 0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
BEGIN
	
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- aplicativo que manda a llamar este procedimiento almacenado
	app_selected := str_data[1]::integer;
	
	-- comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	-- usuario que utiliza el aplicativo
	usuario_ejecutor := str_data[3]::integer;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	INTO emp_id, suc_id;
	
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	-- Programacion de Rutas
	IF app_selected = 71 THEN
		
		IF command_selected = 'new' THEN
			
			id_tipo_consecutivo:=13;--Folio de Programacion de Rutas
			
			--aqui entra para tomar el consecutivo del folio de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--str_data[4]	identificador
			--str_data[5]	fecha_proceso
			
			INSERT INTO cxc_fac_rev_cob(
				folio,--nuevo_folio,
				fecha_proceso, --str_data[6]::timestamp with time zone,
				borrado_logico,--false,
				gral_emp_id,--emp_id,
				gral_suc_id,--suc_id,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion --usuario_ejecutor
			)VALUES(nuevo_folio,str_data[5]::timestamp with time zone,false,emp_id,suc_id,espacio_tiempo_ejecucion,usuario_ejecutor) 
			RETURNING id INTO ultimo_id;
			
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--id_detalle 		str_filas[1]
				--id_h_fac		str_filas[2]
				--rev_cob		str_filas[3]
				
				INSERT INTO cxc_fac_rev_cob_detalle(
					cxc_fac_rev_cob_id, --ultimo_id,
					erp_h_facturas_id, --str_filas[2]::integer,
					revision_cobro --str_filas[3]
				)VALUES(ultimo_id,str_filas[2]::integer,str_filas[3]);
				
				IF str_filas[3]='R' THEN
					--actualizar estatus a Revision en erp_h_facturas
					UPDATE erp_h_facturas SET estatus_revision=1 WHERE id=str_filas[2]::integer;
				END IF;

				IF str_filas[3]='C' THEN
					--actualizar estatus a Cobro en erp_h_facturas
					UPDATE erp_h_facturas SET estatus_revision=2 WHERE id=str_filas[2]::integer;
				END IF;
				
			END LOOP;
			
			valor_retorno := '1';
		END IF;--termina nuevo
		
		
		
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_fac_rev_cob SET momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor, actualizado=TRUE 
			WHERE id = str_data[4]::integer;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--id_detalle 		str_filas[1]
				--id_h_fac		str_filas[2]
				--rev_cob		str_filas[3]
				--seleccionado		str_filas[4]
				
				IF str_filas[3]='R' THEN
					IF str_filas[4]='1' THEN
						--actualizar estatus_revision=2:Entregado en erp_h_facturas
						UPDATE erp_h_facturas SET estatus_revision=2 WHERE id=str_filas[2]::integer;
					ELSE
						--actualizar estatus_revision=0:Sin Revisar en erp_h_facturas
						UPDATE erp_h_facturas SET estatus_revision=0 WHERE id=str_filas[2]::integer;
					END IF;
				END IF;
				
				IF str_filas[3]='C' THEN
					IF str_filas[4]='1' THEN
						--actualizar estatus_revision=2:Entregado en erp_h_facturas
						UPDATE erp_h_facturas SET estatus_revision=2 WHERE id=str_filas[2]::integer;
					ELSE
						--actualizar estatus_revision=0:Sin Revisar en erp_h_facturas
						UPDATE erp_h_facturas SET estatus_revision=1 WHERE id=str_filas[2]::integer;
					END IF;
				END IF;
				
			END LOOP;
			
			valor_retorno := '1';
		END IF;--termina editar
		
	END IF;--Termina programacion de rutas

	
	
	
	-- Cancelacion de Anticipos
	IF app_selected = 146 THEN
		--str_data[4]	identificador
		--str_data[5]	id_cliente
		--str_data[6]	monto
		--str_data[7]	fecha
		--str_data[8]	select_moneda
		--str_data[9]	observaciones

		IF command_selected = 'new' THEN
			
			SELECT INTO str_data string_to_array(''||campos_data||'','___');	
			
                        id_tipo_consecutivo:=11;--Numero de transaccion pago CXC
                        
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--nuevo folio transaccion
			nuevo_consecutivo := nuevo_consecutivo::bigint;
		
			INSERT INTO cxc_ant(
				numero_transaccion, --nuevo_consecutivo,
				cliente_id,--str_data[5]::integer,
				moneda_id,--str_data[8]::integer, 
				anticipo_inicial,--str_data[6]::double precision, 
				anticipo_actual,--str_data[6]::double precision, 
				fecha_anticipo_usuario,--str_data[7]::timestamp with time zone,
				observaciones,--str_data[9],
				momento_creacion,--espacio_tiempo_ejecucion,
				id_usuario_creacion,--usuario_ejecutor,
				empresa_id,--emp_id, 
				sucursal_id--suc_id
			)
			VALUES(nuevo_consecutivo,str_data[5]::integer,str_data[8]::integer, str_data[6]::double precision, str_data[6]::double precision, str_data[7]::timestamp with time zone,str_data[9],espacio_tiempo_ejecucion,usuario_ejecutor,emp_id, suc_id);
			valor_retorno := 'Se ha generado el Anticipo numero: '||nuevo_consecutivo::character varying;
		END IF;--termina registro de anticipo
		
		
		
		IF command_selected = 'cancel' THEN
			UPDATE cxc_ant SET cancelado=TRUE, id_usuario_baja=usuario_ejecutor, momento_baja=espacio_tiempo_ejecucion 
			WHERE id=str_data[4]::integer ;
			
			valor_retorno := 'La cancelaci&oacute;n se realiz&oacute; con &eacute;xito.';
		END IF;
	END IF;
	
	
	
	
	-- Catalogo de Remitentes
	IF app_selected = 147 THEN
		IF command_selected = 'new' THEN
			--str_data[1] app_selected
			--str_data[2] command_selected
			--str_data[3] id_usuario
			--str_data[4] identificador
			--str_data[5] remitente
			--str_data[6] rfc
			--str_data[7] select_tipo
			--str_data[8] calle
			--str_data[9] numero_int
			--str_data[10] numero_ext
			--str_data[11] colonia
			--str_data[12] cp
			--str_data[13] select_pais
			--str_data[14] select_estado
			--str_data[15] select_municipio
			--str_data[16] tel1
			--str_data[17] ext1
			--str_data[18] tel2
			--str_data[19] email
			
			--Folio Catalogo de Remitentes
			id_tipo_consecutivo:=44;
			
			--aqui entra para tomar el consecutivo del folio de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO cxc_remitentes(
				folio, --nuevo_folio,
				rfc, --str_data[6],
				razon_social, --str_data[5], 
				tipo, --str_data[7]::integer,
				calle, --str_data[8],
				no_int, --str_data[9],
				no_ext, --str_data[10],
				colonia, --str_data[11],
				cp,--str_data[12],
				gral_mun_id, --str_data[15]::integer,
				gral_edo_id, --str_data[14]::integer,
				gral_pais_id, --str_data[13]::integer,
				tel1, --str_data[16],
				tel2, --str_data[18],
				ext, --str_data[17],
				email, --str_data[19],
				borrado_logico, --false,
				momento_creacion, --espacio_tiempo_ejecucion,
				gral_usr_id_crea, --usuario_ejecutor,
				gral_emp_id, --emp_id,
				gral_suc_id--suc_id
			)
			VALUES(nuevo_folio, str_data[6], str_data[5],  str_data[7]::integer, str_data[8], str_data[9], str_data[10], str_data[11], str_data[12], str_data[15]::integer, str_data[14]::integer, str_data[13]::integer, str_data[16], str_data[18], str_data[17], str_data[19], false, espacio_tiempo_ejecucion, usuario_ejecutor, emp_id, suc_id);
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_remitentes SET rfc=str_data[6], razon_social=str_data[5], tipo=str_data[7]::integer, calle=str_data[8], no_int=str_data[9], no_ext=str_data[10], colonia=str_data[11], cp=str_data[12], gral_mun_id=str_data[15]::integer, gral_edo_id=str_data[14]::integer, gral_pais_id=str_data[13]::integer, tel1=str_data[16], tel2=str_data[18], ext=str_data[17], email=str_data[19], momento_actualiza=espacio_tiempo_ejecucion,gral_usr_id_actualiza=usuario_ejecutor 
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxc_remitentes SET momento_baja=espacio_tiempo_ejecucion,borrado_logico=true, gral_usr_id_baja=usuario_ejecutor
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--Termian Catalogo de Remitentes


	
	
	-- Catalogo de Destinatarios
	IF app_selected = 148 THEN
		IF command_selected = 'new' THEN
			--str_data[1] app_selected
			--str_data[2] command_selected
			--str_data[3] id_usuario
			--str_data[4] identificador
			--str_data[5] destinatario
			--str_data[6] rfc
			--str_data[7] select_tipo
			--str_data[8] calle
			--str_data[9] numero_int
			--str_data[10] numero_ext
			--str_data[11] colonia
			--str_data[12] cp
			--str_data[13] select_pais
			--str_data[14] select_estado
			--str_data[15] select_municipio
			--str_data[16] tel1
			--str_data[17] ext1
			--str_data[18] tel2
			--str_data[19] email
			--str_data[20] folio_ext
			--str_data[21] check_firma
			--str_data[22] check_sello
			--str_data[23] check_efectivo	
			--str_data[24] id_cliente
			--str_data[25] check_cheque
			--str_data[26] select_serv
			--str_data[27] costo_serv
			
			--Folio Catalogo de Destinatarios
			id_tipo_consecutivo:=45;
			
			--aqui entra para tomar el consecutivo del folio de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO cxc_destinatarios(
				folio, --nuevo_folio,
				rfc, --str_data[6],
				razon_social, --str_data[5], 
				tipo, --str_data[7]::integer,
				calle, --str_data[8],
				no_int, --str_data[9],
				no_ext, --str_data[10],
				colonia, --str_data[11],
				cp,--str_data[12],
				gral_mun_id, --str_data[15]::integer,
				gral_edo_id, --str_data[14]::integer,
				gral_pais_id, --str_data[13]::integer,
				tel1, --str_data[16],
				tel2, --str_data[18],
				ext, --str_data[17],
				email, --str_data[19],
				folio_ext,--str_data[20],
				solicitar_firma,--str_data[21]::boolean,
				solicitar_sello,--str_data[22]::boolean,
				solicitar_efectivo,--str_data[23]::boolean,
				solicitar_cheque,--str_data[25]::boolean,
				inv_prod_id,--str_data[26]::integer,
				costo_serv,--str_data[27]::double precision,
				borrado_logico, --false,
				momento_creacion, --espacio_tiempo_ejecucion,
				gral_usr_id_crea, --usuario_ejecutor,
				gral_emp_id, --emp_id,
				gral_suc_id--suc_id
			)
			VALUES(nuevo_folio, str_data[6], str_data[5], str_data[7]::integer, str_data[8], str_data[9], str_data[10], str_data[11], str_data[12], str_data[15]::integer, str_data[14]::integer, str_data[13]::integer, str_data[16], str_data[18], str_data[17], str_data[19], str_data[20], str_data[21]::boolean, str_data[22]::boolean, str_data[23]::boolean, str_data[25]::boolean, str_data[26]::integer, str_data[27]::double precision, false, espacio_tiempo_ejecucion,usuario_ejecutor,emp_id,suc_id) 
			returning id into ultimo_id;
			
			--Crear registro para relacionar el destinatario con un cliente
			insert into cxc_clie_dest(cxc_clie_id, cxc_destinatario_id) values(str_data[24]::integer, ultimo_id);
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_destinatarios SET rfc=str_data[6], razon_social=str_data[5], tipo=str_data[7]::integer, calle=str_data[8], no_int=str_data[9], no_ext=str_data[10], colonia=str_data[11], cp=str_data[12], gral_mun_id=str_data[15]::integer, gral_edo_id=str_data[14]::integer, gral_pais_id=str_data[13]::integer, tel1=str_data[16], tel2=str_data[18], ext=str_data[17], email=str_data[19], folio_ext=str_data[20], solicitar_firma=str_data[21]::boolean, solicitar_sello=str_data[22]::boolean, solicitar_efectivo=str_data[23]::boolean, solicitar_cheque=str_data[25]::boolean, inv_prod_id=str_data[26]::integer, costo_serv=str_data[27]::double precision, momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_ejecutor 
			WHERE id=str_data[4]::integer;
			
			if str_data[24]::integer > 0 then
				select count(id) from cxc_clie_dest where cxc_clie_id=str_data[24]::integer and cxc_destinatario_id=str_data[4]::integer into exis;
				
				if exis is null then exis:=0; end if;
				
				if exis<=0 then 
					insert into cxc_clie_dest(cxc_clie_id, cxc_destinatario_id) values(str_data[24]::integer, str_data[4]::integer);
				end if;
			end if;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxc_destinatarios SET momento_baja=espacio_tiempo_ejecucion,borrado_logico=true, gral_usr_id_baja=usuario_ejecutor
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--Termian Catalogo de Destinatarios


	
	
	
	-- Catalogo de Agentes Aduanales
	IF app_selected = 149 THEN
		IF command_selected = 'new' THEN
			--str_data[1] app_selected
			--str_data[2] command_selected
			--str_data[3] id_usuario
			--str_data[4] identificador
			--str_data[5] Agente Aduanal
			--str_data[6] select_tipo
			--str_data[7] calle
			--str_data[8] numero_int
			--str_data[9] numero_ext
			--str_data[10] colonia
			--str_data[11] cp
			--str_data[12] select_pais
			--str_data[13] select_estado
			--str_data[14] select_municipio
			--str_data[15] tel1
			--str_data[16] ext1
			--str_data[17] tel2
			--str_data[18] email
			
			--Folio Catalogo de Agentes Aduanales
			id_tipo_consecutivo:=46;
			
			--aqui entra para tomar el consecutivo del folio de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO cxc_agentes_aduanales(
				folio, --nuevo_folio,
				razon_social, --str_data[5], 
				tipo, --str_data[6]::integer,
				calle, --str_data[7],
				no_int, --str_data[8],
				no_ext, --str_data[9],
				colonia, --str_data[10],
				cp,--str_data[11],
				gral_mun_id, --str_data[14]::integer,
				gral_edo_id, --str_data[13]::integer,
				gral_pais_id, --str_data[12]::integer,
				tel1, --str_data[15],
				tel2, --str_data[17],
				ext, --str_data[16],
				email, --str_data[18],
				borrado_logico, --false,
				momento_creacion, --espacio_tiempo_ejecucion,
				gral_usr_id_crea, --usuario_ejecutor,
				gral_emp_id, --emp_id,
				gral_suc_id--suc_id
			)
			VALUES(
				nuevo_folio,
				str_data[5], 
				str_data[6]::integer,
				str_data[7],
				str_data[8],
				str_data[9],
				str_data[10],
				str_data[11],
				str_data[14]::integer,
				str_data[13]::integer,
				str_data[12]::integer,
				str_data[15],
				str_data[17],
				str_data[16],
				str_data[18],
				false,
				espacio_tiempo_ejecucion,
				usuario_ejecutor,
				emp_id,
				suc_id
			);
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_agentes_aduanales SET razon_social=str_data[5], tipo=str_data[6]::integer, calle=str_data[7], no_int=str_data[8], no_ext=str_data[9], colonia=str_data[10], cp=str_data[11], gral_mun_id=str_data[14]::integer, gral_edo_id=str_data[13]::integer, gral_pais_id=str_data[12]::integer, tel1=str_data[15], tel2=str_data[17], ext=str_data[16], email=str_data[18], momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_ejecutor 
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxc_agentes_aduanales SET momento_baja=espacio_tiempo_ejecucion,borrado_logico=true, gral_usr_id_baja=usuario_ejecutor
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--Termian Catalogo de Agentes Aduanales
	
	
	-- Aplicativo Asignacion de Remitentes
	IF app_selected = 150 THEN
		--str_data[4]        identificador
		--str_data[5]        id_cliente	
		--RAISE EXCEPTION '%',command_selected;
		IF command_selected = 'new' THEN			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	eliminado
				--str_filas[2]	iddet
				--str_filas[3]	idcli
				--str_filas[4]	idrem
				--str_filas[5]	noTr
				
				INSERT INTO cxc_clie_remitente(cxc_clie_id, cxc_remitente_id) VALUES(str_filas[3]::integer, str_filas[4]::integer);
			END LOOP;
			
			valor_retorno := '1';
		END IF;

		IF command_selected = 'edit' THEN
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				IF str_filas[1]::integer=1 THEN 
					IF str_filas[2]::integer=0 THEN 
						INSERT INTO cxc_clie_remitente(cxc_clie_id, cxc_remitente_id) VALUES(str_filas[3]::integer, str_filas[4]::integer);
					END IF;
				ELSE
					--RAISE EXCEPTION '%',str_filas[2];
					IF str_filas[2]::integer<>0 THEN 
						DELETE FROM cxc_clie_remitente WHERE id=str_filas[2]::integer;
					END IF;	
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			DELETE FROM cxc_clie_remitente WHERE cxc_clie_id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--Termian Asignacion de Remitentes
	
	
	-- Aplicativo Asignacion de Destinatarios
	IF app_selected = 151 THEN
		--str_data[4]        identificador
		--str_data[5]        id_cliente	
		--RAISE EXCEPTION '%',command_selected;
		IF command_selected = 'new' THEN			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	eliminado
				--str_filas[2]	iddet
				--str_filas[3]	idcli
				--str_filas[4]	iddest
				--str_filas[5]	noTr
				
				INSERT INTO cxc_clie_dest(cxc_clie_id, cxc_destinatario_id) VALUES(str_filas[3]::integer, str_filas[4]::integer);
			END LOOP;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				IF str_filas[1]::integer=1 THEN 
					IF str_filas[2]::integer=0 THEN 
						INSERT INTO cxc_clie_dest(cxc_clie_id, cxc_destinatario_id) VALUES(str_filas[3]::integer, str_filas[4]::integer);
					END IF;
				ELSE
					--RAISE EXCEPTION '%',str_filas[2];
					IF str_filas[2]::integer<>0 THEN 
						DELETE FROM cxc_clie_dest WHERE id=str_filas[2]::integer;
					END IF;	
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			DELETE FROM cxc_clie_dest WHERE cxc_clie_id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--Termian Asignacion de Destinatarios
	
	
	-- Aplicativo Asignacion de Agentes Aduanales
	IF app_selected = 152 THEN
		--str_data[4]        identificador
		--str_data[5]        id_cliente	
		--RAISE EXCEPTION '%',command_selected;
		IF command_selected = 'new' THEN			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	eliminado
				--str_filas[2]	iddet
				--str_filas[3]	idcli
				--str_filas[4]	idagen
				--str_filas[5]	noTr
				
				INSERT INTO cxc_clie_agen_aduanal(cxc_clie_id, cxc_agente_aduanal_id) VALUES(str_filas[3]::integer, str_filas[4]::integer);
			END LOOP;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				IF str_filas[1]::integer=1 THEN 
					IF str_filas[2]::integer=0 THEN 
						INSERT INTO cxc_clie_agen_aduanal(cxc_clie_id, cxc_agente_aduanal_id) VALUES(str_filas[3]::integer, str_filas[4]::integer);
					END IF;
				ELSE
					--RAISE EXCEPTION '%',str_filas[2];
					IF str_filas[2]::integer<>0 THEN 
						DELETE FROM cxc_clie_agen_aduanal WHERE id=str_filas[2]::integer;
					END IF;	
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			DELETE FROM cxc_clie_agen_aduanal WHERE cxc_clie_id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--Termian Asignacion de Agentes Aduanales

	
	
	
	
	
	RETURN valor_retorno; 
	
END;
$$;


--
-- Name: cxc_reporte_saldo_mensual(integer, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cxc_reporte_saldo_mensual(tipo integer, cliente character varying, fecha character varying, id_empresa integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
	
	fila record;
	fila2 record;
	returnrecord record;
	cadena_sql character varying;
	sql_suma_pagos character varying;
	sql_suma_nc character varying;
	
	cadena_sql2 character varying;
	cadena_where character varying;
	incluir_registro boolean;
	suma_pagos double precision;
	
BEGIN
	--select * from cxc_reporte_saldo_mensual(1, 'agri', '2013-10-01', 4) as foo(id_cliente integer, cliente character varying, serie_folio character varying, fecha_factura character varying, moneda_id integer, moneda_abr character varying, moneda_simbolo character varying, orden_compra character varying, monto_factura double precision, importe_pagado double precision, saldo_factura double precision) ORDER BY cliente, moneda_id, serie_folio

	BEGIN 
		--Crear tabla temporal
		CREATE TEMPORARY TABLE tmpReporteCxcSaldoMes (id_cliente integer,cliente character varying,factura character varying,fecha_factura character varying,moneda_id integer,moneda_abr character varying,moneda_simbolo character varying,orden_compra character varying,monto_total double precision,importe_pagado double precision,saldo_factura double precision);
		EXCEPTION WHEN OTHERS THEN
		TRUNCATE TABLE tmpReporteCxcSaldoMes; -- TRUNCATE if the table already exists within the session.
	END;
	
	cadena_where:='';
	IF tipo=1 THEN 
		cadena_where:= 'AND cxc_clie.razon_social ILIKE ''%'||cliente||'%''';
	END IF;
	
	cadena_sql:='
	SELECT 
		cxc_clie.id AS id_cliente,
		cxc_clie.razon_social as cliente,  
		erp_h_facturas.moneda_id,
		gral_mon.descripcion_abr AS moneda_abr, 
		gral_mon.simbolo AS moneda_simbolo,
		erp_h_facturas.serie_folio,  
		erp_h_facturas.orden_compra, 
		to_char(erp_h_facturas.momento_facturacion,''dd/mm/yyyy'')as fecha_facturacion,  
		erp_h_facturas.monto_total,  
		(erp_h_facturas.total_pagos + erp_h_facturas.total_notas_creditos) AS importe_pagado, 
		erp_h_facturas.saldo_factura, 
		erp_h_facturas.fecha_ultimo_pago,
		erp_h_facturas.pagado,
		erp_h_facturas.cancelacion,
		erp_h_facturas.momento_cancelacion 
	FROM erp_h_facturas  
	JOIN cxc_clie ON cxc_clie.id = erp_h_facturas.cliente_id 
	JOIN gral_mon ON gral_mon.id = erp_h_facturas.moneda_id 
	WHERE erp_h_facturas.empresa_id='||id_empresa||' '||cadena_where||' 
	AND erp_h_facturas.momento_facturacion <= '''||fecha||'''::timestamp with time zone
	--AND (erp_h_facturas.fecha_ultimo_pago > '''||fecha||'''::timestamp with time zone OR erp_h_facturas.fecha_ultimo_pago IS NULL)
	--AND (erp_h_facturas.momento_cancelacion > '''||fecha||'''::timestamp with time zone OR erp_h_facturas.momento_cancelacion IS NULL)
	ORDER BY cxc_clie.id, erp_h_facturas.moneda_id, erp_h_facturas.momento_facturacion, erp_h_facturas.serie_folio;';
	
	--RAISE EXCEPTION '%' ,'cadena_sql: '||cadena_sql;
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		incluir_registro:=false;
		suma_pagos:=0.0;
		
		IF fila.cancelacion THEN
			--Si esta cancelado, verificar que haya sido despues de la fecha ingresada como parametro
			IF fila.momento_cancelacion > fecha::timestamp with time zone THEN
				incluir_registro:=true;
			END IF;
		ELSE
			IF fila.pagado THEN
				--Si esta pagado, verificar que haya sido despues de la fecha que se le pasa como parametro
				IF fila.fecha_ultimo_pago > fecha::timestamp with time zone THEN
					incluir_registro:=true;
				END IF;
			ELSE
				incluir_registro:=true;
			END IF;
		END IF;
		
		IF incluir_registro THEN

			sql_suma_pagos:='SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(erp_pagos_detalles.cantidad) FROM erp_pagos JOIN erp_pagos_detalles ON erp_pagos_detalles.pago_id=erp_pagos.id WHERE erp_pagos_detalles.serie_folio='''||fila.serie_folio||''' AND erp_pagos_detalles.cancelacion=FALSE AND erp_pagos.cliente_id='||fila.id_cliente||' AND erp_pagos.fecha_deposito::timestamp with time zone > '''||fecha||'''::timestamp with time zone) AS sbt1';
			
			IF fila.moneda_id=1 THEN
				--Cuando la Factura es en PESOS, hay que convertir todas las notas de credito en pesos
				sql_suma_nc:='SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (SELECT sum(total_nota) FROM (SELECT 	round(( (CASE WHEN moneda_id<>1 THEN (total::double precision * tipo_cambio::double precision) ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='''' AND cancelado=false AND serie_folio_factura='''||fila.serie_folio||''' AND cxc_clie_id='||fila.id_cliente||' AND momento_expedicion::timestamp with time zone > '''||fecha||'''::timestamp with time zone ) AS sbt) AS subt2';
			ELSE
				--Cuando la moneda de la factura es USD hay que convertir todas las Notas de Credito a Dolar
				sql_suma_nc:='SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (SELECT sum(total_nota) FROM (SELECT 	round(( (CASE WHEN moneda_id=1 THEN total/tipo_cambio ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='''' AND cancelado=false AND serie_folio_factura='''||fila.serie_folio||''' AND cxc_clie_id='||fila.id_cliente||' AND momento_expedicion::timestamp with time zone > '''||fecha||'''::timestamp with time zone) AS sbt ) AS subt3';
			END IF;
			
			--Query para obtener suma de  Pagos y Notas de Credito aplicados a la Factura
			cadena_sql2:='SELECT sum(sum) AS pagos FROM ('||sql_suma_pagos||' UNION '||sql_suma_nc||') AS sbt;';
			
			--RAISE EXCEPTION '%' ,'cadena_sql2: '||cadena_sql2;
			
			--Ejecuta query para obtener la suma de los pagos y notas de credito
			EXECUTE cadena_sql2 INTO suma_pagos;
			
			IF suma_pagos IS NULL THEN suma_pagos:=0; END IF;
			
			--Calcular el importe pagado a la antes de la fecha indicada en el parametro
			fila.importe_pagado := fila.importe_pagado::double precision - suma_pagos::double precision;
			
			--Obtener el saldo de la factura
			fila.saldo_factura := fila.monto_total::double precision - fila.importe_pagado::double precision;

			--Insertar registros en la tabla temporal
			INSERT INTO tmpReporteCxcSaldoMes VALUES(fila.id_cliente, fila.cliente, fila.serie_folio, fila.fecha_facturacion, fila.moneda_id, fila.moneda_abr, fila.moneda_simbolo, fila.orden_compra, fila.monto_total, fila.importe_pagado, fila.saldo_factura);
		END IF;
	END LOOP;

	
	--Recorriendo la tabla temporal y retornando sus filas
	FOR returnrecord IN SELECT * FROM tmpReporteCxcSaldoMes LOOP
		RETURN NEXT returnrecord;
	END LOOP;
	
	
END

$$;


--
-- Name: cxp_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cxp_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$


DECLARE
	app_selected integer;
	command_selected text;
	usuario_ejecutor integer;
	emp_id integer;
	suc_id integer;
	str_data text[];
	str_filas text[];
	valor_retorno character varying = ''; 
	fila record;
	
	iter_y integer;--contador de filas o posiciones del arreglo (iterador eje y del arreglo iterado)
	ultimo_id integer =0;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	numero_dias_credito integer=0;
	fecha_de_vencimiento timestamp with time zone;
	fcaducidad date;
	exis integer = 0;
	tip_cam double precision=0.0;
	valor_impuesto double precision = 0.0;
	importe double precision = 0.0;
	subtotal_factura double precision = 0.0;
	impuesto_partida double precision = 0.0;
	retencion_partida double precision = 0.0;
	suma_retencion double precision = 0.0;
	suma_impuesto double precision = 0.0;
	total_factura double precision = 0.0;
	tasa_retencion double precision = 0.0;
	total_retencion double precision = 0.0;
	saldo_fac_prov double precision = 0.0;
	saldo_fac_prov_round double precision = 0.0;
	
	importe_ieps_partida double precision = 0;
	suma_ieps double precision = 0;
	importe_isr double precision = 0;
	
	--Pagos a proveedores
	num_transaccion bigint=0;
	suma_pagos double precision = 0.0;
	suma_pagos_cancelados double precision = 0.0;
	suma_notas_credito  double precision = 0.0;
	saldo_factura_prov double precision = 0.0;
	id_proveedor integer=0;
	factura_prov character varying='';
	
	pago_detalle record;
	sql_select character varying='';
	chequera character varying='';
	ano_actual integer;
	mes_actual integer;
	nuevo_consecutivo_cheque bigint=0;
	id_tes_che integer=0;
	id_beneficiario integer =0;
	razon_social_proveedor character varying;
	referencia_transferencia  character varying;
	reten boolean = true;
	existe_registro integer =0;
	error_consecutivo  character varying = '';
	salvar_registro boolean = true;
	tipo_pago integer=0; 
	
	tipo_movimiento_id integer=0;
	ultimo_tes_mov_id integer =0;
	
	id_impuesto integer = 0;
	porcentaje_impuesto double precision=0;
	cheque_iva  double precision=0;
	cheque_importe  double precision=0;
	
	parametro record;
	id_tipo_consecutivo integer = 0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
	
BEGIN
	
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- aplicativo que manda a llamar este procedimiento almacenado
	app_selected := str_data[1]::integer;
	
	-- comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	-- usuario que utiliza el aplicativo
	usuario_ejecutor := str_data[3]::integer;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	INTO emp_id, suc_id;
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	-- Facturas de proveedores
	IF app_selected = 30 THEN
		
		IF command_selected = 'new' THEN
			
			SELECT dias FROM cxp_prov_credias WHERE id= str_data[15]::integer INTO numero_dias_credito;
			
			--calcula la fecha de vencimiento a partir de la fecha de la factura
			SELECT (to_char(str_data[9]::timestamp with time zone,'yyyy-mm-dd')::DATE + numero_dias_credito)::timestamp with time zone AS fecha_vencimiento INTO fecha_de_vencimiento;
			
			IF str_data[11]::integer=1 THEN 
				tip_cam:=1;
			ELSE
				tip_cam:=str_data[10]::double precision;
			END IF;
			
			
			INSERT INTO cxp_facturas(
				tipo_factura_proveedor, --str_data[6]::integer
				  cxc_prov_id, --str_data[5]::integer
				  serie_folio, --str_data[8]
				  flete, --str_data[16]::double precision,
				  tipo_cambio, --str_data[10]::double precision,
				  fecha_factura,  --str_data[9]::timestamp with time zone,
				  momento_creacion,--espacio_tiempo_ejecucion,
				  numero_guia,--str_data[12]
				  orden_compra,--str_data[13]
				  observaciones,--str_data[7]
				  moneda_id, --str_data[11]::integer
				  fletera_id, --str_data[14]::integer
				  dias_credito_id, --str_data[15]::integer
				  fecha_vencimiento,--fecha_de_vencimiento
				  id_usuario_creacion,--usuario_ejecutor
				  empresa_id, --emp_id
				  sucursal_id--suc_id
			)
			VALUES(str_data[6]::integer,str_data[5]::integer,str_data[8],str_data[16]::double precision,tip_cam ,str_data[9]::timestamp with time zone,espacio_tiempo_ejecucion,str_data[12],str_data[13],str_data[7],str_data[11]::integer,str_data[14]::integer,str_data[15]::integer,fecha_de_vencimiento,usuario_ejecutor,emp_id,suc_id)
			RETURNING id INTO ultimo_id;
			
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--codigo_producto[i] 	str_filas[1]
				--descripcion_producto[i]str_filas[2]
				--unidad[i]		str_filas[3]
				--presentacion[i]	str_filas[4]
				--cantidad[i]		str_filas[5]
				--costo[i]		str_filas[6]
				--impuesto_id[i]	str_filas[7]
				--valor_imp[i]		str_filas[8]
				--eliminado[i]		str_filas[9]
				--ieps_id		str_filas[10]
				--tasa_ieps		str_filas[11]
				
				--costo y canidad no son vacias, se agrega el registro
				IF str_filas[9]::integer != 0 THEN
					--inicializamos valor_impuesto para cada producto del grid
					valor_impuesto:=0.0;
					importe:=0.0;
					importe_ieps_partida:=0.0;
					impuesto_partida:=0.0;
					
					INSERT INTO cxp_facturas_detalle(cxp_facturas_id,codigo_producto,descripcion,unidad_medida,presentacion,cantidad,costo_unitario,gral_imp_id,valor_imp, gral_ieps_id, valor_ieps)
					VALUES(ultimo_id,str_filas[1],str_filas[2],str_filas[3],str_filas[4],str_filas[5]::double precision,str_filas[6]::double precision,str_filas[7]::integer, str_filas[8]::double precision, str_filas[10]::integer, str_filas[11]::double precision);
					
					--Busca el valor del impuesto
					SELECT count(id) FROM gral_imptos WHERE borrado_logico=FALSE AND id=str_filas[7]::integer INTO exis;
					IF exis > 0 THEN
						SELECT iva_1 FROM gral_imptos WHERE borrado_logico=FALSE AND id=str_filas[7]::integer INTO valor_impuesto;
					END IF;
					
					importe := round((str_filas[5]::double precision * str_filas[6]::double precision)::numeric,4)::double precision;

					--Calcular el importe del IEPS de la partida
					importe_ieps_partida := round((importe * str_filas[11]::double precision)::numeric, 4)::double precision;
					
					--Calcular el impuesto de la Partida
					impuesto_partida = round(((importe + importe_ieps_partida::double precision) * valor_impuesto)::numeric,4)::double precision;

					--Acumular montos
					subtotal_factura := subtotal_factura + importe::double precision;
					suma_ieps := suma_ieps + importe_ieps_partida::double precision;
					suma_impuesto := suma_impuesto + impuesto_partida::double precision;
				END IF;
			END LOOP;
			
			
			--Obtener la tasa del impuesto de retencion
			SELECT DISTINCT valor::double precision/100 AS valor FROM erp_parametros_generales WHERE variable = 'tasa_retencion_fletes' LIMIT 1 INTO tasa_retencion;
			
			--inicializar variable
			valor_impuesto:=0.0;
			
			--obtener el valor del iva
			SELECT iva_1 FROM gral_imptos WHERE id = 1 INTO valor_impuesto;
			
			--Calcular retencion
			IF str_data[6]::integer != 4 THEN
				total_retencion := str_data[16]::double precision * tasa_retencion;
			ELSE
				--Aqui entra cuando es una factura de flete
				total_retencion := subtotal_factura * tasa_retencion;
			END IF;
			
			--Sacar impuesto del flete
			suma_impuesto := suma_impuesto + (str_data[16]::double precision * valor_impuesto);
			
			--Sumar flete al subtotal
			subtotal_factura := subtotal_factura + str_data[16]::double precision;

			
			--2=Factura de Proveedor de Servicios u Honorarios
			IF str_data[6]::integer = 2 THEN
				--Calcular la Retencion del IVA
				total_retencion = (suma_impuesto::double precision / 3) * 2;
				
				--Calcular el ISR
				importe_isr = subtotal_factura * 0.10;
			END IF;
			
			
			--Calcular el total
			total_factura := subtotal_factura + suma_ieps::double precision + suma_impuesto::double precision - total_retencion::double precision - importe_isr;
			
			--actualiza cxp_facturas para guardar totales
			UPDATE cxp_facturas SET 
				monto_total=round((total_factura)::numeric,2)::double precision,
				saldo_factura=round((total_factura)::numeric,2)::double precision,
				subtotal=round((subtotal_factura)::numeric,2)::double precision,
				monto_ieps=round((suma_ieps)::numeric,2)::double precision,
				iva=round((suma_impuesto)::numeric,2)::double precision,
				retencion=round((total_retencion)::numeric,2)::double precision,
				monto_ret_isr=round((importe_isr)::numeric,2)::double precision 
			WHERE id=ultimo_id;
			valor_retorno := '1';
		END IF;--termina nueva factura
		
		
		
		
		IF command_selected = 'edit' THEN
			
			SELECT DISTINCT valor::double precision/100 AS valor FROM erp_parametros_generales WHERE variable = 'tasa_retencion_fletes' LIMIT 1 INTO tasa_retencion;
			
			total_retencion := str_data[16]::double precision * tasa_retencion;
			
			SELECT dias FROM cxp_prov_credias WHERE id= str_data[15]::integer INTO numero_dias_credito;
			
			SELECT (to_char(espacio_tiempo_ejecucion,'yyyy-mm-dd')::DATE + numero_dias_credito)::timestamp with time zone AS fecha_vencimiento INTO fecha_de_vencimiento;
			
			IF str_data[11]::integer=1 THEN 
				tip_cam:=1;
			ELSE
				tip_cam:=str_data[10]::double precision;
			END IF;
			
			UPDATE cxp_facturas SET serie_folio=str_data[8], flete=str_data[16]::double precision, tipo_cambio=tip_cam, fecha_factura=str_data[9]::timestamp with time zone, numero_guia=str_data[12], orden_compra=str_data[13], observaciones=str_data[7], moneda_id=str_data[11]::integer, fletera_id=str_data[14]::integer, dias_credito_id=str_data[15]::integer, fecha_vencimiento=fecha_de_vencimiento, momento_actualizacion=espacio_tiempo_ejecucion, id_usuario_actualizacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer;
			
			--elimina detalles de la factura
			DELETE FROM cxp_facturas_detalle WHERE cxp_facturas_id=str_data[4]::integer;
			
			--en este ciclo se vuelven a crear los registros en detalles
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--codigo_producto[i] 	str_filas[1]
				--descripcion_producto[i]str_filas[2]
				--unidad[i]		str_filas[3]
				--presentacion[i]	str_filas[4]
				--cantidad[i]		str_filas[5]
				--costo[i]		str_filas[6]
				--impuesto_id[i]	str_filas[7]
				--valor_imp[i]		str_filas[8]
				--eliminado[i]		str_filas[9]
				
				--costo y canidad no son vacias, se agrega el registro
				IF str_filas[9]::integer != 0 THEN
					importe:=0.0;
					importe_ieps_partida:=0.0;
					impuesto_partida:=0.0;
					
					--inicializamos valor_impuesto para cada producto del grid
					valor_impuesto:=str_filas[8]::double precision;
					
					INSERT INTO cxp_facturas_detalle(cxp_facturas_id,codigo_producto,descripcion,unidad_medida,presentacion,cantidad,costo_unitario,gral_imp_id,valor_imp, gral_ieps_id, valor_ieps)
					VALUES(str_data[4]::integer,str_filas[1],str_filas[2],str_filas[3],str_filas[4],str_filas[5]::double precision,str_filas[6]::double precision,str_filas[7]::integer,str_filas[8]::double precision, str_filas[10]::integer, str_filas[11]::double precision);			
					
					--busca el valor del impuesto
					SELECT count(id) FROM gral_imptos WHERE borrado_logico=FALSE AND id=str_filas[7]::integer INTO exis;
					IF exis > 0 THEN
						SELECT iva_1 FROM gral_imptos WHERE borrado_logico=FALSE AND id=str_filas[7]::integer INTO valor_impuesto;
					END IF;
					
					--Calcular el Importe
					importe := round((str_filas[5]::double precision * str_filas[6]::double precision)::numeric,4)::double precision;

					--Calcular el importe del IEPS de la partida
					importe_ieps_partida := round((importe * str_filas[11]::double precision)::numeric, 4)::double precision;
					
					--Calcular el impuesto de la Partida
					impuesto_partida = round(((importe + importe_ieps_partida::double precision) * valor_impuesto)::numeric,4)::double precision;
					
					--Acumular montos
					subtotal_factura := subtotal_factura + importe::double precision;
					suma_ieps := suma_ieps + importe_ieps_partida::double precision;
					suma_impuesto := suma_impuesto + impuesto_partida::double precision;
				END IF;
			END LOOP;
			
			
			--obtener la tasa del impuesto de retencion
			SELECT DISTINCT valor::double precision/100 AS valor FROM erp_parametros_generales WHERE variable = 'tasa_retencion_fletes' LIMIT 1 INTO tasa_retencion;

			--inicializar variable
			valor_impuesto:=0.0;
			
			--obtener el valor del iva
			SELECT iva_1 FROM gral_imptos WHERE id = 1 INTO valor_impuesto;


			--Calcular retencion
			IF str_data[6]::integer != 4 THEN
				total_retencion := str_data[16]::double precision * tasa_retencion;
			ELSE
				--Aqui entra cuando es una factura de flete
				total_retencion := subtotal_factura * tasa_retencion;
			END IF;
			
			--Calcular el impuesto del Flete y Sumar
			suma_impuesto := suma_impuesto + (str_data[16]::double precision * valor_impuesto);
			
			--Sumar flete al subtotal
			subtotal_factura := subtotal_factura + str_data[16]::double precision;

			
			--2=Factura de Proveedor de Servicios u Honorarios
			IF str_data[6]::integer = 2 THEN
				--Calcular la Retencion del IVA
				total_retencion = (suma_impuesto::double precision / 3) * 2;
				
				--Calcular el ISR
				importe_isr = subtotal_factura * 0.10;
			END IF;
			
			
			--Calcular el total
			total_factura := subtotal_factura + suma_ieps::double precision + suma_impuesto::double precision - total_retencion::double precision - importe_isr;
			
			--Actualiza cxp_facturas para guardar totales
			UPDATE cxp_facturas SET monto_total=round((total_factura)::numeric,2)::double precision, saldo_factura=round((total_factura)::numeric,2)::double precision, subtotal=round((subtotal_factura)::numeric,2)::double precision, monto_ieps=round((suma_ieps)::numeric,2)::double precision, iva=round((suma_impuesto)::numeric,2)::double precision, retencion=round((total_retencion)::numeric,2)::double precision, monto_ret_isr=round((importe_isr)::numeric,2)::double precision  
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;--termina editar factura
		
		IF command_selected = 'cancelacion' THEN
			-- 0=Nuevo, 1=Pago Parcial, 2=Pagado, 3=Cancelado
			
			UPDATE cxp_facturas SET 
				estatus=3,
				cancelacion=true, 
				momento_cancelacion=espacio_tiempo_ejecucion, 
				id_usuario_cancelacion=usuario_ejecutor,
				cxp_tipo_cancelacion_id = str_data[5]::integer,
				motivo_cancelacion = str_data[6]
			WHERE id=str_data[4]::integer;
			valor_retorno := 'true';
		END IF;
		
	END IF;
	--Termina facturas de proveedores

	
	
	-- Pagos a Proveedores
	IF app_selected = 60 THEN
		IF command_selected = 'new' THEN
			ultimo_id:=0;
			salvar_registro:= TRUE;
			--se retorna false, si no hay error en el cheque
			valor_retorno:='false___';
			
			--RAISE EXCEPTION '%' ,'valor_retorno:'||valor_retorno;
			
			IF str_data[9]::integer=2 THEN
				--SELECT id,titulo FROM tes_che WHERE id=str_data[11]::integer INTO chequera;
				
				SELECT count(id) FROM tes_num_che WHERE tes_che_id=str_data[11]::integer INTO existe_registro;
				IF existe_registro > 0 THEN 
					
					SELECT (CASE WHEN consecutivo = consecutivo_final  THEN 'error_consecutivo' ELSE '' END ) error_num_cheque
					FROM tes_num_che WHERE tes_che_id = str_data[11]::integer INTO error_consecutivo;
					
					IF error_consecutivo <> 'error_consecutivo' THEN 
						UPDATE 	tes_num_che SET consecutivo=(
							SELECT sbt.consecutivo + 1  FROM tes_num_che AS sbt WHERE sbt.id=tes_num_che.id
						)
						WHERE tes_che_id=str_data[11]::integer  RETURNING consecutivo INTO nuevo_consecutivo_cheque;
					ELSE
						--se retorna esto, si hay error en el consecutivo del cheque
						valor_retorno:='Error en el consecutivo, no hay cheques disponibles.___';
						salvar_registro:= false;
					END IF;
				ELSE
					--se retorna este mensaje, cuando no hay registro en la tabla
					valor_retorno:='Falta registrar Consecutivo Inicial y Final para esta Chequera.___';
					salvar_registro:= false;
				END IF;
				reten:= false;
			END IF;
			
			--RAISE EXCEPTION '%' ,'valor_retorno:'||valor_retorno;
			IF salvar_registro=TRUE THEN
				--genera nuevo numero de transaccion de pago
				--UPDATE 	gral_emp_consecutivos SET numero_transaccion_pagos=(SELECT sbt.numero_transaccion_pagos +1  FROM gral_emp_consecutivos AS sbt WHERE sbt.id=gral_emp_consecutivos.id)
				--WHERE gral_emp_id=emp_id RETURNING numero_transaccion_pagos INTO num_transaccion;
				
				id_tipo_consecutivo:=8;--Folio pagos a proveedores
				
				--aqui entra para tomar el consecutivo del folio  la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				num_transaccion := nuevo_consecutivo::bigint;
				
				
				IF str_data[8]::integer=1 THEN
					tipo_movimiento_id:=20;--Pago a Proveedor en M.N.
				END IF;
				
				IF str_data[8]::integer=2 THEN
					tipo_movimiento_id:=21;--Pago a Proveedor en Dolares
				END IF;
				
				INSERT INTO cxp_pagos(
					numero_transaccion, --numero_transaccion::bigint,
					cxp_prov_id, --str_data[5]::integer,
					cxp_mov_tipo_id,--tipo_movimiento_id
					fecha_pago, --str_data[6]::date,
					tipo_cambio, --str_data[7]::double precision,
					moneda_id, --str_data[8]::integer,
					tes_mov_tipo_id, --str_data[9]::integer,
					tes_ban_id, --str_data[10]::integer,
					tes_che_id, --str_data[11]::integer,
					numero_cheque,--nuevo_consecutivo_cheque
					referencia, --str_data[13],
					numero_tarjeta, --str_data[14],
					monto_pago, --str_data[15]::double precision,
					observaciones, --str_data[16],
					momento_creacion, --espacio_tiempo_ejecucion,
					gral_usr_id_creacion, --usuario_ejecutor,
					gral_emp_id, --emp_id,
					gral_suc_id
				)VALUES(
					num_transaccion,
					str_data[5]::integer,
					tipo_movimiento_id,
					str_data[6]::date,
					str_data[7]::double precision,
					str_data[8]::integer,
					str_data[9]::integer,
					str_data[10]::integer,
					str_data[11]::integer,
					nuevo_consecutivo_cheque,
					str_data[13],
					str_data[14],
					str_data[15]::double precision,
					str_data[16],
					espacio_tiempo_ejecucion,
					usuario_ejecutor,
					emp_id,
					suc_id
				)RETURNING id INTO ultimo_id;
				
				FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
					--factura_vista 	str_filas[1]
					--saldado		str_filas[2]
					--saldar		str_filas[3]
					--tipo_cambio		str_filas[4]
					
					--registra pago a la factura
					INSERT INTO cxp_pagos_detalles(cxp_pago_id,serie_folio,cantidad, tipo_cambio)
					VALUES(ultimo_id,str_filas[1],str_filas[3]::double precision,str_filas[4]::double precision);
					
					--obtiene suma de pagos para esta factura
					SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(cxp_pagos_detalles.cantidad) FROM cxp_pagos JOIN cxp_pagos_detalles ON cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id WHERE cxp_pagos_detalles.serie_folio=str_filas[1] AND cxp_pagos_detalles.cancelacion=FALSE AND cxp_pagos.cxp_prov_id=str_data[5]::integer ) AS sbt  
					INTO suma_pagos;

					--obtiene suma de las notas de credito para esta factura
					SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(total) FROM cxp_nota_credito WHERE factura=str_filas[1] AND cancelado=FALSE AND cxp_prov_id=str_data[5]::integer ) AS sbt2
					INTO suma_notas_credito;

					-- 0=Nuevo, 1=Pago Parcial, 2=Pagado, 3=Cancelado
					
					--actualiza pagos de la factura
					IF str_filas[2]::boolean=FALSE THEN
						UPDATE cxp_facturas SET 
							total_pagos=suma_pagos,
							total_notas_creditos=suma_notas_credito,
							pagado=str_filas[2]::boolean,
							estatus=1,
							saldo_factura=round((monto_total - suma_pagos - suma_notas_credito)::numeric,2)::double precision,
							fecha_ultimo_pago = str_data[6]::timestamp with time zone
						WHERE serie_folio=str_filas[1] AND cxc_prov_id=str_data[5]::integer;
					ELSE
						UPDATE cxp_facturas SET 
							total_pagos=suma_pagos,
							total_notas_creditos=suma_notas_credito,
							pagado=str_filas[2]::boolean,
							saldo_factura=0,
							estatus=2,
							fecha_ultimo_pago = str_data[6]::timestamp with time zone
						WHERE serie_folio=str_filas[1] AND cxc_prov_id=str_data[5]::integer;
					END IF;
				END LOOP;
				
				
				
				SELECT id, razon_social FROM cxp_prov WHERE id=str_data[5]::integer INTO id_beneficiario, razon_social_proveedor;
				
				--tipo de movimiento tesoreria=Transferencia
				IF str_data[9]::integer=3 THEN 
					referencia_transferencia:=str_data[13];
				ELSE
					referencia_transferencia:='';
				END IF;
				
				
				IF str_data[9]::integer=2 OR str_data[9]::integer=3 THEN
					INSERT INTO tes_mov(
						  tes_che_id,--str_data[11]::integer
						  ano,--ano_actual
						  mes,--mes_actual
						  consecutivo_cheque,--nuevo_consecutivo_cheque
						  tes_mov_tipo_id,--str_data[9]::integer
						  tes_con_id,--str_data[17]::integer
						  gral_suc_id,--suc_id
						  beneficiario_id,--id_beneficiario
						  nombre_beneficiario,--razon_social_proveedor
						  tipo_beneficiario,--(Cliente=1,  Proveedor=2,  Trabajador = 3) 
						  cantidad,--str_data[15]::double precision
						  observacion,--str_data[16],
						  referencia, --referencia_transferencia
						  fecha_emision,--str_data[6]::timestamp with time zone,
						  cancelado,--false,
						  retenido,--false solo para cheques,
						  no_operado,--true,
						  conciliado,--true,
						  cant_letra,--str_data[18]
						  fecha_conciliado,--str_data[6]::timestamp with time zone,
						  sucursal_ctb,--suc_id
						  poliza,--es el numero de p√≥liza de contabilidad , Default= 0 
						  ref_num,--nuevo_consecutivo_cheque,
						  gral_usr_id_captura,--usuario_ejecutor
						  fecha_captura,--espacio_tiempo_ejecucion
						  gral_mod_id,--1=modulo de proveedores
						  anticipo_proveedor,--false,
						  anticipo_cliente,--false,
						  obs_retenido,--''
						  referencia_transfer,--referencia_transferencia
						  obs_conciliado,--''
						  obs_cancela,--''
						  es_traspaso,--false,
						  cancelado_x_proc--false,
					)VALUES(
						  str_data[11]::integer,
						  ano_actual,
						  mes_actual,
						  nuevo_consecutivo_cheque,
						  str_data[9]::integer,
						  str_data[17]::integer,
						  suc_id,
						  id_beneficiario,
						  razon_social_proveedor,
						  1,--( Proveedor=1, Cliente=2, Trabajador = 3) 
						  str_data[15]::double precision,
						  str_data[16],
						  referencia_transferencia,
						  str_data[6]::timestamp with time zone,
						  false,
						  reten,
						  true,
						  true,
						  str_data[18],
						  str_data[6]::timestamp with time zone,
						  suc_id,
						  0 ,
						  nuevo_consecutivo_cheque,
						  usuario_ejecutor,
						  espacio_tiempo_ejecucion,
						  1,
						  false,
						  false,
						  '',
						  referencia_transferencia,
						  '',
						  '',
						  false,
						  false
					)RETURNING id INTO ultimo_tes_mov_id;
					
					--asigna id del ultimo cheque generado
					UPDATE cxp_pagos SET tes_mov_id=ultimo_tes_mov_id WHERE id=ultimo_id;
				END IF;
			END IF;--termina if salvar_registro
			
			valor_retorno:=valor_retorno||num_transaccion::character varying||'___'||ultimo_id;
		END IF;--termina nuevo pago
		
		
		IF command_selected = 'cancelacion' THEN
			UPDATE cxp_pagos SET cancelacion=TRUE,momento_cancelacion=espacio_tiempo_ejecucion,motivo_cancelacion=str_data[5],gral_usr_id_cancelacion=usuario_ejecutor
			WHERE id=str_data[4]::integer 
			RETURNING numero_transaccion,tes_mov_tipo_id, tes_mov_id, cxp_prov_id INTO num_transaccion, tipo_pago, ultimo_tes_mov_id, id_proveedor;
			
			UPDATE cxp_pagos_detalles SET cancelacion=TRUE,momento_cancelacion=espacio_tiempo_ejecucion,gral_usr_id_cancelacion=usuario_ejecutor
			WHERE cxp_pago_id=str_data[4]::integer;
			
			sql_select:='SELECT serie_folio	FROM cxp_pagos_detalles WHERE cxp_pago_id='||str_data[4];
			
			FOR pago_detalle IN EXECUTE(sql_select) LOOP
				--obtiene suma de pagos Cancelados para esta factura
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM(	SELECT sum(cxp_pagos_detalles.cantidad) FROM cxp_pagos JOIN cxp_pagos_detalles ON cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id WHERE cxp_pagos_detalles.serie_folio=pago_detalle.serie_folio AND cxp_pagos_detalles.cancelacion=TRUE AND cxp_pagos.cxp_prov_id=id_proveedor) AS sbt  
				INTO suma_pagos_cancelados;
				
				--obtiene suma de pagos para esta factura
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(cxp_pagos_detalles.cantidad) FROM cxp_pagos JOIN cxp_pagos_detalles ON cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id WHERE cxp_pagos_detalles.serie_folio=pago_detalle.serie_folio AND cxp_pagos_detalles.cancelacion=FALSE AND cxp_pagos.cxp_prov_id=id_proveedor ) AS sbt2  
				INTO suma_pagos;
				
				--obtiene suma de las notas de credito para esta factura
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(total) FROM cxp_nota_credito WHERE factura=pago_detalle.serie_folio AND cancelado=FALSE AND cxp_prov_id=id_proveedor ) AS sbt2
				INTO suma_notas_credito;
				
				UPDATE cxp_facturas SET 
					total_pagos=suma_pagos,
					total_notas_creditos=suma_notas_credito,
					pagado=FALSE,
					saldo_factura=round((monto_total - suma_pagos - suma_notas_credito)::numeric,2)::double precision,
					total_pagos_cancelados = suma_pagos_cancelados 
				WHERE serie_folio=pago_detalle.serie_folio AND cxc_prov_id=id_proveedor;

				
				-- 0=Nuevo, 1=Pago Parcial, 2=Pagado, 3=Cancelado
				UPDATE cxp_facturas SET total_pagos=suma_pagos, total_notas_creditos=suma_notas_credito, pagado=false, saldo_factura=round((monto_total - suma_pagos - suma_notas_credito)::numeric,2)::double precision
				WHERE serie_folio=pago_detalle.serie_folio AND cxc_prov_id=id_proveedor;

				select id, monto_total, saldo_factura from cxp_facturas where serie_folio=pago_detalle.serie_folio and cxc_prov_id=id_proveedor limit 1 into fila; 
				if fila.monto_total is null then fila.monto_total:=0; end if;
				if fila.saldo_factura is null then fila.saldo_factura:=0; end if;
				
				if fila.saldo_factura > 0 then 
					if fila.monto_total > fila.saldo_factura then 
						UPDATE cxp_facturas SET estatus=1  where id=fila.id; 
					end if;
					if fila.monto_total=fila.saldo_factura then 
						UPDATE cxp_facturas SET estatus=0  where id=fila.id; 
					end if;

					if fila.saldo_factura<=0.01 then 
						UPDATE cxp_facturas SET estatus=2  where id=fila.id; 
					end if;
				end if;
			END LOOP;
			
			IF tipo_pago=2 OR tipo_pago=3 THEN 
				--Cancela registro en tes_mov
				UPDATE tes_mov SET cancelado=TRUE, obs_cancela=str_data[5], gral_usr_id_cancela=usuario_ejecutor, fecha_cancela=espacio_tiempo_ejecucion 
				WHERE id = ultimo_tes_mov_id;
			END IF;
			
			valor_retorno:=num_transaccion::character varying;
			
		END IF;--termina cancelacion de pago
		
	END IF;--Termina Pagos a Proveedores
	
	
	
	


	
	-- Anticipos a Proveedores
	IF app_selected = 61 THEN
		IF command_selected = 'new' THEN
			tipo_movimiento_id:=2;--Anticipo a Proveedor
			ultimo_id:=0;
			salvar_registro:= TRUE;
			--se retorna false, si no hay error en el cheque
			valor_retorno:='false___';
			
			
			--anticipo con cheque
			IF str_data[10]::integer=2 THEN
				SELECT id,titulo FROM tes_che WHERE id=str_data[12]::integer INTO chequera;
				
				SELECT count(id) FROM tes_num_che WHERE tes_che_id=str_data[12]::integer INTO existe_registro;
				IF existe_registro > 0 THEN 
					
					SELECT (CASE WHEN consecutivo = consecutivo_final  THEN 'error_consecutivo' ELSE '' END ) error_num_cheque
					FROM tes_num_che WHERE tes_che_id = str_data[12]::integer INTO error_consecutivo;
					
					IF error_consecutivo <> 'error_consecutivo' THEN 
						UPDATE 	tes_num_che SET consecutivo=(
							SELECT sbt.consecutivo + 1  FROM tes_num_che AS sbt WHERE sbt.id=tes_num_che.id
						)
						WHERE tes_che_id=str_data[11]::integer  RETURNING consecutivo INTO nuevo_consecutivo_cheque;
					ELSE
						--se retorna esto, si hay error en el consecutivo del cheque
						valor_retorno:='Error en el consecutivo, no hay cheques disponibles.___';
						salvar_registro:= false;
					END IF;
				ELSE
					--se retorna este mensaje, cuando no hay registro en la tabla
					valor_retorno:='Falta registrar Consecutivo Inicial y Final para esta Chequera.___';
					salvar_registro:= false;
				END IF;
				reten:= false;
			END IF;
			
			--RAISE EXCEPTION '%' ,'valor_retorno:'||valor_retorno;
			IF salvar_registro=TRUE THEN
				
				--obtiene datos del parametro para la sucursal actual
				SELECT cxp_mov_tipo_id,incluye_iva,oc_requerida,gral_suc_id_consecutivo
				FROM cxp_ant_par 
				WHERE gral_suc_id=suc_id AND cxp_mov_tipo_id=tipo_movimiento_id AND borrado_logico=FALSE
				LIMIT 1 INTO parametro;
				
				--obtiene el id del tipo de consecutivo de la la tabla cxp_mov_tipos
				SELECT gral_cons_tipo_id FROM cxp_mov_tipos WHERE id=tipo_movimiento_id INTO id_tipo_consecutivo;
				
				--aqui se verifica si hay que tomar el consecutivo de una sucursal diferente a la actual
				IF parametro.gral_suc_id_consecutivo != 0 THEN
					--aqui entra para tomar el consecutivo de la  sucursal indicada en parametros, diferente a la actual
					UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
					WHERE gral_suc_id=parametro.gral_suc_id_consecutivo AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				ELSE
					--aqui entra para tomar el consecutivo de la sucursal actual
					UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
					WHERE gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				END IF;
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del anticipo
				nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
				
				
				--Obtener el id del impuesto asignado al proveedor
				SELECT cxp_prov.impuesto AS id_impuesto FROM cxp_prov WHERE cxp_prov.id=str_data[5]::integer INTO id_impuesto;
				IF id_impuesto <> 0 THEN
					SELECT iva_1 FROM gral_imptos WHERE id=id_impuesto INTO porcentaje_impuesto;
					cheque_iva:=str_data[7]::double precision * (porcentaje_impuesto/100::double precision);
					cheque_importe:=str_data[7]::double precision - cheque_iva;
				END IF;
				
				
				INSERT INTO cxp_ant(
					folio, --nuevo_folio
					cxp_prov_id, --str_data[5]::integer,
					cxp_mov_tipo_id, --tipo_movimiento_id,
					tes_mov_tipo_id,--str_data[10]::integer
					referencia, --str_data[13],
					moneda_id, --str_data[6]::integer,
					tipo_cambio, --str_data[16]::double precision,
					cantidad, --str_data[7]::double precision,
					aplicado,--0,
					cancelado,--false,
					fecha_anticipo, --str_data[8]::timestamp with time zone,
					tes_che_id, --str_data[12]::integer,
					tes_ban_id, --str_data[11]::integer,
					ref_che,--'',
					ref_num,--nuevo_consecutivo_cheque,
					ano,--ano_actual,
					mes,--mes_actual,
					poliza,--DEFAULT 0,
					gral_suc_id_oc,--suc_id,
					tipo_mov_oc,--0,
					orden_compra,--'',
					iva_porcentaje,--porcentaje_impuesto,
					gral_impto_id,--id_impuesto,
					cuenta_anticipo,--'',
					incluye_iva,--true,
					moneda_cheque, --str_data[6]::integer,
					cantidad_cheque,--str_data[7]::double precision,
					importe_cheque,--cheque_importe,
					iva_cheque,--cheque_iva,
					observaciones,--str_data[9]
					momento_creacion, --espacio_tiempo_ejecucion,
					gral_usr_id_creacion, --usuario_ejecutor,
					gral_emp_id, --emp_id,
					gral_suc_id--suc_id
				)VALUES(
					nuevo_folio,
					str_data[5]::integer,
					tipo_movimiento_id,
					str_data[10]::integer,
					str_data[13],
					str_data[6]::integer,
					str_data[16]::double precision,
					str_data[7]::double precision,
					0,
					false,
					str_data[8]::timestamp with time zone,
					str_data[12]::integer,
					str_data[11]::integer,
					'',
					nuevo_consecutivo_cheque,
					ano_actual,
					mes_actual,
					0,
					suc_id,
					0,
					'',
					porcentaje_impuesto,
					id_impuesto,
					'',
					true,
					str_data[6]::integer,
					str_data[7]::double precision,
					cheque_importe,
					cheque_iva,
					str_data[9],
					espacio_tiempo_ejecucion,
					usuario_ejecutor,
					emp_id,
					suc_id
				)RETURNING id INTO ultimo_id;
				
				SELECT id, razon_social FROM cxp_prov WHERE id=str_data[5]::integer INTO id_beneficiario, razon_social_proveedor;
				
				--tipo de movimiento tesoreria=Transferencia
				IF str_data[10]::integer=3 THEN 
					referencia_transferencia:=str_data[13];
				ELSE
					referencia_transferencia:='';
				END IF;
				
				IF str_data[10]::integer=2 OR str_data[10]::integer=3 THEN
					INSERT INTO tes_mov(
						  tes_che_id,--str_data[12]::integer
						  ano,--ano_actual
						  mes,--mes_actual
						  consecutivo_cheque,--nuevo_consecutivo_cheque
						  tes_mov_tipo_id,--str_data[10]::integer
						  tes_con_id,--str_data[14]::integer
						  gral_suc_id,--suc_id
						  beneficiario_id,--id_beneficiario
						  nombre_beneficiario,--razon_social_proveedor
						  tipo_beneficiario,--( Proveedor=1, Cliente=2, Trabajador = 3) 
						  cantidad,--str_data[7]::double precision
						  observacion,--str_data[9],
						  referencia, --referencia_transferencia
						  fecha_emision,--str_data[8]::timestamp with time zone,
						  cancelado,--false,
						  retenido,--false solo para cheques,
						  no_operado,--true,
						  conciliado,--true,
						  cant_letra,--str_data[17]
						  fecha_conciliado,--str_data[8]::timestamp with time zone,
						  sucursal_ctb,--suc_id
						  poliza,--es el numero de p√≥liza de contabilidad , Default= 0 
						  ref_num,--nuevo_consecutivo_cheque,
						  gral_usr_id_captura,--usuario_ejecutor
						  fecha_captura,--espacio_tiempo_ejecucion
						  gral_mod_id,--1=modulo de proveedores
						  anticipo_proveedor,--true,
						  anticipo_cliente,--false,
						  obs_retenido,--''
						  referencia_transfer,--referencia_transferencia
						  obs_conciliado,--''
						  obs_cancela,--''
						  es_traspaso,--false,
						  cancelado_x_proc--false,
					)VALUES(
						  str_data[12]::integer,
						  ano_actual,
						  mes_actual,
						  nuevo_consecutivo_cheque,
						  str_data[10]::integer,
						  str_data[14]::integer,
						  suc_id,
						  id_beneficiario,
						  razon_social_proveedor,
						  1,--( Proveedor=1, Cliente=2, Trabajador = 3)
						  str_data[7]::double precision,
						  str_data[9],
						  referencia_transferencia,
						  str_data[8]::timestamp with time zone,
						  false,
						  false,
						  true,
						  true,
						  str_data[17],
						  str_data[8]::timestamp with time zone,
						  suc_id,
						  0 ,
						  nuevo_consecutivo_cheque,
						  usuario_ejecutor,
						  espacio_tiempo_ejecucion,
						  1,
						  true,
						  false,
						  '',
						  referencia_transferencia,
						  '',
						  '',
						  false,
						  false 
					)RETURNING id INTO ultimo_tes_mov_id;
					
					--asigna id del ultimo cheque generado
					UPDATE cxp_ant SET tes_mov_id=ultimo_tes_mov_id WHERE id=ultimo_id;
				END IF;
			END IF;--termina if salvar_registro
			
			valor_retorno:=valor_retorno||num_transaccion::character varying||'___'||ultimo_id;
		END IF;--termina nuevo pago
		
		
		IF command_selected = 'cancelacion' THEN
			UPDATE cxp_ant SET cancelado=TRUE,momento_cancelacion=espacio_tiempo_ejecucion,motivo_cancelacion=str_data[5],gral_usr_id_cancelacion=usuario_ejecutor
			WHERE id=str_data[4]::integer RETURNING folio,tes_mov_tipo_id INTO num_transaccion, tipo_pago;

			--sql_select:='SELECT serie_folio	FROM cxp_ant WHERE tes_mov_id='||str_data[4];
			
			IF tipo_pago=2 OR tipo_pago=3 THEN 
				--Cancela registro en tes_mov
				UPDATE tes_mov SET 
					cancelado=TRUE,
					obs_cancela=str_data[5],
					gral_usr_id_cancela=usuario_ejecutor,
					fecha_cancela=espacio_tiempo_ejecucion
				--WHERE cxp_pago_id = str_data[4]::integer;
				--WHERE id = str_data[4]::integer;
				WHERE id = ultimo_tes_mov_id;
			END IF;
			
			valor_retorno:=num_transaccion::character varying;
		END IF;--termina cancelacion de anticipos
		
	END IF;--Termina Registro de Anticipo a Proveedores	
	

	
	-- aplicativo Parametros de Anticipos de Proveedor
	IF app_selected = 62 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	identificador
			--str_data[5]	select_sucursal
			--str_data[6]	select_anticipo
			--str_data[7]	elect_apl_anticipo
			--str_data[8]	select_apl_factura
			--str_data[9]	select_cacelacion
			--str_data[10]	select_incluye_iva
			--str_data[11]	check_requiere_oc
			--str_data[12]	consecutivo_sucursal
			
			INSERT INTO cxp_ant_par(
				gral_suc_id, --str_data[5]::integer,
				cxp_mov_tipo_id, --str_data[6]::integer,
				cxp_mov_tipo_id_apl_ant, --str_data[7]::integer,
				cxp_mov_tipo_id_apl_fac, --str_data[8]::integer,
				cxp_mov_tipo_id_can, --str_data[9]::integer,
				incluye_iva, --str_data[10]::boolean,
				oc_requerida, --str_data[11]::boolean,
				gral_suc_id_consecutivo, --str_data[12]::integer
				borrado_logico, --false,
				momento_creacion, --now(),
				gral_usr_id_creacion, --usuario_id,
				gral_emp_id--emp_id
			) VALUES (
				str_data[5]::integer,
				str_data[6]::integer,
				str_data[7]::integer,
				str_data[8]::integer,
				str_data[9]::integer,
				str_data[10]::boolean,
				str_data[11]::boolean,
				str_data[12]::integer,
				false,
				now(),
				usuario_ejecutor,
				emp_id
			);
			valor_retorno := '1';
		END IF;
		
		
                IF command_selected = 'edit' THEN
                        UPDATE cxp_ant_par SET 
				cxp_mov_tipo_id=str_data[6]::integer,
				cxp_mov_tipo_id_apl_ant=str_data[7]::integer,
				cxp_mov_tipo_id_apl_fac=str_data[8]::integer,
				cxp_mov_tipo_id_can=str_data[9]::integer,
				incluye_iva=str_data[10]::boolean,
				oc_requerida=str_data[11]::boolean,
				gral_suc_id_consecutivo=str_data[12]::integer,
				momento_actualizacion=now(),
				gral_usr_id_actualizacion = usuario_ejecutor
                        WHERE cxp_ant_par.id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
		
                
                IF command_selected = 'delete' THEN
                         UPDATE cxp_ant_par SET momento_baja=now(), borrado_logico=true, gral_usr_id_baja=usuario_ejecutor
                         WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
        END IF;
        --termina Aplicativo Parametros de Anticipos de Proveedor
	
	
	
	
	
	-- aplicativo Notas de Credito a Proveedores
	IF app_selected = 101 THEN
		IF command_selected = 'new' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_nota_credito
			--str_data[5]	id_proveedor
			--str_data[6]	id_impuesto
			--str_data[7]	valor_impuesto
			--str_data[8]	observaciones.toUpperCase()
			--str_data[9]	select_moneda
			--str_data[10]	concepto.toUpperCase()
			--str_data[11]	tipo_cambio
			--str_data[12]	importe
			--str_data[13]	impuesto
			--str_data[14]	total
			--str_data[15]	factura
			--str_data[16]	fac_saldado
			--str_data[17]	folio_nota_credito
			--str_data[18]	fecha_expedicion
			--str_data[19]	select_tipo_nota
			
			id_tipo_consecutivo:=28;--Folio registro Notas de Credito Proveedores
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			
			INSERT INTO cxp_nota_credito(
				folio,--nuevo_folio,
				cxp_prov_id,--str_data[5]::integer,
				gral_impto_id,--str_data[6]::integer,
				valor_impuesto,--str_data[7]::double precision,
				observaciones,--str_data[8],
				moneda_id,--str_data[9]::integer,
				concepto,--str_data[10],
				tipo_cambio,--str_data[11]::double precision,
				subtotal,--str_data[12]::double precision,
				impuesto,--str_data[13]::double precision,
				total,--str_data[14]::double precision,
				factura,--str_data[15],
				serie_folio,--str_data[17],
				fecha_expedicion,--str_data[18]::date,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion,--usuario_ejecutor,
				gral_emp_id,--emp_id,
				gral_suc_id,--suc_id,
				gral_app_id_creacion,--app_selected
				tipo--str_data[19]::smallint
			) VALUES (nuevo_folio,str_data[5]::integer,str_data[6]::integer,str_data[7]::double precision,str_data[8],str_data[9]::integer,str_data[10],str_data[11]::double precision,str_data[12]::double precision,str_data[13]::double precision,str_data[14]::double precision,str_data[15],str_data[17],str_data[18]::date,espacio_tiempo_ejecucion,usuario_ejecutor,emp_id,suc_id,app_selected, str_data[19]::smallint);
			
			
			
			--***************************************************************************************************************************
			--INICIA CALCULO DE NUEVO SALDO DE LA FACTURA
			--***************************************************************************************************************************
			
			--obtiene suma de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(cxp_pagos_detalles.cantidad) FROM cxp_pagos JOIN cxp_pagos_detalles ON cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id WHERE cxp_pagos_detalles.serie_folio=str_data[15] AND cxp_pagos_detalles.cancelacion=FALSE AND cxp_pagos.cxp_prov_id=str_data[5]::integer ) AS sbt  
			INTO suma_pagos;
			
			--obtiene suma de las notas de credito para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(total) FROM cxp_nota_credito WHERE factura=str_data[15] AND cancelado=FALSE AND cxp_prov_id=str_data[5]::integer ) AS sbt2
			INTO suma_notas_credito;
			
			SELECT saldo_factura  FROM cxp_facturas WHERE serie_folio=str_data[15] AND cxc_prov_id=str_data[5]::integer INTO saldo_fac_prov;
			
			saldo_fac_prov := round((saldo_fac_prov)::numeric,2);
			
			-- 0=Nuevo, 1=Pago Parcial, 2=Pagado, 3=Cancelado
			
			--actualiza pagos de la factura
			IF str_data[14]::double precision < saldo_fac_prov THEN
				--RAISE EXCEPTION '%' ,'Pagado: false '||saldo_fac_prov;
				UPDATE cxp_facturas SET 
					estatus=1,
					total_pagos=suma_pagos, total_notas_creditos=suma_notas_credito, pagado=false, 
					saldo_factura=round((monto_total - suma_pagos - suma_notas_credito)::numeric,2)::double precision
				WHERE serie_folio=str_data[15] AND cxc_prov_id=str_data[5]::integer;
			ELSE
				--RAISE EXCEPTION '%' ,'Pagado: true '||saldo_fac_prov;
				UPDATE cxp_facturas SET estatus=2,total_pagos=suma_pagos, total_notas_creditos=suma_notas_credito, pagado=true, saldo_factura=0 
				WHERE serie_folio=str_data[15] AND cxc_prov_id=str_data[5]::integer;
			END IF;
			
			--TERMINA CALCULO DE SALDO DE LA FACTURA
			--***************************************************************************************************************************
			
			
			valor_retorno := '1';
		END IF;

		
		
		
		
                
                IF command_selected = 'cancelacion' THEN
                        UPDATE cxp_nota_credito SET motivo_cancelacion=str_data[5], cancelado=true, momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancelacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer RETURNING cxp_prov_id,factura INTO id_proveedor,factura_prov;
			
			--obtiene suma de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(cxp_pagos_detalles.cantidad) FROM cxp_pagos JOIN cxp_pagos_detalles ON cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id WHERE cxp_pagos_detalles.serie_folio=factura_prov AND cxp_pagos_detalles.cancelacion=FALSE AND cxp_pagos.cxp_prov_id=id_proveedor ) AS sbt  
			INTO suma_pagos;
			
			--obtiene suma de las notas de credito para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(total) FROM cxp_nota_credito WHERE factura=factura_prov AND cancelado=FALSE AND cxp_prov_id=id_proveedor ) AS sbt2
			INTO suma_notas_credito;
			
			UPDATE cxp_facturas SET total_pagos=suma_pagos, total_notas_creditos=suma_notas_credito, pagado=false, saldo_factura=round((monto_total - suma_pagos - suma_notas_credito)::numeric,2)::double precision
			WHERE serie_folio=factura_prov AND cxc_prov_id=id_proveedor;

			select id, monto_total, saldo_factura from cxp_facturas where serie_folio=factura_prov and cxc_prov_id=id_proveedor limit 1 into fila; 
			if fila.monto_total is null then fila.monto_total:=0; end if;
			if fila.saldo_factura is null then fila.saldo_factura:=0; end if;

			-- 0=Nuevo, 1=Pago Parcial, 2=Pagado, 3=Cancelado
			if fila.saldo_factura > 0 then 
				if fila.monto_total > fila.saldo_factura then 
					UPDATE cxp_facturas SET estatus=1  where id=fila.id; 
				end if;
				if fila.monto_total=fila.saldo_factura then 
					UPDATE cxp_facturas SET estatus=0  where id=fila.id; 
				end if;

				if fila.saldo_factura<=0.01 then 
					UPDATE cxp_facturas SET estatus=2  where id=fila.id; 
				end if;
			end if;
			
			valor_retorno := '1';
                END IF;
		
                
        END IF;
        --Termina Aplicativo Notas de Credito a Proveedores
	
	
	
        

	

	
	-- Facturas de proveedores version 2 para Logistik
	IF app_selected = 196 THEN
		
		IF command_selected = 'new' THEN
			
			SELECT dias FROM cxp_prov_credias WHERE id= str_data[15]::integer INTO numero_dias_credito;
			
			--calcula la fecha de vencimiento a partir de la fecha de la factura
			SELECT (to_char(str_data[9]::timestamp with time zone,'yyyy-mm-dd')::DATE + numero_dias_credito)::timestamp with time zone AS fecha_vencimiento INTO fecha_de_vencimiento;
			
			IF str_data[11]::integer=1 THEN 
				tip_cam:=1;
			ELSE
				tip_cam:=str_data[10]::double precision;
			END IF;
			
			
			INSERT INTO cxp_facturas(
				tipo_factura_proveedor, --str_data[6]::integer
				  cxc_prov_id, --str_data[5]::integer
				  serie_folio, --str_data[8]
				  flete, --str_data[16]::double precision,
				  tipo_cambio, --str_data[10]::double precision,
				  fecha_factura,  --str_data[9]::timestamp with time zone,
				  momento_creacion,--espacio_tiempo_ejecucion,
				  numero_guia,--str_data[12]
				  orden_compra,--str_data[13]
				  observaciones,--str_data[7]
				  moneda_id, --str_data[11]::integer
				  fletera_id, --str_data[14]::integer
				  dias_credito_id, --str_data[15]::integer
				  fecha_vencimiento,--fecha_de_vencimiento
				  id_usuario_creacion,--usuario_ejecutor
				  empresa_id, --emp_id
				  sucursal_id--suc_id
			) 
			VALUES(str_data[6]::integer,str_data[5]::integer,str_data[8],str_data[16]::double precision,tip_cam ,str_data[9]::timestamp with time zone,espacio_tiempo_ejecucion,str_data[12],str_data[13],str_data[7],str_data[11]::integer,str_data[14]::integer,str_data[15]::integer,fecha_de_vencimiento,usuario_ejecutor,emp_id,suc_id)
			RETURNING id INTO ultimo_id;

			subtotal_factura := 0;
			suma_ieps := 0;
			suma_impuesto := 0;
			suma_retencion := 0;
			importe_isr := 0;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	eliminado[i]
				--str_filas[2]	det_id[i]
				--str_filas[3]	prod_id[i]
				--str_filas[4]	pres_id[i]
				--str_filas[5]	cantidad[i]
				--str_filas[6]	costo[i]
				--str_filas[7]	select_iva[i]
				--str_filas[8]	iva_tasa[i]
				--str_filas[9]	select_ieps[i]
				--str_filas[10]	ieps_tasa[i]
				--str_filas[11]	ret_id[i]
				--str_filas[12]	ret_tasa[i]
				
				--costo y canidad no son vacias, se agrega el registro
				IF str_filas[1]::integer<>0 THEN
					--inicializamos valor_impuesto para cada producto del grid
					valor_impuesto:=str_filas[8]::double precision;
					importe:=0.0;
					importe_ieps_partida:=0.0;
					impuesto_partida:=0.0;
					retencion_partida:=0.0;
					
					select inv_prod.sku as prod_codigo, inv_prod.descripcion as prod_descripcion, (case when inv_prod_unidades.titulo is null then '' else inv_prod_unidades.titulo end) as unidad, (case when inv_pres.titulo is null then '' else inv_pres.titulo end) as presentacion 
					from inv_prod 
					left join inv_prod_pres_x_prod on (inv_prod_pres_x_prod.producto_id=inv_prod.id and inv_prod_pres_x_prod.presentacion_id=str_filas[4]::integer)
					left join inv_prod_presentaciones as inv_pres on inv_pres.id=inv_prod_pres_x_prod.presentacion_id 
					left join inv_prod_unidades on inv_prod_unidades.id=inv_prod.unidad_id 
					where inv_prod.id=str_filas[3]::integer 
					into fila;

					if fila.prod_codigo is null then fila.prod_codigo:=''; end if;
					if fila.prod_descripcion is null then fila.prod_descripcion:=''; end if;
					if fila.unidad is null then fila.unidad:=''; end if;
					if fila.presentacion is null then fila.presentacion:=''; end if;
					
					insert into cxp_facturas_detalle(
						cxp_facturas_id, --ultimo_id,
						inv_prod_id, --str_filas[3]::integer, 
						inv_prod_pres_id, --str_filas[4]::integer, 
						codigo_producto, --fila.prod_codigo,
						descripcion, --fila.prod_descripcion,
						unidad_medida, --fila.unidad,
						presentacion, --fila.presentacion,
						cantidad, --str_filas[5]::double precision, 
						costo_unitario, --str_filas[6]::double precision, 
						gral_imp_id, --str_filas[7]::integer, 
						valor_imp, --str_filas[8]::double precision,
						gral_ieps_id, --str_filas[9]::integer, 
						valor_ieps, --str_filas[10]::double precision, 
						gral_imptos_ret_id, --str_filas[11]::integer, 
						tasa_ret  --str_filas[12]::double precision 
					)
					values(ultimo_id, str_filas[3]::integer, str_filas[4]::integer, fila.prod_codigo,fila.prod_descripcion,fila.unidad,fila.presentacion, str_filas[5]::double precision, str_filas[6]::double precision, str_filas[7]::integer, str_filas[8]::double precision, str_filas[9]::integer, str_filas[10]::double precision, str_filas[11]::integer, str_filas[12]::double precision);
					
					importe := round((str_filas[5]::double precision * str_filas[6]::double precision)::numeric,4)::double precision;
					
					--Calcular el importe del IEPS de la partida
					importe_ieps_partida := round((importe * str_filas[10]::double precision)::numeric, 4)::double precision;
					
					--Calcular el impuesto de la Partida
					impuesto_partida = round(((importe + importe_ieps_partida::double precision) * valor_impuesto)::numeric,4)::double precision;

					if str_filas[12]::double precision>0 then 
						retencion_partida := round((importe * str_filas[12]::double precision)::numeric, 4)::double precision;
					end if;
					
					--Acumular montos
					subtotal_factura := subtotal_factura + importe::double precision;
					suma_ieps := suma_ieps + importe_ieps_partida::double precision;
					suma_impuesto := suma_impuesto + impuesto_partida::double precision;
					suma_retencion := suma_retencion + retencion_partida::double precision;
				END IF;
			END LOOP;
			
			
			--2=Factura de Proveedor de Servicios u Honorarios
			IF str_data[6]::integer = 2 THEN
				--Calcular la Retencion del IVA
				total_retencion = (suma_impuesto::double precision / 3) * 2;
				
				--Calcular el ISR
				importe_isr = subtotal_factura * 0.10;
			else
				total_retencion := suma_retencion;
			END IF;
			
			--Calcular el total
			total_factura := subtotal_factura + suma_ieps::double precision + suma_impuesto::double precision - total_retencion::double precision - importe_isr;
			
			--Actualiza cxp_facturas para guardar totales
			UPDATE cxp_facturas SET monto_total=round((total_factura)::numeric,2)::double precision, saldo_factura=round((total_factura)::numeric,2)::double precision, subtotal=round((subtotal_factura)::numeric,2)::double precision, monto_ieps=round((suma_ieps)::numeric,2)::double precision, iva=round((suma_impuesto)::numeric,2)::double precision, retencion=round((total_retencion)::numeric,2)::double precision, monto_ret_isr=round((importe_isr)::numeric,2)::double precision 
			WHERE id=ultimo_id;
			valor_retorno := '1';
		END IF;--termina nueva factura
		
		
		
		
		IF command_selected = 'edit' THEN
			
			SELECT dias FROM cxp_prov_credias WHERE id= str_data[15]::integer INTO numero_dias_credito;
			
			SELECT (to_char(espacio_tiempo_ejecucion,'yyyy-mm-dd')::DATE + numero_dias_credito)::timestamp with time zone AS fecha_vencimiento INTO fecha_de_vencimiento;
			
			IF str_data[11]::integer=1 THEN 
				tip_cam:=1;
			ELSE
				tip_cam:=str_data[10]::double precision;
			END IF;
			
			UPDATE cxp_facturas SET serie_folio=str_data[8], flete=str_data[16]::double precision, tipo_cambio=tip_cam, fecha_factura=str_data[9]::timestamp with time zone, numero_guia=str_data[12], orden_compra=str_data[13], observaciones=str_data[7], moneda_id=str_data[11]::integer, fletera_id=str_data[14]::integer, dias_credito_id=str_data[15]::integer, fecha_vencimiento=fecha_de_vencimiento, momento_actualizacion=espacio_tiempo_ejecucion, id_usuario_actualizacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer;
			
			
			--en este ciclo se vuelven a crear los registros en detalles
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	eliminado[i]
				--str_filas[2]	det_id[i]
				--str_filas[3]	prod_id[i]
				--str_filas[4]	pres_id[i]
				--str_filas[5]	cantidad[i]
				--str_filas[6]	costo[i]
				--str_filas[7]	select_iva[i]
				--str_filas[8]	iva_tasa[i]
				--str_filas[9]	select_ieps[i]
				--str_filas[10]	ieps_tasa[i]
				--str_filas[11]	ret_id[i]
				--str_filas[12]	ret_tasa[i]
				
				--costo y canidad no son vacias, se agrega el registro
				IF str_filas[1]::integer<>0 THEN 
					--inicializamos valor_impuesto para cada producto del grid
					valor_impuesto:=str_filas[8]::double precision;
					importe:=0.0;
					importe_ieps_partida:=0.0;
					impuesto_partida:=0.0;
					retencion_partida:=0.0;
					
					--Aqui entra para crear nuevo registro
					select inv_prod.sku as prod_codigo, inv_prod.descripcion as prod_descripcion, (case when inv_prod_unidades.titulo is null then '' else inv_prod_unidades.titulo end) as unidad, (case when inv_pres.titulo is null then '' else inv_pres.titulo end) as presentacion 
					from inv_prod 
					left join inv_prod_pres_x_prod on (inv_prod_pres_x_prod.producto_id=inv_prod.id and inv_prod_pres_x_prod.presentacion_id=str_filas[4]::integer)
					left join inv_prod_presentaciones as inv_pres on inv_pres.id=inv_prod_pres_x_prod.presentacion_id 
					left join inv_prod_unidades on inv_prod_unidades.id=inv_prod.unidad_id 
					where inv_prod.id=str_filas[3]::integer 
					into fila;
					
					if fila.prod_codigo is null then fila.prod_codigo:=''; end if;
					if fila.prod_descripcion is null then fila.prod_descripcion:=''; end if;
					if fila.unidad is null then fila.unidad:=''; end if;
					if fila.presentacion is null then fila.presentacion:=''; end if;
					
					if str_filas[2]::integer>0 then 
						--Aqui entra para actualizar un registro
						update cxp_facturas_detalle SET inv_prod_id=str_filas[3]::integer, inv_prod_pres_id=str_filas[4]::integer, codigo_producto=fila.prod_codigo,descripcion=fila.prod_descripcion,unidad_medida=fila.unidad, presentacion=fila.presentacion,cantidad=str_filas[5]::double precision, costo_unitario=str_filas[6]::double precision, gral_imp_id=str_filas[7]::integer, valor_imp=str_filas[8]::double precision,gral_ieps_id=str_filas[9]::integer, valor_ieps=str_filas[10]::double precision, gral_imptos_ret_id=str_filas[11]::integer, tasa_ret=str_filas[12]::double precision 
						where id=str_filas[2]::integer;
					else
						--Aqui entra para crear nuevo registro
						insert into cxp_facturas_detalle(cxp_facturas_id, inv_prod_id, inv_prod_pres_id, codigo_producto, descripcion, unidad_medida, presentacion, cantidad, costo_unitario, gral_imp_id, valor_imp, gral_ieps_id,valor_ieps,gral_imptos_ret_id, tasa_ret)
						values(str_data[4]::integer, str_filas[3]::integer, str_filas[4]::integer, fila.prod_codigo,fila.prod_descripcion,fila.unidad,fila.presentacion, str_filas[5]::double precision, str_filas[6]::double precision, str_filas[7]::integer, str_filas[8]::double precision, str_filas[9]::integer, str_filas[10]::double precision, str_filas[11]::integer, str_filas[12]::double precision);
					end if;
					
					importe := round((str_filas[5]::double precision * str_filas[6]::double precision)::numeric,4)::double precision;
					
					--Calcular el importe del IEPS de la partida
					importe_ieps_partida := round((importe * str_filas[10]::double precision)::numeric, 4)::double precision;
					
					--Calcular el impuesto de la Partida
					impuesto_partida = round(((importe + importe_ieps_partida::double precision) * valor_impuesto)::numeric,4)::double precision;
					
					if str_filas[12]::double precision>0 then 
						retencion_partida := round((importe * str_filas[12]::double precision)::numeric, 4)::double precision;
					end if;
					
					--Acumular montos
					subtotal_factura := subtotal_factura + importe::double precision;
					suma_ieps := suma_ieps + importe_ieps_partida::double precision;
					suma_impuesto := suma_impuesto + impuesto_partida::double precision;
					suma_retencion := suma_retencion + retencion_partida::double precision;
				else
					if str_filas[2]::integer>0 then 
						delete from cxp_facturas_detalle where id=str_filas[2]::integer;
					end if;
				END IF;
			END LOOP;
			
			--2=Factura de Proveedor de Servicios u Honorarios
			IF str_data[6]::integer = 2 THEN
				--Calcular la Retencion del IVA
				total_retencion = (suma_impuesto::double precision / 3) * 2;
				
				--Calcular el ISR
				importe_isr = subtotal_factura * 0.10;
			else
				total_retencion := suma_retencion;
			END IF;
			
			
			--Calcular el total
			total_factura := subtotal_factura + suma_ieps::double precision + suma_impuesto::double precision - total_retencion::double precision - importe_isr;
			
			--Actualiza cxp_facturas para guardar totales
			UPDATE cxp_facturas SET monto_total=round((total_factura)::numeric,2)::double precision, saldo_factura=round((total_factura)::numeric,2)::double precision, subtotal=round((subtotal_factura)::numeric,2)::double precision, monto_ieps=round((suma_ieps)::numeric,2)::double precision, iva=round((suma_impuesto)::numeric,2)::double precision, retencion=round((total_retencion)::numeric,2)::double precision, monto_ret_isr=round((importe_isr)::numeric,2)::double precision  
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;--termina editar factura
		
		IF command_selected = 'cancelar' THEN
			-- 0=Nuevo, 1=Pago Parcial, 2=Pagado, 3=Cancelado
			
			UPDATE cxp_facturas SET estatus=3, cancelacion=true, momento_cancelacion=espacio_tiempo_ejecucion, id_usuario_cancelacion=usuario_ejecutor, cxp_tipo_cancelacion_id=1, motivo_cancelacion=str_data[6] 
			WHERE id=str_data[4]::integer;
			valor_retorno := 'true';
		END IF;
		
	END IF;
	--Termina facturas de proveedores version 2 para Logistik

	
	
	
	
	
	
	
	
	
	RETURN valor_retorno; 

END;
$$;


--
-- Name: cxp_reporte_saldo_mensual(integer, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.cxp_reporte_saldo_mensual(tipo integer, proveedor character varying, fecha character varying, id_empresa integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
	
	fila record;
	fila2 record;
	returnrecord record;
	cadena_sql character varying;
	cadena_sql2 character varying;
	cadena_where character varying;
	incluir_registro boolean;
	suma_pagos double precision;
	
BEGIN
	
	BEGIN 
		--Crear tabla temporal
		CREATE TEMPORARY TABLE tmprecord (
			id_proveedor integer,
			proveedor character varying,
			factura character varying,
			fecha_factura character varying,
			moneda_id integer,
			moneda_abr character varying,
			moneda_simbolo character varying,
			orden_compra character varying,
			monto_total double precision,
			importe_pagado double precision,
			saldo_factura double precision
		);
		EXCEPTION WHEN OTHERS THEN
		TRUNCATE TABLE tmprecord; -- TRUNCATE if the table already exists within the session.
	END;
	


	cadena_where:='';
	IF tipo=1 THEN 
		cadena_where:= 'AND cxp_prov.razon_social ILIKE ''%'||proveedor||'%''';
	END IF;
	
	/*
	Obtener listado de facturas tomando en cuenta las siguientes condiciones:
	--Que hayan sido generadas en el mes y antes del mes indicado en el parametro fecha
	--Que la fecha del ultimo pago sea mayor al mes indicado en el parametro fecha o que el campo sea null
	--Que la fecha de cancelacion sea mayor al mes indicado en el parametro fecha o que el campo sea null
	*/
	cadena_sql:='
	SELECT  
		cxp_prov.id AS id_proveedor, 
		cxp_prov.razon_social AS proveedor,
		cxp_facturas.serie_folio, 
		to_char(cxp_facturas.fecha_factura,''dd/mm/yyyy'') as fecha_factura, 
		cxp_facturas.moneda_id,
		gral_mon.descripcion_abr AS moneda_abr, 
		gral_mon.simbolo AS moneda_simbolo,
		cxp_facturas.orden_compra, 
		cxp_facturas.monto_total, 
		(cxp_facturas.total_pagos + cxp_facturas.total_notas_creditos) AS importe_pagado, 
		cxp_facturas.saldo_factura, 
		cxp_facturas.pagado,
		cxp_facturas.fecha_ultimo_pago,
		cxp_facturas.cancelacion,
		cxp_facturas.momento_cancelacion 
	FROM cxp_facturas 
	JOIN cxp_prov ON cxp_prov.id = cxp_facturas.cxc_prov_id 
	JOIN gral_mon ON gral_mon.id = cxp_facturas.moneda_id 
	WHERE cxp_facturas.empresa_id='||id_empresa||' '||cadena_where||' 
	AND cxp_facturas.fecha_factura <= '''||fecha||'''::timestamp with time zone
	AND (cxp_facturas.fecha_ultimo_pago > '''||fecha||'''::timestamp with time zone OR cxp_facturas.fecha_ultimo_pago IS NULL)
	AND (cxp_facturas.momento_cancelacion > '''||fecha||'''::timestamp with time zone OR cxp_facturas.momento_cancelacion IS NULL)
	ORDER BY cxp_prov.id, cxp_facturas.moneda_id, cxp_facturas.fecha_factura, cxp_facturas.serie_folio;';
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		incluir_registro:=false;
		suma_pagos:=0.0;
		
		IF fila.cancelacion THEN
			--Si esta cancelado, verificar que haya sido despues de la fecha ingresada como parametro
			IF fila.momento_cancelacion > fecha::timestamp with time zone THEN
				incluir_registro:=true;
			END IF;
		ELSE
			IF fila.pagado THEN
				--Si esta pagado, verificar que haya sido despues de la fecha que se le pasa como parametro
				IF fila.fecha_ultimo_pago > fecha::timestamp with time zone THEN
					incluir_registro:=true;
				END IF;
			ELSE
				incluir_registro:=true;
			END IF;
		END IF;
		
		IF incluir_registro THEN
			--Query para obtener suma de  Pagos y Notas de Credito aplicados a la Factura
			cadena_sql2:='
			SELECT sum(sum) AS pagos FROM (
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(cxp_pagos_detalles.cantidad) FROM cxp_pagos JOIN cxp_pagos_detalles ON cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id WHERE cxp_pagos_detalles.serie_folio='''||fila.serie_folio||''' AND cxp_pagos_detalles.cancelacion=FALSE AND cxp_pagos.cxp_prov_id='||fila.id_proveedor||' AND cxp_pagos.fecha_pago::timestamp with time zone > '''||fecha||'''::timestamp with time zone) AS sbt  
				UNION
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(total) FROM cxp_nota_credito WHERE factura='''||fila.serie_folio||''' AND cancelado=FALSE AND cxp_prov_id='||fila.id_proveedor||' AND fecha_expedicion::timestamp with time zone > '''||fecha||'''::timestamp with time zone) AS sbt2
			) AS sbt3';
			
			EXECUTE cadena_sql2 INTO suma_pagos;
			
			IF suma_pagos IS NULL THEN suma_pagos:=0; END IF;

			--Calcular el importe pagado a la antes de la fecha indicada en el parametro
			fila.importe_pagado := fila.importe_pagado::double precision - suma_pagos::double precision;
			
			--Obtener el saldo de la factura
			fila.saldo_factura := fila.monto_total::double precision - fila.importe_pagado::double precision;
			
			INSERT INTO tmprecord VALUES(fila.id_proveedor, fila.proveedor, fila.serie_folio, fila.fecha_factura, fila.moneda_id, fila.moneda_abr, fila.moneda_simbolo, fila.orden_compra, fila.monto_total, fila.importe_pagado, fila.saldo_factura);
		END IF;
	END LOOP;

	
	--Recorriendo la tabla temporal y retornando sus filas
	FOR returnrecord IN SELECT * FROM tmprecord LOOP
		RETURN NEXT returnrecord;
	END LOOP;
	
	
END

$$;


--
-- Name: env_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.env_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
--###################################
--Procedimiento para todos los Catalogos y Aplicativos del Modulo de Envasado


DECLARE
	app_selected integer;
	command_selected text;
	usuario_id integer;
	emp_id integer;
	suc_id integer;
	str_data text[];
	str_filas text[];
	valor_retorno character varying = ''; 
	iter_y integer;--contador de filas o posiciones del arreglo (iterador eje y del arreglo iterado)
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	ultimo_id integer =0;
	ultimo_id2 integer =0;
	ultimo_id_tras_env integer=0;--id del traspaso de MP de Envases
	ultimo_id2_tras_env integer=0;--id de la Orden de Traspaso de Envases

	id_tipo_movimiento integer = 0;
	id_tipo_consecutivo integer = 0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
	nuevo_folio2 character varying = '';
	id_mov_salida integer = 0;--Movimiento de Salida del producto a Re-Envasar
	id_mov_entrada  integer = 0;--Movimiento de Entrada del producto a Re-Envasar
	
	id_mov_salida_env integer = 0;--Id movimeinto de salida del envase
	id_mov_entrada_env integer = 0;--Id movimiento de entrada del envase
	id_mov_salida_mp integer = 0;--Id movimiento de Salida de MP del envase
	
	--variables para Re-Envasado
	noDecUnidad integer=0;--numero de decimales permitidos para la unidad
	exisActualPres double precision=0;--existencia actual de la presentacion
	equivalenciaPres double precision=0; --equivalencia de la presentacion en la unidad del producto
	cantPresAsignado double precision=0; --Cantidad de Presentacion Asignado para Re-Envasar
	cantUnidadFila double precision=0;
	sumaCantUnidad double precision=0;
	
	sql_select character varying = '';
	sql_select2 character varying = '';
	sql_update character varying = '';
	sql_insert character varying = '';
	fila record;
	fila_det record;
	fila_det_conf record;
	idAlmacen integer=0;
	idEnvConf integer=0;--id de la configuracion del envase
	
	costoUltimoActual double precision=0;
	exis integer=0;
	
	id_equipo integer=0;
	id_empleado integer=0;
	
BEGIN
	
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- aplicativo que manda a llamar este procedimiento almacenado
	app_selected := str_data[1]::integer;
	
	-- comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	-- usuario que utiliza el aplicativo
	usuario_id := str_data[3]::integer;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id;


	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	-- Aplicativo de Configuracion de Envasado
	IF app_selected = 136 THEN
		--str_data[4] 	identificador
		--str_data[5] 	producto_id
		--str_data[6] 	select_presentacion
  
		IF command_selected = 'new' THEN
			INSERT INTO env_conf(
				inv_prod_id,--str_data[5]::integer,
				inv_prod_presentacion_id, --str_data[6]::integer,
				borrado_logico,--false,
				gral_emp_id,--emp_id,
				gral_suc_id,--suc_id,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion --usuario_id
			)
			VALUES(str_data[5]::integer, str_data[6]::integer, false, emp_id, suc_id, espacio_tiempo_ejecucion, usuario_id) 
			RETURNING id INTO ultimo_id;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	eliminado
				--str_filas[2]	notr
				--str_filas[3]	iddetalle
				--str_filas[4]	idprod
				--str_filas[5]	cant
				
				IF str_filas[1]::integer=1 THEN 
					--aqui entra cuando el producto no ha sido eliminado del grid
					INSERT INTO env_conf_det(env_conf_id, inv_prod_id, cantidad) VALUES(ultimo_id, str_filas[4]::integer, str_filas[5]::double precision);
				END IF;
			END LOOP;
			
			valor_retorno := '1';
		END IF;--termina nuevo
		
		
		IF command_selected = 'edit' THEN
			UPDATE env_conf SET 
				inv_prod_id=str_data[5]::integer,
				inv_prod_presentacion_id=str_data[6]::integer,
				momento_actualizacion=espacio_tiempo_ejecucion,
				gral_usr_id_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	eliminado
				--str_filas[2]	notr
				--str_filas[3]	iddetalle
				--str_filas[4]	idprod
				--str_filas[5]	cant
				
				IF str_filas[1]::integer=1 THEN 
					--aqui entra cuando el producto no ha sido eliminado del grid
					IF str_filas[3]::integer!=0 THEN 
						--Aqui entra para actualizar un registro
						UPDATE env_conf_det SET cantidad=str_filas[5]::double precision WHERE id=str_filas[3]::integer;
					ELSE
						--aqui entra para crear un nuevo registro
						INSERT INTO env_conf_det(env_conf_id, inv_prod_id, cantidad) VALUES(str_data[4]::integer, str_filas[4]::integer, str_filas[5]::double precision);
					END IF;
				ELSE
					IF str_filas[3]::integer!=0 THEN 
						--Aqui eliminar un registro eliminado del Grid
						DELETE FROM env_conf_det WHERE id=str_filas[3]::integer;
					END IF;
				END IF;
			END LOOP;
			
			valor_retorno := '1';
		END IF;--termina editar


		IF command_selected = 'delete' THEN
			UPDATE env_conf SET  borrado_logico=true, momento_baja=espacio_tiempo_ejecucion, gral_usr_id_baja=usuario_id
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
	END IF;--Termina Aplicativo de Configuracion de Envasado
	


	-- Aplicativo de Proceso de Envasado
	IF app_selected = 137 THEN
		/*
		--str_data[4] identificador
		--str_data[5] select_estatus
		--str_data[6] fecha
		--str_data[7] hora
		--str_data[8] select_empleado
		--str_data[9] select_almacen_orig
		--str_data[10] producto_id
		--str_data[11] select_presentacion_orig
		*/
		--str_data[4] identificador
		--str_data[5] producto_id
		--str_data[6] produccion_id
		--str_data[7] fecha
		--str_data[8] hora
		--str_data[9] select_alm_orden_orig
		--str_data[10] select_pres_orden_orig
		--str_data[11] equipo
		--str_data[12] operador
		--str_data[13] merma
		--str_data[14] cantidad
		--str_data[15] estatus
		--buscar el numero de decimales de la unidad del producto
		SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
		WHERE inv_prod.id=str_data[5]::integer 
		INTO noDecUnidad;
		
		IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
		
		--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
		IF command_selected = 'new' THEN
			--id_tipo_movimiento:=1;--Traspaso por Envasado
			id_tipo_consecutivo:=43;--Folio Proceso de Envasado
			
			--aqui entra para tomar el consecutivo del pedido de la sucursal actual
			UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--suc_id_consecutivo
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			--RAISE EXCEPTION '%','valor_retorno: '||str_data[5];
			--buscar la existencia actual de la presentacion
			SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis FROM inv_exi_pres  
			WHERE inv_exi_pres.inv_alm_id=str_data[9]::integer AND inv_exi_pres.inv_prod_id=str_data[5]::integer AND inv_exi_pres.inv_prod_presentacion_id=str_data[10]::integer 
			INTO exisActualPres;
			IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
			
			--obtiene is de equipo
			select id from pro_equipos where titulo=str_data[11] 
			AND gral_emp_id=emp_id AND borrado_logico=false limit 1 INTO id_equipo;
			
			--ontiene id de ele empleado
			select id from gral_empleados where nombre_pila||' '||apellido_paterno||' '||apellido_materno=str_data[12]  
			AND gral_emp_id=emp_id AND borrado_logico=false limit 1 INTO id_empleado;
			
			IF id_equipo is null THEN id_equipo:=0; END IF;--Si no selecciono equipo, lo seta en cero
			IF id_empleado is null THEN id_empleado:=0; END IF;--Si no selecciono empleado, lo seta en cero
			
			--redondear la Existencia Actual de la Presentacion Origen
			exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;
			INSERT INTO env_env( 
			 folio,
			 inv_prod_id, -- 5
			 cantidad, -- 14
			 merma, -- 13
			 inv_prod_presentaciones_id, -- 10
			 pro_equipos_id, -- 11
			 gral_empleados_id, -- 12
			 fecha, -- 7
			 hora, -- 8
			 pro_orden_prod_id,--6
			 env_estatus_id,--15
			 inv_alm_id,--9
			 gral_emp_id, -- id de la empresa a la que pertenece este registro
			 gral_suc_id, -- id de la sucursal a la que pertenece este registro
			 borrado_logico,
			 momento_creacion, -- MOMENTO EN QUE SE CREO EL REGISTRO
			 gral_usr_id_creacion -- USUARIO QUE CREA EL REGISTRO
			) VALUES (
			nuevo_folio,
			str_data[5]::integer,
			str_data[14]::double precision,
			str_data[13]::double precision,
			str_data[10]::integer, -- 10
			 id_equipo, -- 11
			 id_empleado, -- 12
			str_data[7]::date, -- 7 fecha
			str_data[8]::time with time zone, -- 8 hora
			 str_data[6]::integer,--6
			 str_data[15]::integer,--15
			 str_data[9]::integer,--9
			emp_id,
			suc_id,
			false,
			espacio_tiempo_ejecucion,
			usuario_id
			) 
			RETURNING id INTO ultimo_id;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP 
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1] eliminado
				--str_filas[2] noTr
				--str_filas[3] iddetalle
				--str_filas[4] idprod
				--str_filas[5] select_aml_origen
				--str_filas[6] select_pres_origen
				--str_filas[7] cantpres
				--str_filas[8] cantuni
				--str_filas[9] select_aml_dest
				--str_filas[10] idconf--id de la configuracion de la presentacion
				IF str_filas[1]::integer=1 THEN 
					
					--aqui entra cuando el producto no ha sido eliminado del grid
					INSERT INTO env_env_det(
					env_env_id,--ultimo_id,
					env_conf_id,--str_filas[5]::integer,
					inv_alm_id,--str_filas[4]::integer,
					cantidad,--str_filas[6]::double precision,
					inv_alm_id_env--str_filas[7]::integer
					) VALUES(ultimo_id, str_filas[10]::integer, str_filas[5]::integer, str_filas[7]::double precision, str_filas[9]::integer);
					
				END IF;
			END LOOP;
			
			--Actualiza el etatus de la orden de produccion.
			UPDATE pro_orden_prod SET env_estatus_id=str_data[15]::integer WHERE id=str_data[6]::integer;
			
			valor_retorno := '1';
			
		END IF;--termina nuevo
		
		
		--Inicia Editar Envasado
		IF command_selected = 'edit' THEN
			
			--str_data[4] identificador
			--str_data[5] producto_id
			--str_data[6] produccion_id
			--str_data[7] fecha
			--str_data[8] hora
			--str_data[9] select_alm_orden_orig
			--str_data[10] select_pres_orden_orig
			--str_data[11] equipo
			--str_data[12] operador
			--str_data[13] merma
			--str_data[14] cantidad
			--str_data[15] estatus
			
			
			--obtiene is de equipo
			select id from pro_equipos where titulo=str_data[11] 
			AND gral_emp_id=emp_id AND borrado_logico=false limit 1 INTO id_equipo;
			
			--ontiene id de ele empleado
			select id from gral_empleados where nombre_pila||' '||apellido_paterno||' '||apellido_materno=str_data[12]  
			AND gral_emp_id=emp_id AND borrado_logico=false limit 1 INTO id_empleado;
			
			IF id_equipo is null THEN id_equipo:=0; END IF;--Si no selecciono equipo, lo seta en cero
			IF id_empleado is null THEN id_empleado:=0; END IF;--Si no selecciono empleado, lo seta en cero
			
			/*
			--estatus:1 = Nuevo
			IF str_data[15]::integer=1 THEN 
				--buscar la existencia actual de la presentacion SI el estatus es Nuevo
				SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis 
				FROM inv_exi_pres  WHERE inv_exi_pres.inv_alm_id=str_data[9]::integer AND inv_exi_pres.inv_prod_id=str_data[5]::integer AND inv_exi_pres.inv_prod_presentacion_id=str_data[10]::integer 
				INTO exisActualPres;
			ELSE
				--si el Estatus ya No es Nuevo, obtenemos la existencia guardada
				SELECT cantidad FROM env_env WHERE id=str_data[4]::integer INTO exisActualPres;
			END IF;
			*/
			
			--RAISE EXCEPTION '%','Estatus: '||str_data[5]::integer;
			IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
			exisActualPres := str_data[14]::double precision;
			--redondear la Existencia Actual de la Presentacion Origen
			exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;
			
			--actualizar registro
			UPDATE env_env SET env_estatus_id=str_data[15]::integer, fecha=str_data[7]::date, hora=str_data[8]::time with time zone, 
			gral_empleados_id=id_empleado,pro_equipos_id=id_equipo, inv_alm_id=str_data[9]::integer, inv_prod_id=str_data[5]::integer, 
			inv_prod_presentaciones_id=str_data[10]::integer, cantidad=exisActualPres, 
			momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id
			WHERE id=str_data[4]::integer RETURNING id INTO ultimo_id;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				
				--str_filas[1] eliminado
				--str_filas[2] noTr
				--str_filas[3] iddetalle
				--str_filas[4] idprod
				--str_filas[5] select_aml_origen
				--str_filas[6] select_pres_origen
				--str_filas[7] cantpres
				--str_filas[8] cantuni
				--str_filas[9] select_aml_dest
				--str_filas[10] idconf--id de la configuracion de la presentacion
				
				IF str_filas[1]::integer=1 THEN 
					--aqui entra cuando el producto no ha sido eliminado del grid
					IF str_filas[3]::integer!=0 THEN 
						--Aqui entra para actualizar un registro
						UPDATE env_env_det SET env_conf_id=str_filas[10]::integer, inv_alm_id=str_filas[5]::integer, cantidad=str_filas[7]::double precision,inv_alm_id_env=str_filas[9]::integer 
						WHERE id=str_filas[3]::integer;
					ELSE 
						--aqui entra para crear un nuevo registro
						INSERT INTO env_env_det(env_env_id,--ultimo_id,
						env_conf_id,--str_filas[5]::integer,
						inv_alm_id,--str_filas[4]::integer,
						cantidad,--str_filas[7]::double precision,
						inv_alm_id_env--str_filas[9]::integer
						) VALUES(ultimo_id, str_filas[10]::integer, str_filas[5]::integer, str_filas[7]::double precision, str_filas[9]::integer);
						
					END IF;
					
				ELSE
					IF str_filas[3]::integer!=0 THEN 
						--Aqui eliminar un registro eliminado del Grid
						DELETE FROM env_env_det WHERE id=str_filas[3]::integer;
					END IF;
				END IF;
			END LOOP;
			
			
			
			
			--Estatus 1=Nuevo, 2=En Proceso, 3=Finalizado, 4=Cancelado 
			IF str_data[15]::integer!=1 AND str_data[15]::integer!=4 THEN 
				--Aqui entra para Generar y Descontar Reservados 
				
				--Obtener registros de la Tabla Header del Envasado 
				SELECT * FROM env_env WHERE id=str_data[4]::integer INTO fila;
				
				--IF fila IS NOT NULL THEN 
				--RAISE EXCEPTION '%','fila.folio: '||fila.folio; 
					
					--obtiener registros de la tabla detalle 
					sql_select:='
						select 
						env_det.env_conf_id,
						env_det.inv_alm_id AS alm_env_origen,
						env_det.inv_alm_id_env AS alm_pres_destino,
						env_det.cantidad AS cant_pres,
						round((env_det.cantidad * inv_prod_presentaciones.cantidad)::numeric,inv_prod_unidades.decimales) AS cant_uni,
						env_conf.inv_prod_presentacion_id  AS id_pres_destino, 
						inv_prod_presentaciones.cantidad AS cant_equiv 
						from (
						select * from env_env_det where env_env_id='||fila.id||') env_det 
						JOIN env_conf ON env_conf.id=env_det.env_conf_id 
						JOIN inv_prod ON inv_prod.id=env_conf.inv_prod_id 
						LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=env_conf.inv_prod_presentacion_id 
						LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
						ORDER BY env_det.inv_alm_id;';
					
					--inicializar valor
					idAlmacen:=0;
					
					
					FOR fila_det IN EXECUTE(sql_select) LOOP
						--RAISE EXCEPTION '%','fila.folio: '||sql_select; 
						--sumar las cantidades de la unidad de cada Fila
						sumaCantUnidad := sumaCantUnidad + fila_det.cant_uni;
						
						--obtiene los componentes del Envase
						sql_select2:='
						SELECT 
							env_conf.id AS id_env,
							env_conf_det.inv_prod_id AS id_prod, 
							inv_prod.sku,
							env_conf_det.cantidad AS cant_componente,
							('||fila_det.cant_pres||'::double precision * env_conf_det.cantidad::double precision)::double precision AS cant_a_envasar,
							0::double precision AS cant_uni_fila,
							inv_prod_unidades.decimales,
							(CASE WHEN inv_prod.inv_prod_presentacion_id IS NULL THEN 0 ELSE inv_prod.inv_prod_presentacion_id END) AS id_pres_def, 
							env_conf.borrado_logico AS eliminado,
							inv_prod_presentaciones.cantidad AS equiv 
						FROM env_conf
						JOIN env_conf_det ON env_conf_det.env_conf_id=env_conf.id 
						JOIN inv_prod ON inv_prod.id=env_conf_det.inv_prod_id 
						LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
						LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod.inv_prod_presentacion_id 
						WHERE env_conf.id='||fila_det.env_conf_id||' AND env_conf.borrado_logico=FALSE 
						ORDER BY env_conf.id;';
						
						idEnvConf:=0;--inicializar
						
						
						--RAISE EXCEPTION '%','sql_select2: '||sql_select2;
						/*
						IF fila_det.cant_pres != 20 THEN
							RAISE EXCEPTION '%','sql_select2: '||sql_select2;
						END IF;
						*/
						FOR fila_det_conf IN EXECUTE(sql_select2) LOOP
							--inicializar valor
							cantUnidadFila := 0;
							
							IF fila_det_conf.decimales IS NULL THEN fila_det_conf.decimales:=0;  END IF;
							IF fila_det_conf.id_pres_def IS NULL THEN fila_det_conf.id_pres_def:=0;  END IF;
							--RAISE EXCEPTION '%','id_pres_def: '||fila_det_conf.id_pres_def;
							
							--inicializar valor
							exisActualPres:=0;
							
							IF fila_det_conf.eliminado = FALSE THEN
								IF fila_det_conf.id_pres_def > 0 THEN
									--buscar la existencia actual en la Presentacion Default del Producto Componente del Envase
									SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis FROM inv_exi_pres  
									WHERE inv_exi_pres.inv_alm_id=fila_det.alm_env_origen::integer AND inv_exi_pres.inv_prod_id=fila_det_conf.id_prod AND inv_exi_pres.inv_prod_presentacion_id=fila_det_conf.id_pres_def 
									INTO exisActualPres;
									
									--RAISE EXCEPTION '%','exisActualPres: '||fila_det.alm_env_origen;
									IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
									
									--redondear la Existencia Actual de la Presentacion Default del Producto Componente del Envase
									IF fila_det_conf.decimales=0 THEN
										--redondear solamente hacia arriba
										exisActualPres := ceiling(exisActualPres::numeric)::double precision;
									ELSE
										exisActualPres := round(exisActualPres::numeric,fila_det_conf.decimales)::double precision;
									END IF;
									
									
									IF fila_det_conf.cant_a_envasar IS NULL THEN fila_det_conf.cant_a_envasar:=0; END IF;
									
									--redondear la Cantidad necesaria del Producto Componente para realizar el envasado
									IF fila_det_conf.decimales=0 THEN
										--redondear solamente hacia arriba
										fila_det_conf.cant_a_envasar := ceiling(fila_det_conf.cant_a_envasar::numeric)::double precision;
									ELSE
										fila_det_conf.cant_a_envasar := round(fila_det_conf.cant_a_envasar::numeric,fila_det_conf.decimales)::double precision;
									END IF;
									
									
									--convertir a unidades la cantidad a envasar
									fila_det_conf.cant_uni_fila := fila_det_conf.cant_a_envasar::double precision * fila_det_conf.equiv::double precision;
									--RAISE EXCEPTION '%','exisActualPres: '||fila_det_conf.cant_uni_fila;
									--redondear la Cantidad necesaria del Producto Componente para realizar el envasado
									IF fila_det_conf.decimales=0 THEN
										--redondear solamente hacia arriba
										fila_det_conf.cant_uni_fila := ceiling(fila_det_conf.cant_uni_fila::numeric)::double precision;
									ELSE
										fila_det_conf.cant_uni_fila := round(fila_det_conf.cant_uni_fila::numeric,fila_det_conf.decimales)::double precision;
									END IF;
									
									--Estatus 2=En Proceso
									IF str_data[15]::integer=2 THEN 
										--******CREACION DE RESERVADOS PARA PRODUCTOS COMPONENTES DEL ENVASE*******************
										--crear reservado en tabla de Existencias(inv_exi)
										
										--RAISE EXCEPTION '%','exisActualPres: '||fila_det_conf.cant_uni_fila;
										
										UPDATE inv_exi SET reservado=(reservado::double precision + fila_det_conf.cant_uni_fila::double precision)::double precision
										WHERE inv_alm_id=fila_det.alm_env_origen AND inv_prod_id=fila_det_conf.id_prod AND ano=ano_actual;
										
										--crear reservado en Existecnias de Presentaciones(inv_exi_pres)
										UPDATE inv_exi_pres SET reservado = (reservado::double precision +  fila_det_conf.cant_a_envasar::double precision)::double precision
										WHERE inv_alm_id=fila_det.alm_env_origen  AND inv_prod_id=fila_det_conf.id_prod  AND inv_prod_presentacion_id=fila_det_conf.id_pres_def;
										--******TERMINA CREACION DE RESERVADOS PARA PRODUCTOS COMPONENTES DEL ENVASE***********
										/*
										IF fila_det.env_conf_id=2 THEN 
											sql_select2:='UPDATE inv_exi_pres SET reservado = (reservado::double precision +  '||fila_det_conf.cant_a_envasar||'::double precision)::double precision
											WHERE inv_alm_id='||fila_det.alm_env_origen||'  AND inv_prod_id='||fila_det_conf.id_prod||'  AND inv_prod_presentacion_id='||fila_det_conf.id_pres_def||';';
											RAISE EXCEPTION '%','sql_select2: '||sql_select2;
										END IF;
										*/
									END IF;
									
									
									--Estatus 3=Finalizado
									IF str_data[5]::integer=3 THEN 
										--******INICIA TRASPASO PARA PRODUCTOS COMPONENTES DEL ENVASE***********************
										
										IF idEnvConf != fila_det_conf.id_env THEN
											
											IF fila_det.alm_env_origen != fila_det.alm_pres_destino THEN 
												--AQUI SOLO ENTRA CUANDO EL ALMACEN ORIGEN ES DIFERENTE AL DESTINO
												--AQUI SE TIENE QUE GENERAR UN TRASPASO
												
												id_tipo_consecutivo:=29;--Folio Traspaso
												
												--aqui entra para tomar el consecutivo del folio  la sucursal actual
												UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
												WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
												
												--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del traspaso
												nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
												
												--crea TRASPASO para productos MP del Envase
												INSERT INTO inv_tras(folio, fecha_traspaso, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, observaciones, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion)
												VALUES (nuevo_folio, espacio_tiempo_ejecucion::date, suc_id, fila_det.alm_env_origen, suc_id, fila_det.alm_pres_destino, 'TRASPASO DE MATERIA PRIMA PARA ENVASADO', espacio_tiempo_ejecucion, emp_id,suc_id, usuario_id)
												RETURNING id INTO ultimo_id_tras_env;
												
												-----------------------------------------------------------------------
												--GENERA REGISTRO PARA ORDEN DE TRASPASO(inv_otras)--------------------
												id_tipo_consecutivo:=30;--Folio Orden de Traspaso
												
												--aqui entra para tomar el consecutivo del folio  la sucursal actual
												UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
												WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
												
												--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio dela Orden de Traspaso
												nuevo_folio2 := prefijo_consecutivo || nuevo_consecutivo::character varying;
												
												--crea ORDEN DE TRASPASO para productos MP del Envase
												INSERT INTO inv_otras(folio, fecha, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion)
												VALUES (nuevo_folio2, espacio_tiempo_ejecucion::date, suc_id, fila_det.alm_env_origen, suc_id, fila_det.alm_pres_destino, espacio_tiempo_ejecucion, emp_id, suc_id, usuario_id)
												RETURNING id INTO ultimo_id2_tras_env;
												
												--CREAR HEADER DE MOVIMIENTOS------------------------------------------------------
												id_tipo_movimiento := 7;--SALIDA POR TRASPASO
												
												--genera registro del movimiento SALIDA de MP para Envases
												INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id ) 
												VALUES(nuevo_folio, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'SALIDA-TRASPASO DE MATERIA PRIMA PARA ENVASES UTILIZADA EN EL PROCESO DE ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected ) 
												RETURNING id INTO id_mov_salida_env;
												
												id_tipo_movimiento := 3;--ENTRADA TRASPASO
												
												--genera registro del movimiento ENTRADA de MP para envases
												INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id) 
												VALUES( nuevo_folio2, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'ENTRADA-TRASPASO DE MATERIA PRIMA PARA ENVASES UTILIZADA EN EL PROCESO DE ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected) 
												RETURNING id INTO id_mov_entrada_env;
												
											END IF;
											
											
											id_tipo_movimiento := 12;--SALIDA MATERIA PRIMA PARA ENVASE
											
											--genera registro del movimiento SALIDA de MP para envases
											INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id ) 
											VALUES(fila.folio, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'SALIDA DE MATERIA PRIMA PARA ENVASE UTILIZADA EN EL PROCESO DE ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected) 
											RETURNING id INTO id_mov_salida_mp;
											
										END IF;
										
										--inicializar valores
										sql_select2:='';
										sql_update := '';
										costoUltimoActual:=0;
										
										--obtener el costo ultimo actual
										sql_select2:='SELECT costo_ultimo_'||mes_actual||' FROM inv_prod_cost_prom WHERE inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual||';';
										EXECUTE sql_select2 INTO costoUltimoActual;
										IF costoUltimoActual IS NULL THEN costoUltimoActual:=0; END IF;
										
										IF fila_det.alm_env_origen != fila_det.alm_pres_destino THEN
											--crear registro en detalles del TRASPASO de MP de Envases
											INSERT INTO inv_tras_det(inv_tras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id )
											VALUES(ultimo_id_tras_env, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, fila_det_conf.id_pres_def);
											
											--crea registro para detalles de la ORDEN DE TRASPASO de MP de Envases
											INSERT INTO inv_otras_det(inv_otras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id )
											VALUES(ultimo_id2_tras_env, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, fila_det_conf.id_pres_def);
											
											
											--***** Registrar detalle del Movimiento de SALIDA de MP de Envases*********************
											INSERT INTO inv_mov_detalle(inv_mov_id,  alm_origen_id, alm_destino_id, producto_id,  cantidad,  costo, inv_prod_presentacion_id )
											VALUES(id_mov_salida_env, fila_det.alm_env_origen, fila_det.alm_pres_destino, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, costoUltimoActual, fila_det_conf.id_pres_def);
											
											
											--DESCONTAR producto de inv_exi
											sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||fila_det_conf.cant_uni_fila||'::double precision), 
											reservado = (reservado::double precision - '||fila_det_conf.cant_uni_fila||'::double precision)::double precision, momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
											WHERE inv_alm_id='||fila_det.alm_env_origen||'::integer AND inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual;
											EXECUTE sql_update;
											
											--Descontar existencia de inv_exi_pres
											UPDATE inv_exi_pres SET salidas=(salidas::double precision + fila_det_conf.cant_a_envasar::double precision), 
											reservado=(reservado::double precision - fila_det_conf.cant_a_envasar::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id 
											WHERE inv_alm_id = fila_det.alm_env_origen AND inv_prod_id = fila_det_conf.id_prod  AND inv_prod_presentacion_id = fila_det_conf.id_pres_def;
											--termina descontar existencia de presentaciones
											
											--fila_det.alm_env_origen
											--fila_det.alm_pres_destino
											
											--***** Registrar detalle del Movimiento de ENTRADA de MP de Envases *********************
											INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id )
											VALUES(id_mov_entrada_env, fila_det.alm_env_origen, fila_det.alm_pres_destino, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, costoUltimoActual, fila_det_conf.id_pres_def);
											
											--inicializar valores
											exis:=0;
											sql_select := '';
											sql_insert:='';
											sql_update := '';
											
											--query para verificar existencia del producto en el almacen y en el a√±o actual
											sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||fila_det_conf.id_prod||' AND inv_alm_id = '||fila_det.alm_pres_destino||' AND ano = '||ano_actual||';';
											EXECUTE sql_select INTO exis;
											
											--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
											--CREAR O ACTUALIZAR REGISTRO EN EL ALMACEN DESTINO PARA EL ENVASADO 
											IF exis >0 THEN
												--aqui entra para ACTUALIZAR registro en inv_exi
												sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||'::double precision + '||fila_det_conf.cant_uni_fila||'::double precision), costo_ultimo_'||mes_actual||'='||costoUltimoActual||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
												WHERE inv_alm_id='||fila_det.alm_pres_destino||' AND inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual||';';
												EXECUTE sql_update;
											ELSE
												--aqui entra para CREAR registro en inv_exi
												sql_insert:='INSERT INTO inv_exi (inv_prod_id, inv_alm_id, ano, entradas_'||mes_actual||', momento_entrada_'||mes_actual||', exi_inicial, costo_ultimo_'||mes_actual||') '||' 
												VALUES('||fila_det_conf.id_prod||', '||fila_det.alm_pres_destino||', '||ano_actual||', '||fila_det_conf.cant_uni_fila||', '''|| espacio_tiempo_ejecucion ||''', 0, '||costoUltimoActual||' );';
												EXECUTE sql_insert;
											END IF;
											
											--***** SUMAR EXISTENCIA DE PRESENTACIONES EN EL ALMACEN DESTINO******
											--inicializar valores
											exis:=0;
											sql_select := '';
											sql_insert:='';
											sql_update := '';
											
											--buscar Registro de la Presentacion en el Almacen Destino
											SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres WHERE inv_exi_pres.inv_alm_id=fila_det.alm_pres_destino AND inv_exi_pres.inv_prod_id=fila_det_conf.id_prod AND inv_exi_pres.inv_prod_presentacion_id=fila_det_conf.id_pres_def 
											INTO exis;
											
											IF exis >0 THEN
												--Sumar existencia de la presentacion
												UPDATE inv_exi_pres SET entradas=(entradas::double precision + fila_det_conf.cant_a_envasar::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id  
												WHERE inv_alm_id = fila_det.alm_pres_destino AND inv_prod_id = fila_det_conf.id_prod AND inv_prod_presentacion_id = fila_det_conf.id_pres_def;
											ELSE
												--aqui entra para CREAR registro en inv_exi
												INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
												VALUES(fila_det.alm_pres_destino, fila_det_conf.id_prod, fila_det_conf.id_pres_def, fila_det_conf.cant_a_envasar::double precision, espacio_tiempo_ejecucion, usuario_id);
											END IF;
											--******TERMINA DE TRASPASO PARA PRODUCTOS COMPONENTES DEL ENVASE********************
											
										END IF;
										--termina if de almacen origen y destino
										
										
										--******INICIA SALIDA DE MP DE ENVASES PORQUE YA FUERON CONSUMIDOS EN EL ENVASADO---
										--***** Registrar detalle del Movimiento de SALIDA de MP de Envases del almacen donde fueron utilizados*********************
										INSERT INTO inv_mov_detalle(inv_mov_id,  alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id)
										VALUES(id_mov_salida_mp, fila_det.alm_pres_destino, 0, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, costoUltimoActual, fila_det_conf.id_pres_def);
										
										IF fila_det.alm_env_origen != fila_det.alm_pres_destino THEN
											--aqui ya no se debe descontar reservados porque ya se hizo en el proceso de traspaso
											--DESCONTAR producto de inv_exi
											sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||fila_det_conf.cant_uni_fila||'::double precision), 
											momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
											WHERE inv_alm_id='||fila_det.alm_pres_destino||'::integer AND inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual;
											EXECUTE sql_update;
											
											--Descontar existencia de inv_exi_pres
											UPDATE inv_exi_pres SET salidas=(salidas::double precision + fila_det_conf.cant_a_envasar::double precision), 
											momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id 
											WHERE inv_alm_id = fila_det.alm_pres_destino AND inv_prod_id = fila_det_conf.id_prod  AND inv_prod_presentacion_id = fila_det_conf.id_pres_def;
											--termina descontar existencia de presentaciones
										ELSE
											--en esta parte se deben quitar los reservados porque no paso por el proceso de traspaso
											--DESCONTAR producto de inv_exi
											sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||fila_det_conf.cant_uni_fila||'::double precision), 
											reservado=(reservado::double precision - '||fila_det_conf.cant_uni_fila||'::double precision)::double precision, 
											momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
											WHERE inv_alm_id='||fila_det.alm_pres_destino||'::integer AND inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual;
											EXECUTE sql_update;
											
											--Descontar existencia de inv_exi_pres
											UPDATE inv_exi_pres SET salidas=(salidas::double precision + fila_det_conf.cant_a_envasar::double precision), 
											reservado=(reservado::double precision - fila_det_conf.cant_a_envasar::double precision), 
											momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id 
											WHERE inv_alm_id = fila_det.alm_pres_destino AND inv_prod_id = fila_det_conf.id_prod  AND inv_prod_presentacion_id = fila_det_conf.id_pres_def;
											--termina descontar existencia de presentaciones
										END IF;
										--***TERMINA DESCUENTO DE MP DE ENVASES CONSUMIDOS EN EL PROCESO DE ENVASADO*********
									END IF;
									
								END IF;
							END IF;
							
						END LOOP;--termina LOOP de productos componentes del Envase
						
						
						--Estatus 3=Finalizado
						IF str_data[15]::integer=3 THEN 
							--aqui solo debe entrar si es ESTATUS es Finalizar
							
							IF idAlmacen!=fila_det.alm_pres_destino THEN
								idAlmacen := fila_det.alm_pres_destino;
								
								--RAISE EXCEPTION '%' ,'fila.inv_alm_id: '||fila.inv_alm_id||'           fila_det.alm_pres_destino:'||fila_det.alm_pres_destino;
								--sql_select->select de el primer for
								
								IF fila.inv_alm_id != fila_det.alm_pres_destino THEN 
									--si el Almacen Origen es diferente al Almacen Destino, 
									--SE HACE UN TRASPASO
									id_tipo_consecutivo:=29;--Folio Traspaso
									nuevo_folio:='';--inicializar
									nuevo_folio2:='';--inicializar
									
									--aqui entra para tomar el consecutivo del folio  la sucursal actual
									UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
									WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
									
									--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del traspaso
									nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
									
									INSERT INTO inv_tras(folio,fecha_traspaso, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, observaciones, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion )
									VALUES (nuevo_folio, espacio_tiempo_ejecucion::date, suc_id, fila.inv_alm_id, suc_id, fila_det.alm_pres_destino, 'TRASPASO POR ENVASADO', espacio_tiempo_ejecucion, emp_id, suc_id, usuario_id)
									RETURNING id INTO ultimo_id;
									
									--********************************************************************************************************
									--GENERA REGISTRO PARA ORDEN DE TRASPASO(inv_otras)
									id_tipo_consecutivo:=30;--Folio Orden de Traspaso
									
									--aqui entra para tomar el consecutivo del folio  la sucursal actual
									UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
									WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
									
									--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio dela Orden de Traspaso
									nuevo_folio2 := prefijo_consecutivo || nuevo_consecutivo::character varying;
									
									INSERT INTO inv_otras(folio, fecha, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion)
									VALUES ( nuevo_folio2, espacio_tiempo_ejecucion::date, suc_id, fila.inv_alm_id, suc_id, fila_det.alm_pres_destino, espacio_tiempo_ejecucion, emp_id, suc_id, usuario_id)
									RETURNING id INTO ultimo_id2;
									--********************************************************************************************************
									
									id_tipo_movimiento := 19;--SALIDA TRASPASO PARA ENVASADO
									--RAISE EXCEPTION '%' ,'Hasta aqui llega inv_mov';
									
									--genera registro del movimiento salida
									INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id ) 
									VALUES(nuevo_folio, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'SALIDA-TRASPASO DE PRODUCTO PARA ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected) 
									RETURNING id INTO id_mov_salida;
									
									id_tipo_movimiento := 20;--ENTRADA TRASPASO ENVASADO
									--genera registro del movimiento entrada
									INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id) 
									VALUES( nuevo_folio2, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'ENTRADA-TRASPASO DE PRODUCTO PARA ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected) 
									RETURNING id INTO id_mov_entrada;
								ELSE
									
									--si almacen Origen y Destino son iguales, 
									--solo se da salida de la Presentacion Origen y Etrada en la Presentacion Destino
									id_tipo_movimiento := 17;--SALIDA PARA ENVASADO
									
									--genera registro del movimiento salida
									INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id ) 
									VALUES(nuevo_folio, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'SALIDA DE PRODUCTO PARA ENVASAR', espacio_tiempo_ejecucion, usuario_id, app_selected) 
									RETURNING id INTO id_mov_salida;

									id_tipo_movimiento := 18;--ENTRADA DE LO ENVASADO
									--genera registro del movimiento entrada
									INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id) 
									VALUES( nuevo_folio2, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'ENTRADA DE PRODUCTO ENVASADO EN NUEVA PRESENTACION', espacio_tiempo_ejecucion, usuario_id, app_selected) 
									RETURNING id INTO id_mov_entrada;
								END IF;
							END IF;
							
							--inicializar valores
							sql_select2:='';
							costoUltimoActual:=0;
							--RAISE EXCEPTION '%' ,'sql_select: '||fila;
							--obtener el costo ultimo actual
							sql_select2:='SELECT costo_ultimo_'||mes_actual||' FROM inv_prod_cost_prom WHERE inv_prod_id='||fila.inv_prod_id||' AND ano='||ano_actual||';';
							EXECUTE sql_select2 INTO costoUltimoActual;
							IF costoUltimoActual IS NULL THEN costoUltimoActual:=0; END IF;
							
							IF fila.inv_alm_id != fila_det.alm_pres_destino THEN 
								--si almacen origen y destino son diferentes, hay traspaso
								--crear registro en detalles deL Traspaso
								INSERT INTO inv_tras_det(inv_tras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id )
								VALUES(ultimo_id, fila.inv_prod_id, fila_det.cant_uni, fila.inv_prod_presentaciones_id);
															--id_pres_destino--inv_prod_presentacion_id
								--crea registro para detalles Orden de Traspaso
								INSERT INTO inv_otras_det(inv_otras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id )
								VALUES(ultimo_id2,fila.inv_prod_id,fila_det.cant_uni,fila_det.id_pres_destino);
							END IF;
							
							--RAISE EXCEPTION '%' ,'sql_select: '||fila.inv_prod_presentaciones_id;
							--***** RESGISTRAR SALIDA DEL ALMACEN ORIGEN*********************
							--genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(inv_mov_id,  alm_origen_id, alm_destino_id,  producto_id,  cantidad,  costo, inv_prod_presentacion_id ) 
							VALUES(id_mov_salida, fila.inv_alm_id, fila_det.alm_pres_destino, fila.inv_prod_id, fila_det.cant_uni, costoUltimoActual, fila.inv_prod_presentaciones_id);
																				--id_pres_destino--inv_prod_presentacion_id
							/*
							todas las salidas son del Mismo Almacen, Producto y presentacion,
							por lo tanto, se hace un acumulado y al ultimo 
							se quita el Reservado y Descuenta de inv_exi e inv_exi_pres
							*/
							
							--***** RESGISTRAR ENTRADA EN EL ALMACEN DESTINO*********************
							--genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id ) 
							VALUES(id_mov_entrada, fila.inv_alm_id, fila_det.alm_pres_destino, fila.inv_prod_id, fila_det.cant_uni, costoUltimoActual, fila_det.id_pres_destino);
							
							
							--reiniciamos el valor de la variable exis a cero
							exis:=0;
							sql_select := '';
							sql_update := '';
							sql_insert := '';
							
							--query para verificar existencia del producto en el almacen y en el a√±o actual
							sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||fila.inv_prod_id||' AND inv_alm_id = '||fila_det.alm_pres_destino||' AND ano = '||ano_actual||';';
							EXECUTE sql_select INTO exis;
							
							--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
							IF exis >0 THEN
								--aqui entra para ACTUALIZAR registro en inv_exi
								sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||fila_det.cant_uni||'::double precision), costo_ultimo_'||mes_actual||'='||costoUltimoActual||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
								WHERE inv_alm_id='||fila_det.alm_pres_destino||' AND inv_prod_id='||fila.inv_prod_id||' AND ano='||ano_actual||';';
								EXECUTE sql_update;
							ELSE
								--aqui entra para CREAR registro en inv_exi
								sql_insert:='INSERT INTO inv_exi (inv_prod_id, inv_alm_id, ano, entradas_'||mes_actual||', momento_entrada_'||mes_actual||', exi_inicial, costo_ultimo_'||mes_actual||') '||' 
								VALUES('||fila.inv_prod_id||', '||fila_det.alm_pres_destino||', '||ano_actual||', '||fila_det.cant_uni||', '''|| espacio_tiempo_ejecucion ||''', 0, '||costoUltimoActual||' );';
								EXECUTE sql_insert;
							END IF;
							
							-------------------------------------------------------------------------------------
							--***** SUMAR EXISTENCIA DE PRESENTACIONES EN EL ALMACEN DESTINO******
							--inicializar a cero
							exis := 0;
							
							--buscar Registro de la Presentacion en el Almacen Destino
							SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres 
							WHERE inv_exi_pres.inv_alm_id=fila_det.alm_pres_destino AND 
							inv_exi_pres.inv_prod_id=fila.inv_prod_id AND inv_exi_pres.inv_prod_presentacion_id=fila_det.id_pres_destino 
							INTO exis;
							
							IF exis >0 THEN
								--Sumar existencia de la presentacion
								UPDATE inv_exi_pres SET entradas=(entradas::double precision + fila_det.cant_pres::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id  
								WHERE inv_alm_id = fila_det.alm_pres_destino AND inv_prod_id = fila.inv_prod_id AND inv_prod_presentacion_id = fila_det.id_pres_destino;
							ELSE
								--aqui entra para CREAR registro en inv_exi
								INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
								VALUES(fila_det.alm_pres_destino, fila.inv_prod_id, fila_det.id_pres_destino, fila_det.cant_pres::double precision, espacio_tiempo_ejecucion, usuario_id);
							END IF;
							--**termina actualizar existencia de Presentaciones
							-----------------------------------------------------------------------------------------
						END IF;
					END LOOP;
					
				--END IF; --termina IF fila IS NOT NULL
				
				
				--redondear la Suma de Cantidades de la Unidad
				sumaCantUnidad := round(sumaCantUnidad::numeric,noDecUnidad)::double precision;
				
				--inicializar valor a cero
				equivalenciaPres:=0;
				
				--buscar la equivalencia de la Presentacion Origen en la Unidad del Producto
				SELECT cantidad  FROM inv_prod_presentaciones WHERE id=fila.inv_prod_presentaciones_id INTO equivalenciaPres;
				
				IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
				
				--convertir la Suma de Unidades en su equivalencia a la Presentacion Origen
				cantPresAsignado := sumaCantUnidad::double precision / equivalenciaPres::double precision;
				
				--redondear la Cantidad de Presentacion Asignado para Re-Envasar
				cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision;
				
				--Estatus 2=En Proceso
				IF str_data[15]::integer=2 THEN 
					--*****AQUI COMIENZA A GENERAR RESERVADOS*******************************************
					--crear reservado en tabla de Existencias(inv_exi)
					UPDATE inv_exi SET reservado=(reservado::double precision + sumaCantUnidad::double precision)::double precision
					WHERE inv_alm_id=fila.inv_alm_id 
					AND inv_prod_id=fila.inv_prod_id 
					AND ano=ano_actual;
					
					--crear reservado en Existecnias de Presentaciones(inv_exi_pres)
					UPDATE inv_exi_pres SET reservado = (reservado::double precision +  cantPresAsignado::double precision)::double precision
					WHERE inv_alm_id=fila.inv_alm_id 
					AND inv_prod_id=fila.inv_prod_id 
					AND inv_prod_presentacion_id=fila.inv_prod_presentaciones_id;
					--*****TERMINA GENERACION DE RESERVADOS********************************************
				END IF;
				
				--Estatus 3=Finalizado
				IF str_data[15]::integer=3 THEN 
					--*****AQUI COMIENZA A DESCONTAR EXISTENCIAS DE PRODUCTO ENVASADO******************
					--query para descontar producto de inv_exi
					sql_update := 'UPDATE inv_exi SET 
						salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||sumaCantUnidad||'::double precision), 
						reservado = (reservado::double precision - '||sumaCantUnidad||'::double precision)::double precision,
						momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
					WHERE inv_alm_id='||fila.inv_alm_id||'::integer 
					AND inv_prod_id='||fila.inv_prod_id||' 
					AND ano='||ano_actual;
					EXECUTE sql_update;
					
					--RAISE EXCEPTION '%' ,'sql_update: '||sql_update;
					--Descontar existencia de inv_exi_pres
					UPDATE inv_exi_pres SET 
						salidas=(inv_exi_pres.salidas::double precision + cantPresAsignado::double precision), 
						reservado=(inv_exi_pres.reservado::double precision - cantPresAsignado::double precision), 
						momento_actualizacion=espacio_tiempo_ejecucion, 
						gral_usr_id_actualizacion=usuario_id 
					WHERE inv_alm_id = fila.inv_alm_id 
					AND inv_prod_id = fila.inv_prod_id  
					AND inv_prod_presentacion_id = fila.inv_prod_presentaciones_id;
					--termina descontar existencia de presentaciones
					--*****AQUI TERMINA DESCONTAR EXISTENCIAS DE PRODUCTO RE-ENVASADO**************
					
				END IF;
				
				IF str_data[15]::integer=1 OR str_data[15]::integer=2 OR str_data[15]::integer=3 THEN 
					--Actualiza el etatus de la orden de produccion.
					UPDATE pro_orden_prod SET env_estatus_id=str_data[15]::integer WHERE id=str_data[6]::integer;
				ELSE
					--Quita el estatus de envasado a la orden de produccion
					UPDATE pro_orden_prod SET env_estatus_id=0 WHERE id=str_data[6]::integer;
				END IF;
				
			END IF;--termina generar y descontar Reservados
			
			valor_retorno := '1';
		END IF;--termina editar de Envasado
		
		
		
	END IF;--Termina Aplicativo de Proceso de Envasado


	
	
	-- Aplicativo de Proceso de Re-Envasado
	IF app_selected = 138 THEN
		--str_data[4] 	identificador
		--str_data[5] 	select_estatus
		--str_data[6] 	fecha
		--str_data[7] 	hora
		--str_data[8] 	select_empleado
		--str_data[9] 	select_almacen_orig
		--str_data[10] 	producto_id
		--str_data[11] 	select_presentacion_orig
		
		--buscar el numero de decimales de la unidad del producto
		SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
		WHERE inv_prod.id=str_data[10]::integer 
		INTO noDecUnidad;
		
		IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
		--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
		
		IF command_selected = 'new' THEN
			id_tipo_movimiento:=1;--Traspaso por Re-Envasado
			id_tipo_consecutivo:=42;--Folio Proceso de Re-Envasado
			
			--aqui entra para tomar el consecutivo del pedido de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			--suc_id_consecutivo
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--buscar la existencia actual de la presentacion
			SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis FROM inv_exi_pres  
			WHERE inv_exi_pres.inv_alm_id=str_data[9]::integer AND inv_exi_pres.inv_prod_id=str_data[10]::integer AND inv_exi_pres.inv_prod_presentacion_id=str_data[11]::integer 
			INTO exisActualPres;
			
			IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
			
			--redondear la Existencia Actual de la Presentacion Origen
			exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;
			
			INSERT INTO env_reenv(
				folio, --nuevo_folio,
				env_estatus_id,--str_data[5]::integer,
				fecha,--str_data[6]::date,
				hora_inicio,--str_data[7]::time with time zone,
				gral_empleado_id,--str_data[8]::integer,
				inv_alm_id,--str_data[9]::integer,
				inv_prod_id,--str_data[10]::integer,
				inv_prod_presentacion_id,--str_data[11]::integer,
				existencia,--exisActualPres,
				gral_emp_id,--emp_id,
				gral_suc_id,--suc_id,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_crea--usuario_id
			)
			VALUES(
				nuevo_folio,
				str_data[5]::integer,
				str_data[6]::date,
				str_data[7]::time with time zone,
				str_data[8]::integer,
				str_data[9]::integer,
				str_data[10]::integer,
				str_data[11]::integer,
				exisActualPres,
				emp_id,
				suc_id,
				espacio_tiempo_ejecucion,
				usuario_id
			)
			RETURNING id INTO ultimo_id;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	eliminado
				--str_filas[2]	notr
				--str_filas[3]	iddetalle
				--str_filas[4]	select_aml_dest
				--str_filas[5]	idEnv
				--str_filas[6]	cantpres
				--str_filas[7]	select_aml_envase
				
				IF str_filas[1]::integer=1 THEN 
					--aqui entra cuando el producto no ha sido eliminado del grid
					INSERT INTO env_reenv_det(
						env_reenv_id,--ultimo_id,
						env_conf_id,--str_filas[5]::integer,
						inv_alm_id,--str_filas[4]::integer,
						cantidad,--str_filas[6]::double precision,
						inv_alm_id_env--str_filas[7]::integer
					) VALUES(ultimo_id, str_filas[5]::integer, str_filas[4]::integer, str_filas[6]::double precision, str_filas[7]::integer);
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;--termina nuevo
		
		
		
		IF command_selected = 'edit' THEN
			--estatus:1 = Nuevo
			IF str_data[5]::integer=1 THEN 
				--buscar la existencia actual de la presentacion SI el estatus es Nuevo
				SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis 
				FROM inv_exi_pres  WHERE inv_exi_pres.inv_alm_id=str_data[9]::integer AND inv_exi_pres.inv_prod_id=str_data[10]::integer AND inv_exi_pres.inv_prod_presentacion_id=str_data[11]::integer 
				INTO exisActualPres;
			ELSE
				--si el Estatus ya No es Nuevo, obtenemos la existencia guardada
				SELECT existencia FROM env_reenv WHERE id=str_data[4]::integer INTO exisActualPres;
			END IF;
			--RAISE EXCEPTION '%','Estatus: '||str_data[5]::integer;
			IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
			
			--redondear la Existencia Actual de la Presentacion Origen
			exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;
			
			--actualizar registro
			UPDATE env_reenv SET env_estatus_id=str_data[5]::integer, fecha=str_data[6]::date, hora_inicio=str_data[7]::time with time zone, gral_empleado_id=str_data[8]::integer, inv_alm_id=str_data[9]::integer, inv_prod_id=str_data[10]::integer, inv_prod_presentacion_id=str_data[11]::integer, existencia=exisActualPres, momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id
			WHERE id=str_data[4]::integer;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	eliminado
				--str_filas[2]	notr
				--str_filas[3]	iddetalle
				--str_filas[4]	select_aml_dest
				--str_filas[5]	idEnv
				--str_filas[6]	cantpres
				
				IF str_filas[1]::integer=1 THEN 
					--aqui entra cuando el producto no ha sido eliminado del grid
					IF str_filas[3]::integer!=0 THEN 
						--Aqui entra para actualizar un registro
						UPDATE env_reenv_det SET env_conf_id=str_filas[5]::integer, inv_alm_id=str_filas[4]::integer, cantidad=str_filas[6]::double precision,inv_alm_id_env=str_filas[7]::integer 
						WHERE id=str_filas[3]::integer;
					ELSE 
						--aqui entra para crear un nuevo registro
						INSERT INTO env_reenv_det(env_reenv_id, env_conf_id, inv_alm_id, cantidad, inv_alm_id_env) 
						VALUES(ultimo_id, str_filas[5]::integer, str_filas[4]::integer, str_filas[6]::double precision, str_filas[7]::integer);
					END IF;
					
				ELSE
					IF str_filas[3]::integer!=0 THEN 
						--Aqui eliminar un registro eliminado del Grid
						DELETE FROM env_reenv_det WHERE id=str_filas[3]::integer;
					END IF;
				END IF;
			END LOOP;
			
			
			
			
			--Estatus 1=Nuevo, 2=En Proceso, 3=Finalizado, 4=Cancelado
			IF str_data[5]::integer!=1 AND str_data[5]::integer!=4 THEN 
				--Aqui entra para Generar y Descontar Reservados
				
				--Obtener registros de la Tabla Header del Envasado
				SELECT * FROM env_reenv WHERE id=str_data[4]::integer INTO fila;
				
				--obtiener registros de la tabla detalle
				sql_select:='
				SELECT 
					env_reenv_det.env_conf_id,
					env_reenv_det.inv_alm_id_env AS alm_env_origen,
					env_reenv_det.inv_alm_id AS alm_pres_destino,
					env_reenv_det.cantidad AS cant_pres,
					round((env_reenv_det.cantidad * inv_prod_presentaciones.cantidad)::numeric,inv_prod_unidades.decimales) AS cant_uni,
					env_conf.inv_prod_presentacion_id  AS id_pres_destino, 
					inv_prod_presentaciones.cantidad AS cant_equiv 
				FROM env_reenv_det 
				JOIN env_conf ON env_conf.id=env_reenv_det.env_conf_id 
				JOIN inv_prod ON inv_prod.id=env_conf.inv_prod_id 
				LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=env_conf.inv_prod_presentacion_id 
				LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
				WHERE env_reenv_det.env_reenv_id='||fila.id||' 
				ORDER BY env_reenv_det.inv_alm_id;';
				
				--inicializar valor
				idAlmacen:=0;
				
				--RAISE EXCEPTION '%','sql_select '||sql_select;
				
				FOR fila_det IN EXECUTE(sql_select) LOOP
					
					--sumar las cantidades de la unidad de cada Fila
					sumaCantUnidad := sumaCantUnidad + fila_det.cant_uni;
					
					--obtiene los componentes del Envase
					sql_select2:='
					SELECT 
						env_conf.id AS id_env,
						env_conf_det.inv_prod_id AS id_prod, 
						inv_prod.sku,
						env_conf_det.cantidad AS cant_componente,
						('||fila_det.cant_pres||'::double precision * env_conf_det.cantidad::double precision)::double precision AS cant_a_envasar,
						0::double precision AS cant_uni_fila,
						inv_prod_unidades.decimales,
						(CASE WHEN inv_prod.inv_prod_presentacion_id IS NULL THEN 0 ELSE inv_prod.inv_prod_presentacion_id END) AS id_pres_def, 
						env_conf.borrado_logico AS eliminado,
						inv_prod_presentaciones.cantidad AS equiv 
					FROM env_conf
					JOIN env_conf_det ON env_conf_det.env_conf_id=env_conf.id
					JOIN inv_prod ON inv_prod.id=env_conf_det.inv_prod_id
					LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
					LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod.inv_prod_presentacion_id
					WHERE env_conf.id='||fila_det.env_conf_id||' AND env_conf.borrado_logico=FALSE
					ORDER BY env_conf.id;';
					
					idEnvConf:=0;--inicializar
					
					--RAISE EXCEPTION '%','sql_select2: '||sql_select2;
					
					--IF fila_det.env_conf_id=2 THEN
						--RAISE EXCEPTION '%','sql_select2: '||sql_select2;
					--END IF;
					
					FOR fila_det_conf IN EXECUTE(sql_select2) LOOP
						--inicializar valor
						cantUnidadFila := 0;
						
						IF fila_det_conf.decimales IS NULL THEN fila_det_conf.decimales:=0;  END IF;
						IF fila_det_conf.id_pres_def IS NULL THEN fila_det_conf.id_pres_def:=0;  END IF;
						--RAISE EXCEPTION '%','id_pres_def: '||fila_det_conf.id_pres_def;
						
						--inicializar valor
						exisActualPres:=0;
						
						IF fila_det_conf.eliminado = FALSE THEN
							IF fila_det_conf.id_pres_def > 0 THEN
								--buscar la existencia actual en la Presentacion Default del Producto Componente del Envase
								SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis FROM inv_exi_pres  
								WHERE inv_exi_pres.inv_alm_id=fila_det.alm_env_origen::integer AND inv_exi_pres.inv_prod_id=fila_det_conf.id_prod AND inv_exi_pres.inv_prod_presentacion_id=fila_det_conf.id_pres_def 
								INTO exisActualPres;
								--RAISE EXCEPTION '%','exisActualPres: '||exisActualPres;
								IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
								
								--redondear la Existencia Actual de la Presentacion Default del Producto Componente del Envase
								IF fila_det_conf.decimales=0 THEN
									--redondear solamente hacia arriba
									exisActualPres := ceiling(exisActualPres::numeric)::double precision;
								ELSE
									exisActualPres := round(exisActualPres::numeric,fila_det_conf.decimales)::double precision;
								END IF;
								
								
								IF fila_det_conf.cant_a_envasar IS NULL THEN fila_det_conf.cant_a_envasar:=0; END IF;
								
								--redondear la Cantidad necesaria del Producto Componente para realizar el envasado
								IF fila_det_conf.decimales=0 THEN
									--redondear solamente hacia arriba
									fila_det_conf.cant_a_envasar := ceiling(fila_det_conf.cant_a_envasar::numeric)::double precision;
								ELSE
									fila_det_conf.cant_a_envasar := round(fila_det_conf.cant_a_envasar::numeric,fila_det_conf.decimales)::double precision;
								END IF;
								
								
								--convertir a unidades la cantidad a envasar
								fila_det_conf.cant_uni_fila := fila_det_conf.cant_a_envasar::double precision * fila_det_conf.equiv::double precision;
								
								--redondear la Cantidad necesaria del Producto Componente para realizar el envasado
								IF fila_det_conf.decimales=0 THEN
									--redondear solamente hacia arriba
									fila_det_conf.cant_uni_fila := ceiling(fila_det_conf.cant_uni_fila::numeric)::double precision;
								ELSE
									fila_det_conf.cant_uni_fila := round(fila_det_conf.cant_uni_fila::numeric,fila_det_conf.decimales)::double precision;
								END IF;
								
								--Estatus 2=En Proceso
								IF str_data[5]::integer=2 THEN 
									--******CREACION DE RESERVADOS PARA PRODUCTOS COMPONENTES DEL ENVASE*******************
									--crear reservado en tabla de Existencias(inv_exi)
									UPDATE inv_exi SET reservado=(reservado::double precision + fila_det_conf.cant_uni_fila::double precision)::double precision
									WHERE inv_alm_id=fila_det.alm_env_origen AND inv_prod_id=fila_det_conf.id_prod AND ano=ano_actual;
									
									--crear reservado en Existecnias de Presentaciones(inv_exi_pres)
									UPDATE inv_exi_pres SET reservado = (reservado::double precision +  fila_det_conf.cant_a_envasar::double precision)::double precision
									WHERE inv_alm_id=fila_det.alm_env_origen  AND inv_prod_id=fila_det_conf.id_prod  AND inv_prod_presentacion_id=fila_det_conf.id_pres_def;
									--******TERMINA CREACION DE RESERVADOS PARA PRODUCTOS COMPONENTES DEL ENVASE***********
									/*
									IF fila_det.env_conf_id=2 THEN 
										sql_select2:='UPDATE inv_exi_pres SET reservado = (reservado::double precision +  '||fila_det_conf.cant_a_envasar||'::double precision)::double precision
										WHERE inv_alm_id='||fila_det.alm_env_origen||'  AND inv_prod_id='||fila_det_conf.id_prod||'  AND inv_prod_presentacion_id='||fila_det_conf.id_pres_def||';';
										RAISE EXCEPTION '%','sql_select2: '||sql_select2;
									END IF;
									*/
								END IF;
								
								
								--Estatus 3=Finalizado
								IF str_data[5]::integer=3 THEN 
									--******INICIA TRASPASO PARA PRODUCTOS COMPONENTES DEL ENVASE***********************
									
									IF idEnvConf != fila_det_conf.id_env THEN

										IF fila_det.alm_env_origen != fila_det.alm_pres_destino THEN
											--AQUI SOLO ENTRA CUANDO EL ALMACEN ORIGEN ES DIFERENTE AL DESTINO
											--AQUI SE TIENE QUE GENERAR UN TRASPASO
											
											id_tipo_consecutivo:=29;--Folio Traspaso
											
											--aqui entra para tomar el consecutivo del folio  la sucursal actual
											UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
											WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
											
											--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del traspaso
											nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
											
											--crea TRASPASO para productos MP del Envase
											INSERT INTO inv_tras(folio, fecha_traspaso, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, observaciones, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion)
											VALUES (nuevo_folio, espacio_tiempo_ejecucion::date, suc_id, fila_det.alm_env_origen, suc_id, fila_det.alm_pres_destino, 'TRASPASO DE MATERIA PRIMA PARA RE-ENVASADO', espacio_tiempo_ejecucion, emp_id,suc_id, usuario_id)
											RETURNING id INTO ultimo_id_tras_env;
											
											-----------------------------------------------------------------------
											--GENERA REGISTRO PARA ORDEN DE TRASPASO(inv_otras)--------------------
											id_tipo_consecutivo:=30;--Folio Orden de Traspaso
											
											--aqui entra para tomar el consecutivo del folio  la sucursal actual
											UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
											WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
											
											--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio dela Orden de Traspaso
											nuevo_folio2 := prefijo_consecutivo || nuevo_consecutivo::character varying;
											
											--crea ORDEN DE TRASPASO para productos MP del Envase
											INSERT INTO inv_otras(folio, fecha, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion)
											VALUES (nuevo_folio2, espacio_tiempo_ejecucion::date, suc_id, fila_det.alm_env_origen, suc_id, fila_det.alm_pres_destino, espacio_tiempo_ejecucion, emp_id, suc_id, usuario_id)
											RETURNING id INTO ultimo_id2_tras_env;
											
											--CREAR HEADER DE MOVIMIENTOS------------------------------------------------------
											id_tipo_movimiento := 7;--SALIDA POR TRASPASO
											
											--genera registro del movimiento SALIDA de MP para Envases
											INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id ) 
											VALUES(nuevo_folio, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'SALIDA-TRASPASO DE MATERIA PRIMA PARA ENVASES UTILIZADA EN EL PROCESO DE RE-ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected ) 
											RETURNING id INTO id_mov_salida_env;
											
											id_tipo_movimiento := 3;--ENTRADA TRASPASO
											
											--genera registro del movimiento ENTRADA de MP para envases
											INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id) 
											VALUES( nuevo_folio2, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'ENTRADA-TRASPASO DE MATERIA PRIMA PARA ENVASES UTILIZADA EN EL PROCESO DE RE-ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected) 
											RETURNING id INTO id_mov_entrada_env;
											
										END IF;
										
										
										id_tipo_movimiento := 12;--SALIDA MATERIA PRIMA PARA ENVASE
										
										--genera registro del movimiento SALIDA de MP para envases
										INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id ) 
										VALUES(fila.folio, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'SALIDA DE MATERIA PRIMA PARA ENVASE UTILIZADA EN EL PROCESO DE RE-ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected) 
										RETURNING id INTO id_mov_salida_mp;
										
									END IF;
									
									--inicializar valores
									sql_select2:='';
									sql_update := '';
									costoUltimoActual:=0;
									
									--obtener el costo ultimo actual
									sql_select2:='SELECT costo_ultimo_'||mes_actual||' FROM inv_prod_cost_prom WHERE inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual||';';
									EXECUTE sql_select2 INTO costoUltimoActual;
									IF costoUltimoActual IS NULL THEN costoUltimoActual:=0; END IF;
									
									IF fila_det.alm_env_origen != fila_det.alm_pres_destino THEN
										--crear registro en detalles del TRASPASO de MP de Envases
										INSERT INTO inv_tras_det(inv_tras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id )
										VALUES(ultimo_id_tras_env, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, fila_det_conf.id_pres_def);
										
										--crea registro para detalles de la ORDEN DE TRASPASO de MP de Envases
										INSERT INTO inv_otras_det(inv_otras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id )
										VALUES(ultimo_id2_tras_env, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, fila_det_conf.id_pres_def);
										
										
										--***** Registrar detalle del Movimiento de SALIDA de MP de Envases*********************
										INSERT INTO inv_mov_detalle(inv_mov_id,  alm_origen_id, alm_destino_id, producto_id,  cantidad,  costo, inv_prod_presentacion_id )
										VALUES(id_mov_salida_env, fila_det.alm_env_origen, fila_det.alm_pres_destino, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, costoUltimoActual, fila_det_conf.id_pres_def);
										
										
										--DESCONTAR producto de inv_exi
										sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||fila_det_conf.cant_uni_fila||'::double precision), 
										reservado = (reservado::double precision - '||fila_det_conf.cant_uni_fila||'::double precision)::double precision, momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
										WHERE inv_alm_id='||fila_det.alm_env_origen||'::integer AND inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual;
										EXECUTE sql_update;
										
										--Descontar existencia de inv_exi_pres
										UPDATE inv_exi_pres SET salidas=(salidas::double precision + fila_det_conf.cant_a_envasar::double precision), 
										reservado=(reservado::double precision - fila_det_conf.cant_a_envasar::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id 
										WHERE inv_alm_id = fila_det.alm_env_origen AND inv_prod_id = fila_det_conf.id_prod  AND inv_prod_presentacion_id = fila_det_conf.id_pres_def;
										--termina descontar existencia de presentaciones
										
										--fila_det.alm_env_origen
										--fila_det.alm_pres_destino
										
										--***** Registrar detalle del Movimiento de ENTRADA de MP de Envases *********************
										INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id )
										VALUES(id_mov_entrada_env, fila_det.alm_env_origen, fila_det.alm_pres_destino, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, costoUltimoActual, fila_det_conf.id_pres_def);
										
										--inicializar valores
										exis:=0;
										sql_select := '';
										sql_insert:='';
										sql_update := '';
										
										--query para verificar existencia del producto en el almacen y en el a√±o actual
										sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||fila_det_conf.id_prod||' AND inv_alm_id = '||fila_det.alm_pres_destino||' AND ano = '||ano_actual||';';
										EXECUTE sql_select INTO exis;
										
										--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
										--CREAR O ACTUALIZAR REGISTRO EN EL ALMACEN DESTINO PARA EL ENVASADO 
										IF exis >0 THEN
											--aqui entra para ACTUALIZAR registro en inv_exi
											sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||'::double precision + '||fila_det_conf.cant_uni_fila||'::double precision), costo_ultimo_'||mes_actual||'='||costoUltimoActual||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
											WHERE inv_alm_id='||fila_det.alm_pres_destino||' AND inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual||';';
											EXECUTE sql_update;
										ELSE
											--aqui entra para CREAR registro en inv_exi
											sql_insert:='INSERT INTO inv_exi (inv_prod_id, inv_alm_id, ano, entradas_'||mes_actual||', momento_entrada_'||mes_actual||', exi_inicial, costo_ultimo_'||mes_actual||') '||' 
											VALUES('||fila_det_conf.id_prod||', '||fila_det.alm_pres_destino||', '||ano_actual||', '||fila_det_conf.cant_uni_fila||', '''|| espacio_tiempo_ejecucion ||''', 0, '||costoUltimoActual||' );';
											EXECUTE sql_insert;
										END IF;
										
										--***** SUMAR EXISTENCIA DE PRESENTACIONES EN EL ALMACEN DESTINO******
										--inicializar valores
										exis:=0;
										sql_select := '';
										sql_insert:='';
										sql_update := '';
										
										--buscar Registro de la Presentacion en el Almacen Destino
										SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres WHERE inv_exi_pres.inv_alm_id=fila_det.alm_pres_destino AND inv_exi_pres.inv_prod_id=fila_det_conf.id_prod AND inv_exi_pres.inv_prod_presentacion_id=fila_det_conf.id_pres_def 
										INTO exis;
										
										IF exis >0 THEN
											--Sumar existencia de la presentacion
											UPDATE inv_exi_pres SET entradas=(entradas::double precision + fila_det_conf.cant_a_envasar::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id  
											WHERE inv_alm_id = fila_det.alm_pres_destino AND inv_prod_id = fila_det_conf.id_prod AND inv_prod_presentacion_id = fila_det_conf.id_pres_def;
										ELSE
											--aqui entra para CREAR registro en inv_exi
											INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
											VALUES(fila_det.alm_pres_destino, fila_det_conf.id_prod, fila_det_conf.id_pres_def, fila_det_conf.cant_a_envasar::double precision, espacio_tiempo_ejecucion, usuario_id);
										END IF;
										--******TERMINA DE TRASPASO PARA PRODUCTOS COMPONENTES DEL ENVASE********************
										
									END IF;
									--termina if de almacen origen y destino
									
									
									--******INICIA SALIDA DE MP DE ENVASES PORQUE YA FUERON CONSUMIDOS EN EL RE-ENVASADO---
									--***** Registrar detalle del Movimiento de SALIDA de MP de Envases del almacen donde fueron utilizados*********************
									INSERT INTO inv_mov_detalle(inv_mov_id,  alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id)
									VALUES(id_mov_salida_mp, fila_det.alm_pres_destino, 0, fila_det_conf.id_prod, fila_det_conf.cant_uni_fila::double precision, costoUltimoActual, fila_det_conf.id_pres_def);
									
									IF fila_det.alm_env_origen != fila_det.alm_pres_destino THEN
										--aqui ya no se debe descontar reservados porque ya se hizo en el proceso de traspaso
										--DESCONTAR producto de inv_exi
										sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||fila_det_conf.cant_uni_fila||'::double precision), 
										momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
										WHERE inv_alm_id='||fila_det.alm_pres_destino||'::integer AND inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual;
										EXECUTE sql_update;
										
										--Descontar existencia de inv_exi_pres
										UPDATE inv_exi_pres SET salidas=(salidas::double precision + fila_det_conf.cant_a_envasar::double precision), 
										momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id 
										WHERE inv_alm_id = fila_det.alm_pres_destino AND inv_prod_id = fila_det_conf.id_prod  AND inv_prod_presentacion_id = fila_det_conf.id_pres_def;
										--termina descontar existencia de presentaciones
									ELSE
										--en esta parte se deben quitar los reservados porque no paso por el proceso de traspaso
										--DESCONTAR producto de inv_exi
										sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||fila_det_conf.cant_uni_fila||'::double precision), 
										reservado=(reservado::double precision - '||fila_det_conf.cant_uni_fila||'::double precision)::double precision, 
										momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
										WHERE inv_alm_id='||fila_det.alm_pres_destino||'::integer AND inv_prod_id='||fila_det_conf.id_prod||' AND ano='||ano_actual;
										EXECUTE sql_update;
										
										--Descontar existencia de inv_exi_pres
										UPDATE inv_exi_pres SET salidas=(salidas::double precision + fila_det_conf.cant_a_envasar::double precision), 
										reservado=(reservado::double precision - fila_det_conf.cant_a_envasar::double precision), 
										momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id 
										WHERE inv_alm_id = fila_det.alm_pres_destino AND inv_prod_id = fila_det_conf.id_prod  AND inv_prod_presentacion_id = fila_det_conf.id_pres_def;
										--termina descontar existencia de presentaciones
									END IF;
									--***TERMINA DESCUENTO DE MP DE ENVASES CONSUMIDOS EN EL PROCESO DE RE-ENVASADO*********
								END IF;
								
							END IF;
						END IF;
						
					END LOOP;--termina LOOP de productos componentes del Envase
					
					
					--Estatus 3=Finalizado
					IF str_data[5]::integer=3 THEN 
						--aqui solo debe entrar si es ESTATUS es Finalizar
						
						IF idAlmacen!=fila_det.alm_pres_destino THEN
							idAlmacen := fila_det.alm_pres_destino;
							
							--RAISE EXCEPTION '%' ,'fila.inv_alm_id: '||fila.inv_alm_id||'           fila_det.alm_pres_destino:'||fila_det.alm_pres_destino;
							
							IF fila.inv_alm_id != fila_det.alm_pres_destino THEN 
								--si el Almacen Origen es diferente al Almacen Destino, 
								--SE HACE UN TRASPASO
								id_tipo_consecutivo:=29;--Folio Traspaso
								nuevo_folio:='';--inicializar
								nuevo_folio2:='';--inicializar
								
								--aqui entra para tomar el consecutivo del folio  la sucursal actual
								UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
								WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
								
								--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del traspaso
								nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
								
								INSERT INTO inv_tras(folio,fecha_traspaso, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, observaciones, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion )
								VALUES (nuevo_folio, espacio_tiempo_ejecucion::date, suc_id, fila.inv_alm_id, suc_id, fila_det.alm_pres_destino, 'TRASPASO POR RE-ENVASADO', espacio_tiempo_ejecucion, emp_id, suc_id, usuario_id)
								RETURNING id INTO ultimo_id;
								
								--********************************************************************************************************
								--GENERA REGISTRO PARA ORDEN DE TRASPASO(inv_otras)
								id_tipo_consecutivo:=30;--Folio Orden de Traspaso
								
								--aqui entra para tomar el consecutivo del folio  la sucursal actual
								UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
								WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
								
								--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio dela Orden de Traspaso
								nuevo_folio2 := prefijo_consecutivo || nuevo_consecutivo::character varying;
								
								INSERT INTO inv_otras(folio, fecha, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion)
								VALUES ( nuevo_folio2, espacio_tiempo_ejecucion::date, suc_id, fila.inv_alm_id, suc_id, fila_det.alm_pres_destino, espacio_tiempo_ejecucion, emp_id, suc_id, usuario_id)
								RETURNING id INTO ultimo_id2;
								--********************************************************************************************************
								
								id_tipo_movimiento := 15;--SALIDA TRASPASO PARA RE-ENVASADO
								
								--genera registro del movimiento salida
								INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id ) 
								VALUES(nuevo_folio, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'SALIDA-TRASPASO DE PRODUCTO PARA RE-ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected) 
								RETURNING id INTO id_mov_salida;

								id_tipo_movimiento := 16;--ENTRADA TRASPASO RE-ENVASADO
								--genera registro del movimiento entrada
								INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id) 
								VALUES( nuevo_folio2, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'ENTRADA-TRASPASO DE PRODUCTO PARA RE-ENVASADO', espacio_tiempo_ejecucion, usuario_id, app_selected) 
								RETURNING id INTO id_mov_entrada;
							ELSE
								
								--si almacen Origen y Destino son iguales, 
								--solo se da salida de la Presentacion Origen y Etrada en la Presentacion Destino
								id_tipo_movimiento := 13;--SALIDA PARA RE-ENVASADO
								
								--genera registro del movimiento salida
								INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id ) 
								VALUES(nuevo_folio, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'SALIDA DE PRODUCTO PARA RE-ENVASAR', espacio_tiempo_ejecucion, usuario_id, app_selected) 
								RETURNING id INTO id_mov_salida;

								id_tipo_movimiento := 14;--ENTRADA DE LO RE-ENVASADO
								--genera registro del movimiento entrada
								INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id) 
								VALUES( nuevo_folio2, id_tipo_movimiento, espacio_tiempo_ejecucion::date, 'ENTRADA DE PRODUCTO RE-ENVASADO EN NUEVA PRESENTACION', espacio_tiempo_ejecucion, usuario_id, app_selected) 
								RETURNING id INTO id_mov_entrada;
							END IF;
						END IF;
						
						--inicializar valores
						sql_select2:='';
						costoUltimoActual:=0;
						
						--obtener el costo ultimo actual
						sql_select2:='SELECT costo_ultimo_'||mes_actual||' FROM inv_prod_cost_prom WHERE inv_prod_id='||fila.inv_prod_id||' AND ano='||ano_actual||';';
						EXECUTE sql_select2 INTO costoUltimoActual;
						IF costoUltimoActual IS NULL THEN costoUltimoActual:=0; END IF;
						
						IF fila.inv_alm_id != fila_det.alm_pres_destino THEN 
							--si almacen origen y destino son diferentes, hay traspaso
							--crear registro en detalles deL Traspaso
							INSERT INTO inv_tras_det(inv_tras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id )
							VALUES(ultimo_id, fila.inv_prod_id, fila_det.cant_uni, fila.inv_prod_presentacion_id);
							
							--crea registro para detalles Orden de Traspaso
							INSERT INTO inv_otras_det(inv_otras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id )
							VALUES(ultimo_id2,fila.inv_prod_id,fila_det.cant_uni,fila_det.id_pres_destino);
						END IF;
						
						
						--***** RESGISTRAR SALIDA DEL ALMACEN ORIGEN*********************
						--genera registro en detalles del movimiento
						INSERT INTO inv_mov_detalle(inv_mov_id,  alm_origen_id, alm_destino_id,  producto_id,  cantidad,  costo, inv_prod_presentacion_id )
						VALUES(id_mov_salida, fila.inv_alm_id, fila_det.alm_pres_destino, fila.inv_prod_id, fila_det.cant_uni, costoUltimoActual, fila.inv_prod_presentacion_id);
						
						/*
						todas las salidas son del Mismo Almacen, Producto y presentacion,
						por lo tanto, se hace un acumulado y al ultimo 
						se quita el Reservado y Descuenta de inv_exi e inv_exi_pres
						*/
						
						--***** RESGISTRAR ENTRADA EN EL ALMACEN DESTINO*********************
						--genera registro en detalles del movimiento
						INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id )
						VALUES(id_mov_entrada, fila.inv_alm_id, fila_det.alm_pres_destino, fila.inv_prod_id, fila_det.cant_uni, costoUltimoActual, fila_det.id_pres_destino);
						
						
						--reiniciamos el valor de la variable exis a cero
						exis:=0;
						sql_select := '';
						sql_update := '';
						sql_insert := '';
						
						--query para verificar existencia del producto en el almacen y en el a√±o actual
						sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||fila.inv_prod_id||' AND inv_alm_id = '||fila_det.alm_pres_destino||' AND ano = '||ano_actual||';';
						EXECUTE sql_select INTO exis;
						
						--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
						IF exis >0 THEN
							--aqui entra para ACTUALIZAR registro en inv_exi
							sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||fila_det.cant_uni||'::double precision), costo_ultimo_'||mes_actual||'='||costoUltimoActual||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
							WHERE inv_alm_id='||fila_det.alm_pres_destino||' AND inv_prod_id='||fila.inv_prod_id||' AND ano='||ano_actual||';';
							EXECUTE sql_update;
						ELSE
							--aqui entra para CREAR registro en inv_exi
							sql_insert:='INSERT INTO inv_exi (inv_prod_id, inv_alm_id, ano, entradas_'||mes_actual||', momento_entrada_'||mes_actual||', exi_inicial, costo_ultimo_'||mes_actual||') '||' 
							VALUES('||fila.inv_prod_id||', '||fila_det.alm_pres_destino||', '||ano_actual||', '||fila_det.cant_uni||', '''|| espacio_tiempo_ejecucion ||''', 0, '||costoUltimoActual||' );';
							EXECUTE sql_insert;
						END IF;
						
						-------------------------------------------------------------------------------------
						--***** SUMAR EXISTENCIA DE PRESENTACIONES EN EL ALMACEN DESTINO******
						--inicializar a cero
						exis := 0;
						
						--buscar Registro de la Presentacion en el Almacen Destino
						SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres 
						WHERE inv_exi_pres.inv_alm_id=fila_det.alm_pres_destino AND inv_exi_pres.inv_prod_id=fila.inv_prod_id AND inv_exi_pres.inv_prod_presentacion_id=fila_det.id_pres_destino 
						INTO exis;
						
						IF exis >0 THEN
							--Sumar existencia de la presentacion
							UPDATE inv_exi_pres SET entradas=(entradas::double precision + fila_det.cant_pres::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id  
							WHERE inv_alm_id = fila_det.alm_pres_destino AND inv_prod_id = fila.inv_prod_id AND inv_prod_presentacion_id = fila_det.id_pres_destino;
						ELSE
							--aqui entra para CREAR registro en inv_exi
							INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
							VALUES(fila_det.alm_pres_destino, fila.inv_prod_id, fila_det.id_pres_destino, fila_det.cant_pres::double precision, espacio_tiempo_ejecucion, usuario_id);
						END IF;
						--**termina actualizar existencia de Presentaciones
						-----------------------------------------------------------------------------------------
					END IF;
				END LOOP;
				
				
				
				--redondear la Suma de Cantidades de la Unidad
				sumaCantUnidad := round(sumaCantUnidad::numeric,noDecUnidad)::double precision;
				
				--inicializar valor a cero
				equivalenciaPres:=0;
				
				--buscar la equivalencia de la Presentacion Origen en la Unidad del Producto
				SELECT cantidad  FROM inv_prod_presentaciones WHERE id=fila.inv_prod_presentacion_id INTO equivalenciaPres;
				
				IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
				
				--convertir la Suma de Unidades en su equivalencia a la Presentacion Origen
				cantPresAsignado := sumaCantUnidad::double precision / equivalenciaPres::double precision;
				
				--redondear la Cantidad de Presentacion Asignado para Re-Envasar
				cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision;
				
				--Estatus 2=En Proceso
				IF str_data[5]::integer=2 THEN 
					--*****AQUI COMIENZA A GENERAR RESERVADOS*******************************************
					--crear reservado en tabla de Existencias(inv_exi)
					UPDATE inv_exi SET reservado=(reservado::double precision + sumaCantUnidad::double precision)::double precision
					WHERE inv_alm_id=fila.inv_alm_id AND inv_prod_id=fila.inv_prod_id AND ano=ano_actual;
					
					--crear reservado en Existecnias de Presentaciones(inv_exi_pres)
					UPDATE inv_exi_pres SET reservado = (reservado::double precision +  cantPresAsignado::double precision)::double precision
					WHERE inv_alm_id=fila.inv_alm_id AND inv_prod_id=fila.inv_prod_id AND inv_prod_presentacion_id=fila.inv_prod_presentacion_id;
					--*****TERMINA GENERACION DE RESERVADOS********************************************
				END IF;
				
				--Estatus 3=Finalizado
				IF str_data[5]::integer=3 THEN 
					--*****AQUI COMIENZA A DESCONTAR EXISTENCIAS DE PRODUCTO RE-ENVASADO******************
					--query para descontar producto de inv_exi
					sql_update := 'UPDATE inv_exi SET 
						salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||sumaCantUnidad||'::double precision), 
						reservado = (reservado::double precision - '||sumaCantUnidad||'::double precision)::double precision,
						momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
					WHERE inv_alm_id='||fila.inv_alm_id||'::integer AND inv_prod_id='||fila.inv_prod_id||' AND ano='||ano_actual;
					EXECUTE sql_update;
					
					--RAISE EXCEPTION '%' ,'sql_update: '||sql_update;
					--Descontar existencia de inv_exi_pres
					UPDATE inv_exi_pres SET 
						salidas=(salidas::double precision + cantPresAsignado::double precision), 
						reservado=(reservado::double precision - cantPresAsignado::double precision), 
						momento_actualizacion=espacio_tiempo_ejecucion, 
						gral_usr_id_actualizacion=usuario_id 
					WHERE inv_alm_id=fila.inv_alm_id AND inv_prod_id=fila.inv_prod_id AND inv_prod_presentacion_id=fila.inv_prod_presentacion_id;
					--termina descontar existencia de presentaciones
					--*****AQUI TERMINA DESCONTAR EXISTENCIAS DE PRODUCTO RE-ENVASADO**************
				END IF;
				
			END IF;--termina generar y descontar Reservados
			
			valor_retorno := '1';
		END IF;--termina editar
		
	END IF;--Termina Aplicativo de Proceso de Re-Envasado	
		
	
	RETURN valor_retorno; 

END;
$$;


--
-- Name: env_bus_aplicativos(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.env_bus_aplicativos(campos_data text) RETURNS SETOF record
    LANGUAGE plpgsql STABLE
    AS $$ 
DECLARE

--√©ste procedimiento es para los buscadores 
--de todos los Aplicativos del Modulo de Envasado
	
	str_data text[];
	app_selected integer;
	usuario_id integer;
	emp_id integer;
	suc_id integer;
	
	sql_query text;
	fila record;
	total_items  int:=0;
	ano_actual integer;
	mes_actual integer;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	
	cadena_where text;
	primer_cond integer;
	f_final character varying;
	exis integer=0;
	
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	--aplicativo seleccionado
	app_selected := str_data[1]::integer;
	usuario_id := str_data[2]::integer;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id;
	
	cadena_where:='';
	primer_cond := 0;
	
	
	--buscador el Aplicativo de Configuracion de Envasado
	IF app_selected = 136 THEN
		--str_data[3]	id_tipo_prod
		--str_data[4]	codigo
		--str_data[5]	descripcion
		--str_data[6]	id_presentacion
		
		IF str_data[3]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND inv_prod.tipo_de_producto_id='||str_data[3];
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ILIKE '''||str_data[5]||'''';
		END IF;
		
		IF str_data[6]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND env_conf.inv_prod_presentacion_id='||str_data[6];
		END IF;
		
		sql_query := '
		SELECT DISTINCT env_conf.id
		FROM env_conf
		JOIN inv_prod ON inv_prod.id=env_conf.inv_prod_id
		JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
		JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=env_conf.inv_prod_presentacion_id
		WHERE env_conf.gral_emp_id='||emp_id||' 
		AND env_conf.borrado_logico=FALSE  '||cadena_where;
		
		--RAISE EXCEPTION '%','sql_query: '||sql_query;
	END IF;	--termina buscador de Configuracion de Envasado
	
	


	--buscador el Aplicativo de Envasado
	IF app_selected = 137 THEN
		--str_data[1] app_selected
		--str_data[2] id_usuario
		--str_data[3] folio
		--str_data[4] codigo
		--str_data[5] descripcion
		--str_data[6] estatus
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND env_env.folio ILIKE '''||str_data[3]||'''';
		END IF;
		IF str_data[6]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND env_env.env_estatus_id='||str_data[6];
		END IF;
		
		sql_query := 'select env.id from (select id, inv_prod_id from env_env where  env_env.gral_emp_id='||emp_id||' AND  borrado_logico=false '||cadena_where||') as env 
			join (select id from inv_prod where sku ilike '''||str_data[4]||''' AND descripcion ilike '''||str_data[5]||''') as product 
			ON product.id=env.inv_prod_id';
		--RAISE EXCEPTION '%','sql_query: '||sql_query;
	END IF; --termina buscador de Envasado
	
	
	--buscador el Aplicativo de Re-Envasado
	IF app_selected = 138 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	almacen
		--str_data[5]	codigo
		--str_data[6]	descripcion
		--str_data[7]	presentacion
		--str_data[8]	empleado
		--str_data[9]	estado
		--str_data[10]	fecha_inicial
		--str_data[11]	fecha_final

		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND env_reenv.folio ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND env_reenv.inv_alm_id='||str_data[4];
		END IF;

		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ILIKE '''||str_data[5]||'''';
		END IF;
		
		IF str_data[6] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ILIKE '''||str_data[6]||'''';
		END IF;
		
		IF str_data[7]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND env_reenv.inv_prod_presentacion_id='||str_data[7];
		END IF;
		
		IF str_data[8]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND env_reenv.gral_empleado_id='||str_data[8];
		END IF;
		
		IF str_data[9]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND env_reenv.env_estatus_id='||str_data[9];
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[10] != '' THEN
			IF str_data[11] = '' THEN
				f_final:=str_data[10];
			ELSE
				f_final:=str_data[11];
			END IF;
			cadena_where:=cadena_where||' AND to_char(env_reenv.fecha::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[10]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := '
		SELECT DISTINCT env_reenv.id 
		FROM  env_reenv
		JOIN inv_prod ON inv_prod.id=env_reenv.inv_prod_id
		WHERE env_reenv.gral_emp_id='||emp_id||' '||cadena_where;
		
		--RAISE EXCEPTION '%','sql_query: '||sql_query;
	END IF;	--termina buscador de Re-Envasado
	
	
	
	
	
	--RAISE EXCEPTION '%',sql_query;
	
	FOR fila IN EXECUTE (sql_query) LOOP
		total_items := 1 + total_items;
		RETURN NEXT fila;
	END LOOP;
	
	IF total_items = 0 THEN
		fila.id:= -1; -- return current row of SELECT
		RETURN NEXT fila;
	END IF;
	
END; 
$$;


--
-- Name: env_validaciones(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.env_validaciones(campos_data text, extra_data text[]) RETURNS text
    LANGUAGE plpgsql
    AS $$
--Procedimiento para validaciones de los Aplicativos del Modulo de Envasado

DECLARE
	
	app_selected integer;
	str_data text[];
	valor_retorno text = '';
	usuario_id integer;
	emp_id integer;
	suc_id integer;
	
	valida_integridad integer;
	match_cadena boolean=false;
	mask_general character varying;
	
	--nuevas variables
	str_filas text[];
	iter_y integer;--contador de filas o posiciones del arreglo (iterador eje y del arreglo iterado)

	--variables para Re-Envasado
	noDecUnidad integer=0;--numero de decimales permitidos para la unidad
	exisActualPres double precision=0;--existencia actual de la presentacion
	equivalenciaPres double precision=0; --equivalencia de la presentacion en la unidad del producto
	cantPresAsignado double precision=0; --Cantidad de Presentacion Asignado para Re-Envasar
	cantUnidadFila double precision=0;
	sumaCantUnidad double precision=0;
	cantPresReservAnterior  double precision=0;
	cantUniReservAnterior double precision=0;
	
	sql_select character varying;
	fila record;
	exis integer:=0;

	
	--variable para prefactura
	total_existencia double precision;
	sql_formula text;
	tipo integer;
	formulacion record;
	cantidad_porcentaje double precision;
	incluye_modulo_produccion boolean;
	cant_reservada_anterior double precision=0;
	incluye_modulo_contabilidad boolean;
	
	
	
	--variables para ordenes de Salida
	existe_lote integer=0;--variable para verificar la existecia de un lote
	id_lote integer=0;--almacena el id del lote
	record1 record;
	id_registro integer=0;
	
	
BEGIN
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- aplicativo que manda a llamar este procedimiento almacenado
	app_selected := str_data[1]::integer;
	
	-- usuario que utiliza el aplicativo
	usuario_id := str_data[3]::integer;
	
	
	
	--RAISE EXCEPTION '%','usuario_id: '||usuario_id;
	
	--obtiene empresa_id, sucursal_id y sucursal_id
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id=usuario_id
	INTO emp_id, suc_id;
	--RAISE EXCEPTION '%','emp_id: '||emp_id;
	
	--query para verificar si la Empresa actual incluye Modulo de Contabilidad
	--SELECT incluye_contabilidad FROM gral_emp WHERE id=emp_id INTO incluye_modulo_contabilidad;
	
	
	--validacion Aplicativo de Configuracion de Envasado
	IF app_selected=136 THEN
		--str_data[4] 	identificador
		--str_data[5] 	producto_id
		--str_data[6] 	select_presentacion
		
		IF str_data[5]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'codigo:Es Necesario selecionar un Producto para configurar su Envasado.___';
		END IF;
		
		IF str_data[6]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'presentacion:Es Necesario selecionar un la Presentaci&oacute;n para configurar el Envase.___';
		END IF;
		
		--aqui buscamos el producto y la presentacion
		SELECT count(id) FROM env_conf 
		WHERE inv_prod_id=str_data[5]::integer AND inv_prod_presentacion_id=str_data[6]::integer  AND gral_emp_id=emp_id  AND borrado_logico=false
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM env_conf 
			WHERE inv_prod_id=str_data[5]::integer AND inv_prod_presentacion_id=str_data[6]::integer AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--validar integridad
			IF str_data[4]::integer != id_registro THEN
				valor_retorno := ''||valor_retorno||'codigo:El producto con esta Presentaci&oacute;n ya tiene configurado un Envase.___';
			END IF;
		END IF;
		
		
		FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
			SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
			--str_filas[1]	eliminado
			--str_filas[2]	notr
			--str_filas[3]	iddetalle
			--str_filas[4]	idprod
			--str_filas[5]	cant
			
			IF str_filas[1]::integer=1 THEN 
				--aqui entra cuando el producto no ha sido eliminado del grid
				IF trim(str_filas[5])='' THEN 
					valor_retorno := ''||valor_retorno||'cant'||str_filas[2]||':Es necesario ingresar la Cantidad.___';
				ELSE
					IF str_filas[5]::double precision<=0 THEN 
						valor_retorno := ''||valor_retorno||'cant'||str_filas[2]||':La Cantidad debe ser mayor que cero.___';
					END IF;
				END IF;
			END IF;
		END LOOP;

		
	END IF;--termina validacion de Aplicativo de Configuracion de Envasado
	
	
	
	

	--validacion de Aplicativo de Proceso de Envasado
	IF app_selected=137 THEN
		valor_retorno := '';
		--str_data[4] identificador
		--str_data[5] producto_id
		--str_data[6] produccion_id
		--str_data[7] fecha
		--str_data[8] hora
		--str_data[9] select_alm_orden_orig
		--str_data[10] select_pres_orden_orig
		--str_data[11] equipo
		--str_data[12] operador
		--str_data[13] merma
		IF str_data[5]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'producto:Es Necesario selecionar el producto a emvasar.___';
		END IF;
		IF str_data[6]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'orden_produccion:Es Necesario selecionar una orde de produccion a envasar.___';
		END IF;
		--str_data[7] fecha inicio
		IF str_data[7]='' OR str_data[7]=' ' THEN
			valor_retorno := ''||valor_retorno||'fecha:Es necesario Ingresar la fecha de inicio.___';
		END IF;
		--str_data[8] hora inicio
		IF str_data[8]='00:00' THEN
			valor_retorno := ''||valor_retorno||'hora:Es necesario Ingresar la Hora de inicio.___';
		END IF;
		IF str_data[9]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'almacen_op:Es Necesario selecionar el almacen de la orden de produccion.___';
		END IF;
		IF str_data[10]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'presentacion_op:Es Necesario selecionar la presentacion de la orden de produccion.___';
		END IF;
		IF trim(str_data[11])='' THEN
			valor_retorno := ''||valor_retorno||'equipo:Es Necesario selecionar la presentacion de la orden de produccion.___';
		END IF;
		
		IF trim(str_data[12])=''  THEN
			valor_retorno := ''||valor_retorno||'operador:Es Necesario selecionar la presentacion de la orden de produccion.___';
		END IF;
		
		IF trim(str_data[13]) = ''  THEN
			valor_retorno := ''||valor_retorno||'merma:Es necesario ingresar la merma.___';
		END IF;
		
		--Valida que una orden de produccion, no haya sido seleccionada antes o este en proceso de envasado.
		IF str_data[2] = 'new' THEN
			select env_estatus_id from pro_orden_prod where id=str_data[6]::integer INTO exis;
			IF exis > 0 THEN
				valor_retorno := ''||valor_retorno||'orden_produccion:La orden de produccion, ya esta en envasado.___';
			END IF;
		END IF;
		
		--Valida que no se pueda finalizar el proceso de envasado, si todavia no se ha finalizado la orden e produccion.
		--Estado 3=Finalizar
		IF str_data[4]::integer=3 THEN
			select pro_proceso_flujo_id from pro_proceso where id=(select pro_proceso_id from pro_orden_prod where id=str_data[6]::integer)  INTO exis;
			IF exis <> 4 THEN
				valor_retorno := ''||valor_retorno||'orden_produccion:La orden de produccion debe estar finalizada para poder terminar el envasado.___';
			END IF;
		END IF;
		--select env_estatus_id from pro_orden_prod where id=str_data[6]::integer;
		
		
		--buscar el numero de decimales de la unidad del producto
		SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
		WHERE inv_prod.id=str_data[5]::integer 
		INTO noDecUnidad;
		IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
		--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
		FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP 
			SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
			--str_filas[1] eliminado
			--str_filas[2] noTr
			--str_filas[3] iddetalle
			--str_filas[4] idprod
			--str_filas[5] select_aml_origen
			--str_filas[6] select_pres_origen
			--str_filas[7] cantpres
			--str_filas[8] cantuni
			--str_filas[9] select_aml_dest
			--str_filas[10] idconf--id de la configuracion de la unidad de medida
			--inicializar en cero
			equivalenciaPres:=0;
			IF str_filas[1]::integer=1 THEN 
				
				--aqui entra cuando el producto no ha sido eliminado del grid
				IF str_filas[9]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'amlDest'||str_filas[2]||':Es necesario seleccionar el Almacen Destino.___';
				END IF;
				IF str_filas[6]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'presDest'||str_filas[2]||':Es necesario seleccionar la Presentaci&oacute;n Destino.___';
				END IF;
				
				IF trim(str_filas[7])='' THEN
					valor_retorno := ''||valor_retorno||'cantPres'||str_filas[2]||':Es necesario ingresar la Cantidad para el Envasado.___';
				ELSE
					IF str_filas[7]::double precision<=0 THEN 
						valor_retorno := ''||valor_retorno||'cantPres'||str_filas[2]||':La Cantidad de la Presentaci&oacute;n para el Envasado debe ser mayor a cero.___';
					ELSE
						--buscar la equivalencia de la Presentacion Destino en la Unidad del Producto 
						SELECT tblpres.cantidad AS equiv_pres FROM env_conf JOIN inv_prod_presentaciones AS tblpres ON tblpres.id=env_conf.inv_prod_presentacion_id 
						WHERE env_conf.id=str_filas[5]::integer 
						INTO equivalenciaPres;
						IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
						--calcular la cantidad de la unidad por Fila
						cantUnidadFila := round(str_filas[7]::numeric,noDecUnidad)::double precision * equivalenciaPres::double precision;
						--redondear la cantidad de la unidad por Fila
						cantUnidadFila := round(cantUnidadFila::numeric,noDecUnidad)::double precision;
						--sumar las cantidades de la unidad de cada Fila
						sumaCantUnidad := sumaCantUnidad + cantUnidadFila;
					END IF;
				END IF;
				
				--validar el almacen de origen del Envase
				IF str_filas[5]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'amlEnv'||str_filas[2]||':Es necesario seleccionar el Almacen Origen del Envase.___';
				ELSE
					--verificar que el campo cantidad no est√© vac√≠o
					IF trim(str_filas[7])!='' THEN
						--verificar que la Cantidad sea mayor que cero
						IF str_filas[7]::double precision>0 THEN 
							--obtiene los componentes del Envase
							sql_select:='
							SELECT 
							env_conf_det.inv_prod_id AS id_prod, 
							inv_prod.sku, 
							env_conf_det.cantidad AS cant_componente, 
							('||str_filas[7]||'::double precision * env_conf_det.cantidad::double precision)::double precision AS cant_a_envasar, 
							inv_prod_unidades.decimales, 
							(CASE WHEN inv_prod.inv_prod_presentacion_id IS NULL THEN 0 ELSE inv_prod.inv_prod_presentacion_id END) AS id_pres_def, 
							env_conf.borrado_logico AS eliminado, 
							inv_prod_presentaciones.cantidad AS equiv, 
							0::double precision AS cant_uni_fila, 
							0::double precision AS cant_reservado_anterior 
							FROM env_conf 
							JOIN env_conf_det ON env_conf_det.env_conf_id=env_conf.id 
							JOIN inv_prod ON inv_prod.id=env_conf_det.inv_prod_id 
							LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
							LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod.inv_prod_presentacion_id 
							WHERE env_conf.id='||str_filas[10]||' AND env_conf.borrado_logico=FALSE;';
							--RAISE EXCEPTION '%','cadena_sql '||sql_select;
							
							FOR fila IN EXECUTE(sql_select) LOOP
								IF fila.decimales IS NULL THEN fila.decimales:=0;  END IF;
								IF fila.id_pres_def IS NULL THEN fila.id_pres_def:=0;  END IF;
								--RAISE EXCEPTION '%','valor_retorno: '||fila.id_pres_def;
								--sku--id_pres_def
								--inicializar valor
								exisActualPres:=0;
								IF fila.eliminado = FALSE THEN
									--RAISE EXCEPTION '%','valor_retorno: '||fila.id_pres_def;
									IF fila.id_pres_def > 0 THEN
										
										--IF str_data[15]::integer=3 THEN
											--buscar la existencia actual en la Presentacion Default del Producto Componente del Envase
											SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis 
											FROM inv_exi_pres  
											WHERE inv_exi_pres.inv_alm_id=str_filas[5]::integer 
											AND inv_exi_pres.inv_prod_id=fila.id_prod 
											AND inv_exi_pres.inv_prod_presentacion_id=fila.id_pres_def 
											INTO exisActualPres;
											IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
											--RAISE EXCEPTION '%','valor_retorno: '||fila.id_prod;
										--END IF;
										
										/*
										--Estado 3=Finalizar
										IF str_data[4]::integer=3 THEN
										--buscar la cantidad reservado anterior
										SELECT cantidad FROM env_reenv_det WHERE id=str_filas[3]::integer 
										INTO fila.cant_reservado_anterior;
										--calcular la cantidad reservada del producto componente
										fila.cant_reservado_anterior:=fila.cant_reservado_anterior::double precision * fila.cant_componente::double precision;
										--sumar la cantidad reservada anterior para tener la existencia real
										exisActualPres = exisActualPres::double precision + fila.cant_reservado_anterior::double precision;
										END IF;
										*/
										--redondear la Existencia Actual de la Presentacion Default del Producto Componente del Envase
										exisActualPres := round(exisActualPres::numeric,fila.decimales)::double precision;
										--redondear la Cantidad necesaria del Producto Componente para realizar le envasado
										fila.cant_a_envasar := round(fila.cant_a_envasar::numeric,fila.decimales)::double precision;
										--validar si la Cantidad Asignada para Envasar es mayor que la Existencia Actual de la Presentacion Origen
										IF fila.cant_a_envasar::double precision > exisActualPres::double precision THEN 
											valor_retorno := ''||valor_retorno||'amlEnv'||str_filas[2]||':El Producto='||fila.sku||', componente del Envase no tiene existencia suficiente para realizar el Envasado.___';
										END IF;
									ELSE
										valor_retorno := ''||valor_retorno||'amlEnv'||str_filas[2]||':El Producto='||fila.sku||', componente del Envase no tiene Presentaci&oacute;n Default. Es necesario Asignar uno en el Cat&aacute;logo de Productos.___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'amlEnv'||str_filas[2]||':La configuraci&oacute;n del Envase ha sido eliminado.___';
								END IF;
							END LOOP;
						END IF;
					END IF;
				END IF;
			END IF;
		END LOOP;
		--RAISE EXCEPTION '%','sumaCantUnidad: '||sumaCantUnidad;
		
		--inicializar valor a cero
		equivalenciaPres:=0;
		
		--buscar la equivalencia de la Presentacion Origen en la Unidad del Producto
		/*
		SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_data[11]::integer 
		INTO equivalenciaPres;
		IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
		--inicializar valor
		exisActualPres:=0;
		--buscar la existencia actual de la presentacion
		SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis 
		FROM inv_exi_pres  
		WHERE inv_exi_pres.inv_alm_id=str_data[9]::integer 
		AND inv_exi_pres.inv_prod_id=str_data[10]::integer 
		AND inv_exi_pres.inv_prod_presentacion_id=str_data[11]::integer 
		INTO exisActualPres;
		IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
		--redondear la Existencia Actual de la Presentacion Origen
		exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;
		--Estado 3=Finalizar
		IF str_data[15]::integer=3 THEN
		--buscar la cantidad en Unidades, reservado anterior
		SELECT round(sum(cant_uni)::numeric,noDecUnidad)::double precision AS cant_uni
		FROM (
		SELECT round((env_env_det.cantidad * inv_prod_presentaciones.cantidad)::numeric,inv_prod_unidades.decimales) as cant_uni
		FROM env_reenv_det JOIN env_conf ON env_conf.id=env_reenv_det.env_conf_id JOIN inv_prod ON inv_prod.id=env_conf.inv_prod_id LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=env_conf.inv_prod_presentacion_id LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
		WHERE env_reenv_det.env_reenv_id=str_data[4]::integer
		) AS sbt
		INTO cantUniReservAnterior;
		--redondear la Suma de Cantidades de la Unidad reservada Anterior
		cantUniReservAnterior := round(cantUniReservAnterior::numeric,noDecUnidad)::double precision; 
		--calcular la cantidad en Presentaciones reservada anterior
		cantPresReservAnterior:=cantUniReservAnterior::double precision / equivalenciaPres::double precision;
		--sumar la cantidad reservada anterior para tener la existencia real
		exisActualPres = exisActualPres::double precision + cantPresReservAnterior::double precision;
		END IF;
		--redondear la Suma de Cantidades de la Unidad
		sumaCantUnidad := round(sumaCantUnidad::numeric,noDecUnidad)::double precision;
		--convertir la Suma de Unidades en su equivalencia a la Presentacion Origen
		cantPresAsignado := sumaCantUnidad::double precision / equivalenciaPres::double precision;
		--redondear la Cantidad de Presentacion Asignado para Re-Envasar
		cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision;
		--validar si la Cantidad Asignada para Re-Envasar es mayor que la Existencia Actual de la Presentacion Origen
		IF cantPresAsignado::double precision > exisActualPres::double precision THEN 
			valor_retorno := ''||valor_retorno||'exispres:La cantidad Asignada para Envasar es mayor que la Existencia Actual.SALTOLINEAExistencia Actual='||exisActualPres||'SALTOLINEAAsignada para Re-Envasar='||cantPresAsignado||'___';
		END IF;
		*/
		--RAISE EXCEPTION '%','cantPresAsignado:'||cantPresAsignado::double precision||'       exisActualPres:'||exisActualPres::double precision;
	END IF;--termina validacion de Aplicativo de Proceso de Envasado




	
	--validacion de Aplicativo de Proceso de Re-Envasado
	IF app_selected=138 THEN
		--str_data[4] 	identificador
		--str_data[5] 	select_estatus
		--str_data[6] 	fecha
		--str_data[7] 	hora
		--str_data[8] 	select_empleado
		--str_data[9] 	select_almacen_orig
		--str_data[10] 	producto_id
		--str_data[11] 	select_presentacion_orig
		--str_data[12] 	exis_pres
		--str_data[13] 	disp_pres
		
		--str_data[7] hora inicio
		IF str_data[7]='00:00' THEN
			valor_retorno := ''||valor_retorno||'hora:Es necesario Ingresar la Hora de inicio.___';
		END IF;
		
		IF str_data[8]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'empleado:Es Necesario selecionar el Empleado que realizar&aacute; el proceso de Re-Envasado.___';
		END IF;
		
		IF str_data[9]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'almacenorig:Es Necesario selecionar el Almacen de Origen para el Re-Envasado.___';
		END IF;
		
		IF str_data[10]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'codigo:Es Necesario selecionar el Producto a Re-Envasar.___';
		END IF;
		
		IF str_data[11]::integer=0  THEN
			valor_retorno := ''||valor_retorno||'presentacionorig:Es Necesario selecionar la Presentaci&oacute;n a Re-Envasar.___';
		END IF;
		
		--buscar el numero de decimales de la unidad del producto
		SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
		WHERE inv_prod.id=str_data[10]::integer 
		INTO noDecUnidad;
		
		IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
		--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
		
		FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
			SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
			--str_filas[1]	eliminado
			--str_filas[2]	notr
			--str_filas[3]	iddetalle
			--str_filas[4]	select_aml_dest
			--str_filas[5]	idEnv
			--str_filas[6]	cantpres
			--str_filas[7]	select_aml_envase
			
			--inicializar en cero
			equivalenciaPres:=0;
			
			IF str_filas[1]::integer=1 THEN 
				--aqui entra cuando el producto no ha sido eliminado del grid
				IF str_filas[4]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'amlDest'||str_filas[2]||':Es necesario seleccionar el Almacen Destino.___';
				END IF;
				
				IF str_filas[5]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'presDest'||str_filas[2]||':Es necesario seleccionar la Presentaci&oacute;n Destino.___';
				END IF;
				
				IF trim(str_filas[6])='' THEN
					valor_retorno := ''||valor_retorno||'cantPres'||str_filas[2]||':Es necesario ingresar la Cantidad para el Re-Envasado.___';
				ELSE
					IF str_filas[6]::double precision<=0 THEN 
						valor_retorno := ''||valor_retorno||'cantPres'||str_filas[2]||':La Cantidad de la Presentaci&oacute;n para el Re-Envasado debe ser mayor a cero.___';
					ELSE
						--buscar la equivalencia de la Presentacion Destino en la Unidad del Producto
						SELECT tblpres.cantidad AS equiv_pres FROM env_conf JOIN inv_prod_presentaciones AS tblpres ON tblpres.id=env_conf.inv_prod_presentacion_id
						WHERE env_conf.id=str_filas[5]::integer 
						INTO equivalenciaPres;
						
						IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
						
						--calcular la cantidad de la unidad por Fila
						cantUnidadFila := round(str_filas[6]::numeric,noDecUnidad)::double precision * equivalenciaPres::double precision;
						
						--redondear la cantidad de la unidad por Fila
						cantUnidadFila := round(cantUnidadFila::numeric,noDecUnidad)::double precision;
						
						--sumar las cantidades de la unidad de cada Fila
						sumaCantUnidad := sumaCantUnidad + cantUnidadFila;
					END IF;
				END IF;
				
				--validar el almacen de origen del Envase
				IF str_filas[7]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'amlEnv'||str_filas[2]||':Es necesario seleccionar el Almacen Origen del Envase.___';
				ELSE
					--verificar que el campo cantidad no est√© vac√≠o
					IF trim(str_filas[6])!='' THEN
						--verificar que la Cantidad sea mayor que cero
						IF str_filas[6]::double precision>0 THEN 
							--obtiene los componentes del Envase
							sql_select:='
							SELECT 
								env_conf_det.inv_prod_id AS id_prod, 
								inv_prod.sku,
								env_conf_det.cantidad AS cant_componente,
								('||str_filas[6]||'::double precision * env_conf_det.cantidad::double precision)::double precision AS cant_a_envasar,
								inv_prod_unidades.decimales,
								(CASE WHEN inv_prod.inv_prod_presentacion_id IS NULL THEN 0 ELSE inv_prod.inv_prod_presentacion_id END) AS id_pres_def, 
								env_conf.borrado_logico AS eliminado,
								inv_prod_presentaciones.cantidad AS equiv,
								0::double precision AS cant_uni_fila,
								0::double precision AS cant_reservado_anterior 
							FROM env_conf
							JOIN env_conf_det ON env_conf_det.env_conf_id=env_conf.id
							JOIN inv_prod ON inv_prod.id=env_conf_det.inv_prod_id
							LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
							LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod.inv_prod_presentacion_id
							WHERE env_conf.id='||str_filas[5]||' AND env_conf.borrado_logico=FALSE;';
							
							--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
							FOR fila IN EXECUTE(sql_select) LOOP
								
								IF fila.decimales IS NULL THEN fila.decimales:=0;  END IF;
								IF fila.id_pres_def IS NULL THEN fila.id_pres_def:=0;  END IF;
								--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
								
								--inicializar valor
								exisActualPres:=0;
								
								IF fila.eliminado = FALSE THEN
									IF fila.id_pres_def > 0 THEN
										--buscar la existencia actual en la Presentacion Default del Producto Componente del Envase
										SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis 
										FROM inv_exi_pres  
										WHERE inv_exi_pres.inv_alm_id=str_filas[7]::integer 
										AND inv_exi_pres.inv_prod_id=fila.id_prod 
										AND inv_exi_pres.inv_prod_presentacion_id=fila.id_pres_def
										INTO exisActualPres;
										
										IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
										
										--Estado 3=Finalizar
										IF str_data[5]::integer=3 THEN
											--buscar la cantidad reservado anterior
											SELECT cantidad FROM env_reenv_det WHERE id=str_filas[3]::integer 
											INTO fila.cant_reservado_anterior;
											
											--calcular la cantidad reservada del producto componente
											fila.cant_reservado_anterior:=fila.cant_reservado_anterior::double precision * fila.cant_componente::double precision;
											
											--sumar la cantidad reservada anterior para tener la existencia real
											exisActualPres = exisActualPres::double precision + fila.cant_reservado_anterior::double precision;
										END IF;
										
										--redondear la Existencia Actual de la Presentacion Default del Producto Componente del Envase
										exisActualPres := round(exisActualPres::numeric,fila.decimales)::double precision;
										
										--redondear la Cantidad necesaria del Producto Componente para realizar le envasado
										fila.cant_a_envasar := round(fila.cant_a_envasar::numeric,fila.decimales)::double precision;
										
										--validar si la Cantidad Asignada para Re-Envasar es mayor que la Existencia Actual de la Presentacion Origen
										IF fila.cant_a_envasar::double precision > exisActualPres::double precision THEN 
											valor_retorno := ''||valor_retorno||'amlEnv'||str_filas[2]||':El Producto='||fila.sku||', componente del Envase no tiene existencia suficiente para realizar el Envasado.___';
										END IF;
										
									ELSE
										valor_retorno := ''||valor_retorno||'amlEnv'||str_filas[2]||':El Producto='||fila.sku||', componente del Envase no tiene Presentaci&oacute;n Default. Es necesario Asignar uno en el Cat&aacute;logo de Productos.___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'amlEnv'||str_filas[2]||':La configuraci&oacute;n del Envase ha sido eliminado.___';
								END IF;
								
							END LOOP;
						END IF;
					END IF;
				END IF;
			END IF;
		END LOOP;
		
		--RAISE EXCEPTION '%','sumaCantUnidad: '||sumaCantUnidad;
		
		--inicializar valor a cero
		equivalenciaPres:=0;
		
		--buscar la equivalencia de la Presentacion Origen en la Unidad del Producto
		SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_data[11]::integer 
		INTO equivalenciaPres;
		
		IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
		
		--inicializar valor
		exisActualPres:=0;
		
		--buscar la existencia actual de la presentacion
		SELECT (inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis 
		FROM inv_exi_pres  
		WHERE inv_exi_pres.inv_alm_id=str_data[9]::integer 
		AND inv_exi_pres.inv_prod_id=str_data[10]::integer 
		AND inv_exi_pres.inv_prod_presentacion_id=str_data[11]::integer 
		INTO exisActualPres;
		
		IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
		
		--redondear la Existencia Actual de la Presentacion Origen
		exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;
		
		
		--Estado 3=Finalizar
		IF str_data[5]::integer=3 THEN
			--buscar la cantidad en Unidades, reservado anterior
			SELECT round(sum(cant_uni)::numeric,noDecUnidad)::double precision AS cant_uni
			FROM (
				SELECT round((env_reenv_det.cantidad * inv_prod_presentaciones.cantidad)::numeric,inv_prod_unidades.decimales) as cant_uni
				FROM env_reenv_det JOIN env_conf ON env_conf.id=env_reenv_det.env_conf_id JOIN inv_prod ON inv_prod.id=env_conf.inv_prod_id LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=env_conf.inv_prod_presentacion_id LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
				WHERE env_reenv_det.env_reenv_id=str_data[4]::integer
			) AS sbt
			INTO cantUniReservAnterior;
			--RAISE EXCEPTION '%','cantUniReservAnterior: '||cantUniReservAnterior;
			--redondear la Suma de Cantidades de la Unidad reservada Anterior
			cantUniReservAnterior := round(cantUniReservAnterior::numeric,noDecUnidad)::double precision; 
			
			--convertir la cantidad en Presentaciones reservada anterior
			cantPresReservAnterior:=cantUniReservAnterior::double precision / equivalenciaPres::double precision;
			
			--sumar la cantidad reservada anterior para tener la existencia real
			exisActualPres = exisActualPres::double precision + cantPresReservAnterior::double precision;
		END IF;
		
		--redondear la Suma de Cantidades de la Unidad
		sumaCantUnidad := round(sumaCantUnidad::numeric,noDecUnidad)::double precision;
		
		--convertir la Suma de Unidades en su equivalencia a la Presentacion Origen
		cantPresAsignado := sumaCantUnidad::double precision / equivalenciaPres::double precision;
		
		--redondear la Cantidad de Presentacion Asignado para Re-Envasar
		cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision;
		
		--validar si la Cantidad Asignada para Re-Envasar es mayor que la Existencia Actual de la Presentacion Origen
		IF cantPresAsignado::double precision > exisActualPres::double precision THEN 
			valor_retorno := ''||valor_retorno||'exispres:La cantidad Asignada para Re-Envasar es mayor que la Existencia Actual.SALTOLINEAExistencia Actual='||exisActualPres||'SALTOLINEAAsignada para Re-Envasar='||cantPresAsignado||'___';
		END IF;
		
		--RAISE EXCEPTION '%','cantPresAsignado:'||cantPresAsignado::double precision||'       exisActualPres:'||exisActualPres::double precision;
	END IF;--termina validacion de Aplicativo de Proceso de Re-Envasado

	
	
	
	
	
	
	IF valor_retorno = '' THEN
		valor_retorno := 'true';
		RETURN valor_retorno;
	ELSE
		RETURN valor_retorno;
	END IF;
	
END;

$$;


--
-- Name: erp_fn_agregar_ceros(character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_agregar_ceros(consecutivo character varying, num integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$ 

DECLARE
	ceros text;
BEGIN
	SELECT INTO ceros lpad(consecutivo, num, '0');
	
	RETURN  ceros;

END;

$$;


--
-- Name: erp_fn_aplicativo_cotizacions_acciones(integer, text, character varying, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_aplicativo_cotizacions_acciones(identificador integer, campos_data text, accion character varying, arreglo text[]) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE


filares	record;
str_data text[];
str_filas text[];
total_filas integer;--total de elementos de arreglo
cont_fila integer;--contador de filas o posiciones del arreglo
valor_retorno integer = 0;

foliocotizacion character varying;--folio de la cotizacion
ultimo_id_cotizacion integer;
ultimo_id_proceso integer;

BEGIN
	foliocotizacion := '';
	
	--RAISE EXCEPTION '%',arreglo[1];
	
	IF accion = 'new' THEN
		SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[1] 	id_cliente
		--str_data[2]	observaciones
		--str_data[3]	id_usuario
		
		--obtener el nuevo consecutivo del folio de cotizacion
		SELECT INTO foliocotizacion erp_fn_obtener_consecutivo from erp_fn_obtener_consecutivo('folio_cotizacion');

		--crea registro en tabla erp_proceso y retorna el id del registro creado
		INSERT INTO  erp_proceso(proceso_flujo_id)VALUES(1) RETURNING id into ultimo_id_proceso;
		
		--crear registro en la tabla cotizacions
		 INSERT INTO  erp_cotizacions(
			  folio,
			  cliente_id,
			  status_id,
			  usuario_id,
			  observaciones,
			  proceso_id,
			  momento_creacion
		)
		VALUES(
			  foliocotizacion,
			  str_data[1]::integer,--id_cliente
			  1,
			  str_data[3]::integer,--id_usuario
			  str_data[2],--observaciones
			  ultimo_id_proceso,--id de la tabla proceso
			  now()
		) RETURNING id into ultimo_id_cotizacion;
		
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		cont_fila:=1;
		FOR cont_fila IN 1 .. total_filas LOOP
			SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
			
			--str_filas[1] eliminado
			IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
				--str_filas[2]	iddetalle
				--str_filas[3]	idproducto
				--str_filas[4]	id_presentacion
				--str_filas[5]	id_impuesto
				--str_filas[6]	cantidad
				--str_filas[7]	costo
				--str_filas[8]	monedagrid
				
				--crea registros para tabla invfisico-detalles
				INSERT INTO erp_cotizacions_detalles(
					  cotizacions_id,
					  producto_id,
					  presentacion_id,
					  tipo_impuesto_id,
					  cantidad,
					  precio_unitario,
					  moneda_id,
					  momento_creacion
				)VALUES(
					  ultimo_id_cotizacion,
					  str_filas[3]::integer,
					  str_filas[4]::integer,
					  str_filas[5]::integer,
					  str_filas[6]::double precision,
					  str_filas[7]::double precision,
					  str_filas[8]::integer,--id_moneda
					  now()
				);
			END IF;
		END LOOP;
		valor_retorno = 1;
	END IF;
	
	
	
	
	IF accion = 'edit' THEN
		SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[1] 	id_cliente
		--str_data[2]	observaciones
		--str_data[3]	id_usuario
		
		UPDATE erp_cotizacions SET cliente_id = str_data[1]::integer, 
					observaciones = str_data[2], 
					status_id=1,
					usuario_id=str_data[3]::integer,
					momento_actualizacion = now()
		WHERE id = identificador;
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		cont_fila:=1;
		FOR cont_fila IN 1 .. total_filas LOOP
			SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
			
			--str_filas[1] 0:eliminado, 1:no eliminado
			IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
				--str_filas[2]	iddetalle
				--str_filas[3]	idproducto
				--str_filas[4]	id_presentacion
				--str_filas[5]	id_impuesto
				--str_filas[6]	cantidad
				--str_filas[7]	costo
				--str_filas[8]	monedagrid
				
				--verifica si trae un id. Este id es el id del registro en la tabla cotizacions_detalles
				IF str_filas[2] !='0' THEN
					--RAISE EXCEPTION '%','No es nuevo';
					--actualiza registros en la tabla invfisico-detalles
					UPDATE erp_cotizacions_detalles SET cantidad = str_filas[6]::double precision,
						precio_unitario = str_filas[7]::double precision,
						moneda_id = str_filas[8]::integer,--id_moneda
						tipo_impuesto_id = str_filas[5]::integer
					WHERE  id = str_filas[2]::integer  AND cotizacions_id = identificador;
				ELSE
					--RAISE EXCEPTION '%','Este si es nuevo es nuevo: '||str_filas[2];
					--crea nuevos registros
					INSERT INTO erp_cotizacions_detalles(cotizacions_id,producto_id,presentacion_id,tipo_impuesto_id,cantidad,precio_unitario,moneda_id,momento_creacion)
					VALUES(identificador,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::integer,str_filas[6]::double precision,str_filas[7]::double precision,str_filas[8]::integer,now());
				END IF;
			ELSE
				--elimina registro que se elimino en el grid
				DELETE FROM erp_cotizacions_detalles where id = str_filas[2]::integer  AND cotizacions_id = identificador;
			END IF;
		END LOOP;
		
		valor_retorno = 1;
	END IF;




	
	
	IF accion = 'delete' THEN
		UPDATE erp_cotizacions SET borrado_logico = true, momento_baja = now()  where id = identificador;
		valor_retorno = 1;
	END IF;
	
	RETURN valor_retorno;
	
END;
$$;


--
-- Name: erp_fn_aplicativo_empleado_acciones(integer, text, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_aplicativo_empleado_acciones(identificador integer, campos_data text, accion character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE


str_data text[];
valor_retorno integer = 0;
sex boolean;
caducidadActiva boolean;
activ boolean;
id_empleado integer;

BEGIN
	sex:=false;
	caducidadActiva:=false;
	activ:=false;
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	IF str_data[20]::integer!=0 THEN
		sex:=true;
	END IF;
	IF str_data[34] ilike 'on' THEN
		caducidadActiva:=true;
	END IF;
	IF str_data[36] ilike 'on' THEN
		activ:=true;
	END IF;
	IF accion = 'new' THEN
		--SELECT INTO str_data string_to_array(''||upper(campos_data)||'','___');
		INSERT INTO erp_empleados(nombre_pila,apellido_paterno,apellido_materno,imss,infonavit,curp,rfc,fecha_nacimiento,fecha_ingreso,escolaridad_id,sexo,civil_id,religion_id,telefono,movil,correo_personal,pais,entidad,localidad,calle,numero,colonia,cp,contacto_emergencia,telefono_emergencia,sangretipo_id,enfermedades,alergias,comentarios,momento_creacion) VALUES (str_data[2],str_data[4],str_data[3],str_data[23],str_data[21],str_data[11],str_data[26],str_data[19]::date,str_data[18]::date,str_data[16]::integer,sex,str_data[17]::integer,str_data[25]::integer,str_data[28],str_data[22],str_data[9],str_data[13],str_data[14],str_data[15],str_data[5],str_data[24],str_data[6],str_data[10],str_data[8],str_data[27],str_data[29]::integer,str_data[12]::text,str_data[7]::text,str_data[30]::text,now());
		
		EXECUTE 'select id from empleados order by id desc limit 1;' INTO id_empleado;
		
		INSERT INTO erp_emails(titulo,palabra_clave,caducidad_activa,caducidad,activo,empleado_id,momento_creacion) VALUES(str_data[31],str_data[32],caducidadActiva,str_data[35]::date,activ,id_empleado,now());
		
		valor_retorno = 1;
	END IF;
	
	IF accion = 'edit' THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--RAISE EXCEPTION '%',str_data[1];
		--RAISE EXCEPTION '%',identificador;
		UPDATE erp_empleados SET 
			nombre_pila = str_data[2]::character varying,
			apellido_paterno = str_data[4]::character varying,
			apellido_materno = str_data[3]::character varying,
			imss = str_data[23]::character varying,
			infonavit = str_data[21]::character varying,
			curp = str_data[11]::character varying,
			rfc = str_data[26]::character varying,
			fecha_nacimiento = str_data[19]::date,
			fecha_ingreso = str_data[18]::date,
			escolaridad_id = str_data[16]::integer,
			sexo = sex,
			civil_id = str_data[17]::integer,
			religion_id = str_data[25]::integer,
			telefono = str_data[28]::character varying,
			movil = str_data[22]::character varying,
			correo_personal = str_data[9]::character varying,
			pais = str_data[13]::character varying,
			entidad = str_data[14]::character varying,
			localidad = str_data[15]::character varying,
			calle = str_data[5]::character varying,
			numero = str_data[24]::character varying,
			colonia = str_data[6]::character varying,
			cp = str_data[10]::character varying,
			contacto_emergencia = str_data[8]::character varying,
			telefono_emergencia = str_data[27]::character varying,
			sangretipo_id = str_data[29]::integer,
			enfermedades = str_data[12]::text,
			alergias = str_data[7]::text,
			comentarios = str_data[30]::text,
			momento_actualizacion = now()
		WHERE id=identificador::integer;
		UPDATE erp_emails SET 
			titulo = str_data[31]::character varying,
			palabra_clave = str_data[32]::character varying,
			caducidad_activa = caducidadActiva,
			caducidad = str_data[35]::date,
			activo = Activo,
			empleado_id = identificador::integer,
			momento_actualizacion = now()
		WHERE empleado_id = str_data[1]::integer;
		valor_retorno = 1;
	END IF;
	
	IF accion = 'delete' THEN

		UPDATE erp_empleados SET borrado_logico=true, momento_baja=now() WHERE id = identificador::integer;
		
		UPDATE erp_emails SET borrado_logico=true, momento_baja=now() WHERE empleado_id = identificador::integer;
		valor_retorno = 1;
	END IF;
	
	
	RETURN valor_retorno;
	
END;$$;


--
-- Name: erp_fn_aplicativo_traspasomercancias_acciones(character varying, text, character varying, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_aplicativo_traspasomercancias_acciones(identificador character varying, campos_data text, accion character varying, arreglo text[]) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE


filares	record;
str_data text[];
str_filas text[];
total_filas integer;--total de elementos de arreglo
cont_fila integer;--contador de filas o posiciones del arreglo
valor_retorno integer = 0;

consecutivo_lote character varying;

numero_entrada character varying;
lote character varying;
costo_unitario double precision;
pedimento_aduanal character varying;
proveedor integer;
f_caducidad date;
cant double precision;
fila character varying;
columna character varying;
anaquel character varying;
id_producto integer;
id_presentacion integer;
sql_busqueda character varying;
cantExis integer;
cantTraspaso double precision;
folio_tras character varying;
almacen_origen integer; --almacena el almacen origen, se utiliza en traspaso de almacen a almacen
BEGIN
	numero_entrada := '';
	lote := '';
	--costo_unitario :=0;
	pedimento_aduanal := '';
	--proveedor :=0;
	--cant :=0;
	fila := '';
	columna := '';
	anaquel := '';
	sql_busqueda:='';
	
	IF accion = 'new' THEN
		SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[1] tipotraspaso
		--str_data[2] no_entrada
		--str_data[3] observaciones
		--RAISE EXCEPTION '%','Tipo traspaso: '||str_data[1];
		
		--obtener el nuevo consecutivo del folio para historico_traspasos
		SELECT INTO folio_tras erp_fn_obtener_consecutivo from erp_fn_obtener_consecutivo('folio_historico_traspaso');
		
		
		IF str_data[1]::integer = 1 THEN
			--traspaso de prealmacen a erp_invfisico

			--crear registro en la tabla historico_traspasos
			INSERT INTO  erp_historico_traspasos(folio,tipo,no_entrada,observaciones,momento_creacion)
			VALUES(folio_tras,str_data[1]::integer,str_data[2],str_data[3],now());

			
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				EXECUTE 'SELECT erp_prealmacen_entradas.no_entrada,
					erp_prealmacen_entradas_detalle.numero_lote,
					inv_prod.id,
					erp_prealmacen_entradas_detalle.presentacion_id,
					erp_prealmacen_entradas_detalle.costo_unitario,
					erp_prealmacen_entradas_detalle.pedimento_aduanal,
					erp_prealmacen_entradas.proveedor_id,
					erp_prealmacen_entradas_detalle.fecha_caducidad,
					erp_prealmacen_entradas_detalle.cantidad
				FROM erp_prealmacen_entradas
				LEFT JOIN erp_prealmacen_entradas_detalle ON erp_prealmacen_entradas_detalle.no_entrada = erp_prealmacen_entradas.no_entrada
				LEFT JOIN inv_prod ON inv_prod.id = erp_prealmacen_entradas_detalle.producto_id
				WHERE erp_prealmacen_entradas.no_entrada = '''||str_data[2]||''' AND erp_prealmacen_entradas_detalle.numero_lote = '''||str_filas[1]||'''' INTO numero_entrada,lote,id_producto,id_presentacion,costo_unitario,pedimento_aduanal,proveedor,f_caducidad,cant;
				
				--crear registros en la tabla erp_invfisico
				INSERT INTO erp_invfisico(no_entrada,numero_lote,producto_id,presentacion_id,costo,pedimento,proveedor_id,fecha_caducidad,momento_creacion) 
				VALUES(numero_entrada,lote,id_producto,id_presentacion,costo_unitario,pedimento_aduanal,proveedor,f_caducidad,now());
				
				--str_filas[1] lote
				--str_filas[2] cantidad
				--str_filas[3] origen
				--str_filas[4] destino
				
				--str_filas[7];	anaquel
				--str_filas[8];	columna
				--str_filas[9];	fila
				--str_filas[10];disponible
				
				--crea registros para tabla erp_invfisico-detalles
				INSERT INTO erp_invfisico_detalles(numero_lote,ubicacion_fila,ubicacion_columna,ubicacion_anaquel,cantidad,almacen_id,momento_creacion) 
				VALUES (lote,str_filas[9],str_filas[8],str_filas[7],cant,str_filas[4]::integer,now());
				
				--crea registros para la tabla  erp_historico_traspasos_detalles
				INSERT INTO erp_historico_traspasos_detalles( folio_traspaso,numero_lote,producto_id,presentacion_id,cantidad,almacen_destino_id,ubicacion_fila,ubicacion_columna,ubicacion_anaquel,disponible,momento_creacion)
				VALUES(folio_tras,lote,id_producto,id_presentacion,cant,str_filas[4]::integer,str_filas[9],str_filas[8],str_filas[7],0,now());
				
			END LOOP;
			--cambia a estado 0, significa que ya se traspaso a erp_invfisico
			UPDATE erp_prealmacen_entradas SET estado = 0, momento_actualizacion = now()  where no_entrada = numero_entrada;
		ELSE
			--traspaso de almacen a almacen
			--crear registro en la tabla historico_traspasos
			INSERT INTO  erp_historico_traspasos(folio,tipo,no_entrada,observaciones,momento_creacion)
			VALUES(folio_tras,str_data[1]::integer,str_data[2],str_data[3],now());
			
			--RAISE EXCEPTION '%','traspaso de almacen a almacen';
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1] 	lote		''
				--str_filas[2] 	cantidad	1
				--str_filas[3] 	origen		1
				--str_filas[4] 	destino		1
				--str_filas[5] 	idproducto	2
				--str_filas[6] 	eliminado	
				
				--str_filas[7]	anaquel
				--str_filas[8]	columna
				--str_filas[9]	fila
				--str_filas[10] disponible
				
				--str_filas[6] eliminado
				IF str_filas[6]::integer != 0 THEN--1: no esta eliminado, 0:eliminado	
					
					almacen_origen:=str_filas[3]::integer;--aqui se toma el id del almacen origen
					
					--esta es la cantidad a traspasar
					cantTraspaso:=str_filas[2]::double precision;
					
					sql_busqueda:='SELECT  erp_invfisico_detalles.almacen_id,
						erp_invfisico.producto_id,
						erp_invfisico.presentacion_id,
						erp_invfisico_detalles.numero_lote,
						erp_invfisico_detalles.cantidad
					FROM erp_invfisico_detalles
					LEFT JOIN erp_invfisico on erp_invfisico.numero_lote = erp_invfisico_detalles.numero_lote
					WHERE erp_invfisico_detalles.numero_lote = '''||str_filas[1]||''' AND erp_invfisico_detalles.almacen_id ='|| str_filas[3]::integer;
					
					--RAISE EXCEPTION '%',sql_busqueda;
					
					FOR filares IN EXECUTE (sql_busqueda) LOOP
						--verifica si ya existe el numero de lote en el almacen destino
						SELECT sum(erp_invfisico_detalles.cantidad) 
						FROM erp_invfisico_detalles 
						WHERE erp_invfisico_detalles.almacen_id = str_filas[4]::integer 
						AND erp_invfisico_detalles.numero_lote = filares.numero_lote INTO cantExis;
						
						--RAISE EXCEPTION '%','cantExis: '||cantExis;
						IF cantTraspaso >= filares.cantidad THEN
							IF(cantExis != null OR cantExis > 0)THEN
								UPDATE erp_invfisico_detalles SET cantidad = (cantExis + filares.cantidad), momento_actualizacion = now() WHERE almacen_id = str_filas[4]::integer AND numero_lote = filares.numero_lote;
							ELSE
								INSERT INTO erp_invfisico_detalles(numero_lote,cantidad,almacen_id,ubicacion_anaquel,ubicacion_columna,ubicacion_fila,momento_creacion) 
								VALUES(filares.numero_lote,filares.cantidad,str_filas[4]::integer,str_filas[7],str_filas[8],str_filas[9],now());
							END IF;
							
							UPDATE erp_invfisico_detalles SET cantidad = 0, momento_actualizacion = now()  WHERE almacen_id = filares.almacen_id AND numero_lote = filares.numero_lote;
							
							--crea registros para la tabla  erp_historico_traspasos_detalles
							INSERT INTO erp_historico_traspasos_detalles( 
							folio_traspaso,
							numero_lote,
							producto_id,
							presentacion_id,
							cantidad,
							almacen_destino_id,
							ubicacion_fila,
							ubicacion_columna,
							ubicacion_anaquel,
							disponible,
							momento_creacion)
							VALUES(
							folio_tras,
							filares.numero_lote,
							filares.producto_id,
							filares.presentacion_id,
							filares.cantidad,
							str_filas[4]::integer,
							str_filas[9],
							str_filas[8],
							str_filas[7],
							str_filas[10]::double precision,
							now());
							
							cantTraspaso:= cantTraspaso - filares.cantidad;
						ELSE
							
							IF cantTraspaso > 0 THEN
								IF(cantExis != null OR cantExis>0)THEN
									UPDATE erp_invfisico_detalles SET cantidad = (cantExis + cantTraspaso), momento_actualizacion = now() WHERE almacen_id = str_filas[4]::integer AND numero_lote = filares.numero_lote;
								ELSE
									INSERT INTO erp_invfisico_detalles(numero_lote,cantidad,almacen_id,ubicacion_anaquel,ubicacion_columna,ubicacion_fila,momento_creacion) 
									VALUES(filares.numero_lote,cantTraspaso,str_filas[4]::integer,str_filas[7],str_filas[8],str_filas[9],now());
								END IF;
								
								UPDATE erp_invfisico_detalles SET cantidad = (filares.cantidad - cantTraspaso), momento_actualizacion = now()  WHERE almacen_id = filares.almacen_id AND numero_lote = filares.numero_lote;
								
								--crea registros para la tabla  erp_historico_traspasos_detalles
								INSERT INTO erp_historico_traspasos_detalles( 
								folio_traspaso,
								numero_lote,
								producto_id,
								presentacion_id,
								cantidad,
								almacen_destino_id,
								ubicacion_fila,
								ubicacion_columna,
								ubicacion_anaquel,
								disponible,
								momento_creacion)
								VALUES(
								folio_tras,
								filares.numero_lote,
								filares.producto_id,
								filares.presentacion_id,
								cantTraspaso,
								str_filas[4]::integer,
								str_filas[9],
								str_filas[8],
								str_filas[7],
								str_filas[10]::double precision,
								now());
								
								cantTraspaso:= 0;
							END IF;
							EXIT;
							
						END IF;
						
					END LOOP;
					
				END IF;
				
			END LOOP;
			
			--aqui se le asigna el almacen al registro creado antes del FOR
			--antes del FOR no se conocia el almacen origen
			UPDATE erp_historico_traspasos SET almacen_id = almacen_origen  WHERE folio = folio_tras;
			
		END IF;
		valor_retorno = 1;
	END IF;
	
	
	
	IF accion = 'delete' THEN
		--DELETE FROM  erp_prealmacen_entradas where no_entrada = identificador;
		--DELETE FROM  erp_prealmacen_entradas_detalle where no_entrada = identificador;
		--UPDATE erp_prealmacen_entradas SET borrado_logico = true, momento_baja = now  where no_entrada = identificador;
		valor_retorno = 1;
	END IF;
	
	RETURN valor_retorno;
	
END;$$;


--
-- Name: erp_fn_buscador_cotizacions(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_buscador_cotizacions(folio character varying, cliente character varying, fecha_inicial character varying, fecha_final character varying) RETURNS SETOF record
    LANGUAGE plpgsql STABLE
    AS $$ 
DECLARE


sql_busqueda_cotizacions text;
fila             record;
total_items     int:=0;
cadena_where text;
f_final character varying;
primer_cond integer;
BEGIN

	cadena_where:='';
	primer_cond := 0;
	
	IF folio != '%%' THEN
		cadena_where:= cadena_where ||' AND erp_cotizacions.folio ilike  '''||folio||'''';
	END IF;
	
	IF cliente != '%%' THEN
		cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||cliente||'''';
	END IF;
	

	--busqueda por fecha creacion
	IF fecha_inicial != '' THEN
		IF fecha_final = '' THEN
			f_final:=fecha_inicial;
		ELSE
			f_final:=fecha_final;
		END IF;
		cadena_where:=cadena_where||' AND to_char(erp_cotizacions.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
	END IF;

	
	sql_busqueda_cotizacions := 'SELECT DISTINCT erp_cotizacions.id FROM erp_cotizacions 
				LEFT JOIN cxc_clie on cxc_clie.id = erp_cotizacions.cliente_id  
				WHERE erp_cotizacions.borrado_logico=false '||cadena_where;
	
	
	FOR fila IN EXECUTE (sql_busqueda_cotizacions) LOOP
		total_items := 1 + total_items;
		RETURN NEXT fila;
	END LOOP;
	
	IF total_items = 0 THEN
		fila.id:= -1; -- return current row of SELECT
		RETURN NEXT fila;
	END IF;

   --RETURN ;

END; 
$$;


--
-- Name: erp_fn_buscador_traspasomercancias(character varying, integer, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_buscador_traspasomercancias(folio character varying, tipo_traspaso integer, almacen integer, fecha_inicial character varying, fecha_final character varying) RETURNS SETOF record
    LANGUAGE plpgsql STABLE
    AS $$ 
DECLARE


sql_busqueda_traspasos text;
fila             record;
total_items     int:=0;
cadena_where text;
f_final character varying;
primer_cond integer;
BEGIN

	cadena_where:='';
	primer_cond := 0;
	
	IF folio != '%%%' THEN
		IF primer_cond=0 THEN
			cadena_where:= cadena_where ||' WHERE folio ilike  '''||folio||'''';
			primer_cond := 1;
		ELSE
			cadena_where:= cadena_where ||' AND folio ilike  '''||folio||'''';
		END IF;
	END IF;

	IF tipo_traspaso != 0 THEN
		IF primer_cond=0 THEN
			cadena_where:= cadena_where ||' WHERE tipo = '||tipo_traspaso;
			primer_cond := 1;
		ELSE
			cadena_where:= cadena_where ||' AND tipo = '||tipo_traspaso;
		END IF;
	END IF;

	IF almacen != 0 THEN
		IF primer_cond=0 THEN
			cadena_where:= cadena_where ||' WHERE almacen_id = '||almacen;
			primer_cond := 1;
		ELSE
			cadena_where:= cadena_where ||' AND almacen_id = '||almacen;
		END IF;
	END IF;

	--busqueda por fecha creacion
	IF fecha_inicial != '' THEN
		IF fecha_final = '' THEN
			f_final:=fecha_inicial;
		ELSE
			f_final:=fecha_final;
		END IF;
		IF primer_cond=0 THEN
			cadena_where:=cadena_where||' WHERE to_char(momento_creacion, ''yyyymmdd'')::integer between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
			primer_cond := 1;
		ELSE
			cadena_where:=cadena_where||' AND to_char(momento_creacion, ''yyyymmdd'')::integer between (to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
	END IF;

	
	sql_busqueda_traspasos := 'select DISTINCT folio as id from erp_historico_traspasos '||cadena_where;


	FOR fila IN EXECUTE (sql_busqueda_traspasos) LOOP
		total_items := 1 + total_items;
		RETURN NEXT fila;
	END LOOP;
	
	IF total_items = 0 THEN
		fila.id:= -1; -- return current row of SELECT
		RETURN NEXT fila;
	END IF;

   --RETURN ;

END; 
$$;


--
-- Name: erp_fn_obtener_consecutivo(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_obtener_consecutivo(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$

DECLARE

	valor_retorno       character varying:= NULL;
	ultimo_consecutivo  character varying:= NULL;
	cadena_extra        character varying:= NULL;


BEGIN
	--obtiene ultimo consecutivo
	SELECT consecutivo FROM erp_consecutivos INTO ultimo_consecutivo WHERE secuencia ILIKE ''|| $1 ||'';

	IF NOT FOUND THEN
		RAISE EXCEPTION 'secuencia no disponible: %', ultimo_consecutivo;
	ELSE
		--sumar 1 al ultimo consecutivo y actualizar
		IF $1 = 'numero_entrada_mercancia' THEN
			UPDATE erp_consecutivos
			SET consecutivo = (ultimo_consecutivo::integer + 1)::character varying,
			    momento_actualizacion = now()
			WHERE secuencia ILIKE ''|| $1 ||'';
			cadena_extra := '';
		END IF;
		--sumar 1 al ultimo consecutivo y actualizar
		IF $1 = 'numero_lote' THEN
			UPDATE erp_consecutivos
			SET consecutivo = (ultimo_consecutivo::integer + 1)::character varying,
			    momento_actualizacion = now()
			WHERE secuencia ILIKE ''|| $1 ||'';
			cadena_extra := '';
		END IF;

		--sumar 1 al ultimo consecutivo y actualizar
		IF $1 = 'folio_historico_traspaso' THEN
			UPDATE erp_consecutivos
			SET consecutivo = (ultimo_consecutivo::integer + 1)::character varying,
			    momento_actualizacion = now()
			WHERE secuencia ILIKE ''|| $1 ||'';
			cadena_extra := '';
		END IF;


		--sumar 1 al ultimo consecutivo y actualizar
		IF $1 = 'folio_cotizacion' THEN
			UPDATE erp_consecutivos
			SET consecutivo = (ultimo_consecutivo::integer + 1)::character varying,
			    momento_actualizacion = now()
			WHERE secuencia ILIKE ''|| $1 ||'';
			cadena_extra := '';
		END IF;

		--sumar 1 al ultimo consecutivo y actualizar
		IF $1 = 'numero_control_cliente' THEN
			UPDATE erp_consecutivos
			SET consecutivo = (ultimo_consecutivo::integer + 1)::character varying,
			    momento_actualizacion = now()
			WHERE secuencia ILIKE ''|| $1 ||'';
			cadena_extra := 'K';
		END IF;

		--sumar 1 al ultimo consecutivo y actualizar
		IF $1 = 'sku_producto' THEN
			UPDATE erp_consecutivos
			SET consecutivo = (ultimo_consecutivo::integer + 1)::character varying,
			    momento_actualizacion = now()
			WHERE secuencia ILIKE ''|| $1 ||'';
			cadena_extra := 'P';
		END IF;

		--sumar 1 al ultimo consecutivo y actualizar
		IF $1 = 'folio_numero_transaccion' THEN
			UPDATE erp_consecutivos
			SET consecutivo = (ultimo_consecutivo::integer + 1)::character varying,
			    momento_actualizacion = now()
			WHERE secuencia ILIKE ''|| $1 ||'';
			cadena_extra := '';
		END IF;


		
		--UPDATE consecutivos SET momento_actualizacion = now() where secuencia ILIKE ''|| $1 ||'';
		
		--obtengo el consecutivo ya actualizado
		SELECT consecutivo FROM erp_consecutivos INTO valor_retorno	WHERE secuencia ILIKE ''|| $1 ||'';
	
	END IF;

	RETURN cadena_extra || valor_retorno;

END;

$_$;


--
-- Name: erp_fn_salva_datos_factura(character varying, character varying, character varying, character varying, double precision, double precision, character varying, character varying, character varying, character varying, character varying, character varying, character varying, text, text, text, integer, integer, integer, double precision, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_salva_datos_factura(rfc_receptor character varying, serie_factura character varying, folio_factura character varying, no_aprobacion character varying, total_operacion double precision, tot_imp_trasladados double precision, edo_comprobante character varying, xml_file_name character varying, fecha_expedicion character varying, razon_social_receptor character varying, tipo_comp character varying, propos character varying, ano_probacion character varying, cadena_conceptos text, cadena_imp_trasladados text, cadena_imp_retenidos text, prefact_id integer, id_usuario integer, id_moneda integer, tipo_cam double precision, refact character varying, reg_fiscal character varying, met_pago character varying, num_cuenta character varying, lugar_de_expedicion character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	id_cliente integer;
	factura character varying;
	total_factura double precision;
	tipo_de_cambio  double precision = 0.0;
	fecha_facturacion timestamp with time zone;
	id_proceso integer;
	id_factura integer;
	ultimo_id integer;
	emp_id integer;
	suc_id integer;
	id_almacen integer;
	cadena_sql text;
	sql_select character varying='';
	sql_update text;
	cadena_sql_formula text;
	--variables para movimientos en existencias
	bandera_tipo_4 boolean;--bandera que identifica si el producto es tipo 4, true=tipo 4, false=No es tipo4
	prefactura_detalle record;
	prefactura record;
	formulacion record;
	fila_fac_rem_doc record;
	identificador_nuevo_movimiento integer = 0;
	tipo_movimiento_id integer=0;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	observaciones_prefactura text = '';
	cantidad_porcentaje double precision;
	id_fac_doc integer;
	
	tipo_documento integer =0;--1=Factura, 2=Remision, 3=factura de Remision
	
	ano_actual integer;
	mes_actual integer;
	
	numero_dias_credito integer=0;
	fecha_de_vencimiento timestamp with time zone;
	id_agente integer =0;
	costo_promedio_actual double precision=0;

	id_tipo_consecutivo integer=0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
	id_osal integer = 0;
	facpar record;--parametros de Facturacion

	cantPresAsignado double precision=0;
	cantPresReservAnterior double precision=0;
	
	controlExisPres boolean; --Variable que indica  si se debe controlar Existencias por Presentacion
	partida_facturada boolean;--Variable que indica si la cantidad de la partida ya fue facturada en su totalidad
	actualizar_proceso boolean; --Indica si hay que actualizar el flujo del proceso. El proceso se debe actualizar cuando ya no quede partidas vivas
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--obtiene empresa_id y sucursal_id
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id
  	FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id=id_usuario
	INTO emp_id, suc_id;
	
	--Obtener parametros para la facturacion
	SELECT * FROM fac_par WHERE gral_suc_id=suc_id INTO facpar;

	--query para verificar si la Empresa actual incluye control de Existencias por Presentacion
	SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
	
	--tomar el id del almacen para ventas
	--id_almacen := facpar.inv_alm_id;
	
	IF id_moneda=1 THEN
		tipo_de_cambio:=1;
	ELSE 
		tipo_de_cambio:=tipo_cam;
	END IF;
	
	--actualizamos la moneda, tipo_cambio y obtenemos id_cliente,total_factura, id_proceso
	UPDATE erp_prefacturas SET moneda_id=id_moneda, tipo_cambio=tipo_de_cambio, refacturar=FALSE  WHERE id = prefact_id
	RETURNING cliente_id, fac_total,proceso_id,observaciones,empleado_id, inv_alm_id INTO id_cliente,total_factura,id_proceso, observaciones_prefactura, id_agente, id_almacen;
	
	--crea registro en fac_cfds
	INSERT INTO fac_cfds(
		rfc_cliente,
		serie,
		folio_del_comprobante_fiscal,
		numero_de_aprobacion,
		monto_de_la_operacion,
		monto_del_impuesto,
		estado_del_comprobante,
		nombre_archivo,
		momento_expedicion,
		razon_social,
		tipo_comprobante,
		proposito,
		anoaprovacion, 
		serie_folio, 
		conceptos, 
		impuestos_trasladados, 
		impuestos_retenidos, 
		regimen_fiscal, 
		metodo_pago, 
		numero_cuenta, 
		lugar_expedicion,
		id_user_crea,
		empresa_id,
		sucursal_id,
		proceso_id
	    ) VALUES(
		rfc_receptor,
		serie_factura,
		folio_factura,
		no_aprobacion,
		total_operacion,
		tot_imp_trasladados,
		edo_comprobante,
		xml_file_name,
		fecha_expedicion,
		razon_social_receptor,
		tipo_comp,
		propos,
		ano_probacion,
		serie_factura||folio_factura,
		cadena_conceptos,
		cadena_imp_trasladados,
		cadena_imp_retenidos,
		reg_fiscal,
		met_pago,
		num_cuenta,
		lugar_de_expedicion,
		id_usuario,
		emp_id,
		suc_id,
		id_proceso
	) RETURNING id,serie_folio,momento_expedicion INTO id_factura,factura,fecha_facturacion;
	
	
	
	
	
	cadena_sql:='SELECT * FROM erp_prefacturas WHERE id='||prefact_id||' LIMIT 1';
	FOR prefactura IN EXECUTE(cadena_sql) LOOP
		
		tipo_documento := prefactura.tipo_documento;
		
		SELECT dias FROM cxc_clie_credias WHERE id=prefactura.terminos_id INTO numero_dias_credito;
		
		--calcula la fecha de vencimiento a partir de la fecha de la factura
		SELECT (to_char(fecha_facturacion,'yyyy-mm-dd')::DATE + numero_dias_credito)::timestamp with time zone AS fecha_vencimiento INTO fecha_de_vencimiento;
		
		--crea registros en la tabla fac_docs
		INSERT INTO fac_docs(serie_folio,folio_pedido,cxc_clie_id,moneda_id,subtotal,impuesto,monto_retencion,total,tipo_cambio,tasa_retencion_immex, proceso_id,cxc_agen_id,terminos_id,orden_compra,observaciones, fac_metodos_pago_id, no_cuenta, enviar_ruta, momento_creacion,gral_usr_id_creacion,fecha_vencimiento, inv_alm_id, cxc_clie_df_id)
		VALUES(factura,prefactura.folio_pedido,prefactura.cliente_id,prefactura.moneda_id, prefactura.fac_subtotal, prefactura.fac_impuesto, prefactura.fac_monto_retencion, prefactura.fac_total, prefactura.tipo_cambio, prefactura.tasa_retencion_immex,prefactura.proceso_id,prefactura.empleado_id,prefactura.terminos_id,prefactura.orden_compra,prefactura.observaciones,prefactura.fac_metodos_pago_id, prefactura.no_cuenta,prefactura.enviar_ruta,fecha_facturacion,id_usuario,fecha_de_vencimiento, id_almacen, prefactura.cxc_clie_df_id)
		RETURNING id INTO id_fac_doc;
		
		--crea registro en erp_h_facturas
		INSERT INTO erp_h_facturas(cliente_id,serie_folio,monto_total,saldo_factura,moneda_id,tipo_cambio,momento_facturacion,id_usuario_creacion, empresa_id, sucursal_id, cxc_agen_id, fecha_vencimiento, subtotal, impuesto, retencion, orden_compra)
		VALUES(id_cliente,factura,total_factura,total_factura,id_moneda,tipo_de_cambio,fecha_facturacion,id_usuario, emp_id, suc_id, id_agente, fecha_de_vencimiento, prefactura.fac_subtotal, prefactura.fac_impuesto, prefactura.fac_monto_retencion, prefactura.orden_compra);
		/*
		prefactura_fila.fac_subtotal,
		prefactura_fila.fac_impuesto,
		prefactura_fila.fac_monto_retencion,
		prefactura_fila.fac_total,
		*/
		--tipo_documento 3=Facturacion de remision
		IF prefactura.tipo_documento = 3 THEN 
			--buscar numero de remision que se incluyeron en esta factura
			sql_select:='SELECT DISTINCT fac_rem_id FROM fac_rems_docs WHERE erp_proceso_id = '||id_proceso;
			
			FOR fila_fac_rem_doc IN EXECUTE(sql_select) LOOP
				--asignar facturado a cada remision
				UPDATE fac_rems SET facturado=TRUE WHERE id=fila_fac_rem_doc.fac_rem_id;
				
			END LOOP;
		END IF;
		
	END LOOP;
	
	
	--bandera que identifica si el producto es tipo 4
	--si es tipo 4 no debe existir movimientos en inventario
	bandera_tipo_4=TRUE;
	tipo_movimiento_id:=5;--Salida por Venta
	id_tipo_consecutivo:=21; --Folio Orden de Salida

	--Bandera que indica si se debe actualizar el flujo del proceso.
	--El proceso solo debe actualizarse cuando no quede ni una sola partida viva
	actualizar_proceso:=true;
	
	--refact=false:No es refacturacion
	--tipo_documento=1:Factura
	IF refact='false' AND tipo_documento=1 THEN
		--aqui entra para tomar el consecutivo del folio  la sucursal actual
		UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
		WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
		
		--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
		nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
		
		--genera registro en tabla inv_osal(Orden de Salida)
		INSERT INTO inv_osal(folio,estatus,erp_proceso_id,inv_mov_tipo_id,tipo_documento,folio_documento,fecha_exp,gral_app_id,cxc_clie_id,inv_alm_id,subtotal,monto_iva,monto_retencion,monto_total,folio_pedido,orden_compra,moneda_id,tipo_cambio,momento_creacion,gral_usr_id_creacion, gral_emp_id, gral_suc_id)
		VALUES(nuevo_folio,0,prefactura.proceso_id,tipo_movimiento_id,tipo_documento,factura,fecha_facturacion,13,prefactura.cliente_id,id_almacen, prefactura.fac_subtotal, prefactura.fac_impuesto, prefactura.fac_monto_retencion, prefactura.fac_total, prefactura.folio_pedido,prefactura.orden_compra,prefactura.moneda_id,prefactura.tipo_cambio,espacio_tiempo_ejecucion,id_usuario, emp_id, suc_id)
		RETURNING id INTO id_osal;
		
		-- el aplicativo de prefacturas es el numero 13
		--genera registro del movimiento
		INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id, gral_app_id,inv_mov_tipo_id, referencia, fecha_mov ) 
		VALUES(observaciones_prefactura,espacio_tiempo_ejecucion,id_usuario,13, tipo_movimiento_id, factura, fecha_facturacion) 
		RETURNING id INTO identificador_nuevo_movimiento;
	END IF;
	
	
	--obtiene lista de productos de la prefactura
	cadena_sql:='
		SELECT  erp_prefacturas_detalles.id AS id_det,
			erp_prefacturas_detalles.producto_id,
			erp_prefacturas_detalles.presentacion_id,
			erp_prefacturas_detalles.cantidad AS cant_pedido,
			erp_prefacturas_detalles.cant_facturado,
			erp_prefacturas_detalles.cant_facturar AS cantidad,
			erp_prefacturas_detalles.tipo_impuesto_id,
			erp_prefacturas_detalles.valor_imp,
			erp_prefacturas_detalles.precio_unitario,
			inv_prod.tipo_de_producto_id as tipo_producto,
			erp_prefacturas_detalles.costo_promedio,
			erp_prefacturas_detalles.reservado,
			erp_prefacturas_detalles.reservado AS nuevo_reservado,
			(CASE WHEN inv_prod_presentaciones.id IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
			(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec 
		FROM erp_prefacturas_detalles 
		JOIN inv_prod ON inv_prod.id=erp_prefacturas_detalles.producto_id
		LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
		LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=erp_prefacturas_detalles.presentacion_id 
		WHERE erp_prefacturas_detalles.cant_facturar>0 
		AND erp_prefacturas_detalles.prefacturas_id='||prefact_id;
	--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
	
	FOR prefactura_detalle IN EXECUTE(cadena_sql) LOOP
		--Inicializar valores
		cantPresReservAnterior:=0;
		cantPresAsignado:=0;
		partida_facturada:=false;
		
		--tipo_documento 3=Factura de remision
		IF tipo_documento = 3 THEN 
			--toma el costo promedio que viene de la prefactura
			costo_promedio_actual := prefactura_detalle.costo_promedio;
		ELSE
			--obtener costo promedio actual del producto
			SELECT * FROM inv_obtiene_costo_promedio_actual(prefactura_detalle.producto_id, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
		END IF;

		--Redondear cantidades
		prefactura_detalle.cant_pedido := round(prefactura_detalle.cant_pedido::numeric,prefactura_detalle.no_dec)::double precision;
		prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
		prefactura_detalle.cantidad := round(prefactura_detalle.cantidad::numeric,prefactura_detalle.no_dec)::double precision;
		prefactura_detalle.reservado := round(prefactura_detalle.reservado::numeric,prefactura_detalle.no_dec)::double precision;
		prefactura_detalle.nuevo_reservado := round(prefactura_detalle.nuevo_reservado::numeric,prefactura_detalle.no_dec)::double precision;
		
		IF (prefactura_detalle.cantidad::double precision <= prefactura_detalle.reservado::double precision) THEN 
			--Asignar la cantidad para descontar de reservado
			prefactura_detalle.reservado := prefactura_detalle.cantidad::double precision;
		END IF;
		
		--Calcular la nueva cantidad reservada
		prefactura_detalle.nuevo_reservado := prefactura_detalle.nuevo_reservado::double precision - prefactura_detalle.reservado::double precision;
		
		--Redondaer la nueva cantidad reservada
		prefactura_detalle.nuevo_reservado := round(prefactura_detalle.nuevo_reservado::numeric,prefactura_detalle.no_dec)::double precision;
		
		
		--crea registro en fac_docs_detalles
		INSERT INTO fac_docs_detalles(fac_doc_id,inv_prod_id, inv_prod_presentacion_id, gral_imptos_id, valor_imp, cantidad,precio_unitario, costo_promedio)
		VALUES(id_fac_doc,prefactura_detalle.producto_id,prefactura_detalle.presentacion_id,prefactura_detalle.tipo_impuesto_id,prefactura_detalle.valor_imp, prefactura_detalle.cantidad,prefactura_detalle.precio_unitario, costo_promedio_actual);
		
		IF refact='false' AND tipo_documento=1 THEN
			
			--Si el tipo de producto es diferente de 4, hay que descontar existencias y generar Movimientos
			--tipo=4 Servicios
			--para el tipo servicios debe NO debe generar movimientos NI descontar existencias
			IF prefactura_detalle.tipo_producto!=4 THEN
				
				bandera_tipo_4=FALSE;--indica que por lo menos un producto es diferente de tipo4, por lo tanto debe generarse movimientos
				
				--tipo=1 Normal o Terminado
				--tipo=2 Subensable o Formulacion o Intermedio
				--tipo=5 Refacciones
				--tipo=6 Accesorios
				--tipo=7 Materia Prima
				--tipo=8 Prod. en Desarrollo
				IF prefactura_detalle.tipo_producto=1 OR prefactura_detalle.tipo_producto=2 OR prefactura_detalle.tipo_producto=5 OR prefactura_detalle.tipo_producto=6 OR prefactura_detalle.tipo_producto=7 OR prefactura_detalle.tipo_producto=8 THEN
					--genera registro en detalles del movimiento
					INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id, costo, inv_prod_presentacion_id)
					VALUES(prefactura_detalle.producto_id, id_almacen,0, prefactura_detalle.cantidad, identificador_nuevo_movimiento, costo_promedio_actual, prefactura_detalle.presentacion_id);
					
					--query para descontar producto de existencias
					sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||prefactura_detalle.cantidad||'::double precision), 
					reservado=(reservado::double precision - '||prefactura_detalle.reservado||'::double precision), momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
					WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||prefactura_detalle.producto_id||' AND ano='||ano_actual;
					EXECUTE sql_update;
					
					--crear registro en orden salida detalle
					INSERT INTO inv_osal_detalle(inv_osal_id,cantidad,precio_unitario,inv_prod_id,inv_prod_presentacion_id)
					VALUES(id_osal,prefactura_detalle.cantidad,prefactura_detalle.precio_unitario,prefactura_detalle.producto_id,prefactura_detalle.presentacion_id);

					
					--Verificar si se est√° llevando el control de existencias por Presentaciones
					IF controlExisPres=true THEN 
						--Si la configuracion indica que se validan Presentaciones desde el Pedido,entonces significa que hay reservados, por lo tanto hay que descontarlos
						IF facpar.validar_pres_pedido=true THEN 
							--Convertir la cantidad reservada a su equivalente en presentaciones
							cantPresReservAnterior := prefactura_detalle.reservado::double precision / prefactura_detalle.cant_equiv::double precision;
							
							--redondear la Cantidad de la Presentacion reservada Anteriormente
							cantPresReservAnterior := round(cantPresReservAnterior::numeric,prefactura_detalle.no_dec)::double precision; 
						END IF;
						
						--Convertir la cantidad de la partida a su equivalente a presentaciones
						cantPresAsignado := prefactura_detalle.cantidad::double precision / prefactura_detalle.cant_equiv::double precision;
						
						--Redondear la cantidad de Presentaciones asignado en la partida
						cantPresAsignado := round(cantPresAsignado::numeric,prefactura_detalle.no_dec)::double precision;
						
						--Sumar salidas de inv_exi_pres
						UPDATE inv_exi_pres SET 
							salidas=(salidas::double precision + cantPresAsignado::double precision), reservado=(reservado::double precision - cantPresReservAnterior::double precision), 
							momento_actualizacion=fecha_facturacion, gral_usr_id_actualizacion=id_usuario 
						WHERE inv_alm_id=id_almacen AND inv_prod_id=prefactura_detalle.producto_id AND inv_prod_presentacion_id=prefactura_detalle.presentacion_id;
						--Termina sumar salidas
					END IF;
					
					
					--::Aqui inica calculos para el control de facturacion por partida::::::::
					--Calcular la cantidad facturada
					prefactura_detalle.cant_facturado:=prefactura_detalle.cant_facturado::double precision + prefactura_detalle.cantidad::double precision;
					
					--Redondear la cantidad facturada
					prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
					
					IF prefactura_detalle.cant_pedido <= prefactura_detalle.cant_facturado THEN 
						partida_facturada:=true;
					ELSE
						--Si entro aqui quiere decir que por lo menos una partida esta quedando pendiente de facturar por completo.
						actualizar_proceso:=false;
					END IF;
					
					--Actualizar el registro de la partida de Prefacturas detalles
					UPDATE erp_prefacturas_detalles SET cant_facturado=prefactura_detalle.cant_facturado, facturado=partida_facturada, cant_facturar=0, reservado=prefactura_detalle.nuevo_reservado 
					WHERE id=prefactura_detalle.id_det;
					
					--Obtener el id del pedido que se esta facturando
					SELECT id FROM poc_pedidos WHERE folio=prefactura.folio_pedido ORDER BY id DESC LIMIT 1 INTO ultimo_id;
					
					IF ultimo_id IS NULL THEN ultimo_id:=0; END IF;
					
					IF ultimo_id<>0 THEN 
						--Actualizar el registro detalle del Pedido
						UPDATE poc_pedidos_detalle SET reservado=prefactura_detalle.nuevo_reservado 
						WHERE poc_pedido_id=ultimo_id AND inv_prod_id=prefactura_detalle.producto_id AND presentacion_id=prefactura_detalle.presentacion_id;
					END IF;
					
				END IF;--termina tipo producto 1,2,7
				
			END IF;
		END IF; --termina if que verifica si es refacturacion
		
	END LOOP;
	
	IF bandera_tipo_4=TRUE THEN 
		IF refact='false' AND tipo_documento=1 THEN
			--la factura es de un producto tipo 4, por lo tanto se elimina el movimiento generado anteriormente
			DELETE FROM inv_mov WHERE id=identificador_nuevo_movimiento;
		END IF;
	END IF;
	
	
	--Verificar si hay que actualizar el flujo del proceso
	IF actualizar_proceso THEN 
		--Actualiza el flujo del proceso a 3=Facturado
		UPDATE erp_proceso SET proceso_flujo_id=3 WHERE id=id_proceso;
	ELSE
		--Actualiza el flujo del proceso a 7=FACTURA PARCIAL
		UPDATE erp_proceso SET proceso_flujo_id=7 WHERE id=id_proceso;
	END IF;
	
	--Una vez terminado el Proceso se asignan ceros a estos campos
	UPDATE erp_prefacturas SET fac_subtotal=0, fac_impuesto=0, fac_monto_retencion=0, fac_total=0
	WHERE id=prefact_id::integer;
	
	IF tipo_comp='FAC' THEN 
		--Aqu√≠ se actualiza el Consecutivo del Folio de la Factura. √âsta actualizacion es por empresa-sucursal
		UPDATE fac_cfds_conf_folios SET folio_actual=(folio_actual+1) WHERE id=(SELECT fac_cfds_conf_folios.id FROM fac_cfds_conf JOIN fac_cfds_conf_folios ON fac_cfds_conf_folios.fac_cfds_conf_id=fac_cfds_conf.id WHERE fac_cfds_conf_folios.proposito='FAC' AND fac_cfds_conf.empresa_id=emp_id AND fac_cfds_conf.gral_suc_id=suc_id);
	END IF;
	
	IF tipo_comp='NCR' THEN 
		--Aqu√≠ se actualiza el Consecutivo del Folio de la Nota de credito. √âsta actualizacion es por empresa-sucursal
		UPDATE fac_cfds_conf_folios SET folio_actual=(folio_actual+1) WHERE id=(SELECT fac_cfds_conf_folios.id FROM fac_cfds_conf JOIN fac_cfds_conf_folios ON fac_cfds_conf_folios.fac_cfds_conf_id=fac_cfds_conf.id WHERE fac_cfds_conf_folios.proposito='NCR' AND fac_cfds_conf.empresa_id=emp_id AND fac_cfds_conf.gral_suc_id=suc_id);
	END IF;

	IF tipo_comp='NCA' THEN 
		--Aqu√≠ se actualiza el Consecutivo del Folio de la Nota de Cargo. √âsta actualizacion es por empresa-sucursal
		UPDATE fac_cfds_conf_folios SET folio_actual=(folio_actual+1) WHERE id=(SELECT fac_cfds_conf_folios.id FROM fac_cfds_conf JOIN fac_cfds_conf_folios ON fac_cfds_conf_folios.fac_cfds_conf_id=fac_cfds_conf.id WHERE fac_cfds_conf_folios.proposito='NCA' AND fac_cfds_conf.empresa_id=emp_id AND fac_cfds_conf.gral_suc_id=suc_id);
	END IF;
	
	
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: erp_fn_validaciones_dir_consignacion_cliente(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_validaciones_dir_consignacion_cliente(campos_data text) RETURNS text
    LANGUAGE plpgsql
    AS $_$DECLARE


str_data text[];
valor_retorno text = '';

match_cadena boolean=false;

mask_general character varying;

BEGIN

	SELECT INTO str_data string_to_array(''||campos_data||'','___');


	--str_data[1] pais
	IF str_data[1]::integer = 0 THEN
		valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar un Pais___';
	END IF;

	--str_data[2] entidad
	IF str_data[2]::integer = 0 THEN
		valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar una Entidad___';
	END IF;
	
	--str_data[3] localidad
	IF str_data[3]::integer = 0 THEN
		valor_retorno := ''||valor_retorno||'localidad:Es necesario seleccionar una Localidad___';
	END IF;
	
	--str_data[4] calle
	EXECUTE 'select '''||str_data[4]||''' ~ ''.{1,50}$'';' INTO match_cadena;
	IF match_cadena = false THEN
		valor_retorno := ''||valor_retorno||'calle:Nombre de Calle No Valido___';
	END IF;
	
	--str_data[5] numero
	EXECUTE 'select '''||str_data[5]||''' ~ ''[A-Za-z0-9]{1,5}'';' INTO match_cadena;
	IF match_cadena = false THEN
		valor_retorno := ''||valor_retorno||'numero:Numero No Valido___';
	END IF;
	
	--str_data[6] colonia
	EXECUTE 'select '''||str_data[6]||''' ~ ''.{1,60}$'';' INTO match_cadena;
	IF match_cadena = false THEN
		valor_retorno := ''||valor_retorno||'colonia:Nombre de colonia no valido___';
	END IF;
	
	--str_data[7] cp
	EXECUTE 'select '''||str_data[7]||''' ~ ''^[0-9]{5}$'';' INTO match_cadena;
	IF match_cadena = false THEN
		valor_retorno := ''||valor_retorno||'cp:Codigo postal no valido, debe ser de 5 digitos___';
	END IF;
	
	--str_data[8] telefono
	EXECUTE 'select '''||str_data[8]||''' ~ ''^[0-9]{8,10}$'';' INTO match_cadena;
	IF match_cadena = false THEN
		valor_retorno := ''||valor_retorno||'telefono:Numero telefonico No Valido, debe ser de 8 a 10 digitos___';
	END IF;
	
	--str_data[9] localternativa
	--str_data[10] fax

	--RAISE EXCEPTION '%','Fax: '||str_data[10];
	--FAX, utiliza la misma mascara que telefono
	IF str_data[10]!='' THEN
		EXECUTE 'select '''||str_data[10]||''' ~ ''^[0-9]{8,10}$'';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'fax:Numero de fax No Valido, debe ser de 8 a 10 digitos___';
		END IF;
	END IF;




	IF valor_retorno = '' THEN
		valor_retorno := 'true';
		RETURN valor_retorno;
	ELSE
		RETURN valor_retorno;
	END IF;
	
END;$_$;


--
-- Name: erp_fn_validaciones_por_aplicativo(text, integer, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.erp_fn_validaciones_por_aplicativo(campos_data text, id_app integer, arreglo text[]) RETURNS text
    LANGUAGE plpgsql
    AS $_$

DECLARE

	espacio_tiempo_ejecucion timestamp with time zone := now();
	ano_actual integer:=0;
	mes_actual integer:=0;
	str_data text[];
	valor_retorno text := '';
	valor_retorno2 text := '';
	valor_retorno3 text := '';
	usuario_id integer;
	command_selected character varying:='';
	emp_id integer;
	suc_id integer;
	facpar record;--parametros de Facturacion
	
	valida_integridad integer;
	match_cadena boolean=false;
	
	titulo_mask character varying;
	adrdress_num_mask character varying;
	cp_mask character varying;
	colonia_mask character varying;
	calle_mask character varying;
	mask_general character varying;
	
	--nuevas variables
	str_filas text[];
	total_filas integer;--total de elementos de arreglo
	cont_fila integer;--contador de filas o posiciones del arreglo
	--Estas  se utilizan para la nomina
	str_percep text[];
	str_deduc text[];
	str_hrs_extras text[];
	str_incapa text[];
	
	str_filas2 text[];
	total_filas2 integer;--total de elementos de arreglo
	cont_fila2 integer;--contador de filas o posiciones del arreglo

	id_banco integer;
	
	--variable de entradas de mercancia
	numero_entrada character varying;
	fecha_caducidad character varying;
	
	--variable para prefactura
	total_existencia double precision;
	sql_formula text;
	tipo integer;
	formulacion record;
	cantidad_porcentaje double precision;
	cant_reservada_anterior double precision:=0;
	incluye_modulo_produccion boolean;
	incluye_modulo_contabilidad boolean;
	empresa_transportista boolean;
	--Indica si incluye nomina
	incluye_nomina  boolean:=false;
	--Variable que indica si se debe controlar las existencias por presentaciones
	controlExisPres boolean := false;
	--Veriable para indicar si debe validar la asignacion de lista de precio a los clientes
	validaListaPrecioCliente boolean:=false;
	cambiaUnidadMedida boolean:=false;
	
	
	tiene_pagos integer:=0;
	
	--Orden produccion subensamble
	ids_subensamble character varying :='';
	sql_select text;
	primero integer :=0;
	componente_id integer :=0;
	suma_componente double precision :=0;
	sku_componente character varying;
	id_almacen integer := 0;
	id_presentacion integer := 0;
	
	--variable para devolucion de mercancias
	saldo_fac double precision := 0;
	serie_folio_fac character varying:='';
	cant_disponible double precision := 0;
	
	--ordenes de entrada
	req_lote boolean := false;
	req_pedimento boolean := false;
	suma_lotes double precision:=0;
	
	--variable para devolucion de orden de produccion
	id_orden_produccion integer:=0;
	operador_id integer:=0;
	equipo_id integer:=0;
	equipo_adicional_id integer:=0;
	estado_calidad integer:=0;
	
	--variables para ordenes de Salida
	existe_lote integer:=0;--variable para verificar la existecia de un lote
	id_lote integer:=0;--almacena el id del lote
	cant_existencia_lote double precision:=0;--almacena la existencia que tiene el lote
	cant_sal_anterior double precision:=0;
	estatus_osal smallint:=0;
	
	--ajustes de inventario
	tipo_costo_movimiento integer := 0;
	grupo_movimiento integer := 0;
	existencia_producto double precision:=0;
	
	--orden de produccion y Cotizaciones
	record1 record;
	
	cuenta_mayor character varying:='';
	id_registro integer:=0;
	
	num_lista_precio integer:=0;
	descuento_producto double precision:=0;
	precio_producto double precision:=0;
	--Moneda del precio del producto
	mon_prec_prod integer:=0;
	--Tipo de cambio de la moneda del producto
	tc_mon_prod double precision:=0;
	descuento double precision:=0;
	precio_minimo double precision:=0;
	operacion_descuento double precision:=0;
	
	--dir_fiscal
	dir_fiscal character varying:='';
	
	--Id de la unidad de medida del producto
	idUnidadMedida integer:=0;
	--Nombre de la unidad de medida del producto
	nombreUnidadMedida character varying:='';
	--Id de la unidad de Medida de la Venta
	idUnidadMedidaVenta integer:=0;
	--Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantUnidadVenta double precision:=0;
	--Cantidad de la existencia convertida a la unidad de venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantExisUnidadVenta double precision:=0;
	
	--Numero de decimales permitidos para la unidad
	noDecUnidad integer:=0;
	--Densidad del producto
	densidadProd double precision:=0;
	--Existencia actual de la presentacion
	exisActualPres double precision:=0;
	--Equivalencia de la presentacion en la unidad del producto
	equivalenciaPres double precision:=0;
	--Cantidad que se esta Intentando traspasar
	cantPres double precision:=0;
	cantPresAsignado double precision:=0;
	cantPresReservAnterior double precision:=0;
	
	cadena character varying:='';
	exis integer:=0;
	registro_cancelado boolean:=false;
	
	idAdenda integer:=0;
BEGIN 
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;

	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- Comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	-- usuario que utiliza el aplicativo
	usuario_id := str_data[3]::integer;
	
	--RAISE EXCEPTION '%','usuario_id: '||usuario_id;
	/*
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id;
	*/
	
	--obtiene empresa_id, sucursal_id y sucursal_id
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id,inv_suc_alm.almacen_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id=usuario_id
	INTO emp_id, suc_id, id_almacen;
	--RAISE EXCEPTION '%','emp_id: '||emp_id;
	
	--Query para verificar si la empresa actual incluye Modulo de Contabilidad, Control de Existencias por Presentacion
	SELECT incluye_produccion, incluye_contabilidad, control_exis_pres, lista_precio_clientes, transportista, nomina FROM gral_emp WHERE id=emp_id 
	INTO incluye_modulo_produccion, incluye_modulo_contabilidad, controlExisPres, validaListaPrecioCliente, empresa_transportista, incluye_nomina;
	
	--Obtener parametros para la facturacion
	SELECT * FROM fac_par WHERE gral_suc_id=suc_id INTO facpar;
	
	--Asignar valor a variable que indica si el usuario puede cambiar la unidad de medida de venta
	cambiaUnidadMedida:=facpar.cambiar_unidad_medida;
	
	--catalogo de almacenes
	IF id_app=1 THEN
		
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloCorrerct'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'nombre:Nombre del Almacen No Valido___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numero:Numero No Valido___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;	
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valida___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CodigoPostalCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo Postal No Valido___';
		END IF;
		
		
		--pais
		IF str_data[10]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais___';
		END IF;
		
		--estado
		IF str_data[11]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado___';
		END IF;
		
		--municipio
		IF str_data[12]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio___';
		END IF;
		
		IF str_data[13]='' THEN
			valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el Numero Telefonico___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[13]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:Numero Telefonico no valido___';
			END IF;
		END IF;
		
		
		IF str_data[15]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'ext1:Numero de Extension No Valido___';
			END IF;
		END IF;

		
		--nombre del responsable
		IF str_data[17]=''  THEN
			valor_retorno := ''||valor_retorno||'responsable:Es necesario Ingresar el Nombre del Responsable___';
		END IF;
		
		--puesto del responsable
		IF str_data[18]='' THEN
			valor_retorno := ''||valor_retorno||'puesto:Es necesario Ingresar el Puesto del Responsable___';
		END IF;
		
		--email
		IF str_data[19]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_EmailCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[19]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:E-Mail No Valido___';
			END IF;
		END IF;
		
		--tipo de almacen 
		IF str_data[20]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'tipoalm:Es necesario seleccionar el Tipo de Almacen___';
		END IF;
		
		
		
		IF arreglo[1] = 'sin datos' THEN
			valor_retorno := ''||valor_retorno||'seleccionados:Es necesario Asignar por lo menos una Sucursal al almacen actual___';
		END IF;
		
		--RAISE EXCEPTION '%','str1: '||str_data[1];
		--valida la integridad de los datos, si el almacen es nuevo
		IF str_data[4] = '0' THEN
			--IF valor_retorno = 'true' THEN
				EXECUTE 'select count(id) from inv_alm where titulo ilike '''||str_data[5]||''' and borrado_logico=false;' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nombre:El nombre del almacen ingresado ya se encuentra registrado___';
				END IF;
			--END IF;
		END IF;
		
	END IF; --termina catalogo de Almacenes
	
	
	
	--Catalogo de proveedores
	IF id_app=2 THEN
		--rfc
		IF str_data[29]::integer = 1 OR str_data[29]::integer = 0 THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
			EXECUTE 'select '''||trim(str_data[6])||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'rfc:RFC No Valido___';
			END IF;
		END IF;
		
		--curp
		IF str_data[7] != ''  AND str_data[7] != ' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CurpCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'curp:La CURP ingresada no es no Valida___';
			END IF;
		END IF;
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonSocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rsocial:Razon Social No Valida___';
		END IF;
		
		--nombre comercial
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloCorrerct'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'ncomercial:Nombre Comercial No Valido___';
		END IF;
		
		--calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--num calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numcalle:Numero de Calle No Valida___';
		END IF;
		
		--colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[12]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CodigoPostalCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[13]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo Postal No Valido___';
		END IF;
		
		--pais
		IF str_data[15]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Proveedor___';
		END IF;
		
		--estado
		IF str_data[16]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Proveedor___';
		END IF;
		
		--municipio
		IF str_data[17]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Proveedor___';
		END IF;
		
		
		--telefono 1
		IF str_data[19]='' OR str_data[19]=' ' THEN
			valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el numero de Tel√©fono___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[19]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:Numero de Tel√©fono No Valido___';
			END IF;
		END IF;
		
		--e-mail
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_EmailCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[24]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'email:Correo Electronico No Valido___';
		END IF;
		
		--zona del proveedor
		IF str_data[27]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'zona:Es necesario seleccionar una Zona para el proveedor___';
		END IF;
		
		--grupo del proveedor
		IF str_data[28]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'grupo:Es necesario seleccionar un Grupo para el proveedor___';
		END IF;
		
		
		--tipo de proveedor
		IF str_data[29]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'provtipo:Es necesario seleccionar el Tipo de Proveedor___';
		END IF;
		
		--Clasificacion 1 del proveedor
		IF str_data[30]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'clasif1:Es necesario seleccionar un Clasificaci√≥n para el proveedor___';
		END IF;
		
		--Clasificacion 2 del proveedor
		IF str_data[31]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'clasif2:Es necesario seleccionar un Clasificaci√≥n para el proveedor___';
		END IF;
		
		--Clasificacion 3 del proveedor
		IF str_data[32]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'clasif3:Es necesario seleccionar un Clasificaci√≥n para el proveedor___';
		END IF;
		
		
		--moneda_id del proveedor
		IF str_data[33]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'moneda:Es necesario seleccionar una moneda para el proveedor___';
		END IF;
		
		
		--dias de credito
		IF str_data[37]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'credito:Es necesario seleccionar los D√≠as de Cr√©dito___';
		END IF;
		
		--inicio de credito
		IF str_data[39]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'inicred:Es necesario seleccionar el Inicio del Cr√©dito___';
		END IF;
		
		--contacto ventas
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ContactoCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[44]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'vcontacto:Ingrese el Nombre del contacto___';
		END IF;
		
		--Puesto del contacto ventas
		IF str_data[45] = '' OR str_data[45] = ' ' THEN
			valor_retorno := ''||valor_retorno||'vpuesto:Es Ingresar el Puesto del Contacto___';
		END IF;
		
		
		
		--e-mail ccontacto ventas
		IF str_data[59] != '' AND str_data[59] != ' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_EmailCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[59]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'vemail:E-mail del Contacto No Valido___';
			END IF;
		END IF;
		
		
		
		--valida la integridad de los datos, si el Proveedor es Nuevo
		IF str_data[4] = '0' THEN
			IF valor_retorno = '' THEN
				IF str_data[29]::integer=1 OR str_data[29]::integer=0 THEN
					EXECUTE 'select count(id) from cxp_prov where  rfc='''||str_data[6]||'''  and borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado ya se encuentra en uso___';
					END IF;
				END IF;
			END IF;
			IF valor_retorno = '' THEN
				EXECUTE 'select count(id) from cxp_prov where  razon_social='''||str_data[8]||''' and borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'rsocial:La Razon Social ingresada ya se encuentra en uso___';
				END IF;
			END IF;
			IF valor_retorno = '' THEN
				EXECUTE 'select count(id) from cxp_prov where clave_comercial='''||str_data[9]||''' and borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'ncomercial:El Nombre comercial ingresado ya se encuentra en uso___';
				END IF;
			END IF;
			IF valor_retorno = '' THEN
				EXECUTE 'select count(id) from cxp_prov where correo_electronico='''||str_data[24]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'email:El Correo Electr√≥nico ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de proveedores
	
	
	
	
	
	
	
	--monedas  0~^~xxx
	IF id_app=3 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','~^~');
		--nombre comercial
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'titulo:Titulo de la moneda No Valido~^~';
		END IF;
		
		IF str_data[1] = '0' THEN
			EXECUTE 'select count(id) from gral_mon where descripcion ilike '''||str_data[2]||''';' INTO valida_integridad;
			--RAISE EXCEPTION '%',valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'titulo:La moneda ingresada ya se encuentra en uso~^~';
			END IF;
		END IF;
	END IF;

	
	--Catalogo de empleados
	IF id_app=4 THEN
		--RAISE EXCEPTION '%',str_data[12]||' '||str_data[13]||' '||str_data[14]||' '||str_data[15]||' '||str_data[16]||' '||str_data[17];
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--nombre, 
		--RAISE EXCEPTION '%',str_data[3]; 
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NombreCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'nombre:Nombre No Valido___';
		END IF;
		
		--apellido paterno
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ApellidopaternoCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'apellidopaterno:Apellido paterno No Valido___';
		END IF;
		
		--apellido materno, 
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ApellidomaternoCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'apellidomaterno:Apellido materno No Valido___';
		END IF;
		
		--imss
		IF trim(str_data[8])<>'' THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ImssCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'imss:No.IMSS No Valido. Debe ser 11 digitos___';
			END IF;
		END IF;
		
		--infonavit
		IF trim(str_data[9])<>'' THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_InfonavitCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'infonavit:Numero de Infonavit No Valido___';
			END IF;
		END IF;
		
		--curp
		IF incluye_nomina THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CurpCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'curp:Curp No Valido___';
			END IF;
		ELSE
			IF trim(str_data[10])<>'' THEN 
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CurpCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'curp:Curp No Valido___';
				END IF;
			END IF;
		END IF;
		
		--rfc
		IF incluye_nomina THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'rfc:RFC No Valido___';
			END IF;
		ELSE
			IF trim(str_data[11])<>'' THEN 
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'rfc:RFC No Valido___';
				END IF;
			END IF;
		END IF;
		
		
		
		--fecha nacimiento
		--IF str_data[12]!='' AND str_data[12]!=' ' THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechaNacIngCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[12]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fechanacimiento:La fecha ingresada  No Valida___';
			END IF;
		--END IF;
		
		--fecha ingreso
		IF incluye_nomina THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechaNacIngCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[13]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fechaingreso:La fecha ingresada no es valida___';
			END IF;
		ELSE
			IF trim(str_data[13])<>'' THEN 
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechaNacIngCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[13]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'fechaingreso:La fecha ingresada no es valida___';
				END IF;
			END IF;
		END IF;
		
		--escolaridad
		IF str_data[14]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'escolaridad:La Escolaridad  NO es valida___';
		END IF;
		
		--sexo
		IF str_data[15]::integer= 0 THEN
			valor_retorno := ''||valor_retorno||'genero:El Genero NO es valido___';
		END IF;
		
		--edo civil
		IF str_data[16]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'civil:El estado civil NO es valido___';
		END IF;

		/*
		--religion
		IF str_data[17]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'religion:La religion NO es valida. ___';
		END IF;
		*/
		
		/*
		--sangre
		IF str_data[30]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'sangre:El tipo de sangre no es valido:___';
		END IF;
		*/
		
		--puesto
		IF str_data[33]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'puesto:El Puesto no es valido. Debe ser 10 digitos___';
		END IF;
		
		--sucursal
		IF str_data[34]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'sucursal:Debe ingresar una Sucursal___';
		END IF;
		
		/*
		--categoria
		IF str_data[35]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'categoria:Debe ingresar una Categoria___';
		END IF;
		*/
		
		--Nombre de usuario
		IF trim(str_data[37])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_UserCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[37]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email_usr:Introduzca un email de usuario___';
			END IF;
		END IF;
		
		--password
		--RAISE EXCEPTION '%',str_data[38];
		IF trim(str_data[37])<>'' THEN
			--Si existe nombre de usuario hay que validar que exista la contrase√±a
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PasswordCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[38]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena= false THEN
				valor_retorno := ''||valor_retorno||'password:Debe introducir una contrase√±a___';
			END IF;
		END IF;
		--RAISE EXCEPTION '%','arreglo: '||arreglo[1];
		--telefono
		IF trim(str_data[18])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[18]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'telefono:El numero telefonico no es valido. Debe ser 10 digitos___';
			END IF;
		END IF;
		
		--pais
		IF str_data[21]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Pais No Valido___';
		END IF;

		--estado
		IF str_data[22]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Estado No Valido___';
		END IF;
		
		--municipio
		IF str_data[23]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Municipio No Valido___';
		END IF;

		--calle
		IF str_data[24]!='' AND str_data[24]!=' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[24]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
			END IF;
		END IF;
		
		--numero
		IF str_data[25]!='' AND str_data[25]!=' ' THEN
			IF str_data[25]!='' AND str_data[25]!=' ' THEN
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[25]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'numero:Numero No Valido___';
				END IF;
			END IF;
		END IF;
		
		--colonia
		IF trim(str_data[26])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[26]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
			END IF;
		END IF;
		
		--cp
		IF trim(str_data[27])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[27]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'cp:CP No Valido___';
			END IF;
		END IF;
		
		--contacto emergencia
		/*
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NombreCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[28]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'ncontacto:Contacto No Valido___';
		END IF;
		*/
		
		--telefono emergencia
		IF trim(str_data[29])<>'' THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[29]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tcontacto:Telefono No Valido. Debe tener al menos 10 digitos___';
			END IF;
		END IF;

		IF incluye_nomina THEN 
			--Aqui solo entra si incluye nomina
			--no_int,--str_data[54],
			
			--str_data[55]::integer Regimen de Contratacion
			IF str_data[55]::integer=0 THEN
				valor_retorno := ''||valor_retorno||'regimencontratacio:Es necesario seleccionar el Regimen de Contratacion.___';
			END IF;
			
			--str_data[56]::integer Tipo de Contrato
			--str_data[57]::integer Tipo de Jornada
			--str_data[58]::integer Periodicidad del Pago
			--str_data[59]::integer Banco
			--str_data[60]::integer Rieso del Puesto
			--str_data[61]::double precision Salario Base
			--str_data[62]::double precision Salario Integrado
			--str_data[63] Registro Patronal
			--str_data[64] Clave
			
			
			--str_data[65] Percepciones
			IF trim(str_data[65])='' THEN
				valor_retorno := ''||valor_retorno||'percep:Es necesario seleccionar por lo menos un concepto de Percepcion.___';
			END IF;
			
			--str_data[66] deducciones
			IF trim(str_data[66])='' THEN
				valor_retorno := ''||valor_retorno||'deduc:Es necesario seleccionar por lo menos un concepto de Deduccion.___';
			END IF;
		END IF;
		
		
		IF str_data[1] = '0' THEN
			IF trim(str_data[10])<>'' THEN 
				EXECUTE 'select count(id) from gral_empleados where borrado_logico=false and gral_emp_id='||emp_id||' and curp ilike '''||str_data[10]||''';' INTO valida_integridad;
				--RAISE EXCEPTION '%',valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'curp:La curp ingresada ya se encuentra en uso___';
				END IF;
			END IF;
			
			valida_integridad:=0;

			IF trim(str_data[11])<>'' THEN 
				EXECUTE 'select count(id) from gral_empleados where borrado_logico=false and gral_emp_id='||emp_id||' and rfc ilike '''||str_data[11]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado ya se encuentra en uso___';
				END IF;
			END IF;
			
			valida_integridad:=0;
			IF trim(str_data[37])<>'' THEN 
				EXECUTE 'select count(id) from gral_usr where titulo ilike '''||str_data[37]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'email_usr:El usuario ingresado ya se encuentra en uso.___';
				END IF;
			END IF;
			
			IF trim(str_data[37])<>'' THEN
				--Si existe el nombre del usuario hay que validar la verificacion del Password
				valida_integridad:=0;
				IF str_data[38] <> str_data[39] THEN
					valor_retorno := ''||valor_retorno||'verificapass:La verificacion del password no coincide con la primera.___';
				END IF;
			END IF;

		END IF;
	END IF;
	
	
	
	
	
	--Catalogo de Clientes
	IF id_app=5 THEN
		
		--rfc
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
		END IF;
		
		--curp
		IF str_data[7]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CurpCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'curp:La curp ingresada no es valida___';
			END IF;
		END IF;

		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;
		
		--clave comercial
		IF str_data[9] = '' OR str_data[9] = ' ' THEN
			valor_retorno := ''||valor_retorno||'clavecomercial:La Clave Comercial es incorrecta___';
		END IF;
		
		--calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--num calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroint:Numero de Calle No Valida___';
		END IF;

		
		--colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[14]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--codigo postal
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--pais
		IF str_data[16]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Cliente___';
		END IF;
		
		--estado
		IF str_data[17]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Cliente___';
		END IF;
		
		--municipio
		IF str_data[18]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Cliente___';
		END IF;
		
		--telefono 1
		IF trim(str_data[6])<>'XEXX010101000' THEN 
			IF str_data[20]='' OR str_data[20]=' ' THEN
				valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el numero de Tel√©fono___';
			ELSE
				--telefono
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[20]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos___';
				END IF;
			END IF;
		END IF;
		
		--FAX, utiliza la misma mascara que telefono
		IF str_data[22]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[22]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fax:El numero de Fax no es valido. Debe ser 10 digitos___';
			END IF;
		END IF;
	

		--email
		IF str_data[25]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[25]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		
		--str_data[26] id agente
		IF str_data[26] = '0' THEN
			valor_retorno := ''||valor_retorno||'agente:Es necesario selecionar un Agente de Ventas para el cliente___';
		END IF;

		--zona
		IF str_data[28] = '0' THEN
			valor_retorno := ''||valor_retorno||'zona:Es necesario selecionar una Zona para el cliente___';
		END IF;

		--grupo
		IF str_data[29] = '0' THEN
			valor_retorno := ''||valor_retorno||'grupo:Es necesario selecionar un Grupo para el cliente___';
		END IF;

		--tipo CLIENTE
		IF str_data[30] = '0' THEN
			valor_retorno := ''||valor_retorno||'tipocliente:Es necesario selecionar el tipo de cliente___';
		END IF;

		--clasificacion 1
		IF str_data[31] = '0' THEN
			valor_retorno := ''||valor_retorno||'clasif1:Es necesario selecionar una Clasificacion para el cliente___';
		END IF;

		--clasificacion 2
		IF str_data[32] = '0' THEN
			valor_retorno := ''||valor_retorno||'clasif2:Es necesario selecionar una Clasificacion para el cliente___';
		END IF;

		--clasificacion 3
		IF str_data[33] = '0' THEN
			valor_retorno := ''||valor_retorno||'clasif3:Es necesario selecionar una Clasificacion para el cliente___';
		END IF;

		--moneda
		IF str_data[34] = '0' THEN
			valor_retorno := ''||valor_retorno||'moneda:Es necesario selecionar una Moneda para el cliente___';
		END IF;
		/*
		--impuesto
		IF str_data[37] = '0' THEN
			valor_retorno := ''||valor_retorno||'impuesto:Es necesario selecionar un Impuesto para el cliente___';
		END IF;
		*/

		IF str_data[39] = '0' THEN
			valor_retorno := ''||valor_retorno||'diascredito:Es necesario selecionar los dias de Credito para el cliente___';
		END IF;
		
		--inicio de credito
		IF str_data[41]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'inicred:Es necesario seleccionar el Inicio del Cr√©dito___';
		END IF;
		
		--e-mail contacto compras
		IF str_data[61] != '' AND str_data[61] != ' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[61]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'cemail:E-mail del Contacto No Valido___';
			END IF;
		END IF;
		
		--e-mail contacto pagos
		IF str_data[77] != '' AND str_data[77] != ' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[77]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'pemail:E-mail del Contacto No Valido___';
			END IF;
		END IF;
		
		--str_data[78] 	select_immex
		--str_data[79] 	retencion_immex
		--str_data[80] 	select_dia_revision
		--str_data[81] 	select_dia_pago
		
		IF str_data[78]::boolean=true THEN
			IF str_data[79]='' OR str_data[79]=' ' THEN
				valor_retorno := ''||valor_retorno||'retimmex:Es necesario ingresar la Tasa de Retenci&oacute;n IMMEX.___';
			ELSE
				IF str_data[79]::double precision > 100 THEN
					valor_retorno := ''||valor_retorno||'retimmex:La Tasa de Retenci&oacute;n IMMEX debe ser menor o igual a 100%.___';
				END IF;
				IF str_data[79]::double precision < 1 THEN
					valor_retorno := ''||valor_retorno||'retimmex:La Tasa de Retenci&oacute;n IMMEX debe ser mayor o igual a 1%.___';
				END IF;
			END IF;
		END IF;
		
		
		IF validaListaPrecioCliente THEN 
			--str_data[89] 	select_lista de precio
			IF str_data[89]='0' THEN
				valor_retorno := ''||valor_retorno||'lp:Es necesario seleccionar una Lista de Precio para el Cliente___';
			END IF;
		END IF;
		
		--str_data[90] 	select_metodo_pago
		IF str_data[90]='0' THEN
			valor_retorno := ''||valor_retorno||'metodopago:Es necesario seleccionar un M&eacute;todo de Pago para el Cliente___';
		END IF;
		
		IF str_data[4] = '0' THEN

			valida_integridad:=0;
			IF trim(str_data[6])<>'XEXX010101000' THEN 
				EXECUTE 'select count(id) from cxc_clie where rfc ilike '''||str_data[6]||''' AND borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado ya se encuentra en uso.___';
				END IF;
			END IF;
			
			valida_integridad:=0;
			EXECUTE 'select count(id) from cxc_clie where razon_social ilike '''||str_data[8]||''' AND borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social ingresada ya se encuentra en uso___';
			END IF;
			
			valida_integridad:=0;
			EXECUTE 'select count(id) from cxc_clie where clave_comercial ilike '''||str_data[9]||''' AND borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'clavecomercial:La Clave Comercial ingresada ya se encuentra en uso___';
			END IF;
			/*
			valida_integridad:=0;
			EXECUTE 'select count(id) from cxc_clie where email ilike '''||str_data[25]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'email:El correo ingresado ya se encuentra en uso___';
			END IF;
			*/
		END IF;
	END IF;--termina validacion de clientes
	
	
	
	
	
	
	--parametros generales
	IF id_app=6 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');

		--calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[1]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;

		--colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;

		--codigo postal
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[3]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;

		--num calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numero:Numero de Calle No Valida___';
		END IF;

		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;

		--rfc
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
		END IF;

		--url facturacion electronica
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''isUrlCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
		END IF;

		--tasa retencion fletes
		IF str_data[12] = '' THEN
			valor_retorno := ''||valor_retorno||'tasafletes:Es necesario ingresar la tasa de retencion para fletes___';
		END IF;
	END IF;

	--bancos
	--nuevas variables que se agregaron para aplicativo bancos
	--str_filas text[];
	--total_filas integer;--total de elementos de arreglo
	--cont_fila integer;--contador de filas o posiciones del arreglo
	--id_banco integer;
	IF id_app=7 THEN

		--SELECT INTO str_filas string_to_array(campos_data,'|');
		
		--obtiene numero de elementos del arreglo str_filas
		total_filas:= array_length(str_filas,1);

		cont_fila:=1;
		FOR cont_fila IN 1 .. total_filas-1 LOOP
			--convertir en arreglo la cedena de cada posicion del arreglo str_filas
			SELECT INTO str_data string_to_array(str_filas[cont_fila],'___');
			IF cont_fila = 1 THEN
				--aqui entra para leer el indice 1 del arreglo, este arreglo debe tener solo tres posiciones
				--str_data[1]	id
				id_banco := str_data[1];
				--str_data[2] 	nombre del banco
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NombrebancoCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := 'nombre:Nombre de banco No Valido___';
				END IF;
				
				--str_data[3] 	clave del banco
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ClaveCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[3]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'clave:Clave no valida___';
				END IF;

				IF str_data[1] = '0' THEN
					EXECUTE 'select count(id) from erp_bancos where titulo ilike '''||str_data[2]||''';' INTO valida_integridad;
					--RAISE EXCEPTION '%',valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'nombre:El nombre del banco ingresado ya se encuentra en uso___';
					END IF;
				END IF;

				
			ELSE 
				--aqui entra para leer los registros  que son mayor que 1
				--RAISE EXCEPTION '%',str_filas[cont_fila];
				--str_data[1]	id_cuenta1
				--str_data[2] 	nocuenta1
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NocuentaCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'nocuenta'||cont_fila-1||':Cuenta no valida___';
				END IF;
				
				--str_data[3]	nosucursal1
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NosucursalCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[3]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'nosucursal'||cont_fila-1||':Numero de sucursal no valida___';
				END IF;
				
				--str_data[4]	sucursal1
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_SucursalCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[4]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'sucursal'||cont_fila-1||':Nombre de sucursal no valida___';
				END IF;
				
				--str_data[5]	dirsucursal1
				IF str_data[5] != '' THEN
					EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_DirsucursalCorrect'';' INTO mask_general;
					EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'dirsucursal'||cont_fila-1||':Direccion de sucursal no valida___';
					END IF;
				END IF;
				--str_data[6]	input_moneda1
				--str_data[7]	input_status1
				
				--str_data[8]	ejecutivo1
				IF str_data[8] != '' THEN
					EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NombreejecutivoCorrect'';' INTO mask_general;
					EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'ejecutivo'||cont_fila-1||':Nombre de ejecutivo no valido___';
					END IF;
				END IF;
				
				--str_data[9]	correo1
				IF str_data[9] != '' THEN
					EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
					EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'correo'||cont_fila-1||':Correo no valido___';
					END IF;
				END IF;
				
				--str_data[10] 	telefono1
				IF str_data[10] != '' THEN
					EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
					EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'telefono'||cont_fila-1||':Numero telefonico no valido___';
					END IF;
				END IF;
				
				IF str_data[1] = '0' THEN
					EXECUTE 'select count(id) from erp_cuentas where titulo ilike '''||str_data[2]||''' and banco_id='||id_banco INTO valida_integridad;
					--RAISE EXCEPTION '%',valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'nocuenta'||cont_fila-1||':La cuenta ingersada para este banco ya se encuentra en uso___';
					END IF;
				END IF;
				--RAISE EXCEPTION '%',str_data[2];
			END IF;
			
		END LOOP;
		
	END IF;
	
	
	
	
	--Productos
	IF id_app=8 THEN

		--query para verificar si la Empresa actual incluye Modulo de Produccion
		SELECT incluye_produccion, control_exis_pres FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, controlExisPres;
		
		--codigo producto,--str_data[31]
		IF str_data[31]='' OR str_data[31]=' ' THEN
			valor_retorno := ''||valor_retorno||'codigo:Es necesario C&oacute;digo del Producto.___';
		END IF;
		
		--descripcion,--str_data[5]
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloenCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'descripcion:La Descripcion igresada no es valida___';
		END IF;
		
		--tipo_de_producto_id,--str_data[18]::integer
		IF str_data[18]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'prodtipo:Es necesario seleccionar el Tipo de Producto.___';
		END IF;
		
		--str_data[20] 	unidad
		IF str_data[20]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'unidad:Es necesario seleccionar la Unidad de Mendida para el Producto.___';
		END IF;
        
        --str_data[47] Valida clave_cfdi_claveprodserv
        IF str_data[47]='' THEN
		  valor_retorno := ''||valor_retorno||'clave_cfdi_claveprodserv:La clave CFDI Producto/Servicio es obligatoria.___';
        ELSE
            EXECUTE 'SELECT count(id) FROM cfdi_claveprodserv WHERE clave='''||str_data[47]||''';' INTO valida_integridad;
			IF valida_integridad = 0 THEN
				valor_retorno := ''||valor_retorno||'clave_cfdi_claveprodserv:La clave CFDI Producto/Servicio '''||str_data[47]||''', no es v&aacute;lida.___';
			END IF;        
        END IF;
        
		--Si el tiopo de producto es diferente de 3 y 4, hay que validar
		--tipo=3 Kit
		--tipo=4 Servicios
		IF str_data[18]::integer<>3 AND str_data[18]::integer<>4 THEN
			--inv_clas_id,--str_data[8]::integer
			IF str_data[8]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'clase:Clasificaci&oacute;n no valida.___';
			END IF;
			
			--inv_stock_clasif_id,--str_data[9]::integer
			IF str_data[9]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'stock:Es necesario seleecionar una Clasificaci&oacute;n de Stock.___';
			END IF;
			
			--inv_prod_familia_id,--str_data[11]::integer
			--IF str_data[11]::integer = 0 THEN
			--	valor_retorno := ''||valor_retorno||'familia:Es necesario seleccionar una Familia para el Producto.___';
			--END IF;
			
			--subfamilia_id,--str_data[12]::integer
			--IF str_data[12]::integer = 0 THEN
			--	valor_retorno := ''||valor_retorno||'subfamilia:Es necesario seleccionar una Subfamilia para el Producto.___';
			--END IF;
			
			--inv_prod_grupo_id,--str_data[13]::integer
			IF str_data[13]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'grupo:Es necesario seleccionar un Grupo para el Producto.___';
			END IF;
			
			/*
			--meta_impuesto,--str_data[15]::integer
			IF str_data[15]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'iva:Es necesario seleccionar el Impuesto para el Producto.___';
			END IF;
			*/
			--inv_prod_linea_id,--str_data[16]::integer
			IF str_data[16]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'linea:Es necesario seleccionar la L&iacute;nea para el Producto.___';
			END IF;
			
			--inv_mar_id,--str_data[17]::integer
			IF str_data[17]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'marca:Es necesario seleccionar la Marca para el Producto.___';
			END IF;
			
			--inv_seccion_id,--str_data[19]::integer
			IF str_data[19]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'seccion:Es necesario seleccionar la Secci&oacute;n para el Producto.___';
			END IF;
			
			--str_data[28] 	presentaciones del producto
			IF trim(str_data[28]) = '' THEN
				valor_retorno := ''||valor_retorno||'seleccionados:Es necesario seleccionar al menos una Presentaci&oacute;n para el Producto___';
			END IF;
			
			IF str_data[30]::double precision = 0 then 
				valor_retorno := ''|| valor_retorno||'densidad:Densidad debe ser mayor que 0___';
			END IF;
		END IF;
		
		--Presentacion Default--str_data[42]::integer
		IF str_data[42]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'presdefault:Es necesario seleccionar la Presentaci&oacute;n Default.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			IF str_data[31]!='' AND str_data[31]!=' ' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod WHERE sku='''||str_data[31]||''' AND borrado_logico=FALSE  AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'codigo:El C&oacute;digo del Producto ya se encuentra registrado.___';
				END IF;
			END IF;
			
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod WHERE descripcion = '''||str_data[5]||''' AND borrado_logico=FALSE  AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'descripcion:La Descripci&oacute;n Ingresada ya se encuentra en uso.___';
				END IF;
			END IF;
						
		ELSE
			EXECUTE 'SELECT sku, id FROM inv_prod WHERE sku='''||str_data[31]||''' AND borrado_logico=FALSE  AND empresa_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'codigo:El C&oacute;digo del Producto ya se encuentra registrado.___';
			END IF;

			--RAISE EXCEPTION '%','controlExisPres: '||controlExisPres;
			--Verificar si hay que validar existencias de Presentaciones
			IF controlExisPres=true THEN 
				IF str_data[18]::integer<>3 AND str_data[18]::integer<>4 THEN
					IF trim(str_data[28]) <> '' THEN
						--convertir en arreglo los id de presentaciones de producto
						SELECT INTO str_filas2 string_to_array(str_data[28],',');
						
						--obtiene numero de elementos del arreglo str_pres
						total_filas2:= array_length(str_filas2,1);
						
						sql_select:='
						SELECT 
							presentacion_id,
							presentacion,
							sum(existencia) AS existencia
						FROM (
							SELECT 
								inv_prod_pres_x_prod.presentacion_id,
								inv_prod_presentaciones.titulo  AS presentacion,
								inv_exi_pres.inv_alm_id,
								(inv_exi_pres.inicial + inv_exi_pres.entradas - inv_exi_pres.reservado - inv_exi_pres.salidas) AS existencia
							FROM inv_prod_pres_x_prod 
							JOIN inv_exi_pres ON (inv_exi_pres.inv_prod_id=inv_prod_pres_x_prod.producto_id AND inv_exi_pres.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id)
							JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
							WHERE inv_prod_pres_x_prod.producto_id='||str_data[4]::integer||' 
						) AS sbt WHERE existencia>0
						GROUP BY presentacion_id, presentacion';

						--En esta cadena se almacenan las presentaciones que fueron eliminados y que tienen existencia
						cadena := '';
						
						FOR record1 IN EXECUTE(sql_select) LOOP
							exis:=0;
							cont_fila2:=1;
							FOR cont_fila2 IN 1 .. total_filas2 LOOP
								IF record1.presentacion_id=str_filas2[cont_fila2]::integer THEN 
									exis:= exis + 1;
								END IF;
							END LOOP;
							
							IF exis=0 THEN 
								cadena := cadena || record1.presentacion||',';
							END IF;
						END LOOP;
						
						IF trim(cadena)<>'' THEN
							valor_retorno := ''||valor_retorno||'seleccionados:Estas presentaciones('||cadena||') no se Pueden eliminar, tienen existencia.___';
						END IF;
						
					END IF;
				END IF;
			END IF;

		END IF;
		
		
		
		/*
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
				--ya no se valida nada
				--str_filas[1]	producto_ingrediente_id
				--str_filas[2] 	porcentaje
				--RAISE EXCEPTION '%',str_data[2];
				END IF;
				
			END LOOP;
			
		END IF;
		*/
	END IF;--termina productos
	
	
	/*
	str_data[1] 	app_selected
	str_data[2] 	command_selected
	str_data[3] 	id_usuario
	str_data[4] 	id_entrada
	str_data[5] 	id_proveedor
	str_data[6] 	factura
	str_data[7] 	expedicion
	str_data[8] 	numeroguia
	str_data[9] 	ordencompra
	str_data[10] 	denominacion
	str_data[11] 	tc
	str_data[12] 	observaciones
	str_data[13] 	fletera_id
	str_data[14] 	flete
	str_data[15] 	almacen_destino
	*/
	--entrada mercancias
	IF id_app=9 THEN
		--obtenemos el valor de control_exis_pres, para saber si es necesario validar existencias por presentaciones
		SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
		
		--id_entrada 	str_data[4]
		--id_proveedor	str_data[5] id_proveedor
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'noproveedor:Es necesario seleccionar un proveedor___';
		END IF;
		
		--factura	str_data[6]
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FacturaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
		END IF;
		
		--expedicion	str_data[7] expedicion
		IF str_data[7] = '' THEN
			valor_retorno := ''||valor_retorno||'expedicion:Es necesario seleccionar una fecha___';
		END IF;
		
		--numeroguia	str_data[8] numeroguia
		/*
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NoguiaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroguia:Numero de Guia no valido___';
		END IF;
		
		--ordencompra	str_data[9] ordencompra
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_OrdencompraCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'ordencompra:Numero de Guia no valido___';
		END IF;
		*/
		
		--denominacion	str_data[10] denominacion
		IF str_data[10]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'denominacion:Es necesario seleccionar una moneda___';
		END IF;
		
		--tipo cambio	str_data[11] tc
		IF str_data[11] = '' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		END IF;
		
		--observaciones	str_data[12]

		--str_data[13] fletera
		IF trim(str_data[13]) = '' THEN
			valor_retorno := ''||valor_retorno||'fletera:Es necesario seleccionar una compa√±ia___';
		END IF;
		
		--str_data[14] flete
		
		--str_data[15] almacen_destino
		
		
		IF trim(str_data[6])<>'' THEN
			valida_integridad:=0;
			EXECUTE 'SELECT count(id) FROM com_fac WHERE  proveedor_id='||str_data[5]||' AND factura ilike '''||str_data[6]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'factura:EL Folio ingresado ya se encuentra registrado___';
			END IF;
		END IF;
		
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--eliminado	str_filas[8]
				IF str_filas[8]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--no_partida 	str_filas[1]
					
					--costo		str_filas[3] costo
					IF str_filas[3] = ' ' OR str_filas[3] = '' THEN
						valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el costo___';
					ELSE
						IF str_filas[3]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'costo'||cont_fila||':El costo debe ser mayor que cero___';
						END IF;
					END IF;
					
					--cantidad	str_filas[2]  cantidad
					IF trim(str_filas[2])='' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[2]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad debe ser mayor que cero___';
						END IF;
					END IF;
					
					
					--Verificar si incluye control de existencias por presentacion
					IF controlExisPres=TRUE THEN 
						--Validar presentacion default
						SELECT cantidad FROM inv_prod_presentaciones WHERE id=str_filas[7]::integer 
						INTO equivalenciaPres;
						
						IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
						
						IF equivalenciaPres=0 THEN
							valor_retorno := ''||valor_retorno|| 'pres'||cont_fila||':Es necesario asignar la equivalencia a la presentacion.___';
						END IF;
					END IF;
					/*
					--caducidad	str_filas[10]
					IF trim(str_filas[10]) != ' ' THEN
						EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechacaducidadCorrect'';' INTO mask_general;
						EXECUTE 'select '''||str_filas[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
						IF match_cadena = false THEN
							valor_retorno := ''||valor_retorno|| 'caducidad'||cont_fila||':Fecha de caducidad no valida___';
						END IF;
					END IF;
					*/
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;
	
	

	--validacion de Traspasos
	IF id_app=10 THEN
		--str_data[4]	identificador
		--str_data[5]	select_suc_origen
		--str_data[6]	select_alm_origen
		--str_data[7]	select_suc_destino
		--str_data[8]	select_alm_destino
		--str_data[9]	observaciones
		--str_data[10]	fecha_traspaso
		
		IF str_data[5] = str_data[7] THEN 
			IF str_data[6] = str_data[8] THEN 
				valor_retorno := ''||valor_retorno||'almdestino:El almacen Destino NO debe ser igual al almacen Origen.___';
			END IF;
		END IF;
		
		IF str_data[8]='0' THEN 
			valor_retorno := ''||valor_retorno||'almdestino:Es necesario seleccionar el Almacen Destino.___';
		END IF;

		--obtenemos el valor de control_exis_pres, para saber si es necesario validar existencias por presentaciones
		SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				IF str_filas[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	idproducto[i]
					--str_filas[2]	cant_traspaso[i]
					--str_filas[3]	no_tr[i]
					--str_filas[4]	select_pres

					--buscar el numero de decimales de la unidad del producto
					SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=str_filas[1]::integer 
					INTO noDecUnidad;

					IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
					
					IF str_filas[2]='' OR str_filas[2]=' ' THEN 
						valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[3]||':Es necesario ingresar la CANTIDAD del para el Traspaso.___';
					ELSE
						IF str_filas[2]::double precision < 0.000001 THEN 
							valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[3]||':La CANTIDAD del Traspaso debe ser mayor que cero.___';
						ELSE
							SELECT (inv_exi.exi_inicial - inv_exi.transito - inv_exi.reservado + inv_exi.entradas_1 + inv_exi.entradas_2 + inv_exi.entradas_3 + inv_exi.entradas_4 + inv_exi.entradas_5 + inv_exi.entradas_6 + inv_exi.entradas_7 + inv_exi.entradas_8 + inv_exi.entradas_9 + inv_exi.entradas_10 + inv_exi.entradas_11 + inv_exi.entradas_12 - inv_exi.salidas_1 - inv_exi.salidas_2 - inv_exi.salidas_3 - inv_exi.salidas_4 - inv_exi.salidas_5 - inv_exi.salidas_6 - inv_exi.salidas_7 - inv_exi.salidas_8 - inv_exi.salidas_9 - inv_exi.salidas_10 - inv_exi.salidas_11 - inv_exi.salidas_12) AS existencia
							FROM inv_exi WHERE inv_prod_id=str_filas[1]::integer AND inv_alm_id=str_data[6]::integer AND ano=EXTRACT(YEAR FROM now())
							INTO existencia_producto;
							
							--redondeo de existencia
							existencia_producto := round((existencia_producto)::numeric, noDecUnidad)::double precision;
							
							IF existencia_producto < round((str_filas[2]::double precision)::numeric, noDecUnidad)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[3]||':La CANTIDAD para el Traspaso no debe ser mayor que la existencia actual.___';
							END IF;
						END IF;
					END IF;
					
					IF str_filas[4]::integer<=0 THEN 
						valor_retorno := ''||valor_retorno||'pres'||str_filas[3]||':Es necesario seleccionar la Presentaci&oacute;n en la que se realizar&aacute; el Traspaso.___';
					ELSE
						IF controlExisPres=true THEN
							--inicializar valor a cero
							equivalenciaPres:=0;
							
							--buscar la equivalencia de la Presentacion Origen en la Unidad del Producto
							SELECT cantidad AS equiv_pres FROM inv_prod_presentaciones WHERE id=str_filas[4]::integer 
							INTO equivalenciaPres;

							IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
							
							--Convertir la Cantidad de Unidades a su equivalencia en Cantidad de Presentaciones
							cantPres := round(str_filas[2]::numeric, noDecUnidad)::double precision / equivalenciaPres::double precision;

							--redondear la Cantidad de la Presentacion
							cantPres := round(cantPres::numeric,noDecUnidad)::double precision;
							
							--buscar Existencia de la Presentacion en el Almacen Origen
							SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exis 
							FROM inv_exi_pres  
							JOIN inv_prod ON inv_prod.id=inv_exi_pres.inv_prod_id  
							JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id  
							WHERE inv_exi_pres.inv_alm_id=str_data[6]::integer 
							AND inv_exi_pres.inv_prod_id=str_filas[1]::integer
							AND inv_exi_pres.inv_prod_presentacion_id=str_filas[4]::integer 
							INTO exisActualPres;
							
							IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
							
							--redondear la Existencia Actual de la Presentacion Origen
							exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;
							
							--validar si la Cantidad de la Presentaciona Traspasar es mayor que la Existencia Actual de la Presentacion en el Almacen origen
							IF cantPres::double precision > exisActualPres::double precision THEN 
								valor_retorno := ''||valor_retorno||'pres'||str_filas[3]||':La Presentaci&oacute;n tiene Existencia='||exisActualPres||',  Traspaso='||cantPres||'. No se puede raelizar el traspaso de una cantidad mayor a la Existencia.___';
							END IF;
						END IF;
					END IF;
					
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Traspasos

	
	
	
	--tipos de impuesto
	IF id_app=11 THEN
		--titulo
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno|| 'titulo:Nombre del impuesto No Valido___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ValorCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[3]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno|| 'valor:Valor del impuesto no valido___';
		END IF;
		
		IF str_data[1] = '0' THEN
			EXECUTE 'select count(id) from erp_ivatipos where titulo ilike '''||str_data[2]||''';' INTO valida_integridad;
			--RAISE EXCEPTION '%',valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'titulo:El impuesto ingresado ya se encuentra en uso___';
			END IF;
		END IF;
	END IF;
	
	
	--Cotizaciones
	IF id_app=12 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5] 	select_tipo_cotizacion
		--str_data[6]	id_cliente √≥ id_prospecto
		--str_data[7]	check_descripcion_larga
		--str_data[8]	observaciones
		--str_data[9]	tipo_cambio
		--str_data[10]	moneda_id
		--str_data[11]	fecha
		--str_data[12]  agente_id
		--str_data[13]  vigencia
		--str_data[14]  incluye_iva
		--str_data[15]  incoterms
		--str_data[16]  tc_usd
		
		--str_data[1] 	id_cliente
		IF str_data[6]='0' OR trim(str_data[6])='' THEN
			IF str_data[5]::integer=1 THEN 
				valor_retorno := ''||valor_retorno||'rfccliente:Es necesario seleccionar un Cliente___';
			ELSE
				valor_retorno := ''||valor_retorno||'rfccliente:Es necesario seleccionar un Prospecto___';
			END IF;
		END IF;
		
		--str_data[9] 	tipo_cambio
		IF str_data[9]!='' THEN
			IF str_data[9]::double precision <= 0 THEN 
				valor_retorno := ''||valor_retorno||'tc:El tipo de cambio debe ser mayor que cero.___';
			END IF;
		ELSE
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el Tipo de Cambio.___';
		END IF;

		--si el tipo de cotizacion es 1=Cliente, entonces hay que Obtener el numero de Lista de Precio
		IF str_data[5]::integer=1 THEN 
			--Obtener el numero de Lista de Precio Asignado al cliente
			select cxc_clie.lista_precio from cxc_clie where cxc_clie.id=str_data[6]::integer into num_lista_precio;
		END IF;
		
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	cantidad
					--str_filas[6]	precio
					--str_filas[7]	monedagrid
					--str_filas[8]	notr
					--str_filas[9]	id_imp_prod
					--str_filas[10]	valor_imp
					--str_filas[11]	select_umedida
					--str_filas[12]	stat_reg
					--str_filas[13]	precio_autorizado
					--str_filas[14]	id_user_aut
					--str_filas[15]	requiere_autorizacion
					--str_filas[16]	salvar_registro
					
					--RAISE EXCEPTION '%','str_filas[8]: '||str_filas[8];
					--str_filas[5]	cantidad
					IF trim(str_filas[5])='' THEN
						valor_retorno := ''||valor_retorno||'cant'||str_filas[8]||':Es necesario ingresar la cantidad.___';
					ELSE
						IF str_filas[5]::double precision <= 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cant'||str_filas[8]||':La cantidad debe ser mayor que cero.___';
						END IF;
					END IF;
					
					--str_filas[6]	precio
					IF trim(str_filas[6])='' THEN
						valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':Es necesario ingresar el Precio Unitario.___';
					ELSE
						IF str_filas[6]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':El Precio Unitario debe ser mayor que cero.___';
						ELSE
							--si el tipo de cotizacion es 1=Cliente, entonces hay que validar precios
							IF str_data[5]::integer=1 THEN 
								
								IF num_lista_precio > 0 THEN
									--Sacando el descuento y precio del producto de acuerdo a la presentacion seleccionada
									sql_select:='SELECT (CASE WHEN descuento_'||num_lista_precio||' IS NULL THEN 0 ELSE descuento_'||num_lista_precio||' END ),inv_pre.precio_'||num_lista_precio||', (CASE WHEN inv_pre.gral_mon_id_pre'||num_lista_precio||' IS NULL THEN 0 ELSE inv_pre.gral_mon_id_pre'||num_lista_precio||' END) FROM inv_pre where inv_prod_id='||str_filas[3]||' AND inv_prod_presentacion_id='||str_filas[4]||' AND borrado_logico=false;';
									--RAISE EXCEPTION '%',sql_select;
									EXECUTE sql_select INTO descuento_producto, precio_producto, mon_prec_prod;
									
									IF descuento_producto IS NULL THEN
										descuento_producto:=0;
									END IF;
									
									IF precio_producto IS NULL THEN
										precio_producto:=0;
									ELSE
										--RAISE EXCEPTION '%', 'MonCot:'||str_data[10]::integer||'       mon_prec_prod:'||mon_prec_prod;
										IF str_filas[7]::integer <> mon_prec_prod::integer THEN 
											/*
											IF mon_prec_prod::integer > 0 THEN 
												SELECT valor FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=mon_prec_prod ORDER BY momento_creacion DESC LIMIT 1 INTO tc_mon_prod;
											ELSE
												tc_mon_prod:=0;
											END IF;
											*/
											IF str_filas[7]::integer=1 AND mon_prec_prod::integer<>1 THEN 
												--si la moneda del pedido es pesos y la moneda del precio es diferente de Pesos,
												--entonces calculamos su equivalente a pesos
												precio_producto:= precio_producto * str_data[16]::double precision;
											END IF;
											
											IF str_filas[7]::integer<>1 AND mon_prec_prod::integer=1 THEN 
												--si la moneda del Pedido es Diferente de Pesos y la moneda del precio es Pesos,
												--entonces calculamos su equivalente a dolar
												precio_producto:= precio_producto / str_data[16]::double precision;
											END IF;
										END IF;
									END IF;
									
									--Redondear a 4 digitos el precio del producto
									precio_producto:=round((precio_producto)::numeric, 4)::double precision;
									
									--RAISE EXCEPTION '%',num_lista_precio;
									--Obteniendo el valor del descuento
									descuento := ((descuento_producto::double precision/100) * precio_producto);
									
									--Redondear a 4 digitos el descuento
									descuento:=round((descuento)::numeric, 4)::double precision;
									
									--Precio minimo
									precio_minimo := precio_producto - descuento;
									
									--Redondear a 2 digitos el Precio Minimo
									precio_minimo := round((precio_minimo)::numeric, 4)::double precision;
									
									--RAISE EXCEPTION '%', 'PrecioVista:'||round(str_filas[6]::numeric, 2)::double precision||'       PrecioMinimo:'||precio_minimo;
									
									IF round(str_filas[6]::numeric, 4)::double precision < precio_minimo THEN 
										--valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':No puede ser asignado este precio.___';
										
										--RAISE EXCEPTION '%','facpar.aut_precio_menor_cot: '||facpar.aut_precio_menor_cot;
										
										--Verificar si la configuraci√≥n permite la autorizacion de precios abajo de la lista de precio en cotizaciones
										if facpar.aut_precio_menor_cot then 
											--Verificar si hay que salvar aun cuando hay precios no autorizados
											if str_filas[16]::boolean=false then 
												--Verificar si est√° autorizado el precio menor
												if str_filas[12]::boolean then 

													--RAISE EXCEPTION '%','str_filas[6]:'||str_filas[6]||'     str_filas[13]:'||str_filas[13];
													
													--Verificar si el precio no es menor al precio autorizado
													if round(str_filas[6]::numeric,4)::double precision < round(str_filas[13]::numeric,4)::double precision then 
														valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':El Precio es menor al autorizado '||str_filas[13]||'.___';
														valor_retorno := ''||valor_retorno||'checkauth'||str_filas[8]||':true.___';
													else
														--Verificar si el precio autorizado no es menor al precio_minimo de venta
														sql_select := '
														SELECT 
															sbt.prod_id,
															sbt.pres_id,
															sbt.moneda_id, 
															(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS pmin  
														FROM (
															SELECT 
																inv_prod.id AS  prod_id,
																inv_prod_pres_x_prod.presentacion_id AS pres_id,
																(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
																(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
																(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
																(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic, 
																(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
																(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
																(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
															FROM inv_prod 
															JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
															JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
															LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
															LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
															WHERE inv_prod.borrado_logico=false AND inv_prod_cost_prom.ano='||ano_actual||' AND inv_prod.id='||str_filas[3]||' AND inv_prod_pres_x_prod.presentacion_id='||str_filas[4]||'  
														) AS sbt LIMIT 1;';
														
														--RAISE EXCEPTION '%','sql_select: '||sql_select;
														
														FOR record1 IN EXECUTE (sql_select) LOOP 
															IF str_filas[7]::integer <> record1.moneda_id::integer THEN 
																IF str_filas[7]::integer=1 AND record1.moneda_id<>1 THEN 
																	--si la moneda del pedido es pesos y la moneda del Costo es diferente de Pesos,
																	--entonces calculamos su equivalente a pesos
																	record1.pmin:= record1.pmin * str_data[16]::double precision;
																END IF;
																
																IF str_filas[7]::integer<>1 AND record1.moneda_id=1 THEN 
																	--si la moneda del Pedido es Diferente de Pesos y la moneda del Costo es Pesos,
																	--entonces calculamos su equivalente a dolar
																	record1.pmin:= record1.pmin / str_data[16]::double precision;
																END IF;
															end if;

															record1.pmin:=round(record1.pmin::numeric, 4)::double precision;

															--RAISE EXCEPTION '%','str_filas[6]:'||str_filas[6]||'     record1.pmin:'||record1.pmin;
															
															IF round(str_filas[6]::numeric, 4)::double precision < record1.pmin THEN 
																valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':El Precio es menor al costo '||record1.pmin||'.___';
															end if;
														END LOOP;
													end if;
												else
													valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':No puede ser asignado este precio.___';
													valor_retorno := ''||valor_retorno||'checkauth'||str_filas[8]||':true.___';
												end if;
											end if;
										else
											valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':No puede ser asignado este precio.___';
										end if;
									END IF;
									
								END IF;
								
							END IF;
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;
	--Termina Validacion de Cotizaciones
	
	
	
	
	--Prefacturas
	IF id_app=13 THEN
		--str_data[3]	id_usuario
		--str_data[4]	id_prefactura
		--str_data[5] 	id_cliente
		
		--Obtener valores para estas variables:incluye_modulo_produccion, controlExisPres
		SELECT incluye_produccion, control_exis_pres FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, controlExisPres;
		
		
		--obtener el id del almacen de donde se va a facturar
		SELECT inv_alm_id FROM erp_prefacturas WHERE id=str_data[4]::integer INTO id_almacen;
		
		IF str_data[5]::integer < 1 THEN
			valor_retorno := ''||valor_retorno||'rfccliente:Es necesario seleccionar un cliente___';
		END IF;
		
		--str_data[6]	id_moneda
		--str_data[7]	observaciones
		--str_data[8]	tipo_cambio_vista
		
		IF str_data[8] = '' OR str_data[8] = ' ' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		ELSE
			IF str_data[8]::double precision <= 0 THEN
				valor_retorno := ''||valor_retorno||'tc:El tipo de cambio debe ser mayor que cero___';
			ELSE
				IF str_data[8]::double precision > 100 THEN
					valor_retorno := ''||valor_retorno||'tc:El tipo de cambio debe ser mayor que 100___';
				END IF;
			END IF;
		END IF;
		
		--str_data[9]	id_vendedor
		IF str_data[9]='0' THEN
			valor_retorno := ''||valor_retorno||'agente:Es necesario seleccionar el Agente. Debe ir a Clientes y asignar el Agente, depues reiniciar el procesos de facturacion de Remision___';
		END IF;
		
		--str_data[10]	id_condiciones
		IF str_data[10]='0' THEN
			valor_retorno := ''||valor_retorno||'terminos:Es necesario seleccionar un Termino de Pago. Debe ir a Clientes y asignar los Dias de Credito, depues reiniciar el procesos de facturacion de Remision___';
		END IF;
		
		--str_data[11]	orden_compra
		--str_data[12]	refacturar
		--str_data[13]	id_metodo_pago
		--str_data[14]	no_cuenta
		--str_data[15]	select_tipo_documento
		--str_data[16]	folio_pedido
		--str_data[16]	
		
		--RAISE EXCEPTION '%',str_data[13];
		
		/*
		IF str_data[13]::integer=2 OR str_data[13]::integer=3 THEN		
			IF str_data[14]='' OR str_data[14]=' ' THEN
				valor_retorno := ''||valor_retorno||'digitos:Es necesario ingresar los ultimos 4 digitos de la tarjeta___';
			ELSE
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_DigitosTarjetaCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[14]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno|| 'digitos:Es necesario ingresar 4 digitos.___';
				END IF;
			END IF;
		END IF;
		*/

		
		--Aqui se validan los datos para la Adenda
		--Primero se verifica si en los parametros indica que se debe incluir la Adenda
		IF facpar.incluye_adenda THEN 
			--Verificar que exista un id de cliente valido
			IF str_data[5]::integer > 1 THEN
				--Buscar el numero de Adenda asignado al cliente.
				SELECT cxc_clie_tipo_adenda_id FROM cxc_clie WHERE id=str_data[5]::integer INTO idAdenda;
				
				--Varificar si tiene adenda asignada
				IF idAdenda > 0 THEN
					--Verificar el numero de adenda
					IF idAdenda=1 THEN 
						--Addenda FEMSA QUIMIPRODUCTOS
						
						--Si el numero de Adenda es 1, entonces solo debe se debe validar datos cuando el tipo de documento es igual a 3.
						--Tipo Documento 3=Factura de Remision
						IF str_data[15]::integer=3 THEN 
							--str_data[20]	NoEntrada
							--str_data[21]	NoRemision
							--str_data[22]	Consignacion
							--str_data[23]  CentroCostos
							--str_data[24]	FechaInicio
							--str_data[25]  FechaFin
							--str_data[26]  Orden Compra
							--str_data[27]  Moneda
							
							valor_retorno2 := '';
							IF trim(str_data[27])='' THEN 
								valor_retorno2 := ''||valor_retorno2||'campo8$La Moneda no debe quedar vacio.&&&&&';
								valor_retorno3 := ''||valor_retorno3||'Orden de Compra, ';
							END IF;
							
							IF trim(str_data[22])='true' THEN 
								--Aqui entra cuando es Consignacion
								IF trim(str_data[23])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo4$Es necesario ingresar el Centro de Costo.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'Centro de Costo, ';
								END IF;
								IF trim(str_data[24])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo5$Es necesario ingresar la Fecha de Inicio.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'Fecha Inicio, ';
								END IF;
								IF trim(str_data[25])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo6$Es necesario ingresar la Fecha de Fin.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'Fecha Fin.';
								END IF;
							ELSE
								IF trim(str_data[26])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo7$La Orden de Compra no debe estar vacio.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'Orden de Compra, ';
								ELSE
									IF char_length(str_data[26])<10 THEN
										valor_retorno2 := ''||valor_retorno2||'campo7$La Orden de Compra debe tener 10 digitos.&&&&&';
										valor_retorno3 := ''||valor_retorno3||'Orden de Compra, ';
									ELSE
										IF char_length(str_data[26])>10 THEN
											valor_retorno2 := ''||valor_retorno2||'campo7$La Orden de Compra debe tener 10 digitos.&&&&&';
											valor_retorno3 := ''||valor_retorno3||'Orden de Compra, ';
										END IF;
									END IF;
								END IF;

								
								IF trim(str_data[20])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo1$El Numero de Entrada no puede quedar vacio.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'No. Entrada, ';
								ELSE
									IF char_length(str_data[20])<10 THEN
										valor_retorno2 := ''||valor_retorno2||'campo1$Numero de Entrada debe tener 10 digitos.&&&&&';
										valor_retorno3 := ''||valor_retorno3||'No. Entrada, ';
									ELSE
										IF char_length(str_data[20])>10 THEN
											valor_retorno2 := ''||valor_retorno2||'campo1$Numero de Entrada debe tener 10 digitos.&&&&&';
											valor_retorno3 := ''||valor_retorno3||'No. Entrada, ';
										END IF;
									END IF;
								END IF;
								
								IF trim(str_data[21])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo2$Es necesario ingresar el Numero de Remision.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'No. Remision, ';
								END IF;
							END IF;
							
							IF valor_retorno2<>'' THEN 
								valor_retorno := ''||valor_retorno||'adenda1: Falta ';
								valor_retorno := ''||valor_retorno||valor_retorno3||'___';
								valor_retorno := ''||valor_retorno||'adenda2:'||valor_retorno2;
							END IF;
						END IF;
					END IF;
					--Termina Addenda FEMSA-QUIMIPRODUCTOS

					--Addenda SUN CHEMICAL
					IF idAdenda=2 THEN 
						IF trim(str_data[11])='' THEN 
							valor_retorno := ''||valor_retorno||'oc:Orden de Compra es obligatorio para la Addenda___';
						END IF;
					END IF;
					--Termina addenda SUN CHEMICAL
				END IF;
			END IF;
		END IF;
		--Termina validacion de datos para la Adenda
		
		--EXECUTE 'select '''||str_data[11]||''' ~ ''^[^@ ]+@[^@ ]+.[^@ .]+$'';' INTO match_cadena;
		--str_data[28]	rfc
		IF trim(str_data[28]) = '' THEN
			valor_retorno := ''||valor_retorno||'rfc:Se requiere el RFC del Cliente.___';
		ELSE
			EXECUTE 'select '''||str_data[28]||''' ~ ''^[A-Za-z0-9&]{3,4}[0-9]{6}[A-Za-z0-9]{3}$'';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'rfc:RFC No Valido.___';
			END IF;
		END IF;
		
		/*
		--str_data[29]	check_envio
		IF trim(str_data[29]) = 'true' THEN
			IF trim(str_data[30]) = '' THEN
				valor_retorno := ''||valor_retorno||'emailenvio:Se requiere el E-Mail para el envio.___';
			ELSE
				EXECUTE 'select '''||str_data[30]||''' ~ ''^[^@ ]+@[^@ ]+.[^@ .]+$'';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'emailenvio:E-Mail No Valido.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[30]	email_envio
		*/

		--str_data[30]	select_tmov
		--str_data[15]	select_tipo_documento
		--1=Factura, 2=Remision, 3=Factura de Remision
		
		if str_data[15]::integer=1 or str_data[15]::integer=3 then 
			if str_data[30]::integer<=0 then 
				--valor_retorno := ''||valor_retorno||'tmov:Seleccionar el Tipo de Movimiento.___';
			end if;
		end if;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] <> 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					--str_filas[8]	valor_impuesto
					--str_filas[9]	id_remision
					--str_filas[10]	costo_promedio
					
					--str_filas[11]	idUnidad
					--str_filas[12]	id_ieps
					--str_filas[13]	tasa_ieps
					--str_filas[14]	vdescto
					
					--Inicializar valores
					cantPresAsignado:=0;
					equivalenciaPres:=0;
					exisActualPres:=0;
					cantPresReservAnterior:=0;
					noDecUnidad:=0;
					cant_reservada_anterior:=0;
					total_existencia:=0;
					
					--str_filas[6]	cantidad
					IF trim(str_filas[6]) = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Es necesario ingresar la cantidad___';
					ELSE
						--Verificar que el campo sea numerico
						IF (SELECT trim(str_filas[6]) ~ '^([0-9]+[.]?[0-9]*|[.][0-9]+)$') THEN 
							
							--RAISE EXCEPTION '%',str_filas[6];
							IF str_filas[6]::double precision < 0.000001 THEN
								/*
								Se comento esta validacion porque ya se se puede facturar parcialmente un pedido
								y se puede dejar partidas en cero para no incluirla en la factura.
								*/
								--valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad debe ser mayor que cero___';
							ELSE	
								--si refacturar=false, valida existencias, si es refacturacion no se valida nada
								IF str_data[12] = 'false' THEN
									
									--obtener el tipo de producto y el numero de Decimales Permitidos
									SELECT 
										inv_prod.tipo_de_producto_id AS tipo_producto,
										(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec,
										inv_prod.unidad_id,
										inv_prod.densidad,
										(CASE WHEN inv_prod_unidades.titulo IS NULL THEN '' ELSE inv_prod_unidades.titulo END) AS unidad
									FROM inv_prod 
									LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
									WHERE inv_prod.id=str_filas[3]::integer 
									INTO tipo, noDecUnidad, idUnidadMedida, densidadProd, nombreUnidadMedida;
									
									IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
									
									--Verificar si se esta facturando en diferente unidad de medida
									IF idUnidadMedida::integer<>str_filas[11]::integer  THEN
										EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
										IF match_cadena=true THEN 
											--Convertir a Litros
											str_filas[6] := str_filas[6]::double precision / densidadProd;
										ELSE
											EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
											IF match_cadena=true THEN
												--Convertir a kilos
												str_filas[6] := str_filas[6]::double precision * densidadProd;
											END IF;
										END IF;
									END IF;
									
									
									--Redondear la Cantidad
									str_filas[6] := round(str_filas[6]::numeric,noDecUnidad)::double precision;
									
									
									--Si el tipo de producto es diferente de 4, hay que validar existencias
									--tipo=4 Servicios
									--para el tipo servicios no se debe validar existencias
									IF tipo<>4 THEN
										
										--Tipo de Documento diferente de 3(Facturacion de Remision)
										IF str_data[15]::integer<>3 THEN
											--tipo=1 Normal o Terminado
											--tipo=2 Subensable o Formulacion o Intermedio
											--tipo=5 Refacciones
											--tipo=6 Accesorios
											--tipo=7 Materia Prima
											--tipo=8 Prod. en Desarrollo
											IF tipo=1 OR tipo=2 OR tipo=5 OR tipo=6 OR tipo=7 OR tipo=8 THEN 
												--llamada a proc que devuelve la existencia del producto. 
												--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
												--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
												SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, id_almacen) INTO total_existencia;
												
												IF str_filas[2]::integer>0 THEN
													--buscamos la cantidad reservada anterior
													SELECT reservado FROM erp_prefacturas_detalles WHERE id=str_filas[2]::integer INTO cant_reservada_anterior;
													
													--Redondear la cantidad reservada anterior
													cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
													
													--le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
													total_existencia := total_existencia::double precision + cant_reservada_anterior::double precision;
												END IF;
												
												--Redondear la existencia actual
												total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
												
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':El producto tiene Existencia 0 en Almacen___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Disponibles '||total_existencia||',  usted esta intentando vender '||str_filas[6]||'___';
													END IF;
												END IF;
												
												--RAISE EXCEPTION '%' ,'controlExisPres: '||controlExisPres;
												--Verificar si hay que validar existencias de Presentaciones
												IF controlExisPres=true THEN 
													--Buscar la equivalencia de la Presentacion
													SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_filas[4]::integer 
													INTO equivalenciaPres;
													
													IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
													
													--Buscar la existencia actual de la Presentacion
													SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exi
													FROM inv_exi_pres WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=str_filas[3]::integer AND inv_prod_presentacion_id=str_filas[4]::integer 
													INTO exisActualPres;
													
													IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
													
													
													--Si la configuracion indica que se validan Presentaciones desde el Pedido,
													--entonces significa que hay reservados, por lo tanto hay que descontarlos para tener la existencia real
													IF facpar.validar_pres_pedido=true THEN 
														--Si la presentacion actual es igual a la presentacion  anterior, entonces calculamos la c
														cantPresReservAnterior := cant_reservada_anterior::double precision / equivalenciaPres::double precision;
														
														--redondear la Cantidad de la Presentacion reservada Anteriormente
														cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
														
														--sumar la cantidad reservada anterior para tener la existencia real
														exisActualPres = exisActualPres::double precision + cantPresReservAnterior::double precision;
													END IF;
													--RAISE EXCEPTION '%' ,'exisActualPres: '||exisActualPres;
													
													--Redondear la Existencia actual de Presentaciones
													exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision; 
													
													--Convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
													cantPresAsignado := str_filas[6]::double precision / equivalenciaPres::double precision;
													
													--Redondear la cantidad de Presentaciones Asignado en la partida
													cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision;
													--RAISE EXCEPTION '%' ,'cantPresAsignado: '||cantPresAsignado;

													
													IF exisActualPres <= 0 THEN
														valor_retorno := ''||valor_retorno||'presentacion'||cont_fila||':No hay existencia en esta Presentacion.___';
													ELSE
														IF exisActualPres::double precision < cantPresAsignado::double precision THEN
															valor_retorno := ''||valor_retorno||'presentacion'||cont_fila||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
														END IF;
													END IF;
													
												END IF;
												
											END IF;
										END IF;
										
									END IF;
								END IF;
							END IF;
							
						ELSE
							--Aqui entra porque el campo cantidad trae un valor no numerico
							valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':El valor para Cantidad es incorrecto, tiene mas de un punto('||str_filas[6]||')___';
						END IF;
						
					END IF;
					--valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el precio unitario___';
					--str_filas[7]	costo
					IF str_filas[7] = ' ' OR str_filas[7] = ''THEN
						valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el precio unitario___';
					ELSE
						IF str_filas[7]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'costo'||cont_fila||':El precio debe ser mayor que cero___';
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--termina prefacturas
	
	
	
	
	--registro de pagos
	--pendiente validacion
	IF id_app=14 THEN
		--str_data[4] 	cliente_id
		--str_data[5] 	deuda_pesos
		--str_data[6] 	deuda_usd
		--str_data[7] 	moneda
		--str_data[8] 	fecha
		--str_data[9] 	banco
		--str_data[10] 	observaciones
		--str_data[11] 	forma_pago
		--str_data[12] 	cheque
		--str_data[13] 	referencia
		--str_data[14] 	tarjeta
		
		--obtiene id de la forma de pago
		--SELECT id FROM erp_pagos_formas WHERE titulo ILIKE str_data[8] LIMIT 1 into id_forma_pago;
		--1 Efectivo
		--2 Cheque
		--3 Tarjeta
		--4 Transferencia
		
		IF str_data[11] = 'Efectivo' THEN
			--no se valida nada
		END IF;
		
		IF str_data[11] = 'Cheque' THEN
			IF str_data[9]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'bancos:Es necesario seleccionar el banco del cheque___';
			END IF;
			IF str_data[12] = '' THEN
				valor_retorno := ''||valor_retorno||'nocheque:Es necesario ingresar el numero de cheque___';
			END IF;
		END IF;
		IF str_data[11] = 'Tarjeta' THEN
			IF str_data[9]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'bancos:Es necesario seleccionar el banco de la tarjeta___';
			END IF;
			/*
			IF str_data[13] = '' THEN
				valor_retorno := ''||valor_retorno||'notarjeta:Es necesario ingresar el numero de la tarjeta___';
			END IF;
			*/
		END IF;
		
		IF str_data[11] = 'Transferencia' THEN
			IF str_data[9]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'bancos:Es necesario seleccionar el banco de la transferencia___';
			END IF;
			IF str_data[13] = '' THEN
				valor_retorno := ''||valor_retorno||'referencia:Es necesario ingresar el numero de referencia de la transferencia___';
			END IF;
		END IF;
		
		--str_data[15] 	antipo
		--str_data[16] 	monto_pago
		--str_data[17] 	fecha_deposito
		--str_data[18] 	ficha_movimiento_deposito
		--str_data[19] 	ficha_cuenta_deposito
		IF str_data[19]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'cuentaempresa:Es necesario seleccionar la cuenta en la que se realizo el deposito___';
		END IF;
		
		--str_data[20] 	ficha_banco_kemikal
		IF str_data[20]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'bancoempresa:Es necesario seleccionar el banco de la empresa donde se realizo el deposito___';
		END IF;
		--str_data[21] 	tipo_cambio
		--str_data[22] 	anticipo_gastado
		--str_data[23] 	no_transaccion_anticipo

		--obtener id del anticipo
		SELECT COUNT(id) FROM cxc_ant WHERE numero_transaccion=str_data[23]::bigint AND cliente_id=str_data[4]::integer AND borrado_logico=false INTO exis;
		IF exis > 0 THEN
			SELECT cancelado FROM cxc_ant WHERE numero_transaccion=str_data[23]::bigint AND cliente_id=str_data[4]::integer LIMIT 1 
			INTO registro_cancelado;

			IF registro_cancelado THEN 
				valor_retorno := ''||valor_retorno||'cancelado:No es posible aplicar &eacute;ste anticipo.<br>Es posible que haya sido cancelado por otro usuario en otro proceso.___';
			END IF;
		END IF;
		
		/*
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1]	factura_vista
				--str_filas[2]	saldado
				--str_filas[3]	saldo
				--str_filas[4]	tipocambio
				
			END LOOP;
		END IF;
		*/
		
	END IF;--termina carteras
	
	
	--registro de centro de costo
	IF id_app=15 THEN
		--str_data[4] 	id
		--str_data[5] 	titulo
		--str_data[6] 	descripcion
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'centrocosto:Es necesario ingresar el nombre del Centro de Costo___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM ctb_cc WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE;'  INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'centrocosto:El nombre del Centro de Costo ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;
	
	
	--validacion de tipos de poliza
	IF id_app=16 THEN
		--str_data[4] 	id
		--str_data[5] 	tipo
		--str_data[6] 	descripcion
		--str_data[7] 	grupo
		
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'tipo:Es necesario ingresar el Tipo de Poliza___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TipoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tipo:El Tipo de poliza debe ser Numero___';
			END IF;
		END IF;
		
		
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		
		IF str_data[7]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'grupo:Es necesario seleccionar un Grupo';
		END IF;
		
		IF trim(str_data[4]) = '0' THEN
			--RAISE EXCEPTION '%',valida_integridad;
			IF trim(str_data[5])<>'' THEN
				
				EXECUTE 'SELECT count(id) FROM ctb_tpol WHERE tipo='||str_data[5]  INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'tipo:El tipo de Poliza ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
	END IF;

	--validacion de conceptos contables
	IF id_app=17 THEN
		--str_data[4] 	id
		--str_data[5] 	titulo
		--str_data[6] 	descripcion
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario ingresar el nombre del Concepto Contable___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion del Concepto Contable___';
		END IF;
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM ctb_con WHERE titulo = '''||str_data[5]||''';'  INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'concepto:El nombre del Concepto ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de conceptos contables
	
	
	
	
	--validacion de Clasificacion de Cuentas(Cuentas de Mayor)
	IF id_app=18 THEN
		--str_data[4]	id
		--str_data[5]	ctamayor
		--str_data[6]	clasificacion
		--str_data[7]	des_espanol
		--str_data[8]	des_ingles
		--str_data[9]	des_otro
		
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'ctamayor:Es necesario selecionar una Cuenta de Mayor___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'clasificacion:Es necesario ingresar la Clasificacion___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ClasificacionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'clasificacion:La Clasificacion debe ser Numero___';
			END IF;
		END IF;
		
		IF str_data[7] = '' THEN
			valor_retorno := ''||valor_retorno||'desesp:Es necesario ingresar la Descripcion en espa√±ol___';
		END IF;
	END IF;--termina validacion de Clasificacion de Cuentas(Cuentas de Mayor)

	--validacion de Catalogo de Agentes
	IF id_app=19 THEN
		--str_data[4]	id
		--str_data[5]	nombre_agente
		--str_data[6]	usuario_agente
		--str_data[7]	comision
		--str_data[8]	region
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'nombre:Es necesario ingresar el nombre completo del Agente___';
		END IF;
		
		IF str_data[6]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'user:Es necesario seleccionar un usuario para el Agente___';
		END IF;
		
		IF str_data[7] = '' OR str_data[7] = ' ' THEN
			valor_retorno := ''||valor_retorno||'comision:Es necesario ingresar la Comision___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ComisionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'comision:La Comision debe ser Numero___';
			END IF;
		END IF;
		
		IF str_data[8]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'region:Es necesario seleccionar una Region para el Agente___';
		END IF;
	END IF;--termina validacion de Catalogo de Agentes
	

	--validacion de Catalogo Clientes Clasificacion 1
	IF id_app=20 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from cxc_clie_clas1 where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina validacion Catalogo Clientes Clasificacion 1
	

	--validacion de Catalogo Clientes Clasificacion 2
	IF id_app=21 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from cxc_clie_clas2 where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina validacion Catalogo Clientes Clasificacion 2

	--validacion de Catalogo Clientes Clasificacion 3
	IF id_app=22 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from cxc_clie_clas3 where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina validacion Catalogo Clientes Clasificacion 3

	--validacion de Catalogo zonas de Clientes
        IF id_app=23 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxc_clie_zonas where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo zonas de clientes

        
        --validacion de Catalogo grupos de Clientes
        IF id_app=24 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxc_clie_grupos where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo grupos de clientes
	
	--validacion de Catalogo Proveedores Clasificacion 1
        IF id_app=25 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_clas1 where  titulo ilike '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Proveedores Clasificacion 1

        --validacion de Catalogo Proveedores Clasificacion 2
        IF id_app=26 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_clas2 where  titulo ilike '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Proveedores Clasificacion 2

        --validacion de Catalogo Proveedores Clasificacion 3
        IF id_app=27 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_clas3 where  titulo ilike '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Proveedores Clasificacion 3

	--validacion de Catalogo zonas de proveedores
        IF id_app=28 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_zonas where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Zonas de Proveedores
        

        --validacion de Catalogo grupo de proveedores
        IF id_app=29 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_grupos where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo grupos de Proveedores
	
	
	
	/*
	str_data[1] 	app_selected
	str_data[2] 	command_selected
	str_data[3] 	id_usuario
	str_data[4]	id_factura+"___"+
	str_data[5]	id_proveedor+"___"+
	str_data[6]	tipo_factura+"___"+
	str_data[7]	observaciones.toUpperCase()+"___"+
	str_data[8]	factura+"___"+
	str_data[9]	expedicion+"___"+
	str_data[10]	tc+"___"+
	str_data[11]	denominacion+"___"+
	str_data[12]	numeroguia+"___"+
	str_data[13]	ordencompra+"___"+
	str_data[14]	fletera_id+"___"+
	str_data[15]	dias_credito_id+"___"+
	str_data[16]	flete;
	*/
	--facturas de proveedores
	IF id_app=30 THEN
		--RAISE EXCEPTION '%','campos_data: '||campos_data;
		--id_factura 	str_data[4]
		--id_proveedor	str_data[5] id_proveedor
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'rfcproveedor:Es necesario seleccionar un proveedor___';
		END IF;
		/*
		--factura	str_data[8]
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FacturaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
		END IF;
		*/
		--factura	str_data[8] expedicion
		IF str_filas[8] = ' ' OR str_data[8] = '' THEN
			valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
		END IF;
		/*
		--expedicion	str_data[9] expedicion
		IF str_filas[9] = ' ' OR str_data[9] = '' THEN
			valor_retorno := ''||valor_retorno||'expedicion:Es necesario seleccionar una fecha___';
		END IF;
		*/
		
		--denominacion	str_data[11] denominacion
		IF str_data[11]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'denominacion:Es necesario seleccionar una moneda___';
		END IF;
		
		--tipo cambio	str_data[10] tc
		IF str_filas[10] = ' ' OR str_data[10] = '' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		END IF;
		
		--observaciones	str_data[12]
		/*
		--str_data[14] fletera
		IF str_data[14] = '' THEN
			valor_retorno := ''||valor_retorno||'fletera:Es necesario seleccionar una compa√±ia___';
		END IF;
		*/
		--str_data[16] flete
		
		
		IF str_data[4] ='0' THEN
			IF str_data[8] != ' ' OR str_data[8] != '' THEN
				IF str_data[5] !='' THEN
					valida_integridad:=0;
					EXECUTE 'SELECT count(id) FROM cxp_facturas WHERE  cxc_prov_id='||str_data[5]||' AND serie_folio ilike '''||str_data[8]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'factura:La Factura ya se encuentra registrada___';
					END IF;
				END IF;
			END IF;
		END IF;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--eliminado	str_filas[9]
				IF str_filas[9]::integer <> 0 THEN--1: no esta eliminado, 0:eliminado
					--codigo_producto 	str_filas[1]
					IF trim(str_filas[1])='' THEN
						valor_retorno := ''||valor_retorno||'codigo'||cont_fila||':Es necesario ingresar el Codigo___';
					END IF;
					
					--descripcion_producto 	str_filas[2]
					IF trim(str_filas[2])='' THEN
						valor_retorno := ''||valor_retorno||'titulo'||cont_fila||':Es necesario ingresar la Descripcion___';
					END IF;
					
					--unidad 		str_filas[3]
					IF trim(str_filas[3])='' THEN
						valor_retorno := ''||valor_retorno||'unidad'||cont_fila||':Es necesario ingresar la Unidad___';
					END IF;
					
					--presentacion 		str_filas[4]
					--cantidad 		str_filas[5]
					IF trim(str_filas[5])='' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[5]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad debe ser mayor que cero___';
						END IF;
					END IF;
					
					--costo		str_filas[6]
					IF trim(str_filas[6])='' THEN
						valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el costo___';
					ELSE
						IF str_filas[6]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'costo'||cont_fila||':El costo debe ser mayor que cero___';
						END IF;
					END IF;

					
					--impuesto_id	str_filas[7]
					--valor_imp	str_filas[8]
					--eliminado	str_filas[9]
					--ieps_id	str_filas[10]
					--tasa_ieps	str_filas[11]
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;
	
	
	

	IF id_app=31 THEN
                                   --aplicacion
                                   --comando
                                   --usuario
                --str_data[4]        id
                --str_data[5]        titulo  topo mov
                --str_data[6]        descripcion descrip
                --str_data[7]        id_moneda
                
                IF str_data[5] = ''  THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del tipo de movimiento___';
                END IF;

                IF str_data[6] = ''  THEN
                        valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar el Titulo del tipo de movimiento___';
                END IF;
                
                IF str_data[4] = '0' THEN 
                        EXECUTE 'select count(id) from cxp_mov_tipos where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                        IF valida_integridad > 0 THEN
                                valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                        END IF;
                END IF;
        END IF;--termina validacion Catalogo tipos de movimientos de Proveedores
        
        
        IF id_app=32 THEN
                                   --aplicacion
                                   --comando
                                   --usuario
                --str_data[4]        id
                --str_data[5]        titulo  topo mov
                --str_data[6]        descripcion descrip
                --str_data[7]        id_moneda
                
                IF str_data[5] = ''  THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del tipo de movimiento___';
                END IF;
		
                IF str_data[6] = ''  THEN
                        valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar el Titulo del tipo de movimiento___';
                END IF;
                
                IF str_data[4] = '0' THEN 
                        EXECUTE 'select count(id) from cxc_mov_tipos where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                        IF valida_integridad > 0 THEN
                                valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                        END IF;
                END IF;
        END IF;--termina validacion Catalogo tipos de movimientos de clientes
	
	
	
	
	
	
	--validacion de Catalogo de tipos de movimientos inventario
	IF id_app=35 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	tipo
		--str_data[6]	descripcion
		--str_data[7]	mov_de_ajuste
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'tipo:Es necesario ingresar el titulo para el tipo de movimiento de inventario___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descripcion, para el tipo de movimiento de inventario___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM inv_mov_tipos WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false;' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'tipo:Ya existe un tipo de movimiento de inventario con el mismo nombre___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de Catalogo de tipos de movimientos inventario
	
	
	
	
	
	/*
	SELECT serie_folio FROM fac_docs WHERE id=100542
	SELECT count(serie_folio) FROM erp_pagos_detalles WHERE cancelacion=FALSE AND serie_folio='SEFAC22'
	SELECT count(serie_folio_factura) FROM fac_nota_credito WHERE serie_folio!='' AND cancelado=FALSE AND serie_folio_factura='SEFAC22'
	*/
	
	--Validacion de Cancelacion de Facturas
	IF id_app=36 THEN
		--str_data[4]	id_factura
		--str_data[5]	tipo_cancelacion
		--str_data[6]	motivo_cancelacion
		
		valor_retorno:='true';
		
		SELECT serie_folio FROM fac_docs WHERE id=str_data[4]::integer INTO serie_folio_fac;
		
		
		
		/*
		SELECT estatus FROM inv_osal WHERE folio_documento=serie_folio_fac AND tipo_documento=1 INTO estatus_osal;
		
		IF estatus_osal=2 THEN 
			IF str_data[5]::integer=1 THEN 
				valor_retorno := 'false___La marcanc&iacute;a se le dio salida del almacen, es necesario realizar una devoluci&oacute;n';
			END IF;
		END IF;
		*/
		
		--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
		IF upper(valor_retorno)='TRUE' THEN 
			--Verifica si hay pagos para la factura
			SELECT count(serie_folio) FROM erp_pagos_detalles WHERE cancelacion=FALSE AND serie_folio=serie_folio_fac INTO tiene_pagos;
			
			--Si tiene_pagos=0, tambien hay que checarsi no tiene notas de Credito aplicada a la factura
			IF tiene_pagos = 0 THEN
				SELECT count(serie_folio_factura) FROM fac_nota_credito WHERE serie_folio!='' AND cancelado=FALSE AND serie_folio_factura=serie_folio_fac INTO tiene_pagos;
				
				IF tiene_pagos > 0 THEN
					valor_retorno := 'false___La Factura '||serie_folio_fac||', tiene Notas de Credito aplicados.<br>Es necesario cancelar primeramente la Nota de Credito y despues cancelar la factura.';
				END IF;
			ELSE
				valor_retorno := 'false___La Factura '||serie_folio_fac||', tiene pagos aplicados.<br>Es necesario cancelar primeramente los pagos y despues cancelar la factura.';
			END IF;
			
		END IF;
		
		
	END IF;--termina validacion de Cancelacion de Facturas
	
	
	
	
	
	
	--validacion de Catalogo de invsecciones
	IF id_app=37 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		--str_data[7]	mov_de_ajuste
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para la seccion___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para la seccion___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM inv_secciones WHERE titulo ilike '''||str_data[5]||''' AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe una seccion con el mismo nombre___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de Catalogo de invsecciones
	
	
	--validacion de Catalogo inventario Marcas
	IF id_app=38 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion
		--str_data[6]	     estatus
		--str_data[7]	     url
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Marca___';
		END IF;
		
		IF str_data[7] = '' THEN
			valor_retorno := ''||valor_retorno||'url:Es necesario ingresar la url___';
		END IF;
		
		IF str_data[7] != '' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''isUrlCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'url:Url incorrecta___';
			END IF;	
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from inv_mar where  titulo ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion Catalogo inventario Marcas	
	
	
	--inicia Catalogo de inv_prod_lineas
	IF id_app=39 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		--str_data[7]	seccion
		--str_data[8]	marcas
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para la linea___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para la linea___';
		END IF;

		IF str_data[7] = '0'  THEN
			valor_retorno := ''||valor_retorno||'seccion:Es necesario seleccionar una seccion para la linea___';
		END IF;

		IF arreglo[1] = 'sin datos' THEN
			valor_retorno := ''||valor_retorno||'marca:Es necesario asignar porlomenos una marca para la linea___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM inv_prod_lineas WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe una linea con el mismo nombre___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina validacion de Catalogo de inv_prod_lineas
        
	
	
	
	 --validacion de Catalogo inventario Zonas de invetarios
	IF id_app=40 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion
		--str_data[6]	     estatus
		--str_data[7]	     zona
			
		IF str_data[7] = '' THEN				
			 valor_retorno := ''||valor_retorno||'zona:Es necesario ingresar la zona___';
		END IF;
		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la  descrpcion de la zona___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from inv_zonas where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'zona:La zona ingresada ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion Catalogo inventario Zonas	de inventarios

	--validacion de Catalogo de tes_mov_tipos
	IF id_app=41 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		--str_data[7]	grupo
		--str_data[8]	tipo
		--str_data[9]	conconsecutivo
		--str_data[10]	conciliacionautomatica
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para el tipo de movimiento___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para el tipo de movimiento___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM tes_mov_tipos WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe un tipo de movimiento con el mismo nombre___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina Catalogo tes_mov_tipos

	--validacion de Catalogo de tes_ban
	IF id_app=42 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		--str_data[7]	clave
		
		IF trim(str_data[5])='' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para el banco___';
		END IF;
		
		IF trim(str_data[6])='' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para el banco___';
		END IF;

		IF incluye_nomina THEN 
			IF trim(str_data[7])='' THEN
				valor_retorno := ''||valor_retorno||'clave:Es necesario ingresar la clave del Banco de acuerdo al catalogo del SAT.___';
			END IF;
		END IF;
		
		IF str_data[4] ='0' THEN
			IF trim(str_data[5])<>'' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM tes_ban WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe un banco con el mismo nombre___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina Catalogo tes_ban

	

	--validacion de Catalogo de Familias
	IF id_app=43 THEN
		--str_data[4] 	id
		--str_data[5] 	titulo
		--str_data[6] 	descripcion
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'familia:Es necesario ingresar el nombre de la Nueva Familia___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod_familias WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'familia:El nombre de la Familia ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de de Catalogo de Familias

	--validacion de Catalogo de Conceptos Bancarios(tes_con)
	IF id_app=44 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para el concepto___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para el concepto___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM tes_con WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe un concepto con el mismo nombre___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina Catalogo tes_con
	
	
	
	--validacion de Catalogo producto grupos
        IF id_app=45 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        grupo
                --str_data[6]	     decripcion
                
		IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'grupo:Es necesario ingresar el grupo___';
		END IF;

                IF str_data[6] = ''  THEN
                        valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la  descripcion del grupo___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from inv_prod_grupos where  titulo ilike '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'grupo:El Grupo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;              
                
        END IF;--termina validacion Catalogo producto grupos

	--validacion de Catalogo plazas en inventarios
        IF id_app=46 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        plaza
                --str_data[6]	     nombre
                --str_data[7]	     zonas
                --str_data[8]	     estatus
                
                IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'plaza:Es necesario ingresar la plaza___';
		END IF;

		IF str_data[7]::integer = 0 THEN				
			 valor_retorno := ''||valor_retorno||'zona:Es necesario elegir una zona___';
		END IF;
		
                IF str_data[6] = ''  THEN
                        valor_retorno := ''||valor_retorno||'nombre:Es necesario ingresar el nombre de la plaza___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from gral_plazas where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'plaza:La plaza ingresada ya se encuentra en uso___';
				END IF;

				EXECUTE 'select count(id) from gral_plazas where  descripcion ilike '''||str_data[6]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nombre:la descripcion de la plaza  ya se encuentra en uso__';
				END IF;
			END IF;
		END IF;
        END IF;--termina validacion Catalogo plazas en inventarios
	
	
	
	--validacion de Catalogo de inv_pre
	IF id_app=47 THEN
		SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		IF str_data[4] ='0' THEN
			IF str_data[5] != '0' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM inv_pre WHERE inv_prod_id='||str_data[5]::integer||' AND inv_prod_presentacion_id='||str_data[76]::integer||' AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'productosku:Ya existe una lista de precios para el producto con esta presentaci&oacute;n.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[5]	producto_id
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'productosku:Es necesario Seleccionar un producto___';
		END IF;
		
		--str_data[6]	lista1
		IF str_data[6] != '' THEN
			IF str_data[6]::double precision > 0 THEN
				--str_data[77]	select_moneda1
				IF str_data[77] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda1:Es necesario Seleccionar la Moneda para el Precio de la Lista 1.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[7]	lista2
		IF str_data[7] != '' THEN
			IF str_data[7]::double precision > 0 THEN
				--str_data[78]	select_moneda2
				IF str_data[78] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda2:Es necesario Seleccionar la Moneda para el Precio de la Lista 2.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[8]	lista3
		IF str_data[8] != '' THEN
			IF str_data[8]::double precision > 0 THEN
				--str_data[79]	select_moneda3
				IF str_data[79] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda3:Es necesario Seleccionar la Moneda para el Precio de la Lista 3.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[9]	lista4
		IF str_data[9] != '' THEN
			IF str_data[9]::double precision > 0 THEN
				--str_data[80]	select_moneda4
				IF str_data[80] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda4:Es necesario Seleccionar la Moneda para el Precio de la Lista 4.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[10]	lista5
		IF str_data[10] != '' THEN
			IF str_data[10]::double precision > 0 THEN
				--str_data[81]	select_moneda5
				IF str_data[81] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda5:Es necesario Seleccionar la Moneda para el Precio de la Lista 5.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[11]	lista6
		IF str_data[11] != '' THEN
			IF str_data[11]::double precision > 0 THEN
				--str_data[82]	select_moneda6
				IF str_data[82] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda6:Es necesario Seleccionar la Moneda para el Precio de la Lista 6.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[12]	lista7
		IF str_data[12] != '' THEN
			IF str_data[12]::double precision > 0 THEN
				--str_data[83]	select_moneda7
				IF str_data[83] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda7:Es necesario Seleccionar la Moneda para el Precio de la Lista 7.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[13]	lista8
		IF str_data[13] != '' THEN
			IF str_data[13]::double precision > 0 THEN
				--str_data[84]	select_moneda8
				IF str_data[84] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda8:Es necesario Seleccionar la Moneda para el Precio de la Lista 8.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[14]	lista9
		IF str_data[14] != '' THEN
			IF str_data[14]::double precision > 0 THEN
				--str_data[85]	select_moneda9
				IF str_data[85] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda9:Es necesario Seleccionar la Moneda para el Precio de la Lista 9.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[15]	lista10
		IF str_data[15] != '' THEN
			IF str_data[15]::double precision > 0 THEN
				--str_data[86]	select_moneda10
				IF str_data[86] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda10:Es necesario Seleccionar la Moneda para el Precio de la Lista 10.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[76]	presentacion
		IF str_data[76] = '0' THEN
			valor_retorno := ''||valor_retorno||'presentacion:Es necesario seleccionar una Presentaci&oacute;n. Si no le muestra opciones tiene que ir al cat&aacute;logo de productos y asignar una presentaci&oacute;n.___';
		END IF;
		
		--str_data[77]	select_moneda1
		--str_data[78]	select_moneda2
		--str_data[79]	select_moneda3
		--str_data[80]	select_moneda4
		--str_data[81]	select_moneda5
		--str_data[82]	select_moneda6
		--str_data[83]	select_moneda7
		--str_data[84]	select_moneda8
		--str_data[85]	select_moneda9
		--str_data[86]	select_moneda10
		
	END IF;--termina Catalogo inv_pre

	--validacion de Catalogo de SubFamilias
	IF id_app=48 THEN
		--str_data[4] 	id
		--str_data[5] 	titulo
		--str_data[6] 	descripcion
		--str_data[7] 	select_familia
		
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'subfamilia:Es necesario ingresar el nombre de la Nueva Subfamilia___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		IF str_data[7]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'selfamilia:Es necesario Seleccionar una Familia___';
		END IF;
		
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod_familias WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE AND id!=identificador_familia_padre AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'subfamilia:El nombre de la Subfamilia ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de de Catalogo de SubFamilias
	
	
	--validacion Catalogo UNIDADES
	IF id_app=49 THEN
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'unidad:Es necesario ingresar la unidad___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion de la nueva unidad___';
		END IF;
		
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod_unidades WHERE titulo_abr = '''||str_data[5]||'''   and borrado_logico=FALSE ' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'unidad:El nombre de la unidad ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de de Catalogo de unidades

	

	
	--validacion de Catalogo Inventario Unidades
        IF id_app=50 THEN
                SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        titulo
                --str_data[6]	     descripcion
                IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'clasificacion:Es necesario ingresar la Clasificacion___';
		END IF;

		IF str_data[6] = '' THEN				
			 valor_retorno := ''||valor_retorno||'descripcion:Es necesario crear una descripcion para la Clasificacion___';
		ELSE
			IF str_data[4] = '0' THEN 
				--RAISE EXCEPTION '%','id de empleadooooooo???'||emp_id;
				EXECUTE 'select count(id) from inv_stock_clasificaciones where  titulo = '''||str_data[5]||''' and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'unidad:La unidad ingresada ya se encuentra en uso___';
				END IF;
				EXECUTE 'select count(id) from inv_stock_clasificaciones where  descripcion = '''||str_data[6]||'''  and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'descripcion:la descripcion de la unidad  ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
                
        END IF;--termina validacion Catalogo Inventario clasificacion stock
	
	
	
	
	--validacion de Catalogo de Comisiones
	--validacion de  Comisiones de arti-culos
	IF id_app=51 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	producto_id
		--str_data[6]	descripcion
		
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'productosku:Es necesario Seleccionar un producto___';
		END IF;

		IF str_data[6] = '' OR str_data[6] = ' ' THEN
			valor_retorno := ''||valor_retorno||'escala:Es necesario ingresar una escala___';
		END IF;
		
	END IF;--termina  Comisiones de arti-culos
	
	
	
	--validacion de Catalogo clasificacion
        IF id_app=52 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                --str_data[6]	     descripcion
                IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'clasificacion:Es necesario ingresar la Clasificacion___';
		END IF;
		
		IF str_data[6] = '' THEN				
			 valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		
		IF str_data[7] = '' THEN				
			 valor_retorno := ''||valor_retorno||'stock:Es necesario ingresar el stock de seguridad___';
		END IF;
		
		IF str_data[8] = '' THEN				
			 valor_retorno := ''||valor_retorno||'factor:Es necesario el factor de seguridad___';
		ELSE
			IF str_data[4] = '0' THEN 
				--RAISE EXCEPTION '%','id de empleadooooooo???'||emp_id;
				EXECUTE 'select count(id) from inv_clas where  titulo = '''||str_data[5]||''' and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'clasificacion:La clasificacion ingresada ya se encuentra en uso___';
				END IF;
				EXECUTE 'select count(id) from inv_clas where  descripcion = '''||str_data[6]||'''  and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'descripcion:la descripcion de la unidad  ya se encuentra en uso___';
				END IF;
				
				/*
				EXECUTE 'select count(id) from inv_clas where  stock_seguridad = '''||str_data[7]||'''  and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'stock:El stock de seguridad  ya se encuentra en uso___';
				END IF;
				
				EXECUTE 'select count(id) from inv_clas where  factor_maximo = '''||str_data[8]||'''  and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'factor:El factor de seguridad  ya se encuentra en uso___';
				END IF;
				*/
			END IF;
		END IF;
                
        END IF;--termina validacion Catalogo Inventario clasificacion
	
	
	--validacion de  inv_pre_ofe
	IF id_app=53 THEN
		--str_data[4]	id
		--str_data[5]	producto_id
		--str_data[6]	descripcion
		
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'productosku:Es necesario Seleccionar un producto___';
		END IF;

		IF str_data[6] = '' OR str_data[6] = ' ' THEN
			valor_retorno := ''||valor_retorno||'fechainicial:Es necesario ingresar una fecha de inicio___';
		END IF;

		IF str_data[7] = '' OR str_data[7] = ' ' THEN
			valor_retorno := ''||valor_retorno||'fechafinal:Es necesario ingresar una fecha de final___';
		END IF;
		
	END IF;--termina  inv_pre_ofe
	
	
	
	
	--orden pre-subensambles
	IF id_app=55 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id
		--str_data[5]	folio
		--str_data[6]	observaciones
		--str_data[7]	select_almacen
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--eliminado	str_filas[10]
				IF str_filas[4]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--RAISE EXCEPTION '%','campos_data: '||str_filas[2];
					--cantidad	str_filas[2]
					--id_prod_grid	str_filas[3]
					--eliminado	str_filas[4]
					--select_pres	str_filas[5]
					
					IF cont_fila=1 THEN
						ids_subensamble:=ids_subensamble||str_filas[3];
					ELSE
						ids_subensamble:=ids_subensamble||','||str_filas[3];
					END IF;
					
					IF str_filas[2] = ' ' OR str_filas[2] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[3]||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[2]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[3]||':La cantidad debe ser mayor que cero___';
						END IF;
					END IF;
				END IF;
				
			END LOOP;
			
			
			--RAISE EXCEPTION '%','ids_subensamble: '||ids_subensamble;
			IF valor_retorno = '' THEN
				sql_select:='
				SELECT inv_kit.producto_kit_id AS id_prod_subensamble,
					inv_kit.producto_elemento_id, 
					inv_prod.sku,
					inv_kit.cantidad,
					(CASE WHEN inv_prod_presentaciones.id IS NULL THEN 0 ELSE inv_prod_presentaciones.id END) AS pres_def_id,
					(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
					(CASE WHEN inv_prod_unidades.decimales IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
				FROM inv_kit
				JOIN inv_prod ON inv_prod.id=inv_kit.producto_elemento_id
				LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod.inv_prod_presentacion_id
				LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				WHERE inv_kit.producto_kit_id IN ('||ids_subensamble||')
				ORDER BY producto_elemento_id';
				
				--RAISE EXCEPTION '%','sql_select: '||sql_select;
			
				primero:=0;
				componente_id:=0;
				sku_componente:='';
				suma_componente:=0;
				id_presentacion:=0;
				noDecUnidad:=0;
				
				FOR formulacion IN EXECUTE(sql_select) LOOP
					
					--Redondear la cantidad del producto componente
					formulacion.cantidad := round(formulacion.cantidad::numeric,formulacion.no_dec)::double precision;
					
					IF primero=0 THEN
						componente_id:=formulacion.producto_elemento_id;
						sku_componente:=formulacion.sku;
						id_presentacion:=formulacion.pres_def_id;
						noDecUnidad := formulacion.no_dec;
						primero:=1;
					END IF;
					
					IF componente_id = formulacion.producto_elemento_id THEN 
						total_filas:= array_length(arreglo,1);
						cont_fila:=1;
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
							--eliminado	str_filas[10]
							IF str_filas[4]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--RAISE EXCEPTION '%','campos_data: '||str_filas[2];
								--cantidad	str_filas[2]
								--id_prod_grid	str_filas[3]
								IF str_filas[3]::integer = formulacion.id_prod_subensamble THEN 
									suma_componente:=suma_componente + (formulacion.cantidad * str_filas[2]::double precision);
								END IF;
							END IF;
							
						END LOOP;
					ELSE
						--Redondear la cantidad del producto componente
						suma_componente := round(suma_componente::numeric,formulacion.no_dec)::double precision;
						
						--Llamada a proc que devuelve la existencia del producto. 
						--El tipo de busqueda de existencia es 1=Busqueda en el almacen que se le esta pasando como parametro
						--El valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
						SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, componente_id, usuario_id, str_data[7]::integer) INTO total_existencia; 

						--Redondear la existencia del producto componente
						total_existencia := round(total_existencia::numeric,formulacion.no_dec)::double precision;
						
						IF total_existencia<=0 THEN
							valor_retorno := ''||valor_retorno||'idprod_'||componente_id||':El Producto componente '||sku_componente||' tiene Existencia 0 en Almacen___';
						ELSE
							IF total_existencia < suma_componente THEN
								valor_retorno := ''||valor_retorno||'idprod_'||componente_id||':El Producto componente '||sku_componente||' tiene Existencia '||total_existencia||',  usted esta intentando utilizar '||suma_componente||'___';
							END IF;
						END IF;

						--Verificar si hay que validar existencias de Presentaciones
						IF controlExisPres=true THEN 
							exisActualPres:=0;
							
							IF id_presentacion > 0 THEN
								
								SELECT (CASE WHEN cantidad IS NULL THEN 0 ELSE cantidad END) FROM inv_prod_presentaciones WHERE id=id_presentacion INTO formulacion.cant_equiv;
								
								IF formulacion.cant_equiv > 0 THEN
									
									--Buscar la existencia actual de la Presentacion
									SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exi
									FROM inv_exi_pres 
									WHERE inv_alm_id=str_data[7]::integer 
									AND inv_prod_id=componente_id::integer 
									AND inv_prod_presentacion_id=id_presentacion::integer 
									INTO exisActualPres;
									
									IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
									
									IF exisActualPres > 0 THEN 
										--redondear la Existencia actual de Presentaciones
										exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision; 
										
										--convertir a su equivalencia en Presentacion, la cantidad del ultimo producto componente
										cantPresAsignado := suma_componente::double precision / formulacion.cant_equiv::double precision;
										
										--redondear la cantidad de Presentaciones Asignado en la partida
										cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
										
										IF exisActualPres::double precision < cantPresAsignado::double precision THEN
											valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':Disponibles='||exisActualPres||',  Produccion='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
										END IF;
									ELSE
										valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':No hay existencia en esta presentacion default del componente.___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':La equivalencia de la Presentacion debe ser mayor que cero.___';
								END IF;	
							ELSE
								valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':El Producto componente '||sku_componente||' no tiene presentacion default.___';
							END IF;			
						END IF;

						
						--toma nuevos valores
						componente_id:=formulacion.producto_elemento_id;
						sku_componente:=formulacion.sku;
						suma_componente:=0;
						id_presentacion:=formulacion.pres_def_id;
						noDecUnidad := formulacion.no_dec;
						
						total_filas:= array_length(arreglo,1);
						cont_fila:=1;
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
							--eliminado	str_filas[10]
							IF str_filas[4]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--RAISE EXCEPTION '%','campos_data: '||str_filas[2];
								--cantidad	str_filas[2]
								--id_prod_grid	str_filas[3]
								IF str_filas[3]::integer = formulacion.id_prod_subensamble THEN 
									suma_componente:=suma_componente + (formulacion.cantidad * str_filas[2]::double precision);
								END IF;
							END IF;
						END LOOP;
					END IF;
				END LOOP;
				
				
				--Redondear la cantidad del ultimo producto componente
				suma_componente := round(suma_componente::numeric,formulacion.no_dec)::double precision;
				
				--Llamada a proc que devuelve la existencia del producto. 
				--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
				--El valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
				SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, componente_id, usuario_id, str_data[7]::integer) INTO total_existencia;

				--Redondear la existencia del producto componente
				total_existencia := round(total_existencia::numeric,formulacion.no_dec)::double precision;
				
				IF total_existencia<=0 THEN
					valor_retorno := ''||valor_retorno||'idprod_'||componente_id||':El Producto componente '||sku_componente||' tiene Existencia 0 en Almacen___';
				ELSE
					IF total_existencia < suma_componente THEN
						valor_retorno := ''||valor_retorno||'idprod_'||componente_id||':El Producto componente '||sku_componente||' tiene Existencia '||total_existencia||',  usted esta intentando utilizar '||suma_componente||'___';
					END IF;
				END IF;

				--Verificar si hay que validar existencias de Presentaciones
				IF controlExisPres=true THEN 
					exisActualPres:=0;
					
					IF id_presentacion > 0 THEN
						--buscar la existencia actual de la Presentacion
						SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exi
						FROM inv_exi_pres 
						WHERE inv_alm_id=str_data[7]::integer 
						AND inv_prod_id=componente_id::integer 
						AND inv_prod_presentacion_id=id_presentacion::integer 
						INTO exisActualPres;
						
						IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
						
						IF exisActualPres > 0 THEN 
							--redondear la Existencia actual de Presentaciones
							exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision; 
							
							--buscar la equivalencia de la Presentacion
							SELECT cantidad  FROM inv_prod_presentaciones WHERE id=id_presentacion::integer 
							INTO equivalenciaPres;
							
							--convertir a su equivalencia en Presentacion, la cantidad del ultimo producto componente
							cantPresAsignado := suma_componente::double precision / equivalenciaPres::double precision;
							
							--redondear la cantidad de Presentaciones Asignado en la partida
							cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
							
							IF exisActualPres::double precision < cantPresAsignado::double precision THEN
								--RAISE EXCEPTION '%','id_presentacion: '||id_presentacion;
								valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':Disponibles='||exisActualPres||',  Produccion='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
							END IF;
						ELSE
							valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':No hay existencia en esta presentacion default del componente.___';
						END IF;
					ELSE
						valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':El Producto componente '||sku_componente||' no tiene presentacion default.___';
					END IF;
				END IF;
				
			END IF;
		ELSE
			valor_retorno := ''||valor_retorno||'subensambles:Es Necesario ingresar minimo un subensamble___';
		END IF;
		
	END IF;
	--termina orden subensambles
	
	
	
	
	--validacion Catalogo direcciones de proveedores
	IF id_app=56 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id                --str_data[5]        calle
		--str_data[6]	     codigoPostal      --str_data[7]        colonia
		--str_data[8]        entreCalles       --str_data[9]	     extDos
		--str_data[10]       extUno            --str_data[11]       numExterior
		--str_data[12]	     numInterior       --str_data[13]       proveedor
		--str_data[14]       id_estado         --str_data[15]	     id_municipio
		--str_data[16]       id_pais           --str_data[17]       telDos
		--str_data[18]	     telUno
		
		IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'calle:Es necesario ingresar la calle___';
		END IF;
		
		IF str_data[6] = '' THEN					
			 valor_retorno := ''||valor_retorno||'codigoPostal:Es necesario ingresar el Codigo Postal___';
		END IF;

		IF str_data[7] = '' THEN				
			 valor_retorno := ''||valor_retorno||'colonia:Es necesario ingresar la colonia___';
		END IF;
		
		IF str_data[11] = '' THEN					
			 valor_retorno := ''||valor_retorno||'numExterior:Es necesario ingresar el numero exterior___';
		END IF;
		
		IF str_data[13]::integer = 0 THEN					
			 valor_retorno := ''||valor_retorno||'proveedor:Es necesario el nombre del proveedor___';
		END IF;
		
		IF str_data[14]::integer = 0 THEN					
			 valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado___';
		END IF;
		
		IF str_data[15]::integer = 0 THEN					
			 valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio___';
		END IF;
		
		IF str_data[16]::integer = 0 THEN					
			 valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pa√≠s___';
		END IF;
		
		IF str_data[18] = '' THEN				
			 valor_retorno := ''||valor_retorno||'telUno:Es necesario ingresar el Numero a Diez digitos___';
		END IF;

		IF str_data[18] != '' THEN				
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[18]||''' ~ '''||mask_general||''';' INTO match_cadena;
			--RAISE EXCEPTION '%','numeo de telefonooo::'||'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';';
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'telUno: Es necesario ingresar el Numero a Diez digitos___';
			END IF;
		END IF;
		
		IF str_data[6] != '' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CodigoPostalCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'codigoPostal:Codigo Postal No Valido___';
			END IF;
			
		
			IF str_data[10] != '' THEN				
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'extUno:Numero de Extension No Valido___';
				END IF;
			END IF;
			
			IF str_data[17] !='' THEN
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[17]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'teldos:Numero Telefonico no valido___';
				END IF;
			END IF;
			
			IF str_data[9]  != '' THEN				
				--valor_retorno := ''||valor_retorno||'extdos:Es necesario ingresar la extencion___';
				--ELSE
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'extDos:Numero de Extension No Valido___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion Catalogo direcciones de proveedores
	
	
	
	--Proceso de produccion de subensamble
	IF id_app=58 THEN
		--str_data[4]	id
		
		--Obtener el almacen de la para tomar las materias primas(es el mismo para destino de la produccion)
		select (CASE WHEN inv_alm_id IS NULL THEN 0 ELSE inv_alm_id END) AS alm_id from  inv_ord_subensamble 
		WHERE id=str_data[4]::integer
		INTO id_almacen;
		
		sql_select:='
		SELECT 
			comp_id_prod,
			sku, 
			comp_pres_def_id, 
			comp_equiv,
			comp_no_dec, 
			sum(comp_cant) AS comp_cant 
		FROM (
			SELECT 
				subensam_det.inv_prod_id_subensamble AS suben_id_prod, 
				subensam_det.cantidad AS suben_cant,
				inv_kit.producto_elemento_id AS comp_id_prod, 
				inv_prod.sku,
				(CASE WHEN pres_comp.id IS NULL THEN 0 ELSE pres_comp.id END) AS comp_pres_def_id,
				(CASE WHEN pres_comp.cantidad IS NULL THEN 0 ELSE pres_comp.cantidad END) AS comp_equiv,
				(CASE WHEN uni_comp.decimales IS NULL THEN 0 ELSE uni_comp.decimales END) AS comp_no_dec,
				(subensam_det.cantidad * inv_kit.cantidad) AS comp_cant 
			FROM inv_ord_subensamble_detalle AS subensam_det 
			JOIN inv_kit ON inv_kit.producto_kit_id=subensam_det.inv_prod_id_subensamble 
			JOIN inv_prod ON inv_prod.id=inv_kit.producto_elemento_id 
			LEFT JOIN inv_prod_presentaciones AS pres_comp ON pres_comp.id=inv_prod.inv_prod_presentacion_id 
			LEFT JOIN inv_prod_unidades AS uni_comp ON uni_comp.id=inv_prod.unidad_id 
			WHERE subensam_det.inv_ord_subensamble_id='||str_data[4]::integer||' 
		) AS sbt 
		GROUP BY comp_id_prod, sku, comp_pres_def_id, comp_equiv, comp_no_dec';
		
		FOR formulacion IN EXECUTE(sql_select) LOOP
			total_existencia:=0;
			
			--Llamada a proc que devuelve la existencia del producto componente.
			--El tipo de busqueda de existencia es 1=Busqueda en el almacen que se le esta pasando como parametro
			--El valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
			SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, formulacion.comp_id_prod, usuario_id, id_almacen) INTO total_existencia; 
			
			--Redondear el total de la existencia
			total_existencia := round(total_existencia::numeric,formulacion.comp_no_dec)::double precision;
			
			--Redondear la cantidad del producto componente
			formulacion.comp_cant := round(formulacion.comp_cant::numeric,formulacion.comp_no_dec)::double precision;
			
			IF total_existencia<=0 THEN
				valor_retorno := ''||valor_retorno||'cantidadcomp_'||formulacion.comp_id_prod||':El Producto componente '||formulacion.sku||' tiene Existencia 0 en Almacen___';
			ELSE
				IF total_existencia < formulacion.comp_cant THEN
					valor_retorno := ''||valor_retorno||'cantidadcomp_'||formulacion.comp_id_prod||':El Producto componente '||formulacion.sku||' tiene Existencia '||total_existencia||',  usted esta intentando utilizar '||formulacion.comp_cant||'___';
				END IF;
			END IF;
			
			
			--Verificar si hay que validar existencias de Presentaciones
			IF controlExisPres=true THEN 
				exisActualPres:=0;
				cantPresAsignado:=0;
				--Verificar qhe el producto componente que tenga asignado una presentacion default
				IF formulacion.comp_pres_def_id > 0 THEN
					--Verificar que la equivalencia de la presentacion default sea mayor que 0
					IF formulacion.comp_equiv > 0 THEN 
						--Buscar la existencia actual de la Presentacion del producto componente
						SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exi
						FROM inv_exi_pres 
						WHERE inv_alm_id=id_almacen::integer 
						AND inv_prod_id=formulacion.comp_id_prod::integer 
						AND inv_prod_presentacion_id=formulacion.comp_pres_def_id::integer 
						INTO exisActualPres;
						
						IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
						
						IF exisActualPres > 0 THEN 
							--redondear la Existencia actual de Presentaciones
							exisActualPres := round(exisActualPres::numeric,formulacion.comp_no_dec)::double precision; 
							
							--convertir a su equivalencia en Presentacion, la cantidad del ultimo producto componente
							cantPresAsignado := formulacion.comp_cant::double precision / formulacion.comp_equiv::double precision;
							
							--redondear la cantidad de Presentaciones Asignado en la partida
							cantPresAsignado := round(cantPresAsignado::numeric,formulacion.comp_no_dec)::double precision; 
							
							IF exisActualPres::double precision < cantPresAsignado::double precision THEN
								valor_retorno := ''||valor_retorno||'prescomp_'||formulacion.comp_id_prod||':Disponibles='||exisActualPres||',  Produccion='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
							END IF;
						ELSE
							valor_retorno := ''||valor_retorno||'prescomp_'||formulacion.comp_id_prod||':No hay existencia en esta presentacion default del componente.___';
						END IF;
					ELSE
						valor_retorno := ''||valor_retorno||'prescomp_'||formulacion.comp_id_prod||':La equivalencia de la Presentacion debe ser mayor que cero.___';
					END IF;	
				ELSE
					valor_retorno := ''||valor_retorno||'prescomp_'||formulacion.comp_id_prod||':El Producto componente '||formulacion.sku||' no tiene presentacion default.___';
				END IF;
				
			END IF;
			
		END LOOP;
		
	END IF;
	--Termina produccion de subensambles

	

		
	--validando campos de aplicativo tes chequera
	IF id_app=59 THEN
		--str_data[1]  app_selected                     str_data[11]  id_estado                         str_data[20]  nombre_sucursal
		--str_data[2]  command_selected			str_data[12]  id_moneda				str_data[21]  telefono1
		--str_data[3]  id_usuario			str_data[13]  id_banco				str_data[22]  extencion1
		--str_data[4]  id_chequera
		--str_data[5]  chequera				str_data[14]  chk_imprimir_chequeningles	str_data[23]  telefono2	
		--str_data[6]  chk_modificar_consecutivo 	str_data[15]  calle				str_data[24]  extencion2
		--str_data[7]  chk_modificar_fecha		str_data[16]  numero				str_data[25]  fax
		--str_data[8]  chk_modificar_cheque		str_data[17]  colonia				str_data[26]  gerente
		--str_data[9]  id_pais				str_data[18]  cp				str_data[27]  ejecutivo
		--str_data[10]  id_municipio			str_data[19]  numero_sucursal			str_data[28]  email;
		
		
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'chequera:Es necesario ingresar una chequera___';
		END IF;
		
		IF str_data[4]::integer = 0 THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM tes_che WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'chequera:La Chequera ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
		
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'banco:Es necesario elegir un banco___';
		END IF;
		/*
		IF str_data[13] != '' THEN
			EXECUTE 'SELECT count(id) FROM tes_che WHERE tes_ban_id = '||str_data[13]||' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'banco:El banco elegido ya se encuentra en uso___';
			END IF;
		END IF;
		*/
		
		IF str_data[19]= '' THEN
			valor_retorno := ''||valor_retorno||'numero_sucursal:Es necesario Ingresar un numero para la sucursal___';
		END IF;
		/*
		IF str_data[19] != '' THEN
			EXECUTE 'SELECT count(id) FROM tes_che WHERE num_sucursal = '||str_data[19]||' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'numero_sucursal:El numero de la sucursal ya se encuentra registrado___';
			END IF;
		END IF;
		*/

		IF str_data[20]= '' THEN
			valor_retorno := ''||valor_retorno||'nombre_sucursal:Es necesario Ingresar nombre a la  sucursal___';
		END IF;

		/*
		IF str_data[20] != '' THEN
			EXECUTE 'SELECT count(id) FROM tes_che WHERE nombre_sucursal = '''||str_data[20]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'nombre_sucursal:El nombre de la sucursal ya se encuentra registrado___';
			END IF;
		END IF;
		*/
		IF str_data[15]= '' THEN
			valor_retorno := ''||valor_retorno||'calle:Es necesario Ingresar el nombre de la calle___';
		END IF;

		IF str_data[16]= '' THEN
			valor_retorno := ''||valor_retorno||'numero:Es necesario Ingresar el numero___';
		END IF;

		IF str_data[17]= '' THEN
			valor_retorno := ''||valor_retorno||'colonia:Es necesario Ingresar el nombre de la colonia___';
		END IF;

		IF str_data[18] = '' THEN
			valor_retorno := ''||valor_retorno||'codigo_postal:Error en el codigo Postal___';
		END IF;
		
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CodigoPostalCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[18]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'codigo_postal:Error en el codigo Postal___';
		END IF;

		IF str_data[9]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario elegir un Pais___';
		END IF;
		IF str_data[10]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario elegir un Municipio___';
		END IF;
		IF str_data[11]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'Estado:Es necesario elegir un Estado___';
		END IF;
		
		IF str_data[21] !='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[21]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:Numero Telefonico no valido___';
			END IF;
		END IF;
		
		
		IF str_data[22]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[22]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'ext1:Numero de Extension No Valido___';
			END IF;
		END IF;

		IF str_data[23] !='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[23]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel2:Numero Telefonico no valido___';
			END IF;
		END IF;
		
		IF str_data[24]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[24]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'ext2:Numero de Extension No Valido___';
			END IF;
		END IF;
		
		IF str_data[25] !='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[25]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fax:Numero fax no valido___';
			END IF;
		END IF;
		--e-mail
		IF str_data[28] !='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_EmailCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[28]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo Electronico No Valido___';
			END IF;
		END IF;		
	END IF;
	--fin de la evaluacion de Tes chequera.

	--validacion de  pagos a proveedores
	IF id_app=60 THEN
		--str_data[4]	id_pago
		
		--str_data[5]	id_proveedor
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'idproveedor:Es necesario Seleccionar un Proveedor___';
		END IF;
		
		--str_data[6]	fecha_pago
		IF str_data[6] = '' OR str_data[6] = ' ' THEN
			valor_retorno := ''||valor_retorno||'fechapago:Es necesario ingresar la fecha de pago___';
		END IF;
		
		--str_data[7]	tipo_cambio
		IF str_data[7] = '' OR str_data[7] = ' ' THEN
			valor_retorno := ''||valor_retorno||'tipocambio:Es necesario ingresar el Tipo de Cambio.___';
		END IF;
		
		--str_data[8]	id_moneda
		IF str_data[8] = '0' THEN
			valor_retorno := ''||valor_retorno||'moneda:Es necesario Seleccionar la Moneda.___';
		END IF;
		
		--str_data[9]	forma_pago
		IF str_data[9] = '0' THEN
			valor_retorno := ''||valor_retorno||'formapago:Es necesario Seleccionar la Forma de Pago.___';
		END IF;
		
		
		IF str_data[9]<>'0' AND str_data[9]<>'1' AND str_data[9]<>'4'THEN	
			--str_data[10]	id_banco
			IF str_data[10] = '0' THEN
				valor_retorno := ''||valor_retorno||'bancoempresa:Es necesario Seleccionar la el Banco.___';
			END IF;
			
			--str_data[11]	id_no_cuenta
			IF str_data[11] = '0' THEN
				valor_retorno := ''||valor_retorno||'nocuenta:Es necesario Seleccionar la el Numero de Cuenta.___';
			END IF;
		END IF;
		
		/*
		--forma pago cheque
		IF str_data[9] = '2' THEN
			--str_data[12]	num_cheque
			IF str_data[12] = '' OR str_data[12] = ' ' THEN
				valor_retorno := ''||valor_retorno||'nocheque:Es necesario ingresar el Numero de Cheque.___';
			END IF;
		END IF;
		*/
		
		--forma pago Transferencia
		IF str_data[9] = '3' THEN
			--str_data[13]	referencia
			IF str_data[13] = '' OR str_data[13] = ' ' THEN
				valor_retorno := ''||valor_retorno||'referencia:Es necesario ingresar el la Referencia.___';
			END IF;
		END IF;
		
		--forma pago tarjeta
		IF str_data[9] = '4' THEN
			--str_data[14]	num_tarjeta
			IF str_data[14] = '' OR str_data[14] = ' ' THEN
				valor_retorno := ''||valor_retorno||'notarjeta:Es necesario ingresar el Numero de Tarjeta.___';
			END IF;
		END IF;
		
		--str_data[15]	monto_pago
		--str_data[16]	observaciones
		--str_data[17] concepto
		IF str_data[17] = '0' THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario Seleccionar el Concepto del Pago.___';
		END IF;
		
	END IF;--termina  validacion de  pagos a proveedores
	
	
	
	
	--validacion de  Anticipos a proveedores
	IF id_app=61 THEN
		--str_data[4]	id_anticipo
		
		--str_data[5]	id_proveedor
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'idproveedor:Es necesario Seleccionar un Proveedor___';
		END IF;
		
		--str_data[6]	id_moneda
		IF str_data[6] = '0' THEN
			valor_retorno := ''||valor_retorno||'moneda:Es necesario Seleccionar la Moneda.___';
		END IF;
		
		--str_data[7]	monto del anticipo
		IF str_data[7] <> ''  THEN
			IF str_data[7]::double precision < 1 THEN
				valor_retorno := ''||valor_retorno||'montoanticipo:El Monto del Anticipo debe ser mayor que cero.___';
			END IF;
		ELSE
			valor_retorno := ''||valor_retorno||'montoanticipo:Es necesario Ingresar el Monto del Anticipo.___';
		END IF;
		
		--str_data[8]	fecha_anticipo
		IF str_data[8] = '' OR str_data[8] = ' ' THEN
			valor_retorno := ''||valor_retorno||'fechaanticipo:Es necesario ingresar la fecha del Anticipo.___';
		END IF;
		
		--str_data[9]	observaciones
		
		--str_data[10]	forma_pago
		IF str_data[10] = '0' THEN
			valor_retorno := ''||valor_retorno||'formapago:Es necesario Seleccionar la Forma de Pago.___';
		END IF;
		
		--str_data[11]	id_banco
		IF str_data[11] = '0' THEN
			valor_retorno := ''||valor_retorno||'bancoempresa:Es necesario Seleccionar el Banco.___';
		END IF;
		
		--str_data[12]	id_chequera
		IF str_data[12] = '0' THEN
			valor_retorno := ''||valor_retorno||'nocuenta:Es necesario Seleccionar la Chequera.___';
		END IF;
		
		--forma pago Transferencia
		IF str_data[10] = '3' THEN
			--str_data[13]	referencia
			IF str_data[13] = '' OR str_data[13] = ' ' THEN
				valor_retorno := ''||valor_retorno||'referencia:Es necesario ingresar la Referencia.___';
			END IF;
		END IF;
		
		--str_data[14] concepto
		IF str_data[14] = '0' THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario Seleccionar el Concepto del Pago.___';
		END IF;
		
		/*
		--str_data[15] orden de compra
		IF str_data[15] = '0' THEN
			valor_retorno := ''||valor_retorno||'ardencompra:Es necesario Seleccionar la Orden de Compra para este Anticipo.___';
		END IF;
		*/
		
		--str_data[16]	tipo_cambio
		IF str_data[16] = '' OR str_data[16] = ' ' THEN
			valor_retorno := ''||valor_retorno||'tipocambio:Es necesario ingresar el Tipo de Cambio.___';
		END IF;
		
	END IF;--termina  validacion de  Anticipos a proveedores
	
	
	--validacion de  Parametros Anticipos a proveedores
	IF id_app=62 THEN
		--str_data[4]	identificador parametro
		
		--str_data[5]	id_sucursal
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'sucursal:Es necesario Seleccionar la Sucursal___';
		END IF;
		
		--str_data[6]	select movimiento anticipo
		IF str_data[6] = '0' THEN
			valor_retorno := ''||valor_retorno||'anticipo:Es necesario Seleccionar un Movimiento.___';
		END IF;
		
		--str_data[7]	select movimiento Aplicado Anticipo
		IF str_data[7] = '0' THEN
			valor_retorno := ''||valor_retorno||'aplanticipo:Es necesario Seleccionar un Movimiento.___';
		END IF;
		
		--str_data[8]	select movimiento Aplicado Factura
		IF str_data[8] = '0' THEN
			valor_retorno := ''||valor_retorno||'aplfactura:Es necesario Seleccionar un Movimiento.___';
		END IF;
		
		--str_data[9]	select movimiento Cancelacion
		IF str_data[9] = '0' THEN
			valor_retorno := ''||valor_retorno||'cancelacion:Es necesario Seleccionar un Movimiento.___';
		END IF;
		
		--validar integridad
		IF valor_retorno = '' AND str_data[4]='0' THEN
			--RAISE EXCEPTION '%','valor_retorno:'||valor_retorno;
			EXECUTE 'SELECT count(id) FROM cxp_ant_par WHERE borrado_logico=false AND cxp_mov_tipo_id='||str_data[6]||' AND gral_suc_id='||str_data[5]||' AND gral_emp_id='||emp_id INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'integridad:Ya existe un registro con &eacute;stos Par&aacute;metros para &eacute;sta Sucursal___';
			END IF;
		END IF;
		
	END IF;--termina  validacion de Parametros Anticipos a proveedores
	
	
	
	--Pedidos  de Clientes
	IF id_app=64 THEN
		--Obtener parametros para la facturacion
		--SELECT * FROM fac_par WHERE gral_suc_id=suc_id INTO facpar;
		
		--query para verificar si la Empresa actual incluye Modulo de Produccion
		SELECT incluye_produccion, control_exis_pres FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, controlExisPres;
		
		--tomar el id del almacen para ventas
		id_almacen := facpar.inv_alm_id;
		
		--str_data[3]	id_usuario
		--str_data[4]	id_pedido
		--str_data[5] 	id_cliente
		IF str_data[5]::integer < 1 THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un cliente___';
		END IF;

		-- trae la lista de precio del cliente------- str_data[5] idcliente
		select lista_precio from cxc_clie where id= str_data[5]::integer into num_lista_precio;

		
		--str_data[6]	select_moneda
		--str_data[7]	observaciones
		--str_data[8]	tipo_cambio
		IF str_data[8] = '' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		END IF;
		--str_data[9]	id_agente
		--str_data[10]	select_condiciones
		--str_data[11]	orden_compra
		
		--str_data[12]	fecha_compromiso
		IF str_data[12] = '' THEN
			valor_retorno := ''||valor_retorno||'fcompromiso:Es necesario ingresar la Fecha de Compromiso___';
		END IF;
		
		--str_data[13]	lugar_entrega
		--str_data[14]	transporte
		--str_data[15]	tasa_ret_immex
		--str_data[16]	select_metodo_pago
		--str_data[17]	no_cuenta
		
		--str_data[16]	id_metodo_pago
		--str_data[17]	no_cuenta
		IF str_data[16]::integer=2 OR str_data[16]::integer=3 THEN
			IF str_data[17]='' OR str_data[17]=' ' THEN
				valor_retorno := ''||valor_retorno||'nocuenta:Es necesario ingresar los ultimos 4 digitos de la tarjeta___';
			ELSE
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_DigitosTarjetaCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[17]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno|| 'nocuenta:Es necesario ingresar 4 digitos.___';
				END IF;
			END IF;
		END IF;

		
		IF empresa_transportista THEN
			--Aqui solo entra cuando la empresa es transportista
			IF str_data[22]='true' THEN
				--Aqui entra cuando el pedido es de flete.
				
				--str_data[23]	nombre_documentador
				--str_data[24]	valor_declarado
				--str_data[25]	select_tviaje
				--str_data[26]	remolque1
				--str_data[27]	remolque2
				--str_data[28]	id_vehiculo
				--str_data[29]	no_operador
				--str_data[30]	nombre_operador
				--str_data[31]	select_pais_origen
				--str_data[32]	select_estado_origen
				--str_data[33]	select_municipio_origen
				--str_data[34]	select_pais_dest
				--str_data[35]	select_estado_dest
				--str_data[36]	select_municipio_dest
				--str_data[37]	agena_id
				--str_data[38]	rem_id
				--str_data[39]	rem_dir_alterna
				--str_data[40]	dest_id
				--str_data[41]	dest_dir_alterna
				--str_data[42]	observaciones_transportista
				
				--str_data[23]	nombre_documentador
				IF str_data[23] = '' THEN
					valor_retorno := ''||valor_retorno||'documentador:Es necesario ingresar el nombre del Documentador.___';
				END IF;
				
				--str_data[24]	valor_declarado
				--str_data[25]	select_tviaje
				IF str_data[25]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'tviaje:Es necesario seleccionar el Tipo de Viaje..___';
				ELSE
					--str_data[26]	remolque1
					IF trim(str_data[26]) = '' THEN
						valor_retorno := ''||valor_retorno||'remolque1:Es necesario seleccionar ingresar el Remolque 1.___';
					END IF;
					
					IF str_data[25]::integer = 2 THEN
						--str_data[27]	remolque2
						IF trim(str_data[27]) = '' THEN
							valor_retorno := ''||valor_retorno||'remolque2:Es necesario seleccionar ingresar el Remolque 2.___';
						END IF;
					END IF;
				END IF;
				
				--str_data[28]	id_vehiculo
				IF str_data[28]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'noeconomico:Es necesario seleccionar una Unidad.___';
				END IF;
				
				--str_data[29]	no_operador
				--str_data[30]	nombre_operador
				IF trim(str_data[30]) = '' THEN
					valor_retorno := ''||valor_retorno||'operador:Es necesario ingresar el Nombre del Operador.___';
				END IF;
				
				--str_data[31]	select_pais_origen
				IF str_data[31]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'paisorig:Es necesario seleccionar el Pais Origen.___';
				END IF;
				
				--str_data[32]	select_estado_origen
				IF str_data[32]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'estadoorig:Es necesario seleccionar el Estado Origen.___';
				END IF;
				
				--str_data[33]	select_municipio_origen
				IF str_data[33]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'municipioorig:Es necesario seleccionar el Municipio Origen.___';
				END IF;
				
				--str_data[34]	select_pais_dest
				IF str_data[34]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'paisdest:Es necesario seleccionar el Pais Destino.___';
				END IF;
				
				--str_data[35]	select_estado_dest
				IF str_data[35]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'estadodest:Es necesario seleccionar el Estado Destino.___';
				END IF;
				
				--str_data[36]	select_municipio_dest
				IF str_data[36]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'municipiodest:Es necesario seleccionar el Municipio Destino.___';
				END IF;
				
				--str_data[37]	agena_id
				IF str_data[37]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'agenano:Es necesario seleccionar un Agente Aduanal.___';
				END IF;
				
				--str_data[38]	rem_id
				IF str_data[38]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'remid:Es necesario seleccionar un Remitente.___';
				END IF;
				
				--str_data[39]	rem_dir_alterna
				--str_data[40]	dest_id
				IF str_data[40]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'nodest:Es necesario seleccionar un Destinatario.___';
				END IF;
				
				--str_data[41]	dest_dir_alterna
				--str_data[42]	observaciones_transportista
			END IF;
		END IF;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					--str_filas[8]	valor_imp
					--str_filas[9]	noTr
					--str_filas[10]	seleccionado
					--str_filas[11]	unidad_medida
					--str_filas[12]	idIeps 
					--str_filas[13]	tasaIeps
					--str_filas[14]	vdescto
					--str_filas[15]	idcot
					--str_filas[16]	iddetcot
					--str_filas[17]	status_autorizacion
					--str_filas[18]	precio_autorizado
					--str_filas[19]	id_user_autoriza
					--str_filas[20]	reqauth
					--str_filas[21]	salvar_registro
					--str_filas[22]	retencion_id
					--str_filas[23]	retencion_tasa
					
					--str_filas[6]	cantidad
					IF trim(str_filas[6]) = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Es necesario ingresar la cantidad___';
					ELSE
						--Verificar que el campo sea numerico
						IF (SELECT trim(str_filas[6]) ~ '^([0-9]+[.]?[0-9]*|[.][0-9]+)$') THEN 
							
							--RAISE EXCEPTION '%',str_filas[6];
							IF str_filas[6]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':La cantidad debe ser mayor que cero___';
							ELSE
								--obtener el tipo de producto y el numero de Decimales Permitidos
								SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
								FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
								WHERE inv_prod.id=str_filas[3]::integer 
								INTO tipo, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
								
								--Tomamos la cantidad en la unidad de Venta seleccionada por el usuario
								cantUnidadVenta:=str_filas[6]::double precision;
								
								IF cambiaUnidadMedida THEN
									IF idUnidadMedida::integer<>str_filas[11]::integer THEN
										IF densidadProd IS NULL OR densidadProd=0 THEN
											densidadProd:=1;
										END IF;
										
										EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
										IF match_cadena=true THEN
											--Convertir a kilos
											str_filas[6] := str_filas[6]::double precision * densidadProd;
										ELSE
											EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
											IF match_cadena=true THEN
												--Convertir a Litros
												str_filas[6] := str_filas[6]::double precision / densidadProd;
											END IF;
										END IF;
									END IF;
								END IF;
								
								--Redondear la Cantidad
								str_filas[6] := round(str_filas[6]::numeric,noDecUnidad)::double precision; 
								cantUnidadVenta := round(cantUnidadVenta::numeric,noDecUnidad)::double precision; 
								
								--Si el tipo de producto es diferente de 4, hay que validar existencias
								--tipo=4 Servicios
								--para el tipo servicios no se debe validar existencias
								IF tipo<>4 THEN
									
									IF incluye_modulo_produccion=FALSE THEN
										--Aqui entra si la Empresa NO INCLUYE Modulo de Produccion
										--Se debe validar existencias de los productos tipo 1,2,5,6,7,8
										
										--tipo=1 Normal o Terminado
										--tipo=2 Subensable o Formulacion o Intermedio
										--tipo=5 Refacciones
										--tipo=6 Accesorios
										--tipo=7 Materia Prima
										--tipo=8 Prod. en Desarrollo
										IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=5 OR tipo::integer=6 OR tipo::integer=7 OR tipo::integer=8 THEN 
											--Llamada a proc que devuelve la existencia del producto. 
											--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
											--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
											SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, id_almacen) INTO total_existencia; 
											
											--Asignanos el total de la venta
											cantExisUnidadVenta:=total_existencia;
											
											IF cambiaUnidadMedida THEN
												IF idUnidadMedida::integer<>str_filas[11]::integer THEN
													EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
													IF match_cadena=true THEN
														--Convertir a litros la existencia para mostrar el warning
														cantExisUnidadVenta := cantExisUnidadVenta::double precision / densidadProd::double precision;
													ELSE
														EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
														IF match_cadena=true THEN 
															--Convertir a Kilos la existencia para mostrar el warning
															cantExisUnidadVenta := cantExisUnidadVenta::double precision * densidadProd::double precision;
														END IF;
													END IF;
												END IF;
											END IF;
											
											--si es diferente de cero estamos en editar
											IF str_filas[2]::integer > 0 THEN 
												--Buscamos la cantidad reservada anterior
												SELECT reservado FROM poc_pedidos_detalle WHERE id=str_filas[2]::integer INTO cant_reservada_anterior;
												
												--le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
												total_existencia := total_existencia::double precision + cant_reservada_anterior::double precision;
											END IF;
											
											--Redondear el total_existencia
											total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;

											/*
											IF total_existencia<=0 THEN
												valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen.___';
											ELSE
												IF total_existencia < str_filas[6]::double precision THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
												END IF;
											END IF;
											*/

											IF facpar.permitir_req_com THEN 
												--AQUI ENTRA CUANDO LA CONFIGURACION PERMITE GENERAR REQUISICION DE COMPRA
												--tipo=7 Materia Prima
												IF tipo::integer=7 THEN 
													--Seleccionado=0 indica que no se ha marcado para enviar a produccion la cantidad que falta
													IF str_filas[10]='0' THEN
														IF total_existencia < str_filas[6]::double precision THEN
															valor_retorno := ''||valor_retorno||'backorder:cantidad'||str_filas[9]||':'||cantExisUnidadVenta||'___';
														END IF;
														
														IF total_existencia<=0 THEN
															valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible=0,  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar una Requisici&oacute;n de Compra.___';
														ELSE
															IF total_existencia < str_filas[6]::double precision THEN
																valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible='||cantExisUnidadVenta||',  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar una Requisici&oacute;n de Compra.___';
															END IF;
														END IF;
													END IF;
												END IF;
												
												--Solo se debe validar existencias de productos tipo 5,6
												--tipo=5 Refacciones
												--tipo=6 Accesorios
												--IF tipo::integer=5 OR tipo::integer=6 THEN 
												IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=5 OR tipo::integer=6 OR tipo::integer=8 THEN 
													IF total_existencia<=0 THEN
														valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen.___';
													ELSE
														IF total_existencia < str_filas[6]::double precision THEN
															valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
														END IF;
													END IF;
												END IF;
											ELSE
												--AQUI ENTRA CUANDO LA CONFIGURACION NO PERMITE GENERAR REQUISICION DE COMPRA
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen.___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
													END IF;
												END IF;
											END IF;											
										END IF;
										
									ELSE
										--Aqui entra si la Empresa SI INCLUYE Modulo de Produccion
										--llamada a proc que devuelve la existencia del producto. 
										--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
										--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
										SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, id_almacen) INTO total_existencia; 
										--RAISE EXCEPTION '%','total_existencia: '||total_existencia;
										--Asignanos el total de la venta
										cantExisUnidadVenta:=total_existencia;
										
										IF cambiaUnidadMedida THEN
											IF idUnidadMedida::integer<>str_filas[11]::integer THEN
												EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
												IF match_cadena=true THEN
													--Convertir a litros la existencia para mostrar el warning
													cantExisUnidadVenta := cantExisUnidadVenta::double precision / densidadProd::double precision;
												ELSE
													EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
													IF match_cadena=true THEN 
														--Convertir a Kilos la existencia para mostrar el warning
														cantExisUnidadVenta := cantExisUnidadVenta::double precision * densidadProd::double precision;
													END IF;
												END IF;
											END IF;
										END IF;
										
										--Si es diferente de cero estamos en editar
										IF str_filas[2]::integer > 0 THEN 
											--buscamos la cantidad reservada anterior
											SELECT reservado FROM poc_pedidos_detalle WHERE id=str_filas[2]::integer INTO cant_reservada_anterior;
											--RAISE EXCEPTION '%','cant_reservada_anterior: '||cant_reservada_anterior;
											--le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
											total_existencia := total_existencia + cant_reservada_anterior;
										END IF;
										
										--Redondear el total_existencia
										total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
										
										--tipo=1 Normal o Terminado
										--tipo=2 Subensable o Formulacion o Intermedio
										--tipo=8 Prod. en Desarrollo
										IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=8 THEN 
											--seleccionado=0 indica que no se ha marcado para enviar a produccion la cantidad que falta
											IF str_filas[10]='0' THEN 
												IF total_existencia < str_filas[6]::double precision THEN
													valor_retorno := ''||valor_retorno||'backorder:cantidad'||str_filas[9]||':'||cantExisUnidadVenta||'___';
												END IF;
												
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible=0,  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar a producci&oacute;n.___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible='||cantExisUnidadVenta||',  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar a producci&oacute;n.___';
													END IF;
												END IF;
											END IF;
										END IF;
										
										--RAISE EXCEPTION '%','facpar.permitir_req_com: '||facpar.permitir_req_com;
										
										IF facpar.permitir_req_com THEN 
											--AQUI ENTRA CUANDO LA CONFIGURACION PERMITE GENERAR REQUISICION DE COMPRA
											--tipo=7 Materia Prima
											IF tipo::integer=7 THEN 

												--RAISE EXCEPTION '%','total_existencia: '||total_existencia||' < '||str_filas[6];
												
												--seleccionado=0 indica que no se ha marcado para enviar a produccion la cantidad que falta
												IF str_filas[10]='0' THEN
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'backorder:cantidad'||str_filas[9]||':'||cantExisUnidadVenta||'___';
													END IF;
													
													IF total_existencia<=0 THEN
														valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible=0,  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar una Requisici&oacute;n de Compra.___';
													ELSE
														IF total_existencia < str_filas[6]::double precision THEN
															valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible='||cantExisUnidadVenta||',  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar una Requisici&oacute;n de Compra.___';
														END IF;
													END IF;
												END IF;
											END IF;
											
											--Solo se debe validar existencias de productos tipo 5,6
											--tipo=5 Refacciones
											--tipo=6 Accesorios
											IF tipo::integer=5 OR tipo::integer=6 THEN 
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
													END IF;
												END IF;
											END IF;
										ELSE
											--AQUI ENTRA CUANDO LA CONFIGURACION NO PERMITE GENERAR REQUISICION DE COMPRA
											--Solo se debe validar existencias de productos tipo 5,6,7
											--tipo=5 Refacciones
											--tipo=6 Accesorios
											--tipo=7 Materia Prima
											IF tipo::integer=5 OR tipo::integer=6 OR tipo::integer=7 THEN 
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
													END IF;
												END IF;
											END IF;
										END IF;
										
									END IF;
									
									
									
									--verificar si hay que validar existencias de Presentaciones
									IF controlExisPres=true THEN 
										--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
										--TRUE = Validar presentaciones desde el Pedido
										--FALSE = No validar presentaciones desde el Pedido
										IF facpar.validar_pres_pedido=true THEN 
											--Buscar la existencia actual de la Presentacion
											SELECT (inicial::double precision + entradas::double precision - salidas::double precision -reservado::double precision) AS exi
											FROM inv_exi_pres WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=str_filas[3]::integer AND inv_prod_presentacion_id=str_filas[4]::integer 
											INTO exisActualPres;
											
											IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
											
											IF exisActualPres > 0 THEN 
												--Si es diferente de cero estamos en editar,por lo tanto hay que buscar la cantidad reservada anterior.
												IF str_filas[2]::integer > 0 THEN 
													--buscamos la cantidad reservada anterior
													SELECT (poc_pedidos_detalle.reservado::double precision / inv_prod_presentaciones.cantidad::double precision) AS cant_pres
													FROM poc_pedidos_detalle 
													JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=poc_pedidos_detalle.presentacion_id
													WHERE poc_pedidos_detalle.id=str_filas[2]::integer 
													INTO cantPresReservAnterior;
													
													--redondear la Cantidad de la Presentacion reservada Anteriormente
													cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
													
													--sumar la cantidad reservada anterior para tener la existencia real
													exisActualPres = exisActualPres::double precision + cantPresReservAnterior::double precision;
												END IF;
												
												--redondear la Existencia actual de Presentaciones
												exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision; 
												
												--buscar la equivalencia de la Presentacion
												SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_filas[4]::integer INTO equivalenciaPres;
												
												--convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
												cantPresAsignado := str_filas[6]::double precision / equivalenciaPres::double precision;
												
												--redondear la cantidad de Presentaciones Asignado en la partida
												cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
												
												IF exisActualPres::double precision < cantPresAsignado::double precision THEN
													IF incluye_modulo_produccion=true OR facpar.permitir_req_com=TRUE THEN 
														--Si incluye modulo de produccion √≥ la configuracion permite generar requisiciones cuando no hay exisencia
														IF incluye_modulo_produccion THEN 
															IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=8 THEN 
																IF str_filas[10]='0' THEN
																	valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
																END IF;
															END IF;
														END IF;
														--Si la configuracion permite generar requisiciones en automatico
														IF facpar.permitir_req_com THEN 
															IF tipo::integer=7 THEN 
																IF str_filas[10]='0' THEN
																	valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
																END IF;
															END IF;
														END IF;
														
														IF tipo::integer=5 OR tipo::integer=6 THEN 
															valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
														END IF;
														
													ELSE 
														valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
													END IF;
												END IF;
											ELSE 
												IF incluye_modulo_produccion=true OR facpar.permitir_req_com=TRUE THEN 
													--Si incluye modulo de produccion √≥ la configuracion permite generar requisiciones cuando no hay exisencia
													
													IF incluye_modulo_produccion THEN 
														IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=8 THEN 
															IF str_filas[10]='0' THEN
																valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':No hay existencia en esta presentacion.___';
															END IF;
														END IF;
													END IF;

													IF facpar.permitir_req_com THEN 
														IF tipo::integer=7 THEN 
															IF str_filas[10]='0' THEN
																valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':No hay existencia en esta presentacion.___';
															END IF;
														END IF;
													END IF;
													
													IF tipo::integer=5 OR tipo::integer=6 THEN 
														valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':No hay existencia en esta presentacion.___';
													END IF;
												ELSE 
													valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':No hay existencia en esta presentacion.___';
												END IF;
											END IF;
										END IF;
										
									END IF;
								END IF;
							END IF;
						ELSE
							--Aqui entra porque el campo cantidad trae un valor no numerico
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El valor para Cantidad es incorrecto, tiene mas de un punto('||str_filas[6]||')___';
						END IF;
					END IF;
					
					
					--str_filas[7]	costo
					IF trim(str_filas[7]) = '' THEN
						valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':Es necesario ingresar el precio unitario___';
					ELSE
						--Verificar que el campo sea numerico
						IF (SELECT trim(str_filas[7]) ~ '^([0-9]+[.]?[0-9]*|[.][0-9]+)$') THEN 
							IF str_filas[7]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':El precio debe ser mayor que cero___';
							ELSE
								IF num_lista_precio > 0 THEN
									--sacando el descuento y precio del producto de acuerdo a la presentacion seleccionada
									sql_select:='SELECT (CASE WHEN descuento_'||num_lista_precio||' IS NULL THEN 0 ELSE descuento_'||num_lista_precio||' END ),inv_pre.precio_'||num_lista_precio||', (CASE WHEN inv_pre.gral_mon_id_pre'||num_lista_precio||' IS NULL THEN 0 ELSE inv_pre.gral_mon_id_pre'||num_lista_precio||' END) FROM inv_pre where inv_prod_id='||str_filas[3]||' AND inv_prod_presentacion_id='||str_filas[4]||' AND borrado_logico=false;';
									
									--RAISE EXCEPTION '%',sql_select;
									EXECUTE sql_select INTO descuento_producto, precio_producto, mon_prec_prod;
									
									IF descuento_producto IS NULL THEN
										descuento_producto:=0;
									END IF;
									
									IF precio_producto IS NULL THEN
										precio_producto:=0;
									ELSE
										IF str_data[6]::integer <> mon_prec_prod::integer THEN 
											/*
											IF mon_prec_prod::integer > 0 THEN 
												SELECT valor FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=mon_prec_prod ORDER BY momento_creacion DESC LIMIT 1 INTO tc_mon_prod;
											ELSE
												tc_mon_prod:=0;
											END IF;
											*/
											
											IF str_data[6]::integer=1 AND mon_prec_prod::integer<>1 THEN 
												--si la moneda del pedido es pesos y la moneda del precio es diferente de Pesos,
												--entonces calculamos su equivalente a pesos
												precio_producto:= precio_producto * str_data[8]::double precision;
											END IF;

											IF str_data[6]::integer<>1 AND mon_prec_prod::integer=1 THEN 
												--si la moneda del Pedido es Diferente de Pesos y la moneda del precio es Pesos,
												--entonces calculamos su equivalente a dolar
												precio_producto:= precio_producto / str_data[8]::double precision;
											END IF;

											--tc str_data[8]
										END IF;
									END IF;
									
									--redondear a 4 digitos el precio del producto
									precio_producto:=round((precio_producto)::numeric, 4)::double precision;
									
									--RAISE EXCEPTION '%',num_lista_precio;
									--obteniendo el valor del descuento
									descuento := ((descuento_producto::double precision/100) * precio_producto);
									--redondear a 4 digitos el descuento
									descuento:=round((descuento)::numeric, 4)::double precision;
									
									--precio minimo
									precio_minimo := precio_producto - descuento;
									
									--redondear a 4 digitos el Precio Minimo
									precio_minimo := round((precio_minimo)::numeric,4)::double precision;

									--RAISE EXCEPTION '%', 'PrecioVista:'||round(str_filas[7]::numeric,4)::double precision||'\nPrecioMinimo:'||precio_minimo;
									
									IF round(str_filas[7]::numeric,4)::double precision < precio_minimo THEN
										--valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':No puede ser asignado este precio.___';
										
										--Verificar si la configuraci√≥n permite la autorizacion de precios abajo de la lista de precio en pedidos
										if facpar.aut_precio_menor_ped then 
											
											--Verificar si hay que salvar aun cuando hay precios no autorizados
											if str_filas[21]::boolean=false then 
												
												--Verificar si est√° autorizado el precio menor
												if str_filas[17]::boolean then 
													
													--RAISE EXCEPTION '%','str_filas[6]:'||str_filas[6]||'     str_filas[13]:'||str_filas[13];
													
													--Verificar si el precio no es menor al precio autorizado
													if round(str_filas[7]::numeric,4)::double precision < round(str_filas[18]::numeric,4)::double precision then 
														valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':El Precio es menor al autorizado '||str_filas[18]||'.___';
														valor_retorno := ''||valor_retorno||'checkauth'||str_filas[9]||':true.___';
													else
														--Verificar si el precio autorizado no es menor al precio_minimo de venta
														sql_select := '
														SELECT 
															sbt.prod_id,
															sbt.pres_id,
															sbt.moneda_id, 
															(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS pmin  
														FROM (
															SELECT 
																inv_prod.id AS  prod_id,
																inv_prod_pres_x_prod.presentacion_id AS pres_id,
																(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
																(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
																(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
																(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic, 
																(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
																(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
																(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
															FROM inv_prod 
															JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
															JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
															LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
															LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
															WHERE inv_prod.borrado_logico=false AND inv_prod_cost_prom.ano='||ano_actual||' AND inv_prod.id='||str_filas[3]||' AND inv_prod_pres_x_prod.presentacion_id='||str_filas[4]||'  
														) AS sbt LIMIT 1;';
														
														--RAISE EXCEPTION '%','sql_select: '||sql_select;
														
														FOR record1 IN EXECUTE (sql_select) LOOP 
															IF str_data[6]::integer <> record1.moneda_id::integer THEN 
																IF str_data[6]::integer=1 AND record1.moneda_id<>1 THEN 
																	--si la moneda del pedido es pesos y la moneda del Costo es diferente de Pesos,
																	--entonces calculamos su equivalente a pesos
																	record1.pmin:= record1.pmin * str_data[8]::double precision;
																END IF;
																
																IF str_data[6]::integer<>1 AND record1.moneda_id=1 THEN 
																	--si la moneda del Pedido es Diferente de Pesos y la moneda del Costo es Pesos,
																	--entonces calculamos su equivalente a dolar
																	record1.pmin:= record1.pmin / str_data[8]::double precision;
																END IF;
															end if;

															record1.pmin:=round(record1.pmin::numeric,4)::double precision;

															--RAISE EXCEPTION '%','str_filas[6]:'||str_filas[6]||'     record1.pmin:'||record1.pmin;
															
															IF round(str_filas[7]::numeric, 4)::double precision < record1.pmin THEN 
																valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':El Precio es menor al costo '||record1.pmin||'.___';
															end if;
														END LOOP;
													end if;
												else
													valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':No puede ser asignado este precio.___';
													valor_retorno := ''||valor_retorno||'checkauth'||str_filas[9]||':true.___';
												end if;
											end if;
										else
											valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':No puede ser asignado este precio.___';
										end if;
										
									END IF;	
								END IF;
								--RAISE EXCEPTION '%',descuento;
							END IF;
						ELSE
							--Aqui entra porque el campo cantidad trae un valor no numerico
							valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':El valor para Precio Unitario es incorrecto, tiene mas de un punto('||str_filas[7]||')___';
						END IF;
					END IF;
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--termina pedidos
	
	
	--Autorizacion de Pedidos de Clientes
	IF id_app=65 THEN 
		IF command_selected = 'autorizar' THEN 
			--str_data[4]::integer
			--Verificar si la configuraci√≥n permite la autorizacion de precios abajo de la lista de precio en pedidos
			if facpar.aut_precio_menor_ped then 
				if (select count(id) from poc_pedidos_detalle where poc_pedido_id=str_data[4]::integer and requiere_aut=true and autorizado=false)>0 then 
					valor_retorno := ''||valor_retorno||'checkauth:No es posible autorizar el pedido porque hay precios por debajo de la lista.<br>Regrese a la parte de edici&oacute;n del Pedido para pedir la autorizaci&oacute;n.___';
				end if;
			end if;
			--RAISE EXCEPTION '%','valor_retorno:'||valor_retorno;
		end if;
		
	END IF;--termina Autorizacion de Pedidos
	
	
	
	--Validacion de Remisiones
	IF id_app=66 THEN
		IF trim(str_data[5]) = ''  THEN
			--valor_retorno := ''||valor_retorno||'oc:Es necesario el Numero de la Orden de Compra.___';
		END IF;
	END IF;
	--Termina validacion de Remsiones
	

	
	
	
	--SQL PARA VALIDAR PRODUCCION
	--validacion de proceso de produccion
	IF id_app=67 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion
		--str_data[5]        id_producto
		--str_data[7]        dias_caducidad
		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo del proceso___';
		END IF;
		
		IF str_data[6] = '' or str_data[6] = '0'  THEN
			valor_retorno := ''||valor_retorno||'sku:Es necesario seleccionar un producto___';
		END IF;
		
		IF str_data[7]::integer <= 0  THEN
			valor_retorno := ''||valor_retorno||'dias:El numero de dias de caducidad debe ser mayor que cero.___';
		END IF;
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		IF total_filas < 1 THEN
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un subproceso___';
		END IF;
		
		IF str_data[4] = '0' THEN 
			--EXECUTE 'select count(id) from inv_prod_presentaciones where  titulo ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			--IF valida_integridad > 0 THEN
			--	valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
			--END IF;
		END IF;
	END IF;--termina validacion de proceso de produccion
	
	
	
	
	--validacion de Catalogo inventario presentaciones
	IF id_app=68 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion
		--str_data[6]        cantidad
		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo de la presentacion___';
		END IF;
		
		IF trim(str_data[6]) = ''  THEN
			valor_retorno := ''||valor_retorno||'cant:Es necesario ingresar la Cantidad de la equivalencia de la Presentacion.___';
		ELSE
			IF str_data[6]::double precision <=0  THEN
				valor_retorno := ''||valor_retorno||'cant:La equivalencia debe ser mayor que cero.___';
			ELSE
				--Verificar si hay que validar existencias de Presentaciones
				IF controlExisPres=true THEN 
					IF trim(str_data[5])<>''  THEN
						SELECT count(id) FROM inv_prod_unidades WHERE titulo ILIKE '%'||str_data[5]||'%' AND borrado_logico=FALSE INTO exis;
						
						IF exis > 0 THEN 
							IF str_data[6]::double precision > 1  THEN
								valor_retorno := ''||valor_retorno||'cant:La equivalencia debe ser igual a 1.___';
							END IF;
						END IF;
					END IF;
				END IF;
			END IF;
		END IF;
		
		IF str_data[4] = '0' THEN 
			EXECUTE 'select count(id) from inv_prod_presentaciones where  titulo ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
			END IF;
		END IF;
		
	END IF;--termina validacion Catalogo inventario presentaciones	
	
	
	
	
	--validacion de proceso de formulas
	IF id_app=69 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  id_prod_master
		--str_data[6]  inv_prod_id
		--str_data[7]  nivel
		--str_data[8]  producto_elemento_id
		--str_data[9]  cantidad
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		
		
		IF str_data[5] = '' or str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'id_prod_master:Es necesario seleccionar un producto';
		END IF;
		
		IF str_data[6] = '' or str_data[6] = '0'  THEN
			valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto de salida___';
		END IF;
		
		IF str_data[7] = '' or str_data[7] = '0'  THEN
			valor_retorno := ''||valor_retorno||'paso_actual:Es necesario ingresar un numero de paso___';
		END IF;
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		IF total_filas < 1 THEN
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto en la configuracion___';
		END IF;
		
		IF str_data[4] = '0' THEN 

			IF str_data[6] = '' or str_data[6] = '0'  THEN
				valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto___';
			ELSE
				EXECUTE 'select count(id) from pro_estruc where inv_prod_id='||str_data[6]::integer||' and borrado_logico=false and gral_emp_id='||emp_id||';' INTO valida_integridad;
				--EXECUTE 'select count(id) from pro_estruc_det where  inv_prod_id_salida='||str_data[6]::integer||'  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'inv_prod_id:El producto de salida seleccionado, ya tiene un proceso___';
				END IF;
			END IF;
		END IF;
		
		
		-- validaciones para el grid --
		IF arreglo[1] != 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				----aqui se vuelven a crear los registros
				IF str_filas[4] != '0' THEN
					
					--VALIDACION PARA  EL GRID
					IF str_filas[2] = ' ' OR str_filas[2] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[2]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':La cantidad debe ser mayor a cero___';
						END IF;
					END IF;
					
					--para validar el numero de paso--
					IF str_filas[3] = ' ' OR str_filas[3] = '' THEN
						valor_retorno := ''||valor_retorno||'posicion'||str_filas[5]||':Es necesario ingresar la posicion___';
					ELSE
						IF str_filas[3]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'posicion'||str_filas[5]||':La posicion debe ser mayor a cero___';
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la configuracion___';
		END IF;
		
	END IF;--termina validacion de proceso de formulas

	--validacion de Aplicativo Notas de Credito
	IF id_app=70 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		
		--str_data[4]	identificador
		--str_data[5]	id_cliente
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones
		--str_data[9]	select_moneda
		--str_data[10]	select_vendedor
		--str_data[11]	concepto
		--str_data[12]	tipo_cambio
		--str_data[13]	importe
		--str_data[14]	impuesto
		--str_data[15]	retencion
		--str_data[16]	total
		--str_data[17]	factura
		
		IF str_data[5] = '0'  THEN
			valor_retorno := ''||valor_retorno||'rfccliente:Es necesario seleccionar un Cliente___';
		END IF;

		IF str_data[11] = ''  THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario el Concepto para la Nota de Credito___';
		END IF;

		IF str_data[12] = ''  THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario el tipo de Cambio___';
		END IF;

		IF str_data[13]='' OR str_data[13]='0' OR str_data[13]='0.00' THEN
			valor_retorno := ''||valor_retorno||'importe:Es necesario el Importe para la Nota de Credito___';
		END IF;
		
		IF str_data[17] = ''  THEN
			valor_retorno := ''||valor_retorno||'factura:Es necesario seleccionar una Factura___';
		END IF;
	END IF;--termina validacion de Aplicativo Notas de Credito

	
	
	
	
	--validacion de Catalogo de vehiculos
	IF id_app=73 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id
		--str_data[5]	select_tipo_unidad
		--str_data[6]	select_clase
		--str_data[7]	select_marca
		--str_data[8]	select_anio
		--str_data[9]	color
		--str_data[10]	no_economico
		--str_data[11]	select_tipo_placa
		--str_data[12]	placas
		--str_data[13]	no_serie
		--str_data[14]	select_tipo_rodada
		--str_data[15]	select_tipo_caja
		--str_data[16]	cap_volumen
		--str_data[17]	cap_peso
		--str_data[18]	select_clasif2
		--str_data[19]	id_prov
		--str_data[20]	id_operador
		--str_data[21]	comentarios
		
		
		IF str_data[5]=''  THEN
			valor_retorno := ''||valor_retorno||'tipounidad:Es necesario seleccionar el Tipo de Unidad.___';
		ELSE
			IF str_data[5]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'tipounidad:Es necesario seleccionar el Tipo de Unidad.___';
			END IF;
		END IF;

		IF str_data[6]=''  THEN
			valor_retorno := ''||valor_retorno||'clase:Es necesario seleccionar la Clase de Unidad.___';
		ELSE
			IF str_data[6]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'clase:Es necesario seleccionar la Clase de Unidad.___';
			END IF;
		END IF;	
		
		IF str_data[7]=''  THEN
			valor_retorno := ''||valor_retorno||'marca:Es necesario seleccionar la Marca.___';
		ELSE
			IF str_data[7]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'marca:Es necesario seleccionar la Marca.___';
			END IF;
		END IF;
		
		IF str_data[8]=''  THEN
			valor_retorno := ''||valor_retorno||'anio:Es necesario seleccionar el A&ntilde;o.___';
		ELSE
			IF str_data[8]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'anio:Es necesario seleccionar el A&ntilde;o.___';
			END IF;
		END IF;

		/*
		IF trim(str_data[9]) = ''  THEN
			valor_retorno := ''||valor_retorno||'color:Es necesario ingresar el Color de la Unidad.___';
		END IF;

		IF trim(str_data[10]) = ''  THEN
			valor_retorno := ''||valor_retorno||'noeconomico:Es necesario ingresar el No. Economico.___';
		END IF;
		*/

		IF str_data[11]=''  THEN
			valor_retorno := ''||valor_retorno||'tplaca:Es necesario seleccionar el Tipo de Placa.___';
		ELSE
			IF str_data[11]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'tplaca:Es necesario seleccionar el Tipo de Placa.___';
			END IF;
		END IF;

		IF trim(str_data[12]) = ''  THEN
			valor_retorno := ''||valor_retorno||'placa:Es necesario ingresar la Placa de la Unidad.___';
		END IF;

		IF trim(str_data[13]) = ''  THEN
			valor_retorno := ''||valor_retorno||'noserie:Es necesario ingresar el Numero de Serie de la Unidad.___';
		END IF;
		
		IF str_data[14]=''  THEN
			valor_retorno := ''||valor_retorno||'trodada:Es necesario seleccionar el Tipo de Rodada.___';
		ELSE
			IF str_data[14]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'trodada:Es necesario seleccionar el Tipo de Rodada.___';
			END IF;
		END IF;
		
		IF str_data[15]=''  THEN
			valor_retorno := ''||valor_retorno||'tcaja:Es necesario seleccionar el Tipo de Caja.___';
		ELSE
			IF str_data[15]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'tcaja:Es necesario seleccionar el Tipo de Caja.___';
			END IF;
		END IF;
		
		IF str_data[16]=''  THEN
			valor_retorno := ''||valor_retorno||'volumen:Es necesario ingresar una cantidad para la Capacidad en metros cubicos.___';
		ELSE
			IF str_data[16]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'volumen:La Capacidad en metros cubicos debe ser mayor a cero.___';
			END IF;
		END IF;
		
		IF str_data[16]=''  THEN
			valor_retorno := ''||valor_retorno||'peso:Es necesario ingresar una cantidad para la Capacidad Peso en toneladas.___';
		ELSE
			IF str_data[16]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'peso:La Capacidad peso en toneladas debe ser mayor a cero.___';
			END IF;
		END IF;
		
		--str_data[18]	select_clasif2
		IF str_data[18]::integer=1 THEN 
			--str_data[19]	id_prov
			IF str_data[19]=''  THEN
				valor_retorno := ''||valor_retorno||'notrans:Es necesario seleccionar el proveedor transportista.___';
			ELSE
				IF str_data[19]::integer=0  THEN
					valor_retorno := ''||valor_retorno||'notrans:Es necesario seleccionar el proveedor transportista.___';
				END IF;
			END IF;
		END IF;
		
		/*
		--str_data[20]	id_operador
		IF str_data[20]=''  THEN
			valor_retorno := ''||valor_retorno||'nooperador:Es necesario seleccionar el Operador de la Unidad.___';
		ELSE
			IF str_data[20]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'nooperador:Es necesario seleccionar el Operador de la Unidad.___';
			END IF;
		END IF;
		*/
		IF trim(str_data[12])<>''  THEN
			valida_integridad:=0;
			EXECUTE 'select count(id) from log_vehiculos where placa ilike '''||str_data[12]||''' and borrado_logico=false and gral_emp_id='||emp_id||';' 
			INTO valida_integridad;
			IF valida_integridad > 0 THEN 
				valida_integridad:=0;
				EXECUTE 'select id from log_vehiculos where placa ilike '''||str_data[12]||''' and borrado_logico=false and gral_emp_id='||emp_id||' limit 1;'
				INTO valida_integridad;
				IF valida_integridad<>str_data[4]::integer THEN 
					valor_retorno := ''||valor_retorno||'placa:La Placa ingresada ya se ecuentra registrada para otra Unidad.___';
				END IF;
			END IF;
		END IF;
		
		IF trim(str_data[13])<>''  THEN
			valida_integridad:=0;
			EXECUTE 'select count(id) from log_vehiculos where numero_serie ilike '''||str_data[13]||''' and borrado_logico=false and gral_emp_id='||emp_id||';' 
			INTO valida_integridad;
			IF valida_integridad > 0 THEN 
				valida_integridad:=0;
				EXECUTE 'select id from log_vehiculos where numero_serie ilike '''||str_data[13]||''' and borrado_logico=false and gral_emp_id='||emp_id||' limit 1;'
				INTO valida_integridad;
				IF valida_integridad<>str_data[4]::integer THEN 
					valor_retorno := ''||valor_retorno||'noserie:El Numero de Serie ingresada ya se ecuentra registrada para otra Unidad..___';
				END IF;
			END IF;
		END IF;
	END IF;
	--Termina validacion Catalogo inventario vehiculos
	
	
	
	--validacion de Catalogo inventario puestos
        IF id_app=75 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        titulo                
                IF str_data[5] = ''  THEN
                        valor_retorno := ''||valor_retorno||'Puesto:Es necesario ingresar el nombre de un Puesto';
                END IF;
                        IF str_data[4] = '0' THEN
                                EXECUTE 'select count(titulo) 
                                from gral_puestos where  titulo ilike '''||str_data[5]||'''  
                                AND borrado_logico=false 
                                AND gral_emp_id='||emp_id||';' 
                                INTO valida_integridad;
                                
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'Puesto:El Puesto ya se encuentra registrado';
                                END IF;        
                        END IF;        
                        
        END IF;--termina validacion Catalogo PUESTOS
	
	
	
	
	--validacion de Aplicativo Devoluciones de Mercancia
	IF id_app=76 THEN
		--str_data[4]	id_factura
		--str_data[5]	id_cliente
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones
		--str_data[9]	select_moneda
		--str_data[10]	select_vendedor
		--str_data[11]	concepto
		--str_data[12]	tipo_cambio
		--str_data[13]	importe
		--str_data[14]	impuesto
		--str_data[15]	retencion
		--str_data[16]	total
		--str_data[17]	factura
		
		IF str_data[12] = ''  THEN
			valor_retorno := ''||valor_retorno||'tcnota:Es necesario ingresar el Tipo de Cambio para la Nota de Credito.___';
		ELSE
			IF str_data[12]::double precision < 1  THEN
				valor_retorno := ''||valor_retorno||'tcnota:El Tipo de Cambio debe ser mayor o igual a 1.___';
			END IF;
		END IF;
		
		IF str_data[11]='' OR str_data[11]=' '  THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario ingresar el Concepto para la Nota de Credito.___';
		END IF;
		
		IF str_data[16]::double precision > 0 THEN
			--obtener el saldo de la factura
			SELECT saldo_factura FROM erp_h_facturas WHERE serie_folio=str_data[17] INTO saldo_fac;

			str_data[16] := round((str_data[16]::double precision)::numeric, 2)::character varying;
			saldo_fac := round((saldo_fac::double precision)::numeric, 2)::double precision;
			
			--validar  que el monto de la nota de credito no sea mayor que el saldo de la factura
			IF str_data[16]::double precision > saldo_fac  THEN
				valor_retorno := ''||valor_retorno||'totalnota:El total de la devolucion no debe ser mayor que el Saldo de la Factura.___';
			END IF;
			
		END IF;
		
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] seleccionado
				IF str_filas[1]::integer != 0 THEN--1: no esta esta seleccionado, 0:No esta seleccionado
					--str_filas[2]	producto_id 
					--str_filas[3]	cantidad
					--str_filas[4]	cantidad_dev
					
					--str_filas[4]	cantidad_dev
					IF str_filas[4] = ' ' OR str_filas[4] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad_dev'||cont_fila||':Es necesario ingresar la cantidad a devolver.___';
					ELSE
						--RAISE EXCEPTION '%',str_filas[4];
						IF str_filas[4]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'cantidad_dev'||cont_fila||':La cantidad a devolver debe ser mayor que cero.___';
						ELSE
							--evaluar  que la cantidad a devolver no sea mayor que la cantidad de la partida
							IF str_filas[4]::double precision >  str_filas[3]::double precision THEN
								valor_retorno := ''||valor_retorno||'cantidad_dev'||cont_fila||':La cantidad a devolver no debe ser mayor que la cantidad de la partida.___';
							END IF;
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--Termina validacion de Aplicativo Devoluciones de Mercancia
	

	--validacion de Catalogo inventario escolaridades
	IF id_app=77 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'Escolaridad:Es necesario ingresar el nombre de una Escolaridad';
		END IF;
		
		EXECUTE 'select count(titulo) from gral_escolaridads 
		where  titulo ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'Escolaridad:La Escolaridad ingresada ya se encuentra registrada';
				END IF;		
	END IF;--termina validacion Catalogo inventario escolaridades  

	--validacion de Catalogo inventario religiones
	IF id_app=78 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'Religion:Es necesario ingresar el nombre de una Religion';
		END IF;
		
		EXECUTE 'select count(titulo) from gral_religions 
		where  titulo ilike '''||str_data[5]||''' AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'Religion:La Religion ingresada ya se encuentra registrada';
		END IF;	

	END IF;--termina validacion Catalogo inventario religiones
	
	
	--validacion de Catalogo inventario tipo de sangre
	IF id_app=79 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'tiposangre:Es necesario ingresar un Tipo de Sangre';
		END IF;
		EXECUTE 'select count(titulo) from gral_sangretipos 
		where  titulo ilike '''||str_data[5]||''' AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'tiposangre:El Tipo de Sangre ingresado ya se encuentra registrado';
		END IF;	

	END IF;--termina validacion Catalogo inventario tipo de sangre

	

	--validacion de Catalogo departamentos
	IF id_app=82 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'depto:Es necesario ingresar el nombre de un Departamento';
		END IF;	

		IF str_data[6] = ''  THEN
			valor_retorno := ''||valor_retorno||'costo:Es necesario ingresar el costo del Departamento';
		END IF;

				
		IF str_data[4] = '0' THEN 
			EXECUTE 'select count(titulo) 
			from gral_deptos where  titulo ilike '''||str_data[5]||''' AND borrado_logico=false  AND gral_emp_id='||emp_id||';' 
			INTO valida_integridad;
			
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'depto:El nombre del Departamento ingresado ya se encuentra en uso';
			END IF;
		END IF;		
	END IF;--termina validacion Catalogo departamentos

	--validacion de Catalogo tipoequipos
	IF id_app=83 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        titulo                
                IF str_data[5] = ''  THEN
                        valor_retorno := ''||valor_retorno||'tipoequipo:Es necesario ingresar el nombre de un Tipo de Equipo';
                END IF;
                IF str_data[4] = '0' THEN 
                        EXECUTE 'select count(titulo) 
                        from pro_tipo_equipo where  titulo ilike '''||str_data[5]||''' 
                        AND borrado_logico=false  
                        AND gral_emp_id='||emp_id||';' 
                        INTO valida_integridad;
                        
                        IF valida_integridad > 0 THEN
                                valor_retorno := ''||valor_retorno||'tipoequipo:El nombre del Tipo de Equipo ingresado ya se encuentra en uso';
                        END IF;
                END IF;
        END IF;--termina validacion Catalogo tipoequipos

	--validacion de Catalogo inventario dias no laborables----------------------------------------------------------------
	IF id_app=84 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        fecha_no_laborable
		--str_data[6]        descripcion		
		IF str_data[5] ='' THEN
			valor_retorno := ''||valor_retorno||'DNL:Es necesario ingresar la fecha no laborable___';
		ELSE
			IF str_data[4]::integer < 0 THEN
				EXECUTE 'select count(fecha_no_laborable) 
				from gral_dias_no_laborables where  fecha_no_laborable = '''||str_data[5]::date||'''  
				AND borrado_logico=false 
				AND gral_emp_id='||emp_id||';' 
				INTO valida_integridad;
			END IF;
		END IF;

		IF str_data[6] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la descripci√≥n___';
		END IF;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'DNL:El D√≠a ya se encuentra registrado___:';
		END IF;		
	END IF;--termina validacion Catalogo dias no laborables
	-----------------------------------------------------------------------------------------------------------

	--validacion de Catalogo categorias ---------------------------------------------------------------------------------------
	IF id_app=85 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo(categ)
		--str_data[6]        sueldo_por_hora 	
		--str_data[7]        sueldo_por_horas_ext 
		--str_data[8]        gral_puesto_id (puesto)	
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'categoria:Es necesario ingresar el nombre de una Categoria___';
		END IF;

		IF str_data[6] ::double precision = 0  THEN
			valor_retorno := ''||valor_retorno||'sueldo_hora:Es necesario ingresar el sueldo por hora___';
		END IF;

		IF str_data[7]::double precision = 0  THEN
			valor_retorno := ''||valor_retorno||'sueldo_hora_extra:Es necesario ingresar el sueldo por Horas Extras___';
		END IF;	

		IF str_data[8]::integer = 0  THEN
			valor_retorno := ''||valor_retorno||'puesto:Es necesario elegir un puesto___';
		END IF;		

		IF str_data[4] = '0' THEN	
			EXECUTE 'select count(titulo) 
			from gral_categ where  titulo ilike '''||str_data[5]||''' 
			AND borrado_logico=false  
			AND gral_emp_id='||emp_id||';' 
			INTO valida_integridad;
			
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'categoria:El nombre de la Categor√≠a ingresada ya se encuentra en uso___';
			END IF;	
		END IF;	
	END IF;--termina validacion de categorias -------------------------------------------------------------------------------------------------

	
	
	
	--validacion de Aplicativo Ordenes de Entrada
	IF id_app=87 THEN
		--str_data[4]	id_oent
		--str_data[5]	observaciones
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	eliminado[i]
					--str_filas[2]	tipo_registro[i]
					--str_filas[3]	id_detalle[i]
					--str_filas[4]	id_almacen[i]
					--str_filas[5]	id_prod_grid[i]
					--str_filas[6]	cantidad_fac[i]
					--str_filas[7]	cantidad_rec[i]
					--str_filas[8]	lote_prov[i]
					--str_filas[9]	pedimento[i]
					--str_filas[10]	caducidad[i]
					--str_filas[11]	no_tr[i]
					--str_filas[12]	req_lote[i]
					--str_filas[13]	oent_detalle_id
					
					SELECT requiere_pedimento,requiere_numero_lote FROM  inv_prod WHERE id=str_filas[5]::integer INTO req_pedimento, req_lote;
					
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='PED' THEN
						suma_lotes:=0;
						--RAISE EXCEPTION '%',str_filas[7];
						--str_filas[7]	cantidad_rec[i]
						IF str_filas[7] = ' ' OR str_filas[7] = '' THEN
							valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':Es necesario ingresar la Cantidad Recibida.___';
						ELSE
							--RAISE EXCEPTION '%',str_filas[7];
							IF str_filas[7]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':La Cantidad Recibida debe ser mayor que cero.___';
							END IF;
						END IF;
						
						
						--IF req_lote=TRUE THEN
							total_filas2:= array_length(arreglo,1);
							cont_fila2:=1;
							FOR cont_fila2 IN 1 .. total_filas2 LOOP
								SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
								
								--str_filas2[1] eliminado
								IF str_filas2[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
									IF str_filas2[2]='LOT' THEN
										--aqui se suman las cantidades de los lotes de la partida actual
										IF str_filas[13]=str_filas2[13] THEN
											suma_lotes := suma_lotes + str_filas2[7]::double precision;
										END IF;
									END IF;
								END IF;
							END LOOP;
							
							--RAISE EXCEPTION '%','suma_lotes:'||suma_lotes||'   Par:'||str_filas[7]::double precision;
							suma_lotes := round(suma_lotes::numeric,2)::double precision;
							
							--str_filas[7]	cantidad_rec[i]
							IF suma_lotes > round(str_filas[7]::numeric,2)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':La suma de los Lotes no debe ser Mayor que Cantidad de la partida.___';
							END IF;
							
							--str_filas[7]	cantidad_rec[i]
							IF suma_lotes < round(str_filas[7]::numeric,2)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':La suma de los Lotes no debe ser Menor que Cantidad de la partida.___';
							END IF;
						--END IF;
						
					ELSE
						IF req_lote=TRUE THEN
							IF str_filas[8]=' ' THEN
								valor_retorno := ''||valor_retorno||'lote_prov'||str_filas[11]||':Es necesario ingresar el numero de Lote.___';
							END IF;
						END IF;
						
						--str_filas[7]	cantidad_rec[i]
						IF str_filas[7] = ' ' OR str_filas[7] = '' THEN
							valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':Es necesario ingresar la Cantidad Recibida para el lote '||str_filas[8]||'.___';
						ELSE
							--RAISE EXCEPTION '%',str_filas[7];
							IF str_filas[7]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':La Cantidad Recibida para el lote '||str_filas[8]||' debe ser mayor que cero.___';
							END IF;
						END IF;
						
						IF req_pedimento=TRUE THEN
							IF str_filas[9]=' ' OR str_filas[9]='' THEN
								valor_retorno := ''||valor_retorno||'pedimento'||str_filas[11]||':Es necesario ingresar el Pedimento.___';
							END IF;
						END IF;
						
						IF str_filas[10] != ' ' AND str_filas[10] != '' THEN
							EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechacaducidadCorrect'';' INTO mask_general;
							EXECUTE 'select '''||str_filas[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
							IF match_cadena = false THEN
								valor_retorno := ''||valor_retorno|| 'caducidad'||str_filas[11]||':Fecha de caducidad no valida.___';
							END IF;
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--Termina validacion de Aplicativo Ordenes de Entrada
	
	
	
	--validacion de preorden de produccion
	IF id_app=89 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  tipoorden
		--str_data[6]  observaciones
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		
		IF str_data[5] = '' or str_data[5] = '0'  THEN
			valor_retorno := ''||valor_retorno||'sku:Es necesario seleccionar un producto___';
		END IF;
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		IF total_filas < 1 THEN
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto___';
		END IF;
		
		-- validaciones para el grid --
		IF arreglo[1] != 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				----aqui se vuelven a crear los registros
				IF str_filas[4] != '0' THEN
					
					--VALIDACION PARA  EL GRID
					IF str_filas[6] = ' ' OR str_filas[6] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[6]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':La cantidad debe ser mayor a cero___';
						END IF;
					END IF;
					
				END IF;
			END LOOP;
		ELSE
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la configuracion___';
		END IF;
		
	END IF;--validacion de preorden de produccion
	
	
	
	
	--Orden de Compra
	IF id_app=90 THEN
	--RAISE EXCEPTION '%','ESTA ENTRANDO AQUIIIII:';
		--str_data[3]	id_usuario
		--str_data[4]	id_orden_compra
		--str_data[5] 	id_proveedor
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'rfcproveed0r:Es necesario seleccionar un Proveedor___';
		ELSE
			IF trim(str_data[5])::integer <= 0 THEN
				valor_retorno := ''||valor_retorno||'rfcproveed0r:Es necesario seleccionar un Proveedor___';
			END IF;
		END IF;
		
		--str_data[6]	observaciones    select * from cxp_prov 
		--str_data[7]	select_moneda
		--str_data[8]	tipo_cambio
		IF trim(str_data[7])='' THEN 
			valor_retorno := ''||valor_retorno||'moneda:Es necesario seleccionar un tipo de Moneda___';
		ELSE 
			IF trim(str_data[7])::double precision<=0 THEN
				valor_retorno := ''||valor_retorno||'moneda:Es necesario seleccionar un tipo de Moneda___';
			END IF;
		END IF;
		
		IF trim(str_data[8]) = '' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		END IF;
		/*
		IF str_data[9] = '' THEN
			valor_retorno := ''||valor_retorno||'grupo:Es necesario ingresar el nombre del grupo___';
		END IF;
		
		IF str_data[11] = '' THEN
			valor_retorno := ''||valor_retorno||'consiganadoa:Es necesario ingresar a quien es consignada la O.C___';
		END IF;
		*/
		
		IF trim(str_data[13]) = '' THEN
			valor_retorno := ''||valor_retorno||'fentrega:Es necesario seleccionar la fecha requerida para la entrega de la mercancia.___';
		END IF;

		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					
					--str_filas[6]	cantidad
					IF trim(str_filas[6]) = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Es necesario ingresar la cantidad___';
					ELSE
						--RAISE EXCEPTION '%',str_filas[6];
						IF str_filas[6]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad debe ser mayor que cero___';
						END IF;
					END IF;
					
					--str_filas[7]	costo
					IF trim(str_filas[7]) = '' THEN
						valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el precio unitario___';
					ELSE
						IF str_filas[7]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'costo'||cont_fila||':El precio debe ser mayor que cero___';
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--termina Orden de Compra
	
	
	
	
	
	
	
	
	--validacion de Catalogo turnos -------------------------------------------------------------------------------------------------
	IF id_app=92 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        turno
		--str_data[6]        hora_ini	
		--str_data[7]        hora_fin 
		--str_data[8]        gral_deptos_id (depto)	
		IF str_data[5]::integer = 0 THEN
			valor_retorno := 0||valor_retorno||'turno:Es necesario ingresar el n√∫mero del Turno___';
		END IF;

		IF str_data[6] = ''  THEN
			valor_retorno := ''||valor_retorno||'hora_inicial:Es necesario ingresar la hora de inicio___';
		END IF;

		IF str_data[7] = ''  THEN
			valor_retorno := ''||valor_retorno||'hora_final:Es necesario ingresar la hora final___';
		END IF;	

		IF str_data[8]::integer = 0  THEN
			valor_retorno := ''||valor_retorno||'depto:Es necesario elegir un departamento___';
		END IF;		
		
		IF str_data[4] = '0' THEN	
				EXECUTE 'select count(turno) 
				from gral_deptos_turnos where  turno = '''||str_data[5]::integer||''' 
				AND borrado_logico=false  
				AND gral_emp_id='||emp_id||';' 
				INTO valida_integridad;
				
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'0turno:El n√∫mero del turno ingresado ya se encuentra en uso___';
				END IF;	
		END IF;	
					
			
	END IF;--termina validacion de turnos -------------------------------------------------------------------------------------------------

	--validacion de orden de produccion
	IF id_app=93 THEN
		
		--obtenemos el id de el almacen de produccion
		select inv_alm_id from pro_par where gral_emp_id=emp_id limit 1 INTO id_almacen;
		
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  tipo_orden
		--str_data[6]  fecha_elavorar
		--str_data[7]  observaciones
		--str_data[8]  command_selected
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		--valida si tiene especificaciones o parametros
		
		IF str_data[8] = '1' OR str_data[8] = '2' OR str_data[8] = '3' THEN
			--RAISE EXCEPTION '%' ,str_data[4];
			IF trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'tipoorden:Es necesario seleccionar un tipo de orden___';
			END IF;
			
			IF trim(str_data[6]) = ''  THEN
				valor_retorno := ''||valor_retorno||'fecha_elavorar:Es necesario seleccionar una fecha de elaboracion___';
			END IF;
			
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			IF total_filas < 1 THEN
				valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto___';
			END IF;
			
			-- validaciones para el grid --
			IF arreglo[1] != 'sin datos' THEN
				total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
					----aqui se vuelven a crear los registros
					--RAISE EXCEPTION '%' ,str_filas[6];
					IF str_filas[1] != '0' THEN
						
						--eliminar[i] +"--1
						--___" + id_reg[i]+"--2
						--___" + inv_prod_id[i]+"--3
						--___" + subproceso_id[i]+"--4
						--___"+ pro_subproceso_prod_id[i]+"--5
						--___"+persona[i]+"--6
						--___"+ equipo[i]+"--7
						--___"+ eq_adicional[i]+"--8
						--___"+ cantidad[i]+"--9
						--___" + no_partida--10
						--VALIDACION PARA  EL GRID
						
						IF str_data[8] = '2' THEN
							--RAISE EXCEPTION '%' ,str_data[4];
							IF str_data[4] = '0' THEN 
								--RAISE EXCEPTION '%' ,str_data[4];
								IF trim(str_filas[6])<>'' THEN
									
									SELECT id FROM gral_empleados where gral_empleados.nombre_pila||' '||gral_empleados.apellido_paterno||' '||gral_empleados.apellido_materno ilike ''||str_filas[6]||'' and borrado_logico=false and gral_emp_id=emp_id INTO operador_id;
									
									IF operador_id is not null THEN

										EXECUTE  'select count(pro_orden_prod_det.id) as cantidad from pro_orden_prod_det 
										join 
										(select id, pro_proceso_id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' AND id <> '||str_data[4]::integer||' limit 1)  as tmp 
										ON pro_orden_prod_det.pro_orden_prod_id=tmp.id 
										join pro_proceso ON (pro_proceso.id=tmp.pro_proceso_id AND pro_proceso.pro_proceso_flujo_id in (2, 3))
										where pro_orden_prod_det.gral_empleados_id='||operador_id||';' INTO valida_integridad;
										
										/*
										--Commentado para que no calide operario-- 14/may/2013
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operador ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
										
									ELSE
										valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operario que selecciono no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operario que selecciono no se encontro___';
								END IF;
								
								IF trim(str_filas[7])<>='' THEN
									SELECT id FROM pro_equipos where titulo ilike ''||str_filas[7]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_id;
									IF equipo_id is not null THEN
										EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' limit 1) and pro_equipos_id='||equipo_id||';' INTO valida_integridad;
										/*
										--Commentado para que no calide equipo-- 14/may/2013
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
									ELSE
										valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo no se encontro___';
								END IF;

								--RAISE EXCEPTION '%' ,'str_filas[8]: HOLA';
								--RAISE EXCEPTION '%' ,'str_filas[8]: '||str_filas[8];
								
								IF trim(str_filas[8])<>'' THEN
									SELECT id FROM pro_equipos_adic where titulo ilike ''||str_filas[8]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_adicional_id;
									--RAISE EXCEPTION '%' ,str_filas[10];
									IF equipo_adicional_id is not null THEN
										EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' limit 1) and pro_equipos_adic_id='||equipo_adicional_id||';' INTO valida_integridad;
										/*
										--Commentado para que no valide equipo adicional-- 14/may/2013
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
									ELSE
										--RAISE EXCEPTION '%' ,str_filas[10];
										valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional no se encontro___';
									END IF;
								ELSE
									--RAISE EXCEPTION '%' ,str_filas[10];
									valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional no se encontro___';
								END IF;
							ELSE
								--RAISE EXCEPTION '%' ,str_filas[6];
								IF trim(str_filas[6])<>'' THEN
									
									SELECT id FROM gral_empleados where trim(gral_empleados.nombre_pila)||' '||trim(gral_empleados.apellido_paterno)||' '||trim(gral_empleados.apellido_materno) ilike ''||trim(str_filas[6])||'' and borrado_logico=false and gral_emp_id=emp_id INTO operador_id;

	--RAISE EXCEPTION '%' ,'SELECT id FROM gral_empleados where gral_empleados.nombre_pila'||' '||'gral_empleados.apellido_paterno'||' '||'gral_empleados.apellido_materno ilike '||trim(str_filas[6])||' and borrado_logico=false and gral_emp_id='||emp_id;
									--RAISE EXCEPTION '%' ,'operador_id: '||operador_id;
									IF operador_id is not null THEN
										
										EXECUTE  'select count(pro_orden_prod_det.id) as cantidad from pro_orden_prod_det 
										join 
										(select id, pro_proceso_id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' AND id <> '||str_data[4]::integer||' limit 1)  as tmp 
										ON pro_orden_prod_det.pro_orden_prod_id=tmp.id 
										join pro_proceso ON (pro_proceso.id=tmp.pro_proceso_id AND pro_proceso.pro_proceso_flujo_id in (2,3)) 
										where pro_orden_prod_det.gral_empleados_id='||operador_id||';' INTO valida_integridad;
										--RAISE EXCEPTION '%' ,valida_integridad;
										--EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										--(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										--borrado_logico=false and gral_emp_id='||emp_id||' and id<>'||str_data[4]::integer||'  limit 1) and gral_empleados_id='||operador_id||';' INTO valida_integridad;
										/*
										--Comentado para permitir repetir el operario
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operador ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
									ELSE
										--RAISE EXCEPTION '%' ,str_filas[10];
										valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operario que selecciono no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operario que selecciono no se encontro___';
								END IF;

								--RAISE EXCEPTION '%' ,str_filas[7];
								
								IF trim(str_filas[7])<>'' THEN
									SELECT id FROM pro_equipos where titulo ilike ''||str_filas[7]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_id;
									--RAISE EXCEPTION '%' ,'SELECT id FROM pro_equipos where titulo ilike '||str_filas[7]||' and borrado_logico=false and gral_emp_id='||emp_id;
									IF equipo_id is not null THEN
										--EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										--(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										--borrado_logico=false and gral_emp_id='||emp_id||' and id<>'||str_data[4]::integer||'  limit 1) and pro_equipos_id='||equipo_id||';' INTO valida_integridad;
										
										EXECUTE  'select count(pro_orden_prod_det.id) as cantidad from pro_orden_prod_det 
										join 
										(select id, pro_proceso_id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' AND id <> '||str_data[4]::integer||' limit 1)  as tmp 
										ON pro_orden_prod_det.pro_orden_prod_id=tmp.id 
										join pro_proceso ON (pro_proceso.id=tmp.pro_proceso_id AND pro_proceso.pro_proceso_flujo_id in (2,3)) 
										where pro_orden_prod_det.pro_equipos_id='||equipo_id||';' INTO valida_integridad;
										/*
										--Comentado para permitir repetir el equipo
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
										
									ELSE
										valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo no se encontro___';
								END IF;
								
								IF trim(str_filas[8])<>'' THEN
									SELECT id FROM pro_equipos_adic where titulo ilike ''||str_filas[8]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_adicional_id;
									--RAISE EXCEPTION '%' ,equipo_adicional_id;
									
									IF equipo_adicional_id is not null THEN
										--EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										--(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										--borrado_logico=false and gral_emp_id='||emp_id||' and id<>'||str_data[4]::integer||'  limit 1) and pro_equipos_adic_id='||equipo_adicional_id||';' INTO valida_integridad;
										
										EXECUTE  'select count(pro_orden_prod_det.id) as cantidad from pro_orden_prod_det 
										join 
										(select id, pro_proceso_id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' AND id <> '||str_data[4]::integer||' limit 1)  as tmp 
										ON pro_orden_prod_det.pro_orden_prod_id=tmp.id 
										join pro_proceso ON (pro_proceso.id=tmp.pro_proceso_id AND pro_proceso.pro_proceso_flujo_id in (2,3)) 
										where pro_orden_prod_det.pro_equipos_adic_id='||equipo_adicional_id||';' INTO valida_integridad;
										/*
										--Comentado para permitir repetir el mismo equipo adicional en el mismo dia
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
									ELSE
										valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional no se encontro___';
								END IF;
							END IF;
							
							IF trim(str_filas[7])<>'' THEN
								IF trim(str_filas[6])='' THEN
									valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':Seleccione un operador___';
								END IF;
							END IF;
							
							IF trim(str_filas[8])<>'' THEN
								IF trim(str_filas[6])='' THEN
									valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':Seleccione un operador___';
								END IF;
							END IF;
							
						END IF;
						
						IF trim(str_filas[9]) = '' THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[10]||':Es necesario ingresar la cantidad___';
						ELSE
							IF str_filas[9]::double precision < 0.000001  THEN
								valor_retorno := ''||valor_retorno||'cantidad'||str_filas[10]||':La cantidad debe ser mayor a cero___';
							END IF;
						END IF;

						
						--En produccion, para verificar si una nueva requisicion tiene existencia
						IF str_data[8] = '3' THEN
							--almacena el proceso en el que se encuentra la orden de produccion
							valida_integridad := 0;
							
							--Query para verificar si la Empresa actual incluye Modulo de Produccion
							SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
							
							--RAISE EXCEPTION '%','controlExisPres: '||controlExisPres;
							
							IF str_data[9]='lotes' THEN
								
								IF str_filas[11] = '0' THEN
									
									IF str_filas[1] <> '0' THEN
										
										--IF str_filas[10] = '0' THEN
											----INSERT INTO pro_orden_detalle_mov(pro_orden_prod_det_id,cantidad,cantidad_adicional ,
											----	pro_subprocesos_id,num_lote,
											----	inv_prod_id,gral_empleados_id, elemento, inv_osal_id) 
											----	values(str_filas[8]::integer, str_filas[4]::double precision,
											----	str_filas[5]::double precision, 
											----	str_filas[9]::integer, str_filas[6],
											----	str_filas[3]::integer, usuario_ejecutor, (cont_fila1+1), str_filas[11]::integer);
											
											suma_componente := 0;
											IF str_filas[5] = '0' THEN
												suma_componente := str_filas[4]::double precision;
											ELSE
												suma_componente := str_filas[5]::double precision;
											END IF;
											
											EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
											
											EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
											
											--todos los pedidos, se tienen que hacer en kilos
											IF match_cadena = false THEN
												--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
												suma_componente := (suma_componente / (select densidad from inv_prod where id=str_filas[3]::integer));
											END IF;
											
											suma_componente := round((suma_componente)::numeric, 4)::double precision;
											
											SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, str_filas[12]::integer) INTO total_existencia; 

											--RAISE EXCEPTION '%' ,'total_existencia: '||total_existencia ||'       suma_componente: '||suma_componente;
											--IF total_existencia <= 0 THEN 
											--	RAISE EXCEPTION '%' ,id_almacen;
											--END IF;
											total_existencia := round((total_existencia)::numeric, 4)::double precision;
											
											cant_disponible:=0;
											
											select sku from inv_prod where id=str_filas[3]::integer INTO sku_componente;
											--Si no selecciono almacen
											IF str_filas[12]::integer = 0 THEN
												valor_retorno := ''||valor_retorno||'almacen1:Seleccione un almacen para '||sku_componente||'___';
											ELSE
												--si seleccion almacen, verificar existencia
												--Recorre todo el arreglo, para verificar si hay mas productos con la misma clave en el mismo almacen
												total_filas2:= array_length(arreglo,1);
												cont_fila2:=1;
												
												/*     Validaciones para la existencia por unidad de medida     */
												FOR cont_fila2 IN 1 .. total_filas2 LOOP
													SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
													
													IF str_filas2[1] != '0' THEN
														--id de el registro, si es cero, va a valida
														IF str_filas2[11] = '0' THEN
															IF str_filas[3]::integer=str_filas2[3]::integer AND str_filas[12]::integer=str_filas2[12]::integer THEN
																--Convertire a unidad de medida, la cantidad de la partida en posicion de str_filas2
																IF str_filas2[4]='' THEN
																	str_filas2[4] := '0';
																END IF;
																
																IF str_filas2[5]='' THEN
																	str_filas2[5] := '0';
																END IF;
																
																IF str_filas2[5] = '0' THEN
																	cant_disponible := str_filas2[4]::double precision;
																ELSE
																	cant_disponible := str_filas2[5]::double precision;
																END IF;
																
																EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas2[3]::integer)||'' INTO titulo_mask;
																
																--unidad de medida para el cmponente
																EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
																
																--todos los pedidos, se tienen que hacer en kilos
																IF match_cadena = false THEN
																	--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
																	cant_disponible := (cant_disponible::double precision / (select densidad from inv_prod where id=str_filas2[3]::integer));
																END IF;
																
																cant_disponible := round((cant_disponible)::numeric, 4)::double precision;
																
																--resta la cantidad de la partida a la existencia
																total_existencia := (total_existencia::double precision - cant_disponible::double precision);

																total_existencia := round((total_existencia)::numeric, 4)::double precision;
																
															END IF;	
														END IF;
													END IF;
													
												END LOOP;
												
												--Convertire a unidad de medida, la cantidad de la partida en posicion de str_filas
												IF str_filas[4]='' THEN
													str_filas[4] := '0';
												END IF;
												
												IF str_filas[5]='' THEN
													str_filas[5] := '0';
												END IF;
												
												IF str_filas[5] = '0' THEN
													cant_disponible := str_filas[4]::double precision;
												ELSE
													cant_disponible := str_filas[5]::double precision;
												END IF;
												
												EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
												
												--unidad de medida para el cmponente
												EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
												
												--todos los pedidos, se tienen que hacer en kilos
												IF match_cadena = false THEN
													--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
													cant_disponible := (cant_disponible / (select densidad from inv_prod where id=str_filas[3]::integer));
												END IF;
												
												cant_disponible := round((cant_disponible)::numeric, 4)::double precision;
												
												--RAISE EXCEPTION '%' ,'total_existencia: '||total_existencia ||'       cant_disponible: '||cant_disponible;
												
												--Suma la cantidad de la partida a la existecia, debido a que se le deconto al recorrer por segunda vez el arreglo
												total_existencia := total_existencia::double precision + cant_disponible::double precision;
												
												IF total_existencia < cant_disponible THEN
													IF total_existencia < 0 THEN
														total_existencia := 0;
													END IF;
													valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||total_existencia||' y necesita '||cant_disponible||'___';
												END IF;
												/*    Termina validaciones por unidad de medida, para la materia prima       */
												
												--RAISE EXCEPTION '%' ,'total_existencia: '||total_existencia ||'       cant_disponible: '||cant_disponible;
												
												
												
												/*     Validaciones para la existencia por presentacion por default     */
												--Convertire a unidad de medida, la cantidad de la partida en posicion de str_filas
												
												IF str_filas[4]='' THEN
													str_filas[4] := '0';
												END IF;
												
												IF str_filas[5]='' THEN
													str_filas[5] := '0';
												END IF;
												
												IF str_filas[5] = '0' THEN
													cant_disponible := str_filas[4]::double precision;
												ELSE
													cant_disponible := str_filas[5]::double precision;
												END IF;
												
												EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
												
												--unidad de medida para el cmponente
												EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
												
												--todos los pedidos, se tienen que hacer en kilos
												IF match_cadena = false THEN
													--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
													cant_disponible := (cant_disponible / (select densidad from inv_prod where id=str_filas[3]::integer));
												END IF;
												
												cant_disponible := round((cant_disponible)::numeric, 4)::double precision;
												
												--Suma la cantidad de la partida a la existecia, debido a que se le deconto al recorrer por segunda vez el arreglo
												total_existencia := total_existencia + cant_disponible;
												
												--RAISE EXCEPTION '%' ,str_filas[12];--2141
												
												--select * from inv_exi_pres where inv_prod_id=str_filas[3]::integer AND inv_alm_id=3 ;
												--buscar la existencia actual de la presentacion
												
												IF controlExisPres=true THEN 
													
													select cantidad from inv_prod_presentaciones where id=
													(Select inv_prod_presentacion_id from inv_prod where id=str_filas[3]::integer limit 1) INTO equivalenciaPres;

													--RAISE EXCEPTION '%' ,'equivalenciaPres: '||equivalenciaPres;
													
													IF equivalenciaPres is not null THEN
														
														sql_select:='select 
															(inv_exi_pres.inicial + inv_exi_pres.entradas - inv_exi_pres.reservado - inv_exi_pres.salidas) AS existencia 
															from (
															Select (CASE WHEN inv_prod_presentacion_id is null THEN 0 ELSE inv_prod_presentacion_id END) as presentacion_id, id from inv_prod where id='||str_filas[3]::integer||' 
															) as prod 
															JOIN inv_exi_pres 
															ON (inv_exi_pres.inv_prod_presentacion_id=prod.presentacion_id AND inv_exi_pres.inv_prod_id=prod.id ) 
															WHERE inv_exi_pres.inv_alm_id='||str_filas[12]::integer||' ';
														--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
														
														EXECUTE sql_select INTO cantPres;
														
														--RAISE EXCEPTION '%' ,'cantPres: '||cantPres||'     total_existencia:'||total_existencia;
														
														IF cantPres is not null OR cantPres > 0.00001 THEN
															--IF (total_existencia/cantPres) < cantPres THEN
															IF (total_existencia / equivalenciaPres::double precision) < cantPres::double precision THEN
																valor_retorno := ''||valor_retorno||'cantidad1:El producto '||sku_componente||', no tiene existencia suficiente en presentacion default.___';
															END IF;
														ELSE
															valor_retorno := ''||valor_retorno||'cantidad1:El producto '||sku_componente||', no tiene existencia suficiente en presentacion default.___';
														END IF;
														
													ELSE
														valor_retorno := ''||valor_retorno||'cantidad1:El producto '||sku_componente||', no tiene presentacion default.___';
													END IF;
													
													--RAISE EXCEPTION '%','controlExisPres: '||cantPres;
													
													IF total_existencia < cant_disponible THEN
														IF total_existencia < 0 THEN
															total_existencia := 0;
														END IF;
														valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||total_existencia||' y necesita '||cant_disponible||'___';															
													END IF;
													
												END IF;
												
												--str_filas[12]::integer
												--EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
												
												--RAISE EXCEPTION '%' ,'inv_alm_id:'||str_filas[12]::integer||' -  inv_prod_id:'||str_filas[3]::integer||' -  inv_prod_presentacion_id:'||str_filas[11]::integer;
												
											END IF;
											
											
											
											
											
											----llamada a proc que devuelve la existencia del producto. 
											----El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
											----el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
											
											
											--IF total_existencia < cant_disponible THEN
											--	valor_retorno := ''||valor_retorno||'cantidad1:El producto '||(select sku from inv_prod where id=str_filas[3]::integer)||' tiene Existencia 0 en Almacen___';
											--ELSE
											--	IF total_existencia < suma_componente THEN
											--		valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||(select sku from inv_prod where id=str_filas[3]::integer)||' es '||total_existencia||', necesita '||suma_componente||'___';
											--	END IF;
											--END IF;
											
										--END IF;
									END IF;
								END IF;
								
							END IF;
							
						END IF;
						
						
						--En produccion, para verificar hay especificaicones, asi como ordenes de salida 
						IF str_data[8] = '4' THEN
							--almacena el proceso en el que se encuentra la orden de produccion
							valida_integridad := 0;
							SELECT pro_proceso_id FROM pro_orden_prod WHERE id=str_data[4]::integer INTO valida_integridad;
							select pro_proceso_flujo_id from pro_proceso where id=valida_integridad INTO valida_integridad;
							IF valida_integridad = 3 THEN
								valida_integridad := 0;
								select count(opd.id), count(opde.pro_orden_prod_det_id) from (selecT id from pro_orden_prod_det where pro_orden_prod_id=str_data[4]::integer) as opd 
								left join pro_orden_prod_subp_esp as opde on opde.pro_orden_prod_det_id=opd.id where opde.pro_orden_prod_det_id is null INTO valida_integridad, primero;
								
								IF valida_integridad > primero THEN
									valor_retorno := ''||valor_retorno||'cantidad1:Debe capturar almenos un resultado de analisis por subproceso___';
								END IF;
								--RAISE EXCEPTION '%' ,primero;
							END IF;
						END IF;
						
					END IF;
				END LOOP;
			ELSE
				valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la orden___';
			END IF;
			
			
			-- validaciones verificar existrencia de la requisicion --
			IF arreglo[1] != 'sin datos' THEN
				total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					sku_componente:='';
					--RAISE EXCEPTION '%' ,arreglo[cont_fila];
					
					IF str_data[9]='lotes' THEN
						
						--SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
						----aqui se vuelven a crear los registros
						SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
						--RAISE EXCEPTION '%' ,str_filas[1];
						--nuevo registro
						IF str_filas[1] <> '0' THEN 

							--Obtiene el codigo de el producto
							select sku from inv_prod where id=str_filas[3]::integer INTO sku_componente;
							
							IF str_filas[4]<>'0' AND trim(str_filas[4])<>'' THEN
								
								--id de el registro, si es cero, va a valida
								--RAISE EXCEPTION '%' ,str_filas[10]||'Hola validador';
								IF str_filas[10] = '0' THEN
									
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, str_filas[12]::integer) INTO total_existencia;
									--RAISE EXCEPTION '%' ,total_existencia;
									

									EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
									
									--unidad de medida para el cmponente
									EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
									
									--todos los pedidos, se tienen que hacer en kilos
									IF match_cadena = false THEN
										--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
										total_existencia := (total_existencia * (select densidad from inv_prod where id=str_filas[3]::integer));
									END IF;
									
									total_existencia := round((total_existencia)::numeric, 4)::double precision;
									

									--RAISE EXCEPTION '%' ,'total_existencia: '||total_existencia;

									
									--IF total_existencia<=0 THEN
									--	valor_retorno := ''||valor_retorno||'cantidad1:El producto '||sku_componente||' tiene Existencia 0 en Almacen___';
									--ELSE
									--	IF total_existencia < str_filas[4]::double precision THEN
									--		valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||total_existencia||' y necesita '||str_filas[4]||'___';
									--	END IF;
									--END IF;
									
									
									--Si no selecciono almacen
									IF str_filas[12]::integer = 0 THEN
										valor_retorno := ''||valor_retorno||'almacen1:Seleccione un almacen para '||sku_componente||'___';
									ELSE
										--si seleccion almacen, verificar existencia
										--Recorre todo el arreglo, para verificar si hay mas productos con la misma clave en el mismo almacen
										total_filas2:= array_length(arreglo,1);
										cont_fila2:=1;
										FOR cont_fila2 IN 1 .. total_filas2 LOOP
											SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
											
											IF str_filas2[1] <> '0' THEN
												--id de el registro, si es cero, va a valida
												IF str_filas2[10] = '0' THEN
													IF str_filas[3]::integer=str_filas2[3]::integer AND str_filas[12]::integer=str_filas2[12]::integer THEN
														IF str_filas2[4]='' THEN
															str_filas2[4]:='0';
														END IF;
														IF str_filas2[5]='' THEN
															str_filas2[5]:='0';
														END IF;
														total_existencia := (total_existencia - (str_filas2[4]::double precision + str_filas2[5]::double precision));
													END IF;	
												END IF;
											END IF;
											
										END LOOP;
										
										
										--IF total_existencia < str_filas2[4]::double precision THEN
										IF total_existencia < 0 THEN
											valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||(total_existencia + str_filas[4]::double precision)||' y necesita '||str_filas[4]||'___';
										END IF;
										
										--IF total_existencia < str_filas2[5]::double precision THEN
										IF total_existencia < 0 THEN
											valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||(total_existencia + str_filas[4]::double precision)||' y necesita '||str_filas[4]||'___';
										END IF;
										
									END IF;

									
									/*
									total_filas2:= array_length(arreglo,1);
									cont_fila2:=1;
									FOR cont_fila2 IN 1 .. total_filas2 LOOP
										SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
										
										--str_filas2[1] eliminado
										IF str_filas2[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
											IF str_filas2[2]='LOT' THEN
												--aqui se suman las cantidades de los lotes de la partida actual
												IF str_filas[4]=str_filas2[4] THEN
													IF str_filas2[9]!='' AND  str_filas2[9]!=' ' THEN
														suma_lotes := suma_lotes + str_filas2[9]::double precision;
													END IF;
												END IF;
											END IF;
										END IF;
									END LOOP;
									*/
									
								END IF;
								
							ELSE
								IF str_filas[2]='' THEN str_filas[2]:='0'; END IF;
								IF str_filas[10]='' THEN str_filas[10]:='0'; END IF;
								IF str_filas[5]='' THEN str_filas[5]:='0'; END IF;
								
								IF str_filas[2]<>'0' AND str_filas[10]='0' THEN 
									--Aqui entra cuando es el Adicional de cualquiera de los productos ya registrados
									IF str_filas[5]='0' THEN 
										valor_retorno := ''||valor_retorno||'cantidad1:Es necesario ingresar la antidad Adicional en el nuevo registro para el componente '||sku_componente||'___';
									END IF;
								ELSE
									--Aqui entra cuando es nuevo producto o es uno existente pero la Cantidad viene en cero o vacio.
									valor_retorno := ''||valor_retorno||'cantidad1:Es necesario ingresar la Cantidad para el nuevo componente '||sku_componente||'___';
								END IF;
							END IF;
							
						END IF;
						
					END IF;
					
				END LOOP;
			END IF;	
		END IF;
		
		--aqui empieza comentarios para no validar existencias
		----validacion para enviar la requisicion
		--IF str_data[8] = '6' THEN
		--	total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		--	cont_fila:=1;
		--	FOR cont_fila IN 1 .. total_filas LOOP
		--		
		--		SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
		--		--eliminar_tmp+"___"+1
		--		--id_reg_requisicion+"___"+2
		--		--id_prod_requisicion+"___"+3
                --               --cantidad_requisicion+"___"+4
                --               --existencia_requisicion+"";5
		--		
		--		----aqui para validar que la existencia sea suficiente 
		--		--RAISE EXCEPTION '%' ,str_filas[6];
		--		IF str_filas[1] != '0' THEN
		--			
		--			EXECUTE 'select titulo from inv_prod_unidades where id=(select unidad_id from inv_prod where id='||str_filas[3]::integer||')' INTO titulo_mask;
		--			
		--			--EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
		--			--verificar existencia
		--			EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
		--			
		--			--todos los pedidos, se tienen que hacer en kilos
		--			IF match_cadena = true THEN
		--				--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad);
		--				suma_componente := str_filas[4]::double precision;
		--			ELSE
		--				--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
		--				--							obtiene la densidad de el producto
		--				suma_componente := str_filas[4]::double precision / (select densidad from inv_prod where id=str_filas[3]::integer);
		--			END IF;
		--			
		--			suma_componente := round((suma_componente)::numeric, 4)::double precision;
		--			
		--			--llamada a proc que devuelve la existencia del producto. 
		--			--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
		--			--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
		--			SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, id_almacen) INTO total_existencia; 
		--			
		--			total_existencia := round((total_existencia)::numeric, 4)::double precision;
		--			
		--			IF total_existencia<=0 THEN
		--				--								obtiene el codigo de el producto
		--				valor_retorno := ''||valor_retorno||'cantidad1:El producto '||(select sku from inv_prod where id=str_filas[3]::integer)||' tiene Existencia 0 en Almacen___';
		--			ELSE
		--				IF total_existencia < suma_componente THEN
		--					--									obtiene el codigo de el producto
		--					valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||(select sku from inv_prod where id=str_filas[3]::integer)||' es '||total_existencia||', necesita '||suma_componente||'___';
		--				END IF;
		--			END IF;
		--			
		--		END IF;
		--		
		--	END LOOP;	
		--	--RAISE EXCEPTION '%' ,sql_formula;
		--	
		--END IF;
		--aqui termina comentarios para no validar existencias
		
		
		
		--aqui inicia validaciones de cantidades que se utilizaron en realidad
		----validacion para las cantidades que se utilizaron al final de la produccion
		IF str_data[8] = '9' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--eliminar_tmp+"___"+--1
				--id_reg_tmp+"___"+--2
				--id_prod_detalle_tmp+"___"+ --3
				--cantidad_elemento_tmp+"___"+--4
				--cantidad_adicional_tmp+"___"+--5
				--lote_tmp+"___"+//inv_osal_id--6
				--inv_prod_id_elemento_tmp+"___"+--7
				--id_reg_parent+"___"+--8
				--$subproceso_id.val()+"___"+--9
				--id_reg_det+"___"+--10
				--inv_osal_id+"___"+--11
				--almacen_id+"___"+--12
				--sucursal_id+"___"+--13
				--agregado+"___"+--14
				--cantidad_real_tmp--15
				
				IF ( str_filas[4]::double precision + str_filas[5]::double precision) < str_filas[15]::double precision THEN
					valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad utilizada excede a la cantidad solicitada___';
				END IF;
				
				IF str_filas[6] = '' OR str_filas[6] = ' ' THEN
					valor_retorno := ''||valor_retorno||'lote'||cont_fila||':Debe hacer los trspasos de almacen___';
				END IF;
				
			END LOOP;
			--RAISE EXCEPTION '%' ,sql_formula;
			
		END IF;
		--aqui termina validaciones de cantidades que se utilizaron en realidad
		
		
		--valida si tiene especificaciones o parametros
		IF str_data[8] = '4' THEN
			--Obtener el status de calidad
			SELECT status_calidad FROM pro_orden_prod WHERE id=str_data[4]::integer limit 1 INTO estado_calidad;
			
			IF estado_calidad IS NULL THEN estado_calidad:=0; END IF;

			--1=Aceptado
			IF estado_calidad=1 THEN
				SELECT pro_proceso_id FROM pro_orden_prod WHERE id=str_data[4]::integer INTO valida_integridad;
				select pro_proceso_flujo_id from pro_proceso where id=valida_integridad INTO valida_integridad;
				IF valida_integridad = 3 THEN
					
					selecT inv_prod_id from pro_orden_prod_det where pro_orden_prod_id=str_data[4]::integer limit 1 INTO componente_id;
					
					--selecT count(id) as cantidad from pro_get_detalle_orden_produccion(componente_id,str_data[4]::integer,id_almacen, 0)  as 
					--foo(id integer, inv_prod_id integer, sku character varying,descripcion character varying, 
					--requiere_numero_lote boolean ,cantidad_adicional double precision,id_reg_det integer, 
					--cantidad double precision,elemento integer, lote character varying, inv_osal_id integer) where lote is null OR lote='' INTO valida_integridad;
					
					selecT count(id) as cantidad from pro_get_detalle_orden_produccionv2(componente_id,str_data[4]::integer,id_almacen, 0) 
					as foo(id integer, inv_prod_id integer, 
					sku character varying,descripcion character varying, requiere_numero_lote boolean ,cantidad_adicional double precision,
					id_reg_det integer, cantidad double precision,elemento integer, lote character varying, inv_osal_id integer, inv_alm_id integer, 
					gral_suc_id integer, agregado boolean,cantidad_usada double precision, guardado boolean) where lote is null OR lote='' INTO valida_integridad;
					
					
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'cantidad1:Debe darle salida a la materia prima___';
					END IF;
					
					valida_integridad := 0;
					----Se comento, por que esta validacion, ya no existira
					----SELECT count(prosal.pro_orden_prod_id) as cantidad from pro_ordenprod_invosal as prosal join inv_osal on (inv_osal.id=prosal.inv_osal_id and inv_osal.estatus=2)
					 ----where prosal.pro_orden_prod_id=str_data[4]::integer INTO valida_integridad;
					 
					 
					----IF valida_integridad <= 0 THEN
					----	valor_retorno := ''||valor_retorno||'cantidad1:Debe confirmar la salida de la materia prima___';
					----END IF;
					
					--RAISE EXCEPTION '%',valida_integridad;
					
				----	IF valor_retorno = '' OR valor_retorno is null THEN
				----		SELECT count(prosal.pro_orden_prod_id) as cantidad from pro_ordenprod_invosal as prosal join inv_osal on (inv_osal.id=prosal.inv_osal_id and inv_osal.estatus=2)
				----		 where prosal.pro_orden_prod_id=str_data[4]::integer  INTO valida_integridad;
				----		IF valida_integridad = 0 THEN
				----			valor_retorno := ''||valor_retorno||'cantidad1:Debe darle salida a la materia prima___';
				----		END IF;
				----	END IF;
				----	--valida que se capturaron los numero de lote en produccion
				----	--SELECT count(opdm.id) as cantidad from (SELECT id from pro_orden_prod_det where pro_orden_prod_id=str_data[4]::integer ) as tmp 
				----	--join pro_orden_detalle_mov as opdm on (opdm.pro_orden_prod_det_id= tmp.id AND (opdm.num_lote is not null AND opdm.num_lote = '')) INTO valida_integridad;
				----	
				----	SELECT count(pro_orden_detalle_mov.num_lote) from (
				----	selecT * from pro_get_detalle_orden_produccion(componente_id,str_data[4]::integer,1)  as foo(id integer, inv_prod_id integer, sku character varying,descripcion character varying, 
				----	requiere_numero_lote boolean ,cantidad_adicional double precision,id_reg_det integer, cantidad double precision,elemento integer, lote character varying)
				----	) as inv 
				----	join 
				----	pro_orden_detalle_mov on (pro_orden_detalle_mov.id=inv.id_reg_det AND pro_orden_detalle_mov.num_lote is not null AND pro_orden_detalle_mov.num_lote <> '' ) INTO valida_integridad;
				----	--RAISE EXCEPTION '%',str_data[4];
				----	IF valida_integridad = 0 THEN
				----		valor_retorno := ''||valor_retorno||'cantidad1:Debe capturar tods los lotes en produccion___';
				----	END IF;
					
					--valida que se capturaron especificaciones en produccion
					SELECT count(tmp.id), count(opdes.id) from (
					SELECT id from pro_orden_prod_det where pro_orden_prod_id=str_data[4]::integer ) as tmp
					left join pro_orden_prod_subp_esp as opdes on opdes.pro_orden_prod_det_id= tmp.id INTO valida_integridad, existe_lote;
					
					IF existe_lote = 0 THEN
						IF valida_integridad < existe_lote THEN
							valor_retorno := ''||valor_retorno||'cantidad1:Debe capturar las especificaciones para cada sumproceso___';
						END IF;
					END IF;
					
					valida_integridad:= 0;
					--valida que todas las cantidades usadas, se hallan guardado
					selecT count(id) as cantidad from pro_get_detalle_orden_produccionv2(componente_id,str_data[4]::integer,id_almacen, 0) 
					as foo(id integer, inv_prod_id integer, 
					sku character varying,descripcion character varying, requiere_numero_lote boolean ,cantidad_adicional double precision,
					id_reg_det integer, cantidad double precision,elemento integer, lote character varying, inv_osal_id integer, inv_alm_id integer, 
					gral_suc_id integer, agregado boolean,cantidad_usada double precision, guardado boolean) where guardado=false  INTO valida_integridad;
					
					--RAISE EXCEPTION '%' ,' componente_id:'||componente_id||' str_data[4]:'||str_data[4]::integer||' id_almacen:'||id_almacen;
					
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'cantidad1:Debe de guardar todas las cantidades reales usadas___';
					END IF;
					
				END IF;

			ELSE
				IF estado_calidad=0 THEN
					valor_retorno := ''||valor_retorno||'statuscalidad:La Orden debe ser Aceptada por personal de Calidad, no es posible terminar.___';
				END IF;

				IF estado_calidad=2 THEN
					valor_retorno := ''||valor_retorno||'statuscalidad:La Orden fue Rechazada por personal de calidad, no es posible terminar.___';
				END IF;
			END IF;
		END IF;
		
	END IF;
	--Termina validacion de orden de produccion

		
	

	
	
	--validacion de Aplicativo Ordenes de Salida
	IF id_app=94 THEN
		--str_data[4]	id_osal
		--str_data[5]	observaciones
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer <> 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	eliminado[i]
					--str_filas[2]	tipo_registro[i]
					--str_filas[3]	id_detalle_lot[i]
					--str_filas[4]	id_detalle_os[i]
					--str_filas[5]	id_almacen[i]
					--str_filas[6]	id_prod_grid[i]
					--str_filas[7]	lote_interno[i]
					--str_filas[8]	cantidad_fac[i]
					--str_filas[9]	cant_sur[i]
					--str_filas[10]	no_tr[i]

					--Inicializar variables
					tipo=0;
					idUnidadMedida=0;
					nombreUnidadMedida:='';
					densidadProd:=0;
					noDecUnidad:=0;
					idUnidadMedidaVenta:=0;
					cantUnidadVenta:=0;
					cantExisUnidadVenta:=0;
					
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='PAR' THEN
						suma_lotes:=0;
						--RAISE EXCEPTION '%',str_filas[9];
						--str_filas[9]	cant_sur[i]
						IF trim(str_filas[9])='' THEN
							valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':Es necesario ingresar la Cantidad Surtida.___';
						ELSE
							--RAISE EXCEPTION '%',str_filas[9];
							IF str_filas[9]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La Cantidad Surtida debe ser mayor que cero.___';
							ELSE
								IF str_filas[8]::double precision <> str_filas[9]::double precision THEN
									valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La Cantidad Surtida debe ser igual que la cantidad facturada para esta partida.___';
								END IF;
							END IF;
						END IF;
						
						
						total_filas2:= array_length(arreglo,1);
						cont_fila2:=1;
						FOR cont_fila2 IN 1 .. total_filas2 LOOP
							SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
							
							--str_filas2[1] eliminado
							IF str_filas2[1]::integer <> 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
								IF str_filas2[2]='LOT' THEN
									--Aqui se suman las cantidades de los lotes de la partida actual
									IF str_filas[4]=str_filas2[4] THEN
										IF trim(str_filas2[9])<>'' THEN
											suma_lotes := suma_lotes + str_filas2[9]::double precision;
										END IF;
									END IF;
								END IF;
							END IF;
						END LOOP;
						
						suma_lotes := round(suma_lotes::numeric,4)::double precision;
						
						IF trim(str_filas[9])<>'' THEN
							--str_filas[9]	cantidad_rec[i]
							IF suma_lotes > round(str_filas[9]::numeric,4)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La suma de los Lotes no debe ser Mayor que Cantidad Surtida en la Partida.___';
							END IF;
							
							--str_filas[9]	cantidad_rec[i]
							IF suma_lotes < round(str_filas[9]::numeric,4)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La suma de los Lotes no debe ser Menor que Cantidad Surtida en la Partida.___';
							END IF;
						END IF;
						
					ELSE
						--Aqui entra cuando el registro es un LOTE
						IF trim(str_filas[7])='' THEN
							valor_retorno := ''||valor_retorno||'lote_int'||str_filas[10]||':Es necesario ingresar un n&uacute;mero de Lote.___';
						ELSE
							--Busca el numero de lote.
							--El query retorna 0 si no se encuentra o si tiene existencia 0
							SELECT count(id) FROM (
								SELECT id, (inicial - salidas + entradas) AS existencia FROM inv_lote 
								WHERE lote_int=str_filas[7] AND inv_prod_id=str_filas[6]::integer AND inv_alm_id=str_filas[5]::integer 
							) AS sbt
							WHERE existencia > 0 INTO existe_lote;
							
							--RAISE EXCEPTION '%','lote_int: '||str_filas[7]||'         inv_prod_id: '||str_filas[6]||'           inv_alm_id: '||str_filas[5];
							
							--si exis_lote es mayor que cero quiere decir que el numero de lote si existe y tiene existencia
							IF existe_lote > 0 THEN

								--Obtener el tipo de producto y el numero de Decimales Permitidos
								SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
								FROM inv_prod 
								LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
								WHERE inv_prod.id=str_filas[6]::integer 
								INTO tipo, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;

								--Obtener la unidad de Medida del producto de esta partida(unidad de medida de la venta)
								SELECT inv_prod_unidad_id FROM inv_osal_detalle WHERE id=str_filas[4]::integer INTO idUnidadMedidaVenta;
								
								--Buscar la existencia actual del numero de Lote.
								SELECT id, (inicial - salidas + entradas - reservado) AS existencia 
								FROM inv_lote 
								WHERE lote_int=str_filas[7] AND inv_prod_id=str_filas[6]::integer AND inv_alm_id=str_filas[5]::integer
								INTO id_lote, cant_existencia_lote;
								
								cant_sal_anterior := 0.0;
								--Si el id_detalle del lote es mayor que cero, es editar
								IF str_filas[3]::integer > 0 THEN
									--Busca la cantidad  anterior de salida ingresada anteriormente
									SELECT cantidad_sal FROM inv_lote_detalle WHERE id=str_filas[3]::integer INTO cant_sal_anterior;
									--RAISE EXCEPTION '%','lote_int: '||cant_sal_anterior||'    exis:'||cant_existencia_lote||'     nuevo:'||(cant_existencia_lote + cant_sal_anterior);
								END IF;
								
								
								IF idUnidadMedidaVenta IS NOT NULL AND idUnidadMedidaVenta > 0 THEN
									IF idUnidadMedida<>idUnidadMedidaVenta THEN
										IF densidadProd IS NULL OR densidadProd=0 THEN
											densidadProd:=1;
										END IF;
										
										EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
										IF match_cadena=true THEN
											--Convertir a litros la existencia para mostrar el warning(Convertir a la Unidad de la Venta)
											cant_existencia_lote := cant_existencia_lote::double precision / densidadProd;
										ELSE
											EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
											IF match_cadena=true THEN
												--Convertir a Kilos la existencia para mostrar el warning(Convertir a la Unidad de la Venta)
												cant_existencia_lote := cant_existencia_lote::double precision * densidadProd;
											END IF;
										END IF;
									END IF;
								END IF;
								
								
								cant_existencia_lote := round((cant_existencia_lote + cant_sal_anterior::double precision)::numeric,4)::double precision;
								
								IF trim(str_filas[9])<>'' THEN
									IF round(str_filas[9]::numeric,4)::double precision > cant_existencia_lote THEN
										valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La existecncia del Lote es '||cant_existencia_lote||'. La Cantidad Surtida NO debe ser mayor que la existencia del Lote.___';
									END IF;
								END IF;
							ELSE
								valor_retorno := ''||valor_retorno||'lote_int'||str_filas[10]||':El n&uacute;mero de Lote no existe para este producto o No tiene Existencia.___';
							END IF;
						END IF;
						
						
						IF str_filas[9] = ' ' OR str_filas[9] = '' THEN
							valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':Es necesario ingresar la Cantidad Surtida para &eacute;ste lote.___';
						ELSE
							IF str_filas[9]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La Cantidad Surtida debe ser mayor que cero.___';
							END IF;
						END IF;
						
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Ordenes de Salida
	
	
	
	
	
	
	--validacion de Ajustes de Inventario
	IF id_app=95 THEN
		--str_data[4]	identificador
		--str_data[5]	select_tipo_mov
		--str_data[6]	observaciones

		SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	idproducto[i]
					--str_filas[2]	id_almacen[i]
					--str_filas[3]	cant_ajuste[i]
					--str_filas[4]	costo_ajuste[i]
					--str_filas[5]	no_tr[i]
					--str_filas[6]	select_pres
					
					SELECT tipo_costo, grupo FROM inv_mov_tipos WHERE id=str_data[5]::integer INTO tipo_costo_movimiento, grupo_movimiento;
					
					IF str_filas[3]='' OR str_filas[3]=' ' THEN 
						valor_retorno := ''||valor_retorno||'cant_ajuste'||str_filas[5]||':Es necesario ingresar la CANTIDAD del Ajuste.___';
					ELSE
						IF str_filas[3]::double precision < 0.000001 THEN 
							valor_retorno := ''||valor_retorno||'cant_ajuste'||str_filas[5]||':La CANTIDAD del ajuste debe ser mayor que cero.___';
						END IF;
					END IF;
					
					
					IF str_filas[6]::integer=0 THEN
						valor_retorno := ''||valor_retorno||'select_pres'||str_filas[5]||':Es necesario seleccionar la Presentacion.___';
					ELSE
						IF controlExisPres=true THEN
							--aqui entra si la configuracion indica que se debe controlar existencias por presentaciones
							
							--0=Entradas, 2=Salidas
							IF grupo_movimiento=2 THEN 
								
								IF trim(str_filas[3])!=''THEN 
									IF str_filas[3]::double precision > 0 THEN
										--buscar el numero de decimales de la unidad del producto
										SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
										WHERE inv_prod.id=str_filas[1]::integer 
										INTO noDecUnidad;

										IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
										
										--inicializar valor a cero
										equivalenciaPres:=0;
										
										--buscar la equivalencia de la Presentacion del Producto
										SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_filas[6]::integer 
										INTO equivalenciaPres;
										
										IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
										
										--inicializar valor
										exisActualPres:=0;
										
										--buscar la existencia actual de la presentacion
										SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exis 
										FROM inv_exi_pres  
										WHERE inv_alm_id=str_filas[2]::integer 
										AND inv_prod_id=str_filas[1]::integer 
										AND inv_prod_presentacion_id=str_filas[6]::integer 
										INTO exisActualPres;
										
										IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
										
										--redondear la Existencia Actual de la Presentacion Origen
										exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;

										
										--convertir la Suma de Unidades en su equivalencia a la Presentacion Origen
										cantPresAsignado := str_filas[3]::double precision / equivalenciaPres::double precision;
										
										--redondear la Cantidad de Presentacion Asignado para Re-Envasar
										cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision;
										
										--validar si la Cantidad Asignada para para el ajuste Negativo
										IF cantPresAsignado::double precision > exisActualPres::double precision THEN 
											valor_retorno := ''||valor_retorno||'cantAjustePres'||str_filas[5]||':La CANTIDAD del Ajuste no debe ser mayor que la existencia actual.___';
										END IF;
									END IF;
								END IF;
							END IF;
						END IF;
					END IF;
					
					--0=Alimentado, 1=Promedio
					IF tipo_costo_movimiento=0 THEN 
						IF trim(str_filas[4])='' THEN 
							valor_retorno := ''||valor_retorno||'costo_ajuste'||str_filas[5]||':Es necesario ingresar COSTO del Ajuste.___';
						ELSE
							IF str_filas[4]::double precision < 0.000001 THEN 
								valor_retorno := ''||valor_retorno||'costo_ajuste'||str_filas[5]||':El COSTO del ajuste debe ser mayor que cero.___';
							END IF;
						END IF;
					END IF;
					
					
					--0=Entradas, 2=Salidas
					IF grupo_movimiento=2 THEN 
						SELECT (inv_exi.exi_inicial - inv_exi.transito - inv_exi.reservado + inv_exi.entradas_1 + inv_exi.entradas_2 + inv_exi.entradas_3 + inv_exi.entradas_4 + inv_exi.entradas_5 + inv_exi.entradas_6 + inv_exi.entradas_7 + inv_exi.entradas_8 + inv_exi.entradas_9 + inv_exi.entradas_10 + inv_exi.entradas_11 + inv_exi.entradas_12 - inv_exi.salidas_1 - inv_exi.salidas_2 - inv_exi.salidas_3 - inv_exi.salidas_4 - inv_exi.salidas_5 - inv_exi.salidas_6 - inv_exi.salidas_7 - inv_exi.salidas_8 - inv_exi.salidas_9 - inv_exi.salidas_10 - inv_exi.salidas_11 - inv_exi.salidas_12) AS existencia
						FROM inv_exi WHERE inv_prod_id=str_filas[1]::integer AND inv_alm_id=str_filas[2]::integer AND ano=EXTRACT(YEAR FROM now())
						INTO existencia_producto;
						
						IF trim(str_filas[3])!=''THEN 
							IF str_filas[3]::double precision > 0 THEN
								IF existencia_producto < str_filas[3]::double precision THEN
									valor_retorno := ''||valor_retorno||'cant_ajuste'||str_filas[5]||':La CANTIDAD del ajuste no debe ser mayor que la existencia actual.___';
								END IF;
							END IF;
						END IF;
					END IF;

					
					
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Ajustes de Inventario
	
	
	
	--validacion de proceso de productos equivalentes
	IF id_app=96 THEN 
		--str_data[1]  app_selected es 96
		--str_data[2]  command_selected = new    
		--str_data[3]  id_usuario es = 1
		--str_data[4]  identificador = 0 nuevo
		--str_data[5]  inv_prod_id 1127   select * from inv_prod_equiv
		
		IF str_data[5] = '' or str_data[5] = '0'  THEN
		--RAISE EXCEPTION 'ESTO TRAE EL 7     %   ',': '||str_data[5]; 
			valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto'; 
		END IF; 
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo 
		IF total_filas < 1 THEN 
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto en equivalente___'; 
		END IF; 
		
		IF str_data[4]::integer = 0 THEN  
			EXECUTE 'select count(inv_prod_id) 
			from inv_prod_equiv 
			where inv_prod_id='||str_data[5]::integer||';' 
			INTO valida_integridad; 
				--EXECUTE 'select count(id) from pro_estruc_det where  inv_prod_id_salida='||str_data[6]::integer||'  AND gral_emp_id='||emp_id||';' INTO valida_integridad; 
			IF valida_integridad > 0 THEN 
				valor_retorno := ''||valor_retorno||'codigo:El producto seleccionado, ya tiene sus equivalentes___'; 
			END IF; 
		END IF; 
		
		-- validaciones para el grid -- 
		IF arreglo[1] != 'sin datos' THEN 
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo 
			cont_fila:=1; 
			FOR cont_fila IN 1 .. total_filas LOOP 

			END LOOP; 
		ELSE 
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la configuracion___'; 
		END IF; 
	END IF;--termina validacion de proceso de productos equivalentes
	
	

	--Validacion de Aplicativo Ordenes de Devolucion
	IF id_app=100 THEN
		--str_data[4]	identificador
		--str_data[5]	observaciones
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	eliminado[i]
					--str_filas[2]	tipo_registro[i]
					--str_filas[3]	id_detalle[i]
					--str_filas[4]	id_almacen[i]
					--str_filas[5]	id_prod_grid[i]
					--str_filas[6]	lote_id[i]
					--str_filas[7]	lote_interno[i]
					--str_filas[8]	cant_dev[i]
					--str_filas[9]	no_tr[i]
					--str_filas[10]	id_partida[i]

					
					
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='PAR' THEN
						suma_lotes:=0;
						--RAISE EXCEPTION '%',str_filas[8];
						
						total_filas2:= array_length(arreglo,1);
						cont_fila2:=1;
						FOR cont_fila2 IN 1 .. total_filas2 LOOP
							SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
							
							--str_filas2[1] eliminado
							IF str_filas2[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
								IF str_filas2[2]='LOT' THEN
									--aqui se suman las cantidades de los lotes de la partida actual
									IF trim(str_filas[10])=trim(str_filas2[10]) THEN
										IF trim(str_filas2[8])<>'' THEN
											suma_lotes := suma_lotes + str_filas2[8]::double precision;
										END IF;
									END IF;
								END IF;
							END IF;
						END LOOP;
						
						suma_lotes := round(suma_lotes::numeric,4)::double precision;
						
						IF trim(str_filas[8])!='' THEN
							--str_filas[8]	cantidad_rec[i]
							IF suma_lotes > round(str_filas[8]::numeric,4)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[9]||':La suma de los Lotes no debe ser Mayor que la Cantidad a devolver de la Partida.___';
							END IF;
							
							--str_filas[8]	cantidad_rec[i]
							IF suma_lotes < round(str_filas[8]::numeric,4)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[9]||':La suma de los Lotes no debe ser Menor que la Cantidad a devolver de la Partida.___';
							END IF;
						END IF;
					ELSE
						IF trim(str_filas[8])='' THEN
							valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[9]||':Es necesario ingresar la Cantidad a Devolver para &eacute;ste lote.___';
						ELSE
							IF str_filas[8]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[9]||':La Cantidad a Devolver debe ser mayor que cero.___';
							END IF;
						END IF;
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Ordenes de Devolucion
	

	
	
	
	--validacion de Aplicativo Notas de Credito Proveedores
	IF id_app=101 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id_nota_credito
		--str_data[5]	id_proveedor
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones.toUpperCase()
		--str_data[9]	select_moneda
		--str_data[10]	concepto.toUpperCase()
		--str_data[11]	tipo_cambio
		--str_data[12]	importe
		--str_data[13]	impuesto
		--str_data[14]	total
		--str_data[15]	factura
		--str_data[16]	fac_saldado
		--str_data[17]	folio_nota_credito
		--str_data[18]	fecha_expedicion
		
		IF str_data[5] = '0'  THEN
			valor_retorno := ''||valor_retorno||'noproveedor:Es necesario seleccionar un Proveedor___';
		END IF;
		
		IF str_data[10] = ''  THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario el Concepto para la Nota de Credito___';
		END IF;
		
		IF str_data[11] = ''  THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario el tipo de Cambio___';
		END IF;
		
		IF str_data[12]='' OR str_data[12]='0' OR str_data[12]='0.00' THEN
			valor_retorno := ''||valor_retorno||'importe:Es necesario el Importe para la Nota de Credito___';
		END IF;
		
		IF str_data[14]='' OR str_data[14]='0' OR str_data[14]='0.00' THEN
			valor_retorno := ''||valor_retorno||'total:Total no valido.___';
		END IF;
		
		IF str_data[15] = ''  THEN
			valor_retorno := ''||valor_retorno||'factura:Es necesario seleccionar una Factura___';
		END IF;
		
		IF str_data[17] = ''  THEN
			valor_retorno := ''||valor_retorno||'folionota:Es necesario seleccionar una Factura___';
		END IF;
		
		IF str_data[18] = ''  THEN
			valor_retorno := ''||valor_retorno||'expedicion:Es necesario ingresar la fecha de la Nota de Credito.___';
		END IF;
	END IF;--termina validacion de Aplicativo Notas de Credito Proveedores
	
	
	
	--validacion de Aplicativo Devoluciones de Mercancia a Proveedores
	IF id_app=102 THEN
		--str_data[4]	id_nota_credito
		--str_data[5]	id_proveedor
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones
		--str_data[9]	select_moneda
		--str_data[10]	concepto
		--str_data[11]	tipo_cambio
		--str_data[12]	importe
		--str_data[13]	impuesto
		--str_data[14]	total
		--str_data[15]	factura
		--str_data[16]	fac_saldado
		--str_data[17]	folio_nota_credito
		--str_data[18]	fecha_expedicion
		--str_data[19]	select_tipo_movimiento
		--str_data[20]	select_tipo_nota
		--str_data[21]	select_almacen
		
		IF str_data[10]='' OR str_data[10]=' '  THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario ingresar el Concepto para la Nota de Cr&eacute;dito.___';
		END IF;
		
		IF str_data[11] = ''  THEN
			valor_retorno := ''||valor_retorno||'tcnota:Es necesario ingresar el Tipo de Cambio para la Nota de Cr&eacute;dito.___';
		ELSE
			IF str_data[11]::double precision < 1  THEN
				valor_retorno := ''||valor_retorno||'tcnota:El Tipo de Cambio debe ser mayor o igual a 1.___';
			END IF;
		END IF;
		
		IF str_data[14]::double precision > 0 THEN
			--obtener el saldo de la factura
			SELECT cxp_facturas.saldo_factura FROM cxp_facturas WHERE cxp_facturas.cxc_prov_id=str_data[5]::integer AND cxp_facturas.serie_folio=str_data[15] AND cxp_facturas.tipo_factura_proveedor=1 
			INTO saldo_fac;

			--validar  que el monto de la nota de credito no sea mayor que el saldo de la factura
			IF str_data[14]::double precision > saldo_fac  THEN
				valor_retorno := ''||valor_retorno||'totalnota:El total de la devoluci&oacute;n no debe ser mayor que el Saldo de la Factura.___';
			END IF;
			
		END IF;

		IF str_data[17]='' OR str_data[17]=' '  THEN
			valor_retorno := ''||valor_retorno||'folionota:Es necesario ingresar el N&uacute;mero de la Nota de Cr&eacute;dito.___';
		END IF;

		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	idproducto
				--str_filas[2]	cantidad
				--str_filas[3]	cant_devuelto
				--str_filas[4]	cant_dev
				--str_filas[5]	notr
				--str_filas[6]	iddetalle
				
				--str_filas[4]	cant_dev
				IF str_filas[4] = ' ' OR str_filas[4] = '' THEN
					valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[5]||':Es necesario ingresar la cantidad a devolver.___';
				ELSE
					--RAISE EXCEPTION '%',str_filas[4];
					IF str_filas[4]::double precision < 0.000001 THEN
						valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[5]||':La cantidad a devolver debe ser mayor que cero.___';
					ELSE
						SELECT round((cantidad - cantidad_devolucion)::numeric,2)::double precision FROM com_fac_detalle WHERE id=str_filas[6]::integer INTO cant_disponible;
						
						
						--evaluar  que la cantidad a devolver no sea mayor que la cantidad Disponible
						IF str_filas[4]::double precision > cant_disponible THEN
							valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[5]||':La cantidad a devolver no debe ser mayor que la cantidad de la partida.___';
						END IF;
					END IF;
				END IF;
					
				
			END LOOP;
			
		END IF;
		
	END IF;--Termina validacion de Aplicativo Devoluciones de Mercancia a Proveedores
	
	
	
	
	
	
	--validacion de Aplicativo Ordenes de Traspaso
	IF id_app=105 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	select_alm_origen
		--str_data[6]	select_alm_destino
		--str_data[7]	observaciones
		--str_data[8]	fecha
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	no_tr[i]
				--str_filas[2]	tipotr[i]
				--str_filas[3]	idPartida[i]
				--str_filas[4]	idproducto[i]
				--str_filas[5]	lote_int[i]
				--str_filas[6]	cant_traspaso[i]
				IF str_filas[2]='PARTIDA' THEN
					suma_lotes:=0.0;
					total_filas2:= array_length(arreglo,1);
					cont_fila2:=1;
					FOR cont_fila2 IN 1 .. total_filas2 LOOP
						SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
						IF str_filas2[2]='LOTE' THEN
							--aqui se suman las cantidades de los lotes de la partida actual
							IF str_filas[3]=str_filas2[3] THEN
								IF str_filas2[6]!='' AND  str_filas2[6]!=' ' THEN
									suma_lotes := suma_lotes + str_filas2[6]::double precision;
								END IF;
							END IF;
						END IF;
					END LOOP;
					
					--redondear a 4 digitos la Suma de Lotes
					suma_lotes := round(suma_lotes::numeric,4)::double precision;
					
					--str_filas[9]	cantidad_rec[i]
					IF suma_lotes > round(str_filas[6]::numeric,4)::double precision THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[1]||':La suma de los Lotes no debe ser Mayor que la Cantidad del Traspaso en la Partida.___';
					END IF;
					
					--str_filas[9]	cantidad_rec[i]
					IF suma_lotes < round(str_filas[6]::numeric,4)::double precision THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[1]||':La suma de los Lotes no debe ser Menor que la Cantidad del Traspaso en la Partida.___';
					END IF;
					
				ELSE
					--aqui entra cuando el registro es un LOTE
					IF str_filas[5] = ' ' OR str_filas[5] = '' THEN
						valor_retorno := ''||valor_retorno||'lote_int'||str_filas[1]||':Es necesario ingresar un n&uacute;mero de Lote.___';
					ELSE
						--busca el lote
						--el query retorna 0 si no se encuentra o si tiene existencia 0
						SELECT count(id) FROM ( SELECT id, (inicial - salidas + entradas - reservado) AS existencia FROM inv_lote WHERE lote_int=str_filas[5] AND inv_prod_id=str_filas[4]::integer AND inv_alm_id=str_data[5]::integer ) AS sbt
						WHERE existencia > 0 INTO existe_lote;
						
						--RAISE EXCEPTION '%','lote_int: '||str_filas[7]||'         inv_prod_id: '||str_filas[6]||'           inv_alm_id: '||str_filas[5];
						
						--si exis_lote es mayor que cero quiere decir que el numero de lote si existe y tiene existencia
						IF existe_lote > 0 THEN
							
							SELECT id, (inicial - salidas + entradas - reservado) AS existencia FROM inv_lote WHERE lote_int=str_filas[5] AND inv_prod_id=str_filas[4]::integer AND inv_alm_id=str_data[5]::integer
							INTO id_lote, cant_existencia_lote;
							
							--redondear a 4 digitos la existencia del lote
							cant_existencia_lote := round(cant_existencia_lote::numeric,4)::double precision;
							
							IF str_filas[6] != ' ' AND str_filas[6] != '' THEN
								IF round(str_filas[6]::numeric,4)::double precision > cant_existencia_lote THEN
									valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[1]||':La existecncia del Lote='||cant_existencia_lote||'. La Cantidad del traspaso NO debe ser mayor que la existencia del Lote.___';
								END IF;
							END IF;
						ELSE
							valor_retorno := ''||valor_retorno||'lote_int'||str_filas[1]||':El n&uacute;mero de Lote no existe para este producto en el almacen Origen o No tiene Existencia.___';
						END IF;
					END IF;
					
					
					IF str_filas[6] = ' ' OR str_filas[6] = '' THEN
						valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[1]||':Es necesario ingresar la Cantidad del Traspaso para &eacute;ste lote.___';
					ELSE
						IF str_filas[6]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[1]||':La Cantidad del Traspaso debe ser mayor que cero.___';
						END IF;
					END IF;
					
				END IF;--termina if de tipo tr
				
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Ordenes de Traspaso
	
	
	
	
	--validacion de Aplicativo Catalogo de Cuentas Contables
	IF id_app=106 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id
		--str_data[5]	cuenta
		--str_data[6]	scuenta
		--str_data[7]	sscuenta
		--str_data[8]	ssscuenta
		--str_data[9]	sssscuenta
		--str_data[10]	cuenta_mayor
		--str_data[11]	estatus
		--str_data[12]	cta_detalle
		--str_data[13]	descripcion_es
		--str_data[14]	descripcion_in
		--str_data[15]	descripcion_otro
		--str_data[16]	select_centro_costo
		--str_data[17]	select_sucursal
		--str_data[18]	select_nivel
		--str_data[19]	select_naturaleza
		--str_data[20]	select_tipo_cta
		
		cuenta_mayor := rpad(str_data[5], 4, '0')||lpad(str_data[6], 4, '0')||lpad(str_data[7], 4, '0')||lpad(str_data[8], 4, '0')||lpad(str_data[9], 4, '0');
		
		IF cuenta_mayor='00000000000000000000' THEN 
			valor_retorno := ''||valor_retorno||'cta:Es necesario ingresar la cuenta.___';
		ELSE
			EXECUTE 'select count(id) FROM ctb_cta WHERE cuenta='''||cuenta_mayor||''' AND gral_emp_id='||emp_id||' AND borrado_logico=false;' 
			INTO valida_integridad; 
			
			IF valida_integridad > 0 THEN 
				EXECUTE 'select id FROM ctb_cta WHERE cuenta='''||cuenta_mayor||''' AND gral_emp_id='||emp_id||' AND borrado_logico=false;' INTO id_registro; 
				IF id_registro != str_data[4]::integer THEN
					valor_retorno := ''||valor_retorno||'cta:La cuenta ya se encuentra registrado.___';
				END IF;
			END IF;
		END IF;
		
		IF trim(str_data[13])='' THEN 
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la descripcion.___';
		END IF;

		IF trim(str_data[17])::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'suc:Es necesario seleccionar la Sucursal.___';
		END IF;

		
		IF trim(str_data[18])::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'nivelcta:Seleccionar el Nivel.___';
		END IF;

		IF trim(str_data[19])::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'natcta:Seleccionar la Naturaleza de la cuenta.___';
		END IF;

		IF trim(str_data[20])::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipocta:Seleccionar el Tipo de la cuenta.___';
		END IF;
		
	END IF;--termina validacion de Catalogo de Cuentas Contables
	
	
	
	
	--################### validacion de proceso de formulas en desarrollo ##############
	--validacion de proceso de formulas en desarrollo
	IF id_app=108 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  id_prod_master
		--str_data[6]  inv_prod_id
		--str_data[7]  nivel
		--str_data[8]  producto_elemento_id
		--str_data[9]  cantidad
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		
		
		IF str_data[5] = '' or str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'id_prod_master:Es necesario seleccionar un producto';
		END IF;
		
		IF str_data[6] = '' or str_data[6] = '0'  THEN
			valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto de salida___';
		END IF;
		
		IF str_data[7] = '' or str_data[7] = '0'  THEN
			valor_retorno := ''||valor_retorno||'paso_actual:Es necesario ingresar un numero de paso___';
		END IF;
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		IF total_filas < 1 THEN
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto en la configuracion___';
		END IF;
		
		IF str_data[4] = '0' THEN 
			
			IF str_data[5] = '' or str_data[5] = '0'  THEN
				valor_retorno := ''||valor_retorno||'id_prod_master:Es necesario seleccionar un producto___';
			ELSE
				EXECUTE 'select count(id) from pro_estruc where inv_prod_id='||str_data[5]::integer||' AND version='||str_data[9]::integer||' AND borrado_logico=false and gral_emp_id='||emp_id||';' INTO valida_integridad;
				--EXECUTE 'select count(id) from pro_estruc_det where  inv_prod_id_salida='||str_data[6]::integer||'  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'id_prod_master:El producto de salida seleccionado, ya tiene un proceso con la misma version___';
				END IF;
			END IF;
			
			/*//Comentado por la nueva version
			IF str_data[6] = '' or str_data[6] = '0'  THEN
				valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto___';
			ELSE
				EXECUTE 'select count(id) from pro_estruc where inv_prod_id='||str_data[6]::integer||' and borrado_logico=false and gral_emp_id='||emp_id||';' INTO valida_integridad;
				--EXECUTE 'select count(id) from pro_estruc_det where  inv_prod_id_salida='||str_data[6]::integer||'  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'inv_prod_id:El producto de salida seleccionado, ya tiene un proceso___';
				END IF;
			END IF;
			*/
		END IF;
		
		--esta parte es para validar que ninguna version de la formula, sea de tipo de producto terminado
		--y que no pueda gruardar si es asi
		IF str_data[4] <> '0' THEN 
			
			valida_integridad := 0;
			
			select count(inv_prod.id) from ( 
			select inv_prod_id from pro_estruc where  pro_estruc_id = ( 
			select pro_estruc_id from pro_estruc where id=str_data[4]::integer 
			) AND pro_estruc.borrado_logico=false ) as tmp_estruct join inv_prod ON inv_prod.id=tmp_estruct.inv_prod_id 
			where inv_prod.tipo_de_producto_id <> 8 INTO valida_integridad;
			
			IF valida_integridad > 0  THEN
				valor_retorno := ''||valor_retorno||'id_prod_master:Ya no se pueden hacer cambios, Existe una version terminada___';
			END IF;
			
		END IF;
		
		
		-- validaciones para el grid --
		IF arreglo[1] != 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				----aqui se vuelven a crear los registros
				IF str_filas[4] != '0' THEN
					
					--VALIDACION PARA  EL GRID
					IF str_filas[2] = ' ' OR str_filas[2] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[2]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':La cantidad debe ser mayor a cero___';
						END IF;
					END IF;
					
					--para validar el numero de paso--
					IF str_filas[3] = ' ' OR str_filas[3] = '' THEN
						valor_retorno := ''||valor_retorno||'posicion'||str_filas[5]||':Es necesario ingresar la posicion___';
					ELSE
						IF str_filas[3]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'posicion'||str_filas[5]||':La posicion debe ser mayor a cero___';
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la configuracion___';
		END IF;
		
	END IF;--termina validacion de proceso de formulas en desarrollo
	--termina validacion de proceso de formulas en desarrollo

	
	
	--validacion de Catalogo Motivos de Visita
	IF id_app=109 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar el motivo de visita';
		END IF;
		
		EXECUTE 'select count(descripcion) from crm_motivos_visita 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:El motivo de visita ingresada ya se encuentra registrada';
				END IF;		
	END IF;--termina validacion de Catalogo Motivos de Visita 

	--validacion de Formas Contacto
	IF id_app=110 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la forma de contacto';
		END IF;
		
		EXECUTE 'select count(descripcion) from crm_formas_contacto 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:La forma de contacto ingresada ya se encuentra registrada';
				END IF;		
	END IF;--termina validacion de Catalogo Formas Contacto 
	
	--validacion de Catalogo Motivos de Llamada
	IF id_app=111 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar el motivo de llamada';
		END IF;
		
		EXECUTE 'select count(descripcion) from crm_motivos_llamada 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:El motivo de llamada ingresado ya se encuentra registrada';
				END IF;		
	END IF;--termina validacion de Catalogo Motivos de Llamada

	--validacion de Catalogo Instrumentos Medicion
	IF id_app=112 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la descripcion del instrumento';
		END IF;
		
		EXECUTE 'select count(descripcion) from pro_instrumentos 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:El instrumento ingresada ya se encuentra registrada';
		END IF;		
	END IF;--termina validacion de Catalogo Instrumentos Medicion  
	
	

	--CATALOGO DE PROSPECTOS(CRM)
	IF id_app=113 THEN
	        --RAISE EXCEPTION '%','total  de filas???'||str_data[1]||'___'||str_data[2]||'___'||str_data[3]||'___'||str_data[4]||'___'||str_data[5]||'___'||str_data[6]||'___'||str_data[7]||'___'||str_data[8]||'___'||str_data[9]||'___'||str_data[10];
		--RAISE EXCEPTION '%','total  de filas???'||str_data[11]||'___'||str_data[12]||'___'||str_data[13]||'___'||str_data[14]||'___'||str_data[15]||'___'||str_data[16]||'___'||str_data[17]||'___'||str_data[18]||'___'||str_data[19]||'___'||str_data[20];
		--RAISE EXCEPTION '%','total  de filas???'||str_data[21]||'___'||str_data[22]||'___'||str_data[23]||'___'||str_data[24]||'___'||str_data[25]||'___'||str_data[26]||'___'||str_data[27]||'___'||str_data[28]||'___'||str_data[29];
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;

		/*
		--rfc
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
		END IF;
		*/
		
		IF str_data[6]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'tipoestatus:Es necesario seleccionar una Etapa.___';
		END IF;

		/*
		IF str_data[7]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'tipoprospecto:Es necesario seleccionar el Tipo Prospecto___';
		END IF;
		
		--calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--num calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroint:Numero de Calle No Valida___';
		END IF;
		
		--colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[14]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--codigo postal
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--pais
		IF str_data[16]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Prospecto___';
		END IF;
		
		--estado
		IF str_data[17]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Prospecto___';
		END IF;
		
		--municipio
		IF str_data[18]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Prospecto___';
		END IF;
		
		--telefono 1
		IF str_data[20]='' OR str_data[20]=' ' THEN
			valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el numero de Tel√©fono___';
		ELSE
			--telefono
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[20]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos___';
			END IF;
		END IF;
		--FAX, utiliza la misma mascara que telefono
		IF str_data[22]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[22]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fax:El numero de Fax no es valido. Debe ser 10 digitos___';
			END IF;
		END IF;
	

		--email
		IF str_data[25]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[25]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		*/
		
		 --gral_emp_id
		IF str_data[4] = '0' THEN
			/*
			valida_integridad:=0;
			EXECUTE 'select count(id) from crm_prospectos where rfc ilike '''||str_data[8]||''' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado ya se encuentra en uso___';
			END IF;
			*/
			
			valida_integridad:=0;
			EXECUTE 'select count(id) from crm_prospectos where razon_social ilike '''||str_data[9]||''' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social ingresada ya se encuentra en uso___';
			END IF;

			/*
			valida_integridad:=0;
			EXECUTE 'select count(id) from crm_prospectos where email ilike '''||str_data[25]||''' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'email:El correo ingresado ya se encuentra en uso___';
			END IF;
			*/
		END IF;
	END IF;--termina validacion de prospectos(CRM)

	--catalogo de registro de llamadas
	IF id_app=114 THEN
		
		--str_data[5] id_agente
		IF str_data[5]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'agente:Es necesario seleccionar el un Agente de Ventas___';
		END IF;
		
		--str_data[6] id_contacto
		IF str_data[6] = '0' THEN
			valor_retorno := ''||valor_retorno||'contacto:Es necesario seleccionar un Contacto___';
		END IF;
		
		--str_data[7] fecha
		IF str_data[7]='' THEN
			valor_retorno := ''||valor_retorno||'fechallamada:Es necesario seleccionar la Fecha de la Llamada___';
		END IF;
		
		--str_data[8] hora_llamada
		IF str_data[8]='00:00' THEN
			valor_retorno := ''||valor_retorno||'horallamada:Es necesario Ingresar la Hora de la Llamada___';
		END IF;
		
		--str_data[9] hora_duracion
		IF str_data[9]='00:00' THEN
			valor_retorno := ''||valor_retorno||'duracionllamada:Es necesario Ingresar la Duracion de la Llamada___';
		END IF;

		IF str_data[12]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'seguimiento:Es necesario seleccionar el un Tipo de Seguimiento___';	
		END IF;

		IF str_data[11]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'calificacion:Es necesario seleccionar el una Calificacion___';	
		END IF;

		IF str_data[10]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'motivo:Es necesario seleccionar el un Motivo de Llamada___';	
		END IF;
		
		
		
		--str_data[15] resultado_llamada
		IF str_data[17]='' THEN
			valor_retorno := ''||valor_retorno||'resultadollamada:Es necesario llenar el campo Resultado de la Llamada___';
		END IF;
		
		
	END IF;

	
	
	--Validacion de Registro de Visitas(CRM)
	IF id_app=115 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		
		--str_data[5] id_agente
		IF str_data[5]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'agente:Es necesario seleccionar el un Agente de Ventas___';
		END IF;
		
		--str_data[6] id_contacto
		IF str_data[6] = '0' THEN
			valor_retorno := ''||valor_retorno||'contacto:Es necesario seleccionar un Contacto___';
		END IF;
		
		--str_data[7] fecha
		IF str_data[7]='' THEN
			valor_retorno := ''||valor_retorno||'fechavisita:Es necesario seleccionar la Fecha de la Visita___';
		END IF;
		
		--str_data[8] hora_visita
		IF str_data[8]='00:00' THEN
			valor_retorno := ''||valor_retorno||'horavisita:Es necesario Ingresar la Hora de la Visita___';
		END IF;
		
		--str_data[9] hora_duracion
		IF str_data[9]='00:00' THEN
			valor_retorno := ''||valor_retorno||'duracionvisita:Es necesario Ingresar la Duracion de la Visita___';
		END IF;
		
		--str_data[10] select_motivo_visita
		--str_data[11] select_calif_visita
		--str_data[12] select_tipo_seguimiento
		--str_data[13] select_oportunidad
		--str_data[14] recusrsos_visita
		
		--str_data[15] resultado_visita
		IF str_data[15]='' THEN
			valor_retorno := ''||valor_retorno||'resultadovisita:Es necesario llenar el campo Resultado de la Visita___';
		END IF;
		
		--str_data[16] observaciones_visita
		--str_data[17] fecha_proxima_visita
		--str_data[18] hora_proxima_visita
		--str_data[19] comentarios_proxima_visita
		
		
	END IF;--termina validacion de Registro de Visitas(CRM)
	
	
	
	
	--Catalogo de Direcciones Fiscales de Clientes
	IF id_app=118 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		--str_data[5] id_cliente
		
		--str_data[6] calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;

		--str_data[7] numero_int
		
		--str_data[8] numero_ext
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroext:Numero de Calle No Valida___';
		END IF;
		
		--str_data[9] colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--str_data[10] cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--str_data[11] select_pais
		IF str_data[11]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Cliente___';
		END IF;
		
		--str_data[12] select_estado
		IF str_data[12]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Cliente___';
		END IF;
		
		--str_data[13] select_municipio
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Cliente___';
		END IF;
		
		--str_data[14] entrecalles
		--str_data[21] contacto
		
		--str_data[15] tel1
		IF str_data[15]='' OR str_data[15]=' ' THEN
			valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el numero de Tel√©fono___';
		ELSE
			--telefono
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos___';
			END IF;
		END IF;
		
		--str_data[16] ext1
		
		----str_data[17] fax utiliza la misma mascara que telefono
		IF str_data[17]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[17]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fax:El numero de Fax no es valido. Debe ser 10 digitos___';
			END IF;
		END IF;

		--str_data[18] tel2
		--str_data[19] ext2

		--str_data[20] email
		IF str_data[20]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[20]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		
		
		SELECT count(id) from cxc_clie_df 
		WHERE cxc_clie_id=str_data[5]::integer
		AND gral_pais_id=str_data[11]::integer
		AND gral_edo_id=str_data[12]::integer
		AND gral_mun_id=str_data[13]::integer
		AND replace(colonia,' ' ,'')=replace(str_data[9],' ' ,'')
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id from cxc_clie_df 
			WHERE cxc_clie_id=str_data[5]::integer
			AND gral_pais_id=str_data[11]::integer
			AND gral_edo_id=str_data[12]::integer
			AND gral_mun_id=str_data[13]::integer
			AND replace(colonia,' ' ,'')=replace(str_data[9],' ' ,'')
			INTO id_registro;
			
			--validar integridad
			IF str_data[4]::integer != id_registro THEN
				valor_retorno := ''||valor_retorno||'colonia:La direcci&oacute;n Fiscal con la misma colonia, Pa&iacute;s, Estado y Municipio ya existe para &eacute;ste Cliente.___';
			END IF;
			
		END IF;
		
	END IF;--termina validacion de Catalogo de Direcciones Fiscales de Clientes
	
	

	--validacion de Catalogo oportunidades
	IF id_app=120 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--120
                --str_data[4]        id
			--str_data[5]	contacto_id
			--str_data[6]	fecha_oportunidad
			--str_data[7]	fecha_cotizacion
			--str_data[8]	fecha_cierre
			--str_data[9]	monto
			--str_data[10]	empleado
			--str_data[11]	tipo_oportunidad
			--str_data[12]	etapa_venta
			--str_data[13]	estatus
			--str_data[14]	cierre_oportunidad
			--id+"___"+contacto_id+"___"+fecha_oportunidad+"___"+fecha_cotizacion
			--+"___"+fecha_cierre+"___"+monto+"___"+empleado+"___"+tipo_oportunidad+"___"+etapa_venta+"___"+
			--estatus+"___"+cierre_oportunidad;//6		
		--RAISE EXCEPTION '%',str_data[10];
		IF str_data[10] = '0' OR str_data[10] = ''  THEN
			valor_retorno := ''||valor_retorno||'empleado:Es necesario seleccionar un agente___';
		END IF;
		
		IF str_data[5] = '0' OR str_data[5] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'contacto:Ingrese un contacto___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'fecha_oportunidad:Ingrese una fecha de oportunidad___';
		END IF;
		

		IF str_data[12] = '0'  THEN
			valor_retorno := ''||valor_retorno||'etapa_venta:Seleccione una etapa de venta___';
		END IF;

		IF str_data[11] = '0'  THEN
			valor_retorno := ''||valor_retorno||'tipo_oportunidad:Seleccione un tipo de oportunidad___';
		END IF;
		
			
	END IF;--termina validacion de oportunidades

	--validaciones de Registro de Metas
	IF id_app = 123 THEN
		/*app_selected//1
		+"___"+command_selected//2
		+"___"+id_usuario//3
		+"___"+identificador//4
		+"___"+select_agente//5
		+"___"+opciones//6
		+"___"+cant_llamadas//7
		+"___"+cant_visitas//8
		+"___"+cant_prospectos//9
		+"___"+ano//10
		+"___"+mes//11
		+"___"+cant_cotizaciones	//12
		+"___"+cant_cotizaciones2//13
		+"___"+cant_oportunidades//14
		+"___"+cant_oportunidades2//15
		+"___"+monto_cotizaciones//16
		+"___"+monto_cotizaciones2//17
		+"___"+monto_oportunidades//18
		+"___"+monto_oportunidades2//19
		+"___"+ventas_clientes//20
		+"___"+ventas_opor_clientes//21	
		+"___"+ventas_prospecto;//22	*/
            
		

		
		
		IF str_data[7]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantllamadas:Ingrese una cantidad valida___';
		END IF;

		IF str_data[8]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantvisitas:Ingrese una cantidad valida___';
		END IF;

		IF str_data[9]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantprospectos:Ingrese una cantidad valida___';
		END IF;

		IF str_data[11]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'mes:Seleccione un mes valido___';
		END IF;

		IF str_data[12]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantcotizaciones:Ingrese una cantidad valida___';
		END IF;

		IF str_data[13]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantcotizaciones2:Ingrese una cantidad valida___';
		END IF;

		IF str_data[14]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantoportunidades:Ingrese una cantidad valida___';
		END IF;

		IF str_data[15]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantoportunidades2:Ingrese una cantidad valida___';
		END IF;

		IF str_data[16]::double precision = 0 THEN
			valor_retorno:=''||valor_retorno||'montocotizaciones:Ingrese una cantidad valida___';
		END IF;

		IF str_data[17]::double precision = 0 THEN
			valor_retorno:=''||valor_retorno||'montocotizaciones2:Ingrese una cantidad valida___';
		END IF;

		IF str_data[18]::double precision = 0 THEN
			valor_retorno:=''||valor_retorno||'montooportunidades:Ingrese una cantidad valida___';
		END IF;

		IF str_data[19]::double precision = 0 THEN
			valor_retorno:=''||valor_retorno||'montooportunidades2:Ingrese una cantidad valida___';
		END IF;

		IF str_data[20]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'ventclientesestablecidos:Ingrese una cantidad valida___';
		END IF;

		IF str_data[21]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'ventoporclientes:Ingrese una cantidad valida___';
		END IF;

		IF str_data[22]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'ventprospectos:Ingrese una cantidad valida___';
		END IF;
	END IF;
	

	--VALIDACIONES PARA EL APLICATIVO REGISTRO DE CASOS
	IF id_app=124 THEN
	/*     str_data[1] app_selected
	+"___"+str_data[2]command_selected
	+"___"+str_data[3]id_usuario
	+"___"+str_data[4]identificador
	+"___"+str_data[5]id_cliente_prospecto
	+"___"+str_data[6]select_estatus
	+"___"+str_data[7]select_prioridad
	+"___"+str_data[8]select_tipo_caso
	+"___"+str_data[9]fecha_cierre
	+"___"+str_data[10]descripcion.toUpperCase()
	+"___"+str_data[11]resolucion.toUpperCase()
	+"___"+str_data[13]tipo
	+"___"+str_data[14]gral_empleado_id
	;*/
		IF str_data[13]::integer = 0 THEN
			valor_retorno := 'opcion:Seleccione una opcion___';
		END IF;
		IF str_data[5]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'cliente_prospecto:El cliente ingresado no fue ingresado desde el pluguin____';
		END IF;
		IF str_data[6]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'estatus:Seleccione un Estatus___';
		END IF;
		IF str_data[7]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'prioridad:Seleccione una Prioridad___';
		END IF;
		IF str_data[8]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'tipocaso:Seleccione un tipo de Caso___';
		END IF;
		IF str_data[9] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'fecha_cierre:Es necesario ingresar la fecha___';
		END IF;
		IF str_data[10] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		IF str_data[11] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'resolucion:Es necesario ingresar la Resolucion___';
		END IF;
		IF str_data[12] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'tipo_observaciones_agente:Es necesario ingresar la observacion del Agente___';
		END IF;
	END IF;
	--FIN DE LAS VALIDACIONES PARA EL REGISTRO DE CASOS
	
	
	
	--validacion de Aplicativo Actualizador de Precios a partir de Precio Minimo
	IF id_app=126 THEN
		
		primero:=0;
		
		--str_data[11]	lista1
		IF str_data[11]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[12]	lista2
		IF str_data[12]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[13]	lista3
		IF str_data[13]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[14]	lista4
		IF str_data[14]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[15]	lista5
		IF str_data[15]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[16]	lista6
		IF str_data[16]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[17]	lista7
		IF str_data[17]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[18]	lista8
		IF str_data[18]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[19]	lista9
		IF str_data[19]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[20]	lista10
		IF str_data[20]::double precision > 0 THEN primero:=1; END IF;

		--si primero=0, quiere decir que ninguna lista trae valor mayor que cero, es decir no asignaron precio a ninguna lista
		IF primero=0 THEN
			valor_retorno := 'precio:Es necesario asignar precio a por lo menos a una Lista___';
		END IF;
		
	END IF;
	--Termina validacion de Actualizador de Precios a partir de Precio Minimo
	
	
	
	--validacion de Catalogo Contactos
	IF id_app=127 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]-- id
		--str_data[5]--tipo_contacto
		--str_data[6]--folio
                --str_data[7]--id_cliente
                --str_data[8]--nombre
                --str_data[9]--apellido_paterno
                --str_data[10]--apellido_materno
                --str_data[11]--telefono_1
                --str_data[12]--telefono_2
                --str_data[13]--fax
                --str_data[14--telefono_directo
                --str_data[15]--correo_1
                --str_data[16]--correo_2
                --str_data[18]	agente
		IF str_data[7] = '0'  THEN
			valor_retorno := ''||valor_retorno||'cliente:Es Necesario Seleccionar un cliente o prospecto___';
		END IF;
		
		IF str_data[8] = '' OR str_data[8] = ' '  THEN
			valor_retorno := ''||valor_retorno||'nombre:Es Necesario ingresar un nombre de contacto___';
		END IF;
		
		IF str_data[9] = '' OR str_data[9] = ' '  THEN
			valor_retorno := ''||valor_retorno||'apellido_materno:Es Necesario ingresar un apellido paterno de contacto___';
		END IF;
		
		IF str_data[11] = '' OR str_data[11] = ' '  THEN
			valor_retorno := ''||valor_retorno||'telefono_1:Es Necesario ingresar un telefono de contacto___';
		END IF;
		
		IF str_data[18]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'agente:Es Necesario seleccionar un agente.___';
		END IF;
		/*
		EXECUTE 'select count(descripcion) from pro_instrumentos 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:El instrumento ingresada ya se encuentra registrada';
		END IF;	
		*/	
	END IF;--termina validacion de Catalogo Contactos
	
	
	--validacion de Catalogo de Incoterms
	IF id_app=132 THEN
		--str_data[4] 	identificador
		--str_data[5] 	nombre
		--str_data[6] 	descripcion_es
		--str_data[7] 	descripcion_ing
		
		IF trim(str_data[5])=''  THEN
			valor_retorno := ''||valor_retorno||'nombre:Es Necesario ingresar el Nombre del Incoterm.___';
		END IF;
		
		IF trim(str_data[6])='' THEN
			valor_retorno := ''||valor_retorno||'descripciones:Es Necesario ingresar la Descripci&oacute;n espa&ntilde;ol.___';
		END IF;
		
		--aqui buscamos el nombre
		SELECT count(id) FROM poc_cot_incoterms 
		WHERE nombre=str_data[5] AND gral_emp_id=emp_id AND borrado_logico=false
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM poc_cot_incoterms 
			WHERE nombre=str_data[5] AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--validar integridad
			IF str_data[4]::integer != id_registro THEN
				valor_retorno := ''||valor_retorno||'nombre:El nombre del Incoterm ya se encuentra registrado.___';
			END IF;
		END IF;
		
		--aqui buscamos la descripcion
		SELECT count(id) FROM poc_cot_incoterms 
		WHERE upper(descripcion_esp)=upper(str_data[6]) AND gral_emp_id=emp_id AND borrado_logico=false
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM poc_cot_incoterms 
			WHERE upper(descripcion_esp)=upper(str_data[6]) AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--validar integridad
			IF str_data[4]::integer != id_registro THEN
				valor_retorno := ''||valor_retorno||'descripciones:La Descripci&oacute;n en espa&ntilde;ol ya se encuentra registrado.___';
			END IF;
		END IF;
	END IF;--termina validacion de Catalogo de Incoterms
	
	
	
	--VALIDACIONES PARA EL APLICATIVO CONFIGURACION DE CONSULTAS
        IF id_app=130 THEN
                
        END IF;--termina VALIDACIONES PARA EL APLICATIVO CONFIGURACION DE CONSULTAS
	
	
	--validacion de Catalogo Politicas de Pago.
        IF id_app=134 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Politica de Pago___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from poc_cot_politicas_pago where  descripcion ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Politicas de Pago
	
	
	--validacion de Catalogo de comerciales)
        IF id_app=135 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Condicion de Venta___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from poc_cot_condiciones_com where  descripcion ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo de condiciones comerciales)
	
	

	--validacion de Catalogo de Equipos Adicionales)
        IF id_app=140 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF trim(str_data[5]) = '' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Equipo Adicional___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from pro_equipos_adic where  borrado_logico = false and titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo de Equipos Adicionales)

	

	--validacion de Catalogo de Equipos 
        IF id_app=141 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                --str_data[7]        tipo
                
                IF trim(str_data[5]) = '' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Equipo___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from pro_equipos where  borrado_logico=false and titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
		
		IF char_length(str_data[6])>10 THEN 
			valor_retorno := ''||valor_retorno||'nombrecorto:La longitud del Nombre Corto debe ser de diez caracteres como maximo.___';
		END IF;
		
		IF str_data[7]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipo:Es necesario seleccionar el Tipo de Equipo.___';
		END IF;
        END IF;--termina validacion Catalogo de Equipos 
	
	
	
	
	--aplicativo Consulta de Facturas
	--validacion para datos de Addendas 
        IF id_app=142 THEN
                --str_data[1]	app_selected
                --str_data[2]	command_selected
                --str_data[3]	id_usuario
                --str_data[4]	id_fac_doc
                --str_data[5]	tipo_addenda_id
                --str_data[6]	adenda_campo1
                --str_data[7]	adenda_campo2
                --str_data[8]	adenda_campo3
                --str_data[9]	adenda_campo4
                --str_data[10]	adenda_campo5
                --str_data[11]	adenda_campo6
                --str_data[12]	adenda_campo7
                --str_data[13]	adenda_campo8
                
                IF trim(str_data[5]) = '' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Equipo___';
                ELSE
                        IF str_data[5]::integer > 0 THEN 
				IF str_data[5]::integer = 3 THEN 
					IF trim(str_data[6]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo1:Es necesario el Numero de Orden de Compra.___';
					END IF;

					IF trim(str_data[7]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo2:Es necesario el Correo del Emisor.___';
					END IF;

					IF trim(str_data[8]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo3:Es necesario ingresar la Moneda.___';
					END IF;
					
					IF trim(str_data[9]) = '' THEN 
						valor_retorno := ''||valor_retorno||'campo4:Es necesario ingresar un valor para Tipo de Cambio.___';
					else
						if str_data[9]::double precision <=0 then 
							valor_retorno := ''||valor_retorno||'campo4:El valor para Tipo de Cambio debe ser mayor a cero.___';
						end if;
					END IF;
					
					IF trim(str_data[10]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo5:Es necesario ingresar el Subtotal de la Factura.___';
					else
						if str_data[10]::double precision <=0 then 
							valor_retorno := ''||valor_retorno||'campo5:El valor para Subtotal debe ser mayor a cero.___';
						end if;
					END IF;

					IF trim(str_data[11]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo6:Es necesario ingresar el Total de la Factura.___';
					else
						if str_data[11]::double precision <=0 then 
							valor_retorno := ''||valor_retorno||'campo6:El valor para Total debe ser mayor a cero.___';
						end if;
					END IF;
					
				END IF;
				--Termina validacion addeda=3
                        END IF;
                END IF;
		
                
        END IF;--termina validacion Addendas
	

	--Validacion de Aplicativo Captura de Costos
	IF id_app=145 THEN
		--str_data[4]	identificador
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	idreg[i]
				--str_filas[2]	idprod[i]
				--str_filas[3]	costo_ultimo[i]
				--str_filas[4]	selectMon[i]
				--str_filas[5]	tc[i]
				--str_filas[6]	notr[i]
				
				IF trim(str_filas[3])='' THEN
					valor_retorno := ''||valor_retorno||'costo_ultimo'||str_filas[6]||':El costo no debe quedar vacio.___';
				ELSE
					IF str_filas[3]::double precision<=0 THEN
						valor_retorno := ''||valor_retorno||'costo_ultimo'||str_filas[6]||':El costo debe ser mayor a cero.___';
					END IF;
				END IF;

				IF str_filas[4]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'selectMon'||str_filas[6]||':Debe seleccionar una moneda.___';
				END IF;

				IF trim(str_filas[5])='' THEN
					valor_retorno := ''||valor_retorno||'tc'||str_filas[6]||':El Tipo de Cambio no debe quedar vacio.___';
				ELSE
					IF str_filas[5]::double precision<=0 THEN
						valor_retorno := ''||valor_retorno||'tc'||str_filas[6]||':El Tipo de Cambio debe ser mayor a cero.___';
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Captura de Costos
	

	
	
	--Cancelacion de Anticipos
        IF id_app=146 THEN
		--str_data[4]	identificador
		--str_data[5]	id_cliente
		--str_data[6]	monto
		--str_data[7]	fecha
		--str_data[8]	select_moneda
		--str_data[9]	observaciones
		
		exis:=0;
		IF str_data[4]::integer = 0 THEN 
                
			IF trim(str_data[5]) = '0' OR trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'cliente:Es necesario seleccionar un cliente.___';
			END IF;
			
			IF trim(str_data[6]) = '' THEN
				valor_retorno := ''||valor_retorno||'monto:Es necesario ingresar el monto del Anticipo.___';
			ELSE
				IF trim(str_data[6])::double precision = 0 THEN
					valor_retorno := ''||valor_retorno||'monto:El monto del Anticipo debe ser mayor que cero.___';
				END IF;
			END IF;
			
			IF trim(str_data[9]) = '' THEN
				valor_retorno := ''||valor_retorno||'observaciones:Es necesario ingresar las observaciones.___';
			END IF;
			
		ELSE
			SELECT count(erp_pagos_detalles.id) FROM erp_pagos
			JOIN erp_pagos_detalles ON erp_pagos_detalles.pago_id=erp_pagos.id
			WHERE erp_pagos.anticipo_id=str_data[4]::integer AND erp_pagos_detalles.cancelacion=false
			INTO exis;
			
			IF exis IS NULL THEN exis:=0; END IF;
			
			IF exis > 0 THEN 
				valor_retorno := ''||valor_retorno||'No es posible cancelar en anticipo porque ha sido aplicado a una o mas facturas';
			END IF;
		END IF;
	END IF;
	
	
	

	

	

	--Catalogo de Remitentes
	IF id_app=147 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		--str_data[5] remitente
		--str_data[6] rfc
		--str_data[7] select_tipo
		--str_data[8] calle
		--str_data[9] numero_int
		--str_data[10] numero_ext
		--str_data[11] colonia
		--str_data[12] cp
		--str_data[13] select_pais
		--str_data[14] select_estado
		--str_data[15] select_municipio
		--str_data[16] tel1
		--str_data[17] ext1
		--str_data[18] tel2
		--str_data[19] email
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;
		
		IF str_data[7]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipo:Es necesario seleccionar el tipo de Remitente(Nacional o Extranjero).___';
		ELSE
			IF str_data[7]::integer=1 THEN 
				--Validar Rfc solo cuando el remitente es Nacional
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
				END IF;
			END IF;
		END IF;
		
		
		--str_data[6] calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--str_data[10] numero_ext
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroext:Numero de Calle No Valida___';
		END IF;
		
		--str_data[11] colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--str_data[12] cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[12]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--str_data[13] select_pais
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Remitente.___';
		END IF;
		
		--str_data[14] select_estado
		IF str_data[14]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Remitente.___';
		END IF;
		
		--str_data[15] select_municipio
		IF str_data[15]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Remitente.___';
		END IF;

		--str_data[16] tel1
		IF trim(str_data[16])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[16]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos. Solo se permiten espacios en blanco y -.___';
			END IF;
		END IF;

		--str_data[19] email
		IF trim(str_data[19])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[19]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		
		--str_data[6] rfc
		--Aqui buscamos la Razon Social del Remitente
		SELECT count(id) FROM cxc_remitentes WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') AND gral_emp_id=emp_id AND borrado_logico=false 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM cxc_remitentes WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social del Remitente ya se encuentra registrado.___';
			END IF;
		END IF;

		--Validar integridad del RFC solo cuando el Remitente sea Nacional
		IF str_data[7]::integer=1 THEN 
			--Aqui buscamos el RFC del Remitente
			SELECT count(id) FROM cxc_remitentes WHERE rfc=str_data[6] AND gral_emp_id=emp_id AND borrado_logico=false
			INTO valida_integridad;
			
			IF valida_integridad>0 THEN 
				SELECT id FROM cxc_remitentes WHERE rfc=str_data[6] AND gral_emp_id=emp_id AND borrado_logico=false
				INTO id_registro;
				
				--Validar integridad
				IF str_data[4]::integer <> id_registro THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC del Remitente ya se encuantra registrado.___';
				END IF;
			END IF;
		END IF;
	END IF;--Termina validacion de Catalogo de Remitentes

	
	--Catalogo de Destinatarios
	IF id_app=148 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		--str_data[5] destinatario
		--str_data[6] rfc
		--str_data[7] select_tipo
		--str_data[8] calle
		--str_data[9] numero_int
		--str_data[10] numero_ext
		--str_data[11] colonia
		--str_data[12] cp
		--str_data[13] select_pais
		--str_data[14] select_estado
		--str_data[15] select_municipio
		--str_data[16] tel1
		--str_data[17] ext1
		--str_data[18] tel2
		--str_data[19] email
		--str_data[20] folio_ext
		--str_data[21] check_firma
		--str_data[22] check_sello
		--str_data[23] check_efectivo
		--str_data[24] id_cliente
		--str_data[25] check_cheque
		--str_data[26] select_serv
		--str_data[27] costo_serv
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;
		
		IF str_data[7]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipo:Es necesario seleccionar el tipo de Destinatario(Nacional o Extranjero).___';
		ELSE
			IF str_data[7]::integer=1 THEN 
				--Validar Rfc solo cuando el remitente es Nacional
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
				EXECUTE 'select '''||trim(str_data[6])||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
				END IF;
			END IF;
		END IF;
		
		
		--str_data[6] calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--str_data[10] numero_ext
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroext:Numero de Calle No Valida___';
		END IF;
		
		--str_data[11] colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--str_data[12] cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[12]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--str_data[13] select_pais
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Destinatario.___';
		END IF;
		
		--str_data[14] select_estado
		IF str_data[14]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Destinatario.___';
		END IF;
		
		--str_data[15] select_municipio
		IF str_data[15]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Destinatario.___';
		END IF;

		--str_data[16] tel1
		IF trim(str_data[16])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[16]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos. Solo se permiten espacios en blanco y -.___';
			END IF;
		END IF;

		--str_data[19] email
		IF trim(str_data[19])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[19]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;

		IF str_data[24]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar el Cliente al que pertenece el Destinatario.___';
		END IF;
		
		
		--str_data[6] rfc
		--Aqui buscamos la Razon Social del destinatario
		SELECT count(id) FROM cxc_destinatarios WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') and upper(folio_ext)=upper(str_data[20]) AND gral_emp_id=emp_id AND borrado_logico=false 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM cxc_destinatarios WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') and upper(folio_ext)=upper(str_data[20]) AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social del Destinatario ya se encuentra registrado con el mismo Folio Externo.___';
			END IF;
		END IF;
		
		--Validar integridad del RFC solo cuando el destinatario sea Nacional
		IF str_data[7]::integer=1 THEN 
			--Aqui buscamos el RFC del Remitente
			SELECT count(id) FROM cxc_destinatarios WHERE rfc=str_data[6] and upper(folio_ext)=upper(trim(str_data[20])) AND gral_emp_id=emp_id AND borrado_logico=false
			INTO valida_integridad;
			
			IF valida_integridad>0 THEN 
				SELECT id FROM cxc_destinatarios WHERE rfc=str_data[6] and upper(folio_ext)=upper(trim(str_data[20])) AND gral_emp_id=emp_id AND borrado_logico=false
				INTO id_registro;
				
				--Validar integridad
				IF str_data[4]::integer <> id_registro THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC del Destinatario ya se encuantra registrado con el mismo Folio Externo.___';
				END IF;
			END IF;
		END IF;

		--str_data[20] folio_ext
		--str_data[24] id_cliente
		--Aqui buscamos el folio externo del destinatario si no esta vacia
		if trim(str_data[20])<>'' then 
			if str_data[20]::integer>0 then 
				SELECT count(cxc_destinatarios.id) FROM cxc_destinatarios join cxc_clie_dest on cxc_clie_dest.cxc_destinatario_id=cxc_destinatarios.id WHERE upper(cxc_destinatarios.folio_ext)=upper(str_data[20]) and cxc_clie_dest.cxc_clie_id=str_data[24]::integer AND cxc_destinatarios.gral_emp_id=emp_id AND cxc_destinatarios.borrado_logico=false 
				INTO valida_integridad;
				
				IF valida_integridad>0 THEN 
					--valor_retorno := ''||valor_retorno||'folioext:El Folio Externo Ya se encuentra registrado para el cliente seleccionado.___';
					
					SELECT cxc_destinatarios.id FROM cxc_destinatarios join cxc_clie_dest on cxc_clie_dest.cxc_destinatario_id=cxc_destinatarios.id WHERE upper(cxc_destinatarios.folio_ext)=upper(str_data[20]) and cxc_clie_dest.cxc_clie_id=str_data[24]::integer AND cxc_destinatarios.gral_emp_id=emp_id AND cxc_destinatarios.borrado_logico=false limit 1 
					INTO id_registro;
					
					--Validar integridad
					IF str_data[4]::integer <> id_registro THEN
						valor_retorno := ''||valor_retorno||'folioext:El Folio Externo Ya se encuentra registrado para el cliente seleccionado.___';
					END IF;
					
				END IF;
			end if;
		end if;
		
	END IF;--Termina validacion de Catalogo de Destinatarios
	
	
	
	
	--Catalogo de Agentes Aduanales
	IF id_app=149 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		--str_data[5] Agente Aduanal
		--str_data[6] select_tipo
		--str_data[7] calle
		--str_data[8] numero_int
		--str_data[9] numero_ext
		--str_data[10] colonia
		--str_data[11] cp
		--str_data[12] select_pais
		--str_data[13] select_estado
		--str_data[14] select_municipio
		--str_data[15] tel1
		--str_data[16] ext1
		--str_data[17] tel2
		--str_data[18] email
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;

		
		IF str_data[6]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipo:Es necesario seleccionar el tipo de Agente Aduanal(Nacional o Extranjero).___';
		END IF;
		

		/*
		--str_data[6] calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		*/
		
		/*
		--str_data[9] numero_ext
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroext:Numero de Calle No Valida___';
		END IF;
		*/
		
		/*
		--str_data[10] colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		*/

		/*
		--str_data[11] cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		*/
		
		/*
		--str_data[12] select_pais
		IF str_data[12]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Agente Aduanal.___';
		END IF;
		
		--str_data[13] select_estado
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Agente Aduanal.___';
		END IF;
		
		--str_data[14] select_municipio
		IF str_data[14]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Agente Aduanal.___';
		END IF;
		*/
		
		--str_data[15] tel1
		IF trim(str_data[15])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos. Solo se permiten espacios en blanco y -.___';
			END IF;
		END IF;

		--str_data[18] email
		IF trim(str_data[18])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[18]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		
		--Aqui buscamos la Razon Social del destinatario
		SELECT count(id) FROM cxc_destinatarios WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') AND gral_emp_id=emp_id AND borrado_logico=false 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM cxc_destinatarios WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social del Agente Aduanal ya se encuentra registrado.___';
			END IF;
		END IF;
	END IF;--Termina validacion de Catalogo de Agentes Aduanales
	
	
	
	--Validacion de Asignacion de Remitentes
	IF id_app=150 THEN
		--str_data[4]        identificador
		--str_data[5]        id_cliente		
		IF trim(str_data[5])='0' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un cliente.';
		END IF;
	END IF;--Termina validacion de Asignacion de Remitentes

	--Catalogo de Operadores
	IF id_app=154 THEN
		--nombre operador
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombre:Ingresar Nombre___';
		END IF;

		--apellido paterno operador
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'paterno:Ingresar Apellido Paterno___';
		END IF;
	END IF;--termina validacion de Catalogo de Operadores

	--Validacion para Aplicativo para cambiar contrase√±a de usuario
	IF id_app=155 THEN
		IF trim(str_data[4])='' THEN 
			valor_retorno := ''||valor_retorno||'passant:Es necesario ingresar Contrase&ntilde;a anterior.___';
		ELSE
			--Obtener la contrase√±a actual del usuario
			select "password" from gral_usr where id=str_data[3]::integer into cadena;
			
			IF cadena IS NULL THEN 
				valor_retorno := ''||valor_retorno||'passant:No existe la Contrase&ntilde;a anterior.___';
			ELSE
				IF cadena<>str_data[4] THEN 
					valor_retorno := ''||valor_retorno||'passant:Contrase&ntilde;a anterior ingresada no corresponde.___';
				END IF;
			END IF;
		END IF;
		
		IF trim(str_data[5])='' THEN 
			valor_retorno := ''||valor_retorno||'passnew:Es necesario ingresar Contrase&ntilde;a Nueva.___';
		ELSE
			IF trim(str_data[6])='' THEN 
				valor_retorno := ''||valor_retorno||'passnew2:Es necesario Repetir Contrase&ntilde;a Nueva.___';
			ELSE
				IF str_data[5]<>str_data[6] THEN 
					valor_retorno := ''||valor_retorno||'passnew2:No es igual a la Nueva Contrase&ntilde;a.___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion Aplicativo para cambiar contrase√±a de usuario

	

	--validacion de Catalogo inventario Ieps
        IF id_app=167 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        titulo 
                --str_data[6]        descripcion 
                --str_data[7]        tasa 

                               
                     --titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombreieps:Es necesario ingresar la descripcion del Ieps.___';
		END IF;
		
                  --descripcion
                  /*
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la descripcion del Ieps.___';
		END IF;
		*/
		
                --tasa
		IF trim(str_data[7]) = '' THEN
			valor_retorno := ''||valor_retorno||'tasa:Es necesario ingresar la tasa del Ieps.___';
		END IF;
             

		IF str_data[4] = '0' THEN
			IF str_data[7]!='' AND str_data[7]!=' ' THEN
				EXECUTE 'SELECT count(id) FROM gral_ieps WHERE tasa='''||str_data[7]::double precision||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'tasa:La Tasa ya se encuentra registrada.___'; 
				END IF;
			END IF;
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM gral_ieps WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nombreieps:El Titulo del Ieps ya se encuentra registrada.___';
				END IF;
			END IF;
			--titulo			
		ELSE
			EXECUTE 'SELECT titulo, id FROM gral_ieps WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'nombreieps:El Titulo del Ieps ya se encuentra registrada.___';
			END IF;

			EXECUTE 'SELECT tasa, id FROM gral_ieps WHERE tasa='''||str_data[7]::double precision||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'tasa:La Tasa ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;
        --Termina validacion Catalogo Ieps

	--Validacion de Catalogo Percepciones
        IF id_app=170 THEN
                --str_data[4]   id
		--str_data clave nuevo_folio
		--str_data[5]	titulo
		--str_data[6]	activo
		--str_data[7]	tipopercepciones
                               
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Percepci&oacute;n.___';
		END IF;

           
                --tipopercepciones
		IF str_data[7]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'percepcion:Es necesario seleccionar un tipo de Percepci&oacute;n.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM nom_percep WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Percepci&oacute;n ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM nom_percep WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Percepci&oacute;n ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo Percepciones

        --Validacion de Catalogo Deducciones
        IF id_app=171 THEN
                --str_data[4]   id
		--str_data clave nuevo_folio
		--str_data[5]	titulo
		--str_data[6]	activo
		--str_data[7]	tipodeducciones
		
                --titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Deducci&oacute;n.___';
		END IF;

           
                --tipodeducciones
		IF str_data[7]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'deduccion:Es necesario seleccionar un tipo de Deducci&oacute;n.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM nom_deduc WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Percepci&oacute;n ya se encuentra registrada.___';
				END IF;
			END IF;
			--titulo			
		ELSE
			EXECUTE 'SELECT titulo, id FROM nom_deduc WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Percepci&oacute;n ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;
        --Termina Validacion Catalogo Deducciones

	
	
	--validacion de Catalogo Periodicidad de Pago
        IF id_app=172 THEN
                --str_data[4]  id
                --str_data[5]  titulo 
                --str_data[6]  no_periodos
		--str_data[7]  activo
		
                 --titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Periodicidad de Pago.___';
		END IF;
		
		--no_periodos
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'periodos:Es necesario ingresar el N&uacute;mero del Peridodo.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--no_periodos
			IF str_data[6]!='' AND str_data[6]!=' ' THEN
				
			EXECUTE 'SELECT count(id) FROM nom_periodicidad_pago WHERE no_periodos = '''||str_data[6]::integer||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'periodos:El N&uacute;mero del Periodo ya se encuentra registrada.___'; 
				END IF;
			END IF;
			
			--titulo
			IF str_data[5] != '' THEN

			EXECUTE 'SELECT count(id) FROM nom_periodicidad_pago WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Periodicidad de Pago ya se encuentra registrada.___';
				
				END IF;
			END IF;
			--titulo			
		ELSE
			EXECUTE 'SELECT titulo, id FROM nom_periodicidad_pago WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Periodicidad de Pago ya se encuentra registrada.___';
			END IF;
			--no_periodos
			EXECUTE 'SELECT no_periodos, id FROM nom_periodicidad_pago WHERE no_periodos='''||str_data[6]::integer||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'periodos:El N&uacute;mero del Periodo ya se encuentra registrada.___';
			END IF;
		END IF;
        END IF;
        --Termina validacion Periodicidad de Pago

	
	--Validacion de Facturacion de Nomina
        IF id_app=173 THEN
		IF command_selected='new' OR command_selected='edit' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5]	comp_tipo
			--str_data[6]	comp_forma_pago
			--str_data[7]	comp_tc
			--str_data[8]	comp_no_cuenta
			--str_data[9]	fecha_pago
			--str_data[10]	select_comp_metodo_pago
			--str_data[11]	select_comp_moneda
			--str_data[12]	select_comp_periodicidad
			--str_data[13]	select_no_periodo

			 --str_data[5]	comp_tipo
			IF trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'comptipo: Se requiere el Tipo de Comprobante.___';
			END IF;
			
			--str_data[6]	comp_forma_pago
			IF trim(str_data[6]) = '' THEN
				valor_retorno := ''||valor_retorno||'compformapago:Se requiere la Forma de Pago.___';
			END IF;
			
			--str_data[9]	fecha_pago
			IF trim(str_data[9]) = '' THEN
				valor_retorno := ''||valor_retorno||'compfechapago:Se requiere la Fecha de Pago.___';
			END IF;

			--str_data[10]	select_comp_metodo_pago
			IF trim(str_data[10]) = '' THEN
				valor_retorno := ''||valor_retorno||'compmetodopago:Se requiere el Metodo de Pago.___';
			ELSE
				IF str_data[10]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'compmetodopago:Se requiere el Metodo de Pago.___';
				END IF;
			END IF;

			
			--str_data[11]	select_comp_moneda
			IF trim(str_data[11]) = '' THEN
				valor_retorno := ''||valor_retorno||'compmoneda:Se requiere la Moneda.___';
			ELSE
				IF str_data[11]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'compmoneda:Se requiere la Moneda.___';
				END IF;
			END IF;
			
			--str_data[12]	select_comp_periodicidad 
			IF trim(str_data[12]) <> '' THEN
				IF str_data[12]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'compperiodicidad:Se requiere la Periodicidad de Pago.___';
				END IF;
			ELSE
				valor_retorno := ''||valor_retorno||'compperiodicidad:Se requiere la Periodicidad de Pago.___';
			END IF;
			
			
			
			IF str_data[4]='0' THEN
				--str_data[13]	select_no_periodo
				IF trim(str_data[13])<>'' AND trim(str_data[13])<>'0' THEN
					EXECUTE 'SELECT count(id) FROM fac_nomina WHERE nom_periodos_conf_det_id='||str_data[13]::integer||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'compnoperiodo:Ya existe una N&oacute;mina con el N&uacute;mero del Periodo seleccionado.___'; 
					END IF;
				END IF;
			ELSE
				
			END IF;

			
		END IF;

		
		IF command_selected='new_nomina' OR command_selected='edit_nomina' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5]	id_reg
			--str_data[6]	id_empleado
			IF trim(str_data[6])='' OR trim(str_data[6])='0'THEN
				valor_retorno := ''||valor_retorno||'noempleado:Se requiere seleccionar un empleado valido.___';
			END IF;
			
			--str_data[7]	no_empleado
			IF trim(str_data[7]) = '' THEN
				valor_retorno := ''||valor_retorno||'noempleado:Se requiere la Clave del Empleado.___';
			END IF;
			
			--str_data[8]	rfc_empleado
			IF trim(str_data[8]) = '' THEN
				valor_retorno := ''||valor_retorno||'rfcempleado:Se requiere el RFC del Empleado.___';
			ELSE
				EXECUTE 'select '''||str_data[8]||''' ~ ''^[A-Za-z0-9&]{3,4}[0-9]{6}[A-Za-z0-9]{3}$'';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'rfcempleado:RFC No Valido.___';
				END IF;
			END IF;
			
			--str_data[9]	nombre_empleado
			IF trim(str_data[9]) = '' THEN
				valor_retorno := ''||valor_retorno||'nombreempleado:Se requiere el Nombre completo del Empleado.___';
			END IF;
			
			--str_data[10]	select_departamento
			--str_data[11]	select_puesto
			--str_data[12]	fecha_contrato
			
			--str_data[13]	antiguedad
			IF trim(str_data[13]) = '' THEN
				valor_retorno := ''||valor_retorno||'antiguedad:Se requiere la Antig&uuml;edad en n&uacute;mero de semanas.___';
			ELSE
				IF str_data[13]::double precision<=0 THEN 
					valor_retorno := ''||valor_retorno||'antiguedad:La Antig&uuml;edad en n&uacute;mero de semanas debe ser mayor a cero.___';
				END IF;
			END IF;
			
			--str_data[14]	curp
			IF trim(str_data[14]) = '' THEN
				valor_retorno := ''||valor_retorno||'curp:Se requiere la CURP del Empleado.___';
			ELSE
				EXECUTE 'select '''||str_data[14]||''' ~ ''^[A-Za-z]{4}[0-9]{6}[A-Za-z]{6}[A-Za-z0-9]{1}[0-9]{1}$'';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'curp:Curp No Valido___';
				END IF;
			END IF;
			
			--str_data[15]	select_reg_contratacion
			IF str_data[15]::integer=0 THEN
				valor_retorno := ''||valor_retorno||'regimencontratacio:Se requiere el R&eacute;gimen de Contrataci&oacute;n del Empleado.___';
			END IF;
			
			--str_data[16]	select_tipo_contrato
			--str_data[17]	select_tipo_jornada
			--str_data[18]	select_preriodo_pago
			IF str_data[18]::integer=0 THEN
				valor_retorno := ''||valor_retorno||'periodicidadpago:Se requiere la Periodicidad del Pago.___';
			END IF;
			
			--str_data[19]	clabe
			--str_data[20]	select_banco
			--str_data[21]	select_riesgo_puesto
			--str_data[22]	imss
			--str_data[23]	reg_patronal
			--str_data[24]	salario_base
			--str_data[25]	fecha_ini_pago
			IF trim(str_data[25])='' THEN
				valor_retorno := ''||valor_retorno||'fechainipago:Se requiere Fecha Inicial del Periodo de Pago.___';
			END IF;
			
			--str_data[26]	fecha_fin_pago
			IF trim(str_data[26]) = '' THEN
				valor_retorno := ''||valor_retorno||'fechafinpago:Se requiere Fecha Final del Periodo de Pago.___';
			END IF;
			
			--str_data[27]	salario_integrado
			--str_data[28]	no_dias_pago
			IF trim(str_data[28])='' THEN
				valor_retorno := ''||valor_retorno||'nodiaspago:Se requiere el N&uacute;mero de D&iacute;as Pagados.___';
			ELSE
				IF str_data[28]::integer<=0 THEN
					valor_retorno := ''||valor_retorno||'nodiaspago:Se requiere el N&uacute;mero de D&iacute;as Pagados.___';
				END IF;
			END IF;
			
			--str_data[29]	concepto_descripcion
			IF trim(str_data[29]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_descripcion:Se requiere el Concepto para el Comprobante.___';
			END IF;
			
			--str_data[30]	concepto_unidad
			IF trim(str_data[30]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_unidad:Se requiere la Unidad.___';
			END IF;
			--str_data[31]	concepto_cantidad
			IF trim(str_data[31]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_cantidad:Se requiere la Cantidad.___';
			ELSE 
				IF str_data[31]::double precision <=0 THEN
					valor_retorno := ''||valor_retorno||'grid__concepto_cantidad:La Cantidad debe ser mayor a cero.___';
				END IF;
			END IF;
			--str_data[32]	concepto_valor_unitario
			IF trim(str_data[32]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_valor_unitario:Se requiere el Valor Unitario del Concepto.___';
			ELSE 
				IF str_data[32]::double precision <=0 THEN
					valor_retorno := ''||valor_retorno||'grid__concepto_valor_unitario:El Valor Unitario debe ser mayor a cero.___';
				END IF;
			END IF;
			
			--str_data[33]	concepto_importe
			IF trim(str_data[33]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_importe:Se requiere el Importe del Concepto.___';
			ELSE 
				IF str_data[33]::double precision <=0 THEN
					valor_retorno := ''||valor_retorno||'grid__concepto_importe:El Importe debe ser mayor a cero.___';
				END IF;
			END IF;
			
			--str_data[34]	descuento
			--str_data[35]	motivo_descuento
			--str_data[36]	select_impuesto_retencion
			IF str_data[36]::integer=0 THEN
				valor_retorno := ''||valor_retorno||'selectimpuestoret:Se requiere el impuesto de la retenci&oacute;n.___';
			END IF;
			--str_data[37]	importe_retencion
			IF trim(str_data[37]) = '' THEN
				valor_retorno := ''||valor_retorno||'importeisr:Se requiere el Monto de la Retenci&oacute;n.___';
			ELSE
				IF str_data[37]::double precision<=0 THEN
					valor_retorno := ''||valor_retorno||'importeisr:Se requiere el Monto de la Retenci&oacute;n.___';
				END IF;
			END IF;
			
			--str_data[38]	comp_subtotal
			--str_data[39]	comp_descuento
			--str_data[40]	comp_retencion
			--str_data[41]	comp_total
			--str_data[42]	percep_total_gravado
			--str_data[43]	percep_total_excento
			--str_data[44]	deduc_total_gravado
			--str_data[45]	deduc_total_excento
			--str_data[46]	percepciones
			
			--str_data[46]	percepciones
			IF str_data[46] is not null AND str_data[46]<>'' THEN 
				--Convertir en arreglo la cadena de Percepciones
				SELECT INTO str_percep string_to_array(str_data[46],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_percep,1) .. array_upper(str_percep,1) LOOP
					SELECT INTO str_filas string_to_array(str_percep[cont_fila],'|');
					--str_filas[1]	id_percep
					--str_filas[2]	noTrPercep
					--str_filas[3]	percep_monto_gravado
					--str_filas[4]	percep_monto_excento
					
					--str_data[3]	percep_monto_gravado
					IF trim(str_filas[3]) = '' THEN
						--valor_retorno := ''||valor_retorno||'grid2__percep_monto_gravado'||str_filas[2]||':Se requiere el Importe del Concepto.___';
					ELSE 
						IF str_filas[3]::double precision <=0 THEN
							--valor_retorno := ''||valor_retorno||'grid2__percep_monto_gravado'||str_filas[2]||':El Importe debe ser mayor a cero.___';
						END IF;
					END IF;
					
				END LOOP;
			END IF;
			--str_data[47]	deducciones
			--str_data[48]	hrs_extras
			--str_data[49]	incapacidades
			
		END IF;
        END IF;
        --Termina validacion Periodicidad de Pago

	--validacion de Catalogo de Configuraci√≥n Periodicidad de Pago
        IF id_app=174 THEN
                --str_data[4]  id
                --str_data[5]  a√±o 
                --str_data[6]  periodicidad de pago
		--str_data[7]  titulo

	      --a√±o
		IF str_data[5]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'select_anio:Es necesario seleccionar un A&ntilde;o.___';
		END IF;

		  --periodicidad de Pago
		IF str_data[6]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'periodo:Es necesario seleccionar un tipo de Periodicidad de Pago.___';
		END IF;

		
		IF str_data[4] = '0' THEN
			--anio
			IF str_data[5] != ' ' THEN
				EXECUTE 'SELECT count(id) FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id = '''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'select_anio:El A&ntilde;o ya se encuentra registrado.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT ano, id FROM nom_periodos_conf WHERE ano='''||str_data[5]||''' AND nom_periodicidad_pago_id = '''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'select_anio:El A&ntilde;o ya se encuentra registrado.___';
			END IF;
		END IF;

		IF str_data[4] = '0' THEN
			--periodicidad de pago
			IF str_data[6] != ' ' THEN
				EXECUTE 'SELECT count(id) FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id = '''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'periodo:La Periodicidad de Pago ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT nom_periodicidad_pago_id, id FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id='''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'periodo:La Periodicidad de Pago ya se encuentra registrada.___';
			END IF;
		END IF;

		
		IF str_data[4] = '0' THEN
			--prefijo
			IF str_data[7] != ' ' THEN
				EXECUTE 'SELECT count(id) FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id='''||str_data[6]||''' AND prefijo = '''||str_data[7]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:EL Prefijo ya se encuentra registrado1.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT prefijo, id FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id='''||str_data[6]||''' AND prefijo='''||str_data[7]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:EL Prefijo ya se encuentra registrado2.___';
			END IF;
		END IF;

		-- validaciones para el grid --
		IF arreglo[1] <> 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	id_reg 
				--str_filas[2]	id_periodo 
				--str_filas[3]	folio 
				--str_filas[4]	tituloperiodo
				--str_filas[5]	fecha_inicio 
				--str_filas[6]	fecha_final
				--str_filas[7]	noTr

				---VALIDACION PARA  EL GRID
				IF str_filas[5] = ' ' OR str_filas[5] = '' THEN
					valor_retorno := ''||valor_retorno||'fechainicial'||str_filas[7]||':Es necesario ingresar la fecha inicial.___';
				END IF;

				IF str_filas[6] = ' ' OR str_filas[6] = '' THEN
					valor_retorno := ''||valor_retorno||'fechafinal'||str_filas[7]||':Es necesario ingresar la fecha final.___';
				END IF;
				
				IF trim(str_filas[4])='' THEN 
					valor_retorno := ''||valor_retorno||'tituloperiodo'||str_filas[7]||':Es necesario ingresar un titulo.___';

				END IF;

				--str_filas[4]	tituloperiodo
				--str_filas[7]	noTr
				
				cont_fila2:=1;
				FOR cont_fila2 IN 1 .. array_length(arreglo,1) LOOP
					SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');

					--str_filas2[4]	tituloperiodo
					--str_filas2[7]	noTr
					--Aqui se verifica en el listado si existe un elemento con la misma descripcion
					IF str_filas[4]=str_filas2[4] THEN
						--Si existe entra aqu√≠
						--Hay que verificar que no sea el mismo elemento
						IF str_filas[7]<>str_filas2[7] THEN
							valor_retorno := ''||valor_retorno||'tituloperiodo'||str_filas[7]||':Es necesario ingresar un titulo diferente'||str_filas2[4]||'.___';

						END IF;
					END IF;

				END LOOP;

				IF str_filas[1] = '0' THEN
				--tituloperiodo
					IF str_filas[4] != ' ' THEN
						EXECUTE 'SELECT count(id) FROM nom_periodos_conf_det WHERE titulo = '''||str_filas[4]||''' AND nom_periodos_conf_id = '''||str_filas[2]||''' ;' INTO valida_integridad;
						IF valida_integridad > 0 THEN
							valor_retorno := ''||valor_retorno||'tituloperiodo'||str_filas[7]||':El Titulo ya se encuentra en uso.___';
						END IF;
					END IF;
				ELSE
					EXECUTE 'SELECT titulo, id FROM nom_periodos_conf_det WHERE  titulo='''||str_filas[4]||''' AND nom_periodos_conf_id = '''||str_filas[2]||''' ;' INTO titulo_mask, valida_integridad;
					IF str_filas[1]::integer != valida_integridad THEN
						valor_retorno := ''||valor_retorno||'tituloperiodo'||str_filas[7]||':El Titulo ya se encuentra registrado.___';
					END IF;
				END IF;
				
			END LOOP;
		
		END IF;
		
        END IF;
        --validacion de Catalogo de Configuraci√≥n Periodicidad de Pago

	--validacion de Parametros de Facturacion
        IF id_app=175 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected
		--str_data[3]  id_usuario 
		--str_data[4]  identificador
		--str_data[5]  identificador_suc
		--str_data[6]  correo_envio
		--str_data[7]  passwd_correo_envio
		--str_data[8]  passwd2_correo_envio
		--str_data[9]  servidor_correo_envio
		--str_data[10]  puerto_correo_envio
		--str_data[11]  correo_cco
		--str_data[12]  select_almacen_ventas
		--str_data[13]  select_formato_pedido
		
                 --correo_envio
		IF trim(str_data[6]) <> '' THEN
			EXECUTE 'select '''||str_data[6]||''' ~ ''^[^@ ]+@[^@ ]+.[^@ .]+$'';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'correoenvio:Correo Electr&oacute;nico No Valido.___';
			ELSE
				IF trim(str_data[11]) <> '' THEN
					EXECUTE 'select '''||str_data[11]||''' ~ ''^[^@ ]+@[^@ ]+.[^@ .]+$'';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'correocco:Correo Electr&oacute;nico para env&iacute;o de copia oculta No Valido.___';
					END IF;
				END IF;
			END IF;
			
			IF trim(str_data[7]) = '' THEN
				valor_retorno := ''||valor_retorno||'passwd:Ingresar Contrase&ntilde;a.___';
			ELSE
				IF trim(str_data[8]) = '' THEN
					valor_retorno := ''||valor_retorno||'passwd2:Repetir Contrase&ntilde;a.___';
				ELSE
					IF trim(str_data[7])<>trim(str_data[8]) THEN
						valor_retorno := ''||valor_retorno||'passwd2:La Contrase&ntilde;a no coincide con la primera.___';
					END IF;
				END IF;
			END IF;

			IF trim(str_data[9]) = '' THEN
				valor_retorno := ''||valor_retorno||'servidorenvio:Es necesario el servidor SMTP para el env&iacute;o. Ejemplo: smtp.gmail.com___';
			END IF;

			IF trim(str_data[10]) = '' THEN
				valor_retorno := ''||valor_retorno||'puertoenvio:Es necesario el puerto para el env&iacute;o.___';
			END IF;
		END IF;
		
		IF str_data[12]::integer=0 THEN
			valor_retorno := ''||valor_retorno||'almventas:Es necesario seleccionar el almacen para ventas.___';
		END IF;

		IF str_data[13]::integer=0 THEN
			valor_retorno := ''||valor_retorno||'formatopedido:Es necesario seleccionar el formato para el PDF del pedido.___';
		END IF;
		
        END IF;
        --Termina validacion de Parametros de Facturacion

        --validacion de Catalogo de Descuentos
        IF id_app=176 THEN
                --str_data[4]  id
                --str_data[5]  nocliente 
                --str_data[6]  valor
                
                --cliente
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Ingresar el n&uacute;mero de control del cliente.___';
		
		END IF;
                
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'valor:Se requiere el valor del Descuento.___';
		ELSE 
			IF str_data[6]::double precision <=0 THEN
				valor_retorno := ''||valor_retorno||'valor:El valor del descuento debe ser mayor a cero.___';
			END IF;
		END IF;
		
		
		
		IF str_data[4] = '0' THEN
			--cliente
			IF trim(str_data[5])<>'' THEN
				EXECUTE 'SELECT count(id) FROM cxc_clie_descto WHERE cxc_clie_id = '''||str_data[5]::integer||''' ;' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nocliente:El Cliente ya se encuentra registrado.___'; 
				END IF;
			END IF;			
		ELSE
			--cliente
			EXECUTE 'SELECT cxc_clie_id, id FROM cxc_clie_descto WHERE cxc_clie_id='''||str_data[5]::integer||''' ;' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'nocliente:El Cliente ya se encuentra registrado.___';
			END IF;
		END IF;
        END IF;
        --Termina validacion Catalogo de Descuentos

        --Validacion de Aplicativo de Polizas Contables
        IF id_app=179 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	select_sucursal
		--str_data[6]	select_mes
		--str_data[7]	select_anio
		--str_data[8]	select_tipo
		--str_data[9]	select_moneda
		--str_data[10]	select_concepto
		--str_data[11]	fecha
		--str_data[12]	descripcion
		--str_data[13]	observacion
                
                --select_sucursal
		IF trim(str_data[5])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'sucursal:Seleccione una Sucursal.___';
		END IF;

                --select_mes
		IF trim(str_data[6])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'mes:Seleccione el Mes.___';
		END IF;

                --select_anio
		IF trim(str_data[7])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'anio:Seleccione el A&ntilde;o.___';
		END IF;

                --select_tipo
		IF trim(str_data[8])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'tipo:Seleccione el Tipo de P&oacute;liza.___';
		END IF;

                --select_moneda
		IF trim(str_data[9])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'moneda:Seleccione la Moneda.___';
		END IF;

                --select_concepto
		IF trim(str_data[10])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'concepto:Seleccione el Concepto.___';
		END IF;
		
		--fecha
		IF trim(str_data[11]) = '' THEN
			valor_retorno := ''||valor_retorno||'fecha:Seleccione la Fecha.___';
		END IF;

		/*

		*/
		/*
		--debe
		IF trim(str_data[15]) = '' THEN
			valor_retorno := ''||valor_retorno||'debe:Ingrese una cantidad para Debe.___';
		END IF;

		--haber
		IF trim(str_data[16]) = '' THEN
			valor_retorno := ''||valor_retorno||'haber:Ingrese una cantidad para Haber.___';
		END IF;
		*/
		
		--str_data[17]	id_cta

		/*
		IF trim(str_data[5])::integer<>0 THEN
			IF trim(str_data[6])::integer<>0 THEN
				IF trim(str_data[7])::integer<>0 THEN
					IF trim(str_data[17])::integer<>0 THEN
						EXECUTE 'SELECT count(id) FROM ctb_pol WHERE gral_suc_id='||str_data[5]::integer||' and ano='||str_data[7]::integer||' and mes='||str_data[6]::integer||' and ctb_cta_id='||str_data[17]::integer||' and borrado_logico=false;' INTO valida_integridad;
						IF valida_integridad > 0 THEN
							EXECUTE 'SELECT id FROM ctb_pol WHERE gral_suc_id='||str_data[5]::integer||' and ano='||str_data[7]::integer||' and mes='||str_data[6]::integer||' and ctb_cta_id='||str_data[17]::integer||' and borrado_logico=false;' INTO id_registro;

							--RAISE EXCEPTION '%','id_registro='||id_registro||'    str_data[4]='||str_data[4];
							
							IF id_registro<>str_data[4]::integer THEN
								valor_retorno := ''||valor_retorno||'cta:La poliza para esta cuenta ya se encuentra registrada.___'; 
							END IF;
						END IF;
					END IF;
				END IF;
			END IF;
		END IF;
		*/

		-- validaciones para el grid --
		IF arreglo[1]<>'sin datos' THEN
			
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	eliminado
				--str_filas[2]	id_det
				--str_filas[3]	select_tmov
				--str_filas[4]	id_cta
				--str_filas[5]	select_cc
				--str_filas[6]	debe
				--str_filas[7]	haber
				--str_filas[8]	cta
				--str_filas[9]	no_tr

				--Verificar que el registro no se haya eliminado del grid
				IF str_filas[1]::integer > 0 then
					IF str_filas[3]::integer <= 0 then
						valor_retorno := ''||valor_retorno||'select_tmov'||str_filas[9]||':Es necesario seleccionar e Tipo de Movimiento.___';
					END IF;
					
					IF str_filas[4]::integer <= 0 then
						valor_retorno := ''||valor_retorno||'cta'||str_filas[9]||':Es necesario la cuenta.___';
					END IF;

					
					IF trim(str_filas[6])='' AND trim(str_filas[7])='' THEN
						valor_retorno := ''||valor_retorno||'debe'||str_filas[9]||':Es necesario ingresar una cantidad para alguno de los dos campos: Debe o Haber.___';
						valor_retorno := ''||valor_retorno||'haber'||str_filas[9]||':Es necesario ingresar una cantidad para alguno de los dos campos: Debe o Haber.___';
					ELSE
						IF trim(str_filas[6])::double precision<=0 AND trim(str_filas[7])::double precision<=0 THEN
							valor_retorno := ''||valor_retorno||'debe'||str_filas[9]||':Es necesario ingresar una cantidad para alguno de los dos campos: Debe o Haber.___';
							valor_retorno := ''||valor_retorno||'haber'||str_filas[9]||':Es necesario ingresar una cantidad para alguno de los dos campos: Debe o Haber.___';
						END IF;
					END IF;
				END IF;
			END LOOP;
		END IF;
        END IF;
        --Termina validacion del Aplicativo de Polizas Contables

        
	--Validacion Aplicativo Carga de Documentos(LOG)
	IF id_app=180 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected
		--str_data[3]  id_usuario
		--str_data[4]  id_emp
		--str_data[5]  id_suc
		--str_data[6]  id_cliente

		IF trim(str_filas[6])='' then 
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
		else
			IF str_filas[6]::integer <= 0 then
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			END IF;
		end if;
		
		IF arreglo[1]<>'sin datos' THEN
			cont_fila:=1;
			FOR cont_fila IN 1 .. array_length(arreglo,1) LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	elim
				--str_filas[2]	noTr
				--str_filas[3]	iddet
				--str_filas[4]	iduni
				--str_filas[5]	idruta
				
				IF str_filas[1]::integer=1 THEN 
					IF trim(str_filas[4])='' then 
						valor_retorno := ''||valor_retorno||'.no_uni'||str_filas[2]||':Es necesario seleccionar una Unidad(Vehiculo).___';
					else
						IF str_filas[4]::integer <= 0 then
							valor_retorno := ''||valor_retorno||'.no_uni'||str_filas[2]||':Es necesario seleccionar una Unidad(Vehiculo).___';
						END IF;
					end if;
					
					IF trim(str_filas[4])='' then 
						valor_retorno := ''||valor_retorno||'.no_ruta'||str_filas[2]||':Es necesario seleccionar una Ruta.___';
					else
						IF str_filas[5]::integer <= 0 then
							valor_retorno := ''||valor_retorno||'.no_ruta'||str_filas[2]||':Es necesario seleccionar una Ruta.___';
						END IF;
					end if;
				END IF;
			END LOOP;
		END IF;
		
	end if;
	--Termina validacion de carga de DocumentosLOG()

        
        --Validacion Aplicativo Administrador de Viajes(LOG)
        IF id_app=181 THEN
                --str_data[1]  app_selected
                --str_data[2]  command_selected 
                --str_data[3]  id_usuario
                
		if str_data[2]='new' or str_data[2]='edit' or str_data[2]='confirm' then 
			--str_data[4]  identificador
			--str_data[5]  fecha
			--str_data[6]  hora
			--str_data[7]  sucursal
			--str_data[8]  id_vehiculo
			--str_data[9]  observaciones
			--str_data[10]  adicionales
			--str_data[11]  id_ruta
			--str_data[12]  id_almacen_salida
			--str_data[13]  suma_precio_venta
			--str_data[14]  select_tipo_dist
			
			--fecha
			IF trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'fecha:Ingresar la Fecha del Viaje.___';
			END IF;

			IF trim(str_data[7])::integer<1 THEN
				valor_retorno := ''||valor_retorno||'idsuc:Seleccionar la Sucursal.___';
			END IF;
			
			IF trim(str_data[8]) = '' THEN
				valor_retorno := ''||valor_retorno||'idvehiculo:Seleccionar la Unidad.___';
			END IF;
			
			IF trim(str_data[11]) = '' THEN
				valor_retorno := ''||valor_retorno||'noruta:Es necesario seleccionar una Ruta para el viaje.___';
			else
				IF str_data[11]::integer <= 0 THEN
					valor_retorno := ''||valor_retorno||'noruta:Es necesario seleccionar una Ruta para el viaje.___';
				end if;
			END IF;	
			
			IF str_data[12]::integer <= 0 THEN
				valor_retorno := ''||valor_retorno||'almacen:Seleccionar el Almacen de salida.___';
			end if;
			
			IF trim(str_data[14])::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'tdist:Es neleccionar el Tipo de Distribucion.___';
			END IF;
			
			--Validar que los pedidos no hayan sido confirmados anteriormente en otro viaje
			if trim(str_data[2])='confirm' then 
				IF arreglo[1]<>'sin datos' THEN
					cont_fila:=1;
					FOR cont_fila IN 1 .. array_length(arreglo,1) LOOP
						SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
						--str_filas[1]	elim
						--str_filas[2]	iddet
						--str_filas[3]	idcga
						--str_filas[4]	idped
						--str_filas[5]	iddest
						--str_filas[6]	idmun
						--str_filas[7]	selec
						--str_filas[8]	selec_chk_firma
						--str_filas[9]	selec_chk_sello
						--str_filas[10]	selec_chk_efectivo
						--str_filas[11]	selec_chk_cheque
						IF str_filas[7]::integer=1 THEN 
							if (select count(id) from log_doc_ped where id=str_filas[4]::integer and log_status_id>=1)>0 then 
								--Aqu√≠ entra porque el pedido ya ha sido enviado en un viaje
								valor_retorno := ''||valor_retorno||'PED_REP:'||str_filas[4]||'___';
							end if;
						end if;
					END LOOP;
				END IF;
			end if;
			
			--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
			
			--RAISE EXCEPTION '%','str_data[10]='||str_data[10];
			IF trim(str_data[10])<>'' THEN
				--Validar Servicios Adicionales
				
				--Convertir en arreglo la cadena de Adicionales
				SELECT INTO str_filas string_to_array(str_data[10],'|');
				
				cont_fila=1;
				FOR cont_fila IN array_lower(str_filas,1) .. array_upper(str_filas,1) LOOP
					SELECT INTO str_filas2 string_to_array(str_filas[cont_fila],'&&');
					--str_filas2[1]	idreg
					--str_filas2[2]	del
					--str_filas2[3]	noTr
					--str_filas2[4]	idprod
					--str_filas2[5]	precio

					if str_filas2[2]::integer=1 then
						--str_data[5]	precio
						IF trim(str_filas2[5]) = '' THEN
							valor_retorno := ''||valor_retorno||'precio'||str_filas2[3]||':Se requiere el Precio.___';
						ELSE 
							IF str_filas2[5]::double precision <=0 THEN
								valor_retorno := ''||valor_retorno||'precio'||str_filas2[3]||':El Precio debe ser mayor a cero.___';
							END IF;
						END IF;
					end if;
				END LOOP;
			END IF;
		else
			if trim(str_data[2])='cancel' then 
				--Aqui entra cuando la opcion seleccionda es cancelar
				
			end if;
			
			if trim(str_data[2])='guardar_rechazos' then 
				--Aqui entra para validar los datos de rechazos de productos.
				
				--str_data[4]  id_det_viaje
				--str_data[5]  select_almacen_destino
				--str_data[6]  almacen_origen
				IF trim(str_data[5])::integer<1 THEN
					valor_retorno := ''||valor_retorno||'almacenrechazo:Seleccionar almacen donde se almacenara el rechazo.___';
				END IF;
				
				--Validaciones para el grid de productos--
				IF arreglo[1]<>'sin datos' THEN
					
					total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
					cont_fila:=1;
					
					FOR cont_fila IN 1 .. total_filas LOOP
						SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
						--str_filas[1]	noTr
						--str_filas[2]	id_det_ped
						--str_filas[3]	cant_uni_dev
						--str_filas[4]	select_tr
						--str_filas[5]	precio_unitario_mn
						--str_filas[6]	id_prod
						
						--Validar cantidad de unidades
						if trim(str_filas[3])='' then
							valor_retorno := ''||valor_retorno||'cant_uni_dev'||str_filas[1]||':Es necesario ingresar la Cantidade de Unidades Rechazadas.___';
						else
							if str_filas[3]::double precision<=0 then
								valor_retorno := ''||valor_retorno||'cant_uni_dev'||str_filas[1]||':La Cantidad de Rechazados debe ser mayor a cero.___';
							end if;
						end if;
						
						--Validar tipo de rechazo
						if str_filas[4]::integer<=0 then
							valor_retorno := ''||valor_retorno||'select_tr'||str_filas[1]||':Es necesario seleccionar el Tipo de Rechazo___';
						end if;
						
					END LOOP;
				END IF;
			end if;
		end if;
        END IF;
        --Termina validacion Aplicativo Administrador de Viajes(LOG)

 	--Validacion de Catalogo de Vehiculo Marca
        IF id_app=182 THEN
                --str_data[4]   id
		--str_data[5]	titulo
                               
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Marca.___';
		END IF;

           
                
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM log_vehiculo_marca WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Marca ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_vehiculo_marca WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Marca ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo de Vehiculo Marca

	--Validacion de Catalogo de Vehiculo Tipo Rodada
        IF id_app=183 THEN
                --str_data[4]   id
		--str_data[5]	titulo
                               
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Rodada.___';
		END IF;

           
                
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM log_vehiculo_tipo_rodada WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Rodada ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_vehiculo_tipo_rodada WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Rodada ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo Vehiculo Tipo Rodada

        --Validacion de Catalogo de Vehiculo Tipo Caja
        IF id_app=184 THEN
                --str_data[4]   id
		--str_data[5]	titulo
                               
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Caja.___';
		END IF;

           
                
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM log_vehiculo_tipo_caja WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Caja ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_vehiculo_tipo_caja WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Caja ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo de Vehiculo Tipo Caja

        --Validacion Catalogo de Servicios Adicionales(LOG)
        IF id_app=185 THEN
		
		IF arreglo[1]<>'sin datos' THEN
			cont_fila:=1;
			FOR cont_fila IN 1 .. array_length(arreglo,1) LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	idreg
				--str_filas[2]	idprod
				--str_filas[3]	elim
				--str_filas[4]	noTr
				IF str_filas[3]::integer=1 THEN 
					EXECUTE 'SELECT count(id) FROM log_serv_adic WHERE inv_prod_id='||str_filas[2]||';' INTO valida_integridad;
					IF valida_integridad > 0 THEN 
						valida_integridad:=0;

						--Buscar el id del registro encontrado
						EXECUTE 'SELECT id FROM log_serv_adic WHERE inv_prod_id='||str_filas[2]||' limit 1;' INTO valida_integridad;

						--Si es diferente al registro actual quiere decir que lo estamos queriando repetir por lo tanto no debe pasar
						if valida_integridad<>str_filas[1]::integer then 
							valor_retorno := ''||valor_retorno||'idreg'||str_filas[4]||':El servicio ya fue se encuentra registrado.___'; 
						end if;
					END IF;
				END IF;
			END LOOP;
		END IF;
        END IF;
        --Termina validacion Catalogo de Servicios Adicionales(LOG)

        

	--Validacion de Catalogo de Tipos de Unidades
        IF id_app=187 THEN
                --str_data[4]   id
		--str_data[5]	titulo
		--str_data[6]	volumeninicio
		--str_data[7]	volumenfin
		--str_data[8]	kginicio
		--str_data[9]	kgfin
		                       
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Unidad.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM log_vehiculo_tipo WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Unidad ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_vehiculo_tipo WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Unidad ya se encuentra registrada.___';
			END IF;
		END IF;

		IF trim(str_data[6])=''  THEN
			valor_retorno := ''||valor_retorno||'volumeninicio:Es necesario ingresar una cantidad para la Capacidad en metros cubicos.___';
		ELSE 
			/*
			IF str_data[6]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'volumeninicio:La Capacidad en metros cubicos debe ser mayor a cero.___';
			END IF;
			*/
		END IF;
		
		IF trim(str_data[7])=''  THEN
			valor_retorno := ''||valor_retorno||'volumenfin:Es necesario ingresar una cantidad para la Capacidad en metros cubicos.___';
		ELSE
			/*
			IF str_data[7]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'volumenfin:La Capacidad en metros cubicos debe ser mayor a cero.___';
			END IF;
			*/
		END IF;

		IF trim(str_data[8])=''  THEN
			valor_retorno := ''||valor_retorno||'kginicio:Es necesario ingresar una cantidad para la Capacidad Peso en Kilogramos.___';
		ELSE
			/*
			IF str_data[8]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'kginicio:La Capacidad peso en Kilogramos debe ser mayor a cero.___';
			END IF;
			*/
		END IF;
		
		IF trim(str_data[9])=''  THEN
			valor_retorno := ''||valor_retorno||'kgfin:Es necesario ingresar una cantidad para la Capacidad Peso en Kilogramo.___';
		ELSE
			/*
			IF str_data[9]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'kgfin:La Capacidad peso en Kilogramos debe ser mayor a cero.___';
			END IF;
			*/
		END IF;
        END IF;--Termina Validacion Catalogo de Tipos de Unidades

        --Validacion de Aplicativo de Registro de Cargas(LOG)
        IF id_app=188 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	no_carga
		--str_data[6]	fecha_entrega
		--str_data[7]	select_almacen
		--str_data[8]	id_cliente
		--str_data[9]	observaciones

		if str_data[2]='new' or str_data[2]='edit' or str_data[2]='delete' then 
			--no_carga
			IF trim(str_data[5])='' THEN
				valor_retorno := ''||valor_retorno||'nocarga:Es necesario ingresar el No. de Carga.___';
			END IF;

			--fecha_entrega
			IF trim(str_data[6])='' THEN
				valor_retorno := ''||valor_retorno||'fecha:Es necesario ingresar la Fecha de Entrega.___';
			END IF;

			--select_almacen
			IF trim(str_data[7])::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'almacen:Es necesario seleccionar el Almacen.___';
			END IF;

			--id_cliente
			IF trim(str_data[8])='' THEN
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			END IF;

			
			--Validaciones para el grid de pedidos--
			IF arreglo[1]<>'sin datos' THEN
				
				total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	tipoTr
					--str_filas[3]	noTr
					--str_filas[4]	iddet
					--str_filas[5]	iddest
					--str_filas[6]	no_pedido
					--str_filas[7]	no_fac
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						if trim(str_filas[2])='PAR' then
							--El campo No. de Pedido solo se debe validar cuando la fila es tipo partida
							if trim(str_filas[6])='' then
								valor_retorno := ''||valor_retorno||'no_pedido'||str_filas[3]||':Es necesario ingresar el No. de Pedido.___';
							end if;
						end if;
						
						if trim(str_filas[7])='' then
							valor_retorno := ''||valor_retorno||'no_fac'||str_filas[3]||':Es necesario ingresar el No. de Factura.___';
						end if;
					END IF;
				END LOOP;
			END IF;
		else
			--Aqui entra para validar detalles del pedido

			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5]	almacen_destino
			--str_data[6]	tipo_carga
			
			--Validaciones para el grid de productos--
			IF arreglo[1]<>'sin datos' THEN
				
				total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	noTr
					--str_filas[3]	iddet
					--str_filas[4]	id_prod
					--str_filas[5]	id_uni
					--str_filas[6]	cant
					--str_filas[7]	peso
					--str_filas[8]	volumen
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						--Validar cantidad de unidades
						if trim(str_filas[6])='' then
							valor_retorno := ''||valor_retorno||'cant'||str_filas[2]||':Es necesario ingresar la Cantidad de unidades.___';
						else 
							if str_filas[6]::double precision<=0 then
								valor_retorno := ''||valor_retorno||'cant'||str_filas[2]||':La Cantidad debe ser mayor a cero.___';
							else 
								--Verificar si es necesario revisar existencias en inventario del de producto
								if str_data[6]::boolean=false then 
									exis:=0;
									total_existencia:=0;
									cant_reservada_anterior:=0;
									
									select count(log_entrada_det.cantidad) as exis from log_entrada_det where log_entrada_det.inv_prod_id=str_filas[4]::integer and log_entrada_det.cantidad > log_entrada_det.entregado 
									into exis;
									
									if exis > 0 then 
										select sum(log_entrada_det.cantidad) as existencia  
										from log_entrada_det 
										where log_entrada_det.inv_prod_id=str_filas[4]::integer and log_entrada_det.cantidad > log_entrada_det.entregado 
										into total_existencia;

										if str_filas[3]::integer > 0 then 
											--Buscar la cantidad en el detalle del pedido
											select cantidad from log_doc_ped_det where id=str_filas[3]::integer into cant_reservada_anterior;
										end if;
										
										total_existencia:=total_existencia + cant_reservada_anterior::double precision;

										--Redondeo de existencia
										total_existencia := round((total_existencia)::numeric,4)::double precision;
										
										if total_existencia < round(str_filas[6]::numeric,4)::double precision then 
											valor_retorno := ''||valor_retorno||'cant'||str_filas[2]||':Existencia='||total_existencia||', no se puede incluir una cantidad mayor al pedido.___';
										end if;
									end if;
								end if;
							end if;
						end if;
						
						--Validar peso
						if trim(str_filas[7])='' then
							valor_retorno := ''||valor_retorno||'peso'||str_filas[2]||':Es necesario ingresar el Peso.___';
						else
							if str_filas[7]::double precision<=0 then
								valor_retorno := ''||valor_retorno||'peso'||str_filas[2]||':La Peso debe ser mayor a cero.___';
							end if;
						end if;

						--Validar volumen
						if trim(str_filas[8])='' then
							valor_retorno := ''||valor_retorno||'volumen'||str_filas[2]||':Es necesario ingresar el Volumen.___';
						else
							if str_filas[8]::double precision<=0 then
								valor_retorno := ''||valor_retorno||'volumen'||str_filas[2]||':El Volumen debe ser mayor a cero.___';
							end if;
						end if;
					END IF;
				END LOOP;
			END IF;
			
		end if;
        END IF;
        --Termina validacion del Aplicativo de Registro de Cargas(LOG)

	

	--validacion de Aplicativo Tarifario
        IF id_app=189 THEN
                --str_data[4]  id
                --str_data[5]  nombreruta 
                --str_data[6]  select_tiporuta
		--str_data[7]  kilometros
		
		--nombreruta
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombreruta:Es necesario ingresar un Titulo a la Ruta.___';
		END IF;

		--tiporuta
		IF str_data[6]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'select_tiporuta:Es necesario seleccionar un tipo de Ruta.___';
		END IF;

		--kilometros
		IF trim(str_data[7]) = '' THEN
			valor_retorno := ''||valor_retorno||'kilometros:Es necesario ingresar el N&uacute;mero de Kilometros.___';
		END IF;

		IF str_data[4] = '0' THEN
			--nombreruta
			IF str_data[6] != ' ' THEN
				EXECUTE 'SELECT count(id) FROM log_ruta WHERE titulo = '''||str_data[5]||''' AND log_ruta_tipo_id = '''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nombreruta:El Titulo de la Ruta ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_ruta WHERE titulo = '''||str_data[5]||''' AND log_ruta_tipo_id='''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'nombreruta:El Titulo de la Ruta ya se encuentra registrada.___';
			END IF;
		END IF;

		-- Validaciones para el Grid Tipo de Unidades --
		IF arreglo[1] <> 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	id_reg 
				--str_filas[2]	eliminado 
				--str_filas[3]	id_tipounidad
				--str_filas[4]	costo 
				--str_filas[5]	noTr 
				--str_filas[6]	costo hot shot 
				
				---costo directo
				IF trim(str_filas[4]) = '' THEN
					valor_retorno := ''||valor_retorno||'costo'||str_filas[5]||':Es necesario ingresar un costo.___';
				ELSE 
					/*
					IF str_filas[4]::double precision <=0 THEN
						valor_retorno := ''||valor_retorno||'costo'||str_filas[5]||':El Costo debe ser mayor a cero.___';
					END IF;
					*/
				END IF;
				
				---costo hot shot
				IF trim(str_filas[4]) = '' THEN
					valor_retorno := ''||valor_retorno||'costo_hs'||str_filas[5]||':Es necesario ingresar el Costo Hot Shot.___';
				ELSE 
					/*
					IF str_filas[4]::double precision <=0 THEN
						valor_retorno := ''||valor_retorno||'costo_hs'||str_filas[5]||':El Costo Hot Shot debe ser mayor a cero.___';
					END IF;
					*/
				END IF;
				
			END LOOP;
		END IF;

		IF trim(str_data[9])<>'' THEN
			--Validar Poblaciones
			
			--Convertir en arreglo la cadena de Poblaciones
			SELECT INTO str_filas string_to_array(str_data[9],'|');
			
			cont_fila=1;
			FOR cont_fila IN array_lower(str_filas,1) .. array_upper(str_filas,1) LOOP
				SELECT INTO str_filas2 string_to_array(str_filas[cont_fila],'&&');

				--str_filas2[1]	idreg
				--str_filas2[2]	eliminado
				--str_filas2[3]	notr
				--str_filas2[4]	id_mun
				--str_filas2[5]	select_localidad
				--str_filas2[6]	select_entidad
				--str_filas2[7]	select_pais

				IF str_filas2[2]::integer > 0 then
					--select_localidad
					IF str_filas2[5]::integer <= 0 THEN
						valor_retorno := ''||valor_retorno||'select_municipio'||str_filas2[3]||':Es necesario seleccionar un Municipio.___';
					END IF;
					
					--select_entidad
					IF str_filas2[6]::integer <= 0 THEN
						valor_retorno := ''||valor_retorno||'select_entidad'||str_filas2[3]||':Es necesario seleccionar una Entidad.___';
					END IF;
					
					--select_pais
					IF str_filas2[7]::integer <= 0 THEN
						valor_retorno := ''||valor_retorno||'select_pais'||str_filas2[3]||':Es necesario seleccionar un Pais.___';
					END IF;
				END IF;
			END LOOP;
		END IF;
		
        END IF;
        --validacion de Aplicativo Tarifario

        
	--Validacion de Catalogo de Tipo de Rechazo
        IF id_app=190 THEN
                --str_data[4]   id
		--str_data[5]	titulo
		
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo al Tipo de Rechazo.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5]!='' THEN
				EXECUTE 'SELECT count(id) FROM log_tipo_rechazo WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo del Tipo de Rechazo ya se encuentra registrado.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_tipo_rechazo WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo del Tipo de Rechazo ya se encuentra registrado.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo de Tipo de Rechazo

	
	
	
	--Validacion de Aplicativo de Captura de Evidencias(LOG)
        IF id_app=191 THEN
		--str_data[1]   app_selected
		--str_data[2]   command_selected
		--str_data[3]   id_usuario 
		--str_data[4]   id_factura
		--str_data[5]   id_carga
		--str_data[6]   id_pedido
		--str_data[7]   id_det_viaje
		--str_data[8]   chk_firma
		--str_data[9]   chk_sello
		--str_data[10]   chk_cheque
		--str_data[11]   chk_eftvo
		--str_data[12]   no_che
		--str_data[13]   monto
		--str_data[14]   no_tr
		--str_data[15]   con_evidencia

		/*
		--str_data[4]   id_factura
		IF trim(str_data[4]) = '' THEN
			valor_retorno := ''||valor_retorno||'factura:No existe numero de factura.___';
		END IF;

		--Validar solo cuando hay evidencias
		if str_data[15]::boolean then 
			--str_data[10]   chk_cheque
			if str_data[10]::boolean then
				if trim(str_data[12])='' then 
					valor_retorno := ''||valor_retorno||'evidencia_no_che'||str_data[14]||':Es necesario ingresar el Numero de Cheque.___';
				end if;
				
				if trim(str_data[13])='' then 
					valor_retorno := ''||valor_retorno||'evidencia_monto'||str_data[14]||':Es necesario ingresar el Monto.___';
				else
					if str_data[13]::double precision<=0 then 
						valor_retorno := ''||valor_retorno||'evidencia_monto'||str_data[14]||':El Monto debe ser mayor a cero.___';
					end if;
				end if;
			else
				--Validar si se selecciono el checkbox para efectivo
				if str_data[11]::boolean then
					if trim(str_data[13])='' then 
						valor_retorno := ''||valor_retorno||'evidencia_monto'||str_data[14]||':Es necesario ingresar el Numero de Cheque.___';
					else
						if str_data[13]::double precision<=0 then 
							valor_retorno := ''||valor_retorno||'evidencia_monto'||str_data[14]||':El monto debe ser mayor a cero.___';
						end if;
					end if;
				end if;
			end if;
		end if;
		*/
		
		IF arreglo[1]<>'sin datos' THEN
			
			cont_fila:=1;
			FOR cont_fila IN array_lower(arreglo,1) .. array_upper(arreglo,1) LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	notr
				--str_filas[2]	id_factura
				--str_filas[3]	id_carga
				--str_filas[4]	id_pedido
				--str_filas[5]	id_det_viaje
				--str_filas[6]	chk_firma
				--str_filas[7]	chk_sello
				--str_filas[8]	chk_cheque
				--str_filas[9]	chk_eftvo
				--str_filas[10]	no_che
				--str_filas[11]	monto
				--str_filas[12]	fecha
				--str_filas[13]	con_evidencia

				--str_data[2]   id_factura
				IF trim(str_filas[2]) = '' THEN
					valor_retorno := ''||valor_retorno||'notr'||str_filas[1]||':No existe numero de factura.___';
				END IF;
				
				--Validar solo cuando hay evidencias
				if str_filas[13]::boolean then 
					--str_data[8]   chk_cheque
					if str_filas[8]::boolean then
						if trim(str_filas[10])='' then 
							valor_retorno := ''||valor_retorno||'.evidencia_no_che'||str_filas[1]||':Es necesario ingresar el Numero de Cheque.___';
						end if;
						
						if trim(str_filas[11])='' then 
							valor_retorno := ''||valor_retorno||'.evidencia_monto'||str_filas[1]||':Es necesario ingresar el Monto.___';
						else
							if str_filas[11]::double precision<=0 then 
								valor_retorno := ''||valor_retorno||'.evidencia_monto'||str_filas[1]||':El Monto debe ser mayor a cero.___';
							end if;
						end if;
					else
						--Validar si se selecciono el checkbox para efectivo
						if str_filas[9]::boolean then
							if trim(str_filas[11])='' then 
								valor_retorno := ''||valor_retorno||'.evidencia_monto'||str_filas[1]||':Es necesario ingresar el Numero de Cheque.___';
							else
								if str_filas[11]::double precision<=0 then 
									valor_retorno := ''||valor_retorno||'.evidencia_monto'||str_filas[1]||':El monto debe ser mayor a cero.___';
								end if;
							end if;
						end if;
					end if;
				end if;
				
			END LOOP;
		END IF;
		
        END IF;--Termina Validacion  Captura de Evidencias(LOG)

        
	--Validacion de Tarifario de Venta por POBLACION
        IF id_app=194 THEN
                --str_data[4]   id
		--str_data[5]	id_cliente
		--str_data[6]	select_pais
		--str_data[7]	select_estado
		--str_data[8]	select_municipio

		--id_cliente
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
		else
			IF str_data[5]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			end if;
		END IF;
		
		--select_pais
		IF str_data[6]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais.___';
		END IF;

		--select_estado
		IF str_data[7]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado.___';
		END IF;
		
		--select_municipio
		IF str_data[8]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio o Poblacion.___';
		END IF;

		
		SELECT count(id) from log_tarifario_venta WHERE cxc_clie_id=str_data[5]::integer AND gral_mun_id=str_data[8]::integer 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id from log_tarifario_venta WHERE cxc_clie_id=str_data[5]::integer AND gral_mun_id=str_data[8]::integer 
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				--valor_retorno := ''||valor_retorno||'noruta:Ya esxiste un registro con la misma Ruta.___';
				valor_retorno := ''||valor_retorno||'nocliente:Ya esxiste un registro con el mismo Cliente.___';
			END IF;
		END IF;
        END IF;--Termina Validacion de Tarifario de Venta por POBLACION

	

	--Validacion de Tarifario de Venta por RANGO
        IF id_app=195 THEN
		--str_data[4]   id
		--str_data[5]	id_cliente
		--str_data[6]	vigencia_ini
		--str_data[7]	vigencia_fin
		--str_data[8]	select_tipo_tarifa
		
		--id_cliente
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
		else
			IF str_data[5]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			end if;
		END IF;
		
		SELECT count(log_tarifario_venta.id) from log_tarifario_venta 
		join log_tarifario_venta_det on (log_tarifario_venta_det.log_tarifario_venta_id=log_tarifario_venta.id and log_tarifario_venta_det.log_tarifa_tipo_id=str_data[8]::integer and log_tarifario_venta_det.fecha_inicio=str_data[6]::date and log_tarifario_venta_det.fecha_fin=str_data[7]::date)
		WHERE log_tarifario_venta.cxc_clie_id=str_data[5]::integer 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT log_tarifario_venta.id from log_tarifario_venta join log_tarifario_venta_det on (log_tarifario_venta_det.log_tarifario_venta_id=log_tarifario_venta.id and log_tarifario_venta_det.log_tarifa_tipo_id=str_data[8]::integer and log_tarifario_venta_det.fecha_inicio=str_data[6]::date and log_tarifario_venta_det.fecha_fin=str_data[7]::date)
			WHERE cxc_clie_id=str_data[5]::integer
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				valor_retorno := ''||valor_retorno||'nocliente:Ya esxiste un registro con el mismo Cliente, Tipo de Tarifa y Vigencia.___';
			END IF;
		END IF;
		
		--str_filas[1]	notr 
		--str_filas[2]	iddet 
		--str_filas[3]	elim
		--str_filas[4]	titulo_rango 
		--str_filas[5]	valor1 
		--str_filas[6]	valor2 
		--str_filas[7]	precio 
        END IF;--Termina Validacion de Tarifario de Venta por RANGO

	/*
	str_data[1] 	app_selected
	str_data[2] 	command_selected
	str_data[3] 	id_usuario
	str_data[4]	id_factura+"___"+
	str_data[5]	id_proveedor+"___"+
	str_data[6]	tipo_factura+"___"+
	str_data[7]	observaciones.toUpperCase()+"___"+
	str_data[8]	factura+"___"+
	str_data[9]	expedicion+"___"+
	str_data[10]	tc+"___"+
	str_data[11]	denominacion+"___"+
	str_data[12]	numeroguia+"___"+
	str_data[13]	ordencompra+"___"+
	str_data[14]	fletera_id+"___"+
	str_data[15]	dias_credito_id+"___"+
	str_data[16]	flete;
	*/
	
	--facturas de proveedores version 2 para Logistik
	IF id_app=196 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id_factura
		--str_data[5]	id_proveedor
		--str_data[6]	tipo_factura
		--str_data[7]	observaciones
		--str_data[8]	factura
		--str_data[9]	expedicion
		--str_data[10]	tc
		--str_data[11]	denominacion
		--str_data[12]	numeroguia
		--str_data[13]	ordencompra
		--str_data[14]	fletera_id
		--str_data[15]	dias_credito_id
		--str_data[16]	flete
		
		if trim(str_data[2])<>'cancelar' then 
			--Aqui solo debe entrar cuando es new y edit
			
			--id_proveedor	str_data[5] id_proveedor
			IF trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'noproveedor:Es necesario seleccionar un proveedor___';
			END IF;
			/*
			--factura	str_data[8]
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FacturaCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
			END IF;
			*/
			--factura	str_data[8] expedicion
			IF trim(str_filas[8])='' THEN
				valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
			END IF;
			/*
			--expedicion	str_data[9] expedicion
			IF str_filas[9] = ' ' OR str_data[9] = '' THEN
				valor_retorno := ''||valor_retorno||'expedicion:Es necesario seleccionar una fecha___';
			END IF;
			*/
			
			--denominacion	str_data[11] denominacion
			IF str_data[11]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'denominacion:Es necesario seleccionar una moneda___';
			END IF;
			
			--tipo cambio	str_data[10] tc
			IF trim(str_filas[10])='' THEN
				valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
			END IF;
			
			--observaciones	str_data[12]
			/*
			--str_data[14] fletera
			IF str_data[14] = '' THEN
				valor_retorno := ''||valor_retorno||'fletera:Es necesario seleccionar una compa√±ia___';
			END IF;
			*/
			--str_data[16] flete
			
			
			IF str_data[4] ='0' THEN
				IF trim(str_data[8])<>'' THEN
					IF str_data[5] !='' THEN
						valida_integridad:=0;
						EXECUTE 'SELECT count(id) FROM cxp_facturas WHERE  cxc_prov_id='||str_data[5]||' AND serie_folio ilike '''||str_data[8]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
						IF valida_integridad > 0 THEN
							valor_retorno := ''||valor_retorno||'factura:La Factura ya se encuentra registrada___';
						END IF;
					END IF;
				END IF;
			END IF;
			
			total_filas:= array_length(arreglo,1);
			cont_fila:=1;
			IF trim(arreglo[1])<>'sin datos' THEN
				
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
					--str_filas[1]	eliminado[i]
					--str_filas[2]	det_id[i]
					--str_filas[3]	prod_id[i]
					--str_filas[4]	pres_id[i]
					--str_filas[5]	cantidad[i]
					--str_filas[6]	costo[i]
					--str_filas[7]	select_iva[i]
					--str_filas[8]	iva_tasa[i]
					--str_filas[9]	select_ieps[i]
					--str_filas[10]	ieps_tasa[i]
					--str_filas[11]	ret_id[i]
					--str_filas[12]	ret_tasa[i]
					--str_filas[13]	no_tr
					
					--eliminado	str_filas[1]
					IF str_filas[1]::integer <> 0 THEN--1: no esta eliminado, 0:eliminado
						
						--cantidad 		str_filas[5]
						IF trim(str_filas[5])='' THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[13]||':Es necesario ingresar la cantidad___';
						ELSE
							IF str_filas[5]::double precision < 0.000001  THEN
								valor_retorno := ''||valor_retorno||'cantidad'||str_filas[13]||':La cantidad debe ser mayor que cero___';
							END IF;
						END IF;
						
						--costo		str_filas[6]
						IF trim(str_filas[6])='' THEN
							valor_retorno := ''||valor_retorno||'costo'||str_filas[13]||':Es necesario ingresar el costo___';
						ELSE
							IF str_filas[6]::double precision < 0.000001  THEN
								valor_retorno := ''||valor_retorno||'costo'||str_filas[13]||':El costo debe ser mayor que cero___';
							END IF;
						END IF;
						
						--impuesto_id	str_filas[7]
						--valor_imp	str_filas[8]
						--eliminado	str_filas[9]
						--ieps_id	str_filas[10]
						--tasa_ieps	str_filas[11]
					END IF;
					
				END LOOP;
				
			END IF;
		else
			if trim(str_data[2])='cancelar' then 
				serie_folio_fac:='';
				tiene_pagos:=0;

				select serie_folio from cxp_facturas where id=str_data[4]::integer and cxc_prov_id=str_data[5]::integer into serie_folio_fac;

				if serie_folio_fac is null then serie_folio_fac:=''; end if;

				--Verificar si la factura tiene pagos registrados	
				select count(cxp_pagos.id) as tiene_pagos 
				from cxp_pagos 
				join cxp_pagos_detalles on (cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id and cxp_pagos_detalles.serie_folio=serie_folio_fac and cxp_pagos_detalles.cancelacion=false)
				where cxp_pagos.cxp_prov_id=str_data[5]::integer and cxp_pagos.cancelacion=false 
				into tiene_pagos;
				
				if tiene_pagos>0 then 
					valor_retorno := ''||valor_retorno||'cancelacion:No es posible cancelar la Factura '|| serie_folio_fac ||' porque tiene pagos aplicados.___';
				end if;
				
				--inicializar variable
				tiene_pagos:=0;
				
				--Verificar si no tiene notas de credito aplicadas
				select count(cxp_nota_credito.id) as tiene_nc 
				from cxp_nota_credito 
				where cxp_nota_credito.cxp_prov_id=str_data[5]::integer and cxp_nota_credito.factura=serie_folio_fac and cxp_nota_credito.cancelado=false 
				into tiene_pagos;
				
				if tiene_pagos>0 then 
					valor_retorno := ''||valor_retorno||'cancelacion:No es posible cancelar la Factura '|| serie_folio_fac ||' porque tiene Notas de Credito aplicados.___';
				end if;
				
			end if;
		end if;
	END IF;
	--Termina Validacion para Facturas de Provedores version 2 para Logistik

	--Validacion de Entradas al Almacen(LOG)
        IF id_app=197 THEN
		--str_data[1]   app_selected
		--str_data[2]   command_selected
		--str_data[3]   id_usuario
		--str_data[4]   id_emp
		--str_data[5]   select_sucursal
		--str_data[6]   id_cliente
		--str_data[7]   observaciones
		--str_data[8]   select_almacen
		--str_data[9]   fecha
		--str_data[10]   select_tipo_dist
		--str_data[11]   ident_uni
		--str_data[12]   select_tipo_unidad
		--str_data[13]   id_ruta
		--str_data[14]   costo_ruta
		
		--select_sucursal
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'idsuc:Es necesario la Sucursal.___';
		else
			IF str_data[5]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'idsuc:Seleccionar Sucursal.___';
			end if;
		END IF;
		
		--id_cliente
		IF trim(str_data[6])='' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
		else
			IF str_data[6]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			end if;
		END IF;

		--select_almacen
		IF trim(str_data[8])='' THEN
			valor_retorno := ''||valor_retorno||'almacen:Es necesario el Almacen.___';
		else
			IF str_data[8]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'almacen:Es necesario seleccionar un Almacen.___';
			end if;
		END IF;

		--fecha
		IF trim(str_data[9])='' THEN
			valor_retorno := ''||valor_retorno||'fecha:Es necesario ingresar la Fecha.___';
		END IF;

		--select_tipo_dist
		IF trim(str_data[8])='' THEN
			valor_retorno := ''||valor_retorno||'tdist:Es necesario el Tipo de viaje.___';
		else
			IF str_data[8]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'tdist:Es necesario seleccionar el Tipo de viaje.___';
			end if;
		END IF;

		
		--ident_uni
		IF trim(str_data[11])='' THEN
			valor_retorno := ''||valor_retorno||'idvehiculo:Es necesario seleccionar la Unidad de Transporte.___';
		else
			IF str_data[11]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'idvehiculo:Es necesario seleccionar la Unidad de Transporte.___';
			end if;
		END IF;

		--select_tipo_unidad
		IF trim(str_data[12])='' THEN
			valor_retorno := ''||valor_retorno||'tipounidad:Es necesario el Tipo de Unidad.___';
		else
			IF str_data[12]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'tipounidad:Es necesario seleccionar el Tipo de Unidad.___';
			end if;
		END IF;

		--id_ruta
		IF trim(str_data[13])='' THEN
			valor_retorno := ''||valor_retorno||'noruta:Es necesario seleccionar la Ruta.___';
		else
			IF str_data[13]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'noruta:Es necesario seleccionar la Ruta.___';
			end if;
		END IF;

		--costo_ruta
		IF trim(str_data[14])='' THEN
			valor_retorno := ''||valor_retorno||'costoruta:Es necesario el Costo de la Ruta.___';
		else
			IF str_data[14]::double precision<=0 THEN
				valor_retorno := ''||valor_retorno||'costoruta:El Costo de la Ruta debe ser mayor a cero.___';
			end if;
		END IF;
        END IF;--Termina Validacion de Entradas al Almacen(LOG)

        
        IF id_app=203 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	nombre
		--str_data[6]	select_fecha
		--str_data[7]	select_pol_num
		--str_data[8]	select_tipo

		--Nombre del asiento
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombre:Es necesario ingresar el Nombre del Asiento.___';
		END IF;
        end if;

	--Validacion de Catalogo de IVA Trasladado
        IF id_app=204 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	tasa
		--str_data[7]	cta_id

		--Titulo del Impuesto
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Impuesto.___';
		END IF;

		--Tasa del Impuesto
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'tasa:Es necesario ingresar la Tasa del Impuesto.___';
		END IF;

		if incluye_modulo_contabilidad then 
			--Tasa del Impuesto
			IF trim(str_data[7]) = '' THEN
				valor_retorno := ''||valor_retorno||'cta:Es necesario seleccionar la Cuenta Contable para el Impuesto.___';
			else
				if str_data[7]::integer=0 then 
					valor_retorno := ''||valor_retorno||'cta:Es necesario seleccionar la Cuenta Contable para el Impuesto.___';
				end if;
			END IF;
		end if;
		
        end if;
        --Termina Validacion de Catalogo de IVA Trasladado

	--Validacion de Catalogo de IVA Retenido
        IF id_app=205 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	tasa
		--str_data[7]	cta_id

		--Titulo del Impuesto
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Impuesto.___';
		END IF;

		--Tasa del Impuesto
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'tasa:Es necesario ingresar la Tasa del Impuesto.___';
		END IF;

		if incluye_modulo_contabilidad then 
			--Tasa del Impuesto
			IF trim(str_data[7]) = '' THEN
				valor_retorno := ''||valor_retorno||'cta:Es necesario seleccionar la Cuenta Contable para el Impuesto.___';
			else
				if str_data[7]::integer=0 then 
					valor_retorno := ''||valor_retorno||'cta:Es necesario seleccionar la Cuenta Contable para el Impuesto.___';
				end if;
			END IF;
		end if;
		
        end if;
        --Termina Validacion de Catalogo de IVA Retenido

        
	--Validacion Aplicativo de Registro de Proyectos(CRM)
        IF id_app=207 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	nombre
		--str_data[6]	descripcion
		--str_data[7]	select_agente
		--str_data[8]	id_contacto
		--str_data[9]	id_prov
		--str_data[10]	fecha_inicio
		--str_data[11]	fecha_fin
		--str_data[12]	select_estatus
		--str_data[13]	select_prioridad
		--str_data[14]	select_muestra
		--str_data[15]	observaciones
		
		--Nombre del proyecto
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombre:Ingresar el Nombre &oacute; Titulo del Proyecto.___';
		END IF;

		--descripcion
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Debe ingresar la Descripci&oacute;n del Proyecto.___';
		END IF;

		--select_agente
		if str_data[7]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'agente:Seleccione un Agente de Ventas.___';
		end if;
		
		--id_contacto
		if str_data[8]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'contacto:Seleccione un Contacto.___';
		end if;
		/*
		--id_prov
		if str_data[9]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'proveedor:Seleccione un Proveedor.___';
		end if;
		*/

		--str_data[12]	select_estatus
		if str_data[12]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'estatus:Asigne un Estatus.___';
		end if;
		
		--str_data[13]	select_prioridad
		if str_data[13]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'prioridad:Asigne una Prioridad.___';
		end if;
		
		--str_data[14]	select_muestra
		if str_data[14]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'muestra:Asigne una Muestra.___';
		end if;

		if (select count(id) from crm_registro_proyecto where lower(trim(titulo))=lower(trim(str_data[5])))>0 then 
			if str_data[4]::integer >0 then 
				select id from crm_registro_proyecto where lower(trim(titulo))=lower(trim(str_data[5])) limit 1 into id_registro;
				--Verificar si el registro que se encontr√≥ no es el mismo que se est√° actualizando
				if id_registro<>str_data[4]::integer then 
					valor_retorno := ''||valor_retorno||'nombre:El Nombre o Titulo del Proyecto ya se encuentra registrado.___';
				end if;
			else
				valor_retorno := ''||valor_retorno||'nombre:El Nombre o Titulo del Proyecto ya se encuentra registrado.___';
			end if;
			
		end if;
		
        end if;
        --Termina Validacion de Catalogo de Registro de Proyectos(CRM)
	
	
	--Validacion Aplicativo Tipos de Seguimiento de Visitas
        IF id_app=208 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	titulo
		
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Ingresar Titulo del Tipo de Seguimiento de Visitas.___';
		END IF;
		
		if (select count(id) from crm_tipos_seguimiento_visita where lower(trim(titulo))=lower(trim(str_data[5])))>0 then 
			if str_data[4]::integer >0 then 
				select id from crm_tipos_seguimiento_visita where lower(trim(titulo))=lower(trim(str_data[5])) limit 1 into id_registro;
				--Verificar si el registro que se encontr√≥ no es el mismo que se est√° actualizando
				if id_registro<>str_data[4]::integer then 
					valor_retorno := ''||valor_retorno||'titulo:El Titulo del Tipo de Seguimiento de Visita ya se encuentra registrado.___';
				end if;
			else
				valor_retorno := ''||valor_retorno||'titulo:El Titulo del Tipo de Seguimiento de Visita ya se encuentra registrado.___';
			end if;
			
		end if;
		
        end if;
        --Termina Validacion de Catalogo Tipos de Seguimiento de Visitas

	--Validacion Aplicativo Tipos de Seguimiento de Visitas
        IF id_app=209 THEN
		--str_data[4]	id
		--str_data[5]	clave
		--str_data[6]	titulo
		
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'clave:Ingresar Clave.___';
		END IF;

		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Ingresar Titulo.___';
		END IF;

		if (select count(id) from fac_metodos_pago where lower(trim(clave_sat))=lower(trim(str_data[5])) and borrado_logico=false and gral_emp_id=emp_id)>0 then 
			if str_data[4]::integer >0 then 
				select id from fac_metodos_pago where lower(trim(clave_sat))=lower(trim(str_data[5])) and borrado_logico=false and gral_emp_id=emp_id limit 1 into id_registro;
				
				--Verificar si el registro que se encontr√≥ no es el mismo que se est√° actualizando
				if id_registro<>str_data[4]::integer then 
					valor_retorno := ''||valor_retorno||'clave:La Clave del SAT ya se encuentra registrado.___';
				end if;
			else
				valor_retorno := ''||valor_retorno||'clave:La Clave del SAT ya se encuentra registrado.___';
			end if;
		end if;
		
		if (select count(id) from fac_metodos_pago where lower(trim(titulo))=lower(trim(str_data[6])) and borrado_logico=false and gral_emp_id=emp_id)>0 then 
			if str_data[4]::integer >0 then 
				select id from fac_metodos_pago where lower(trim(titulo))=lower(trim(str_data[6])) and borrado_logico=false and gral_emp_id=emp_id limit 1 into id_registro;
				
				--Verificar si el registro que se encontr√≥ no es el mismo que se est√° actualizando
				if id_registro<>str_data[4]::integer then 
					valor_retorno := ''||valor_retorno||'titulo:El Titulo del Metodo de Pago ya se encuentra registrado.___';
				end if;
			else
				valor_retorno := ''||valor_retorno||'titulo:El Titulo del Metodo de Pago ya se encuentra registrado.___';
			end if;
		end if;
		
        end if;
        --Termina Validacion de Catalogo Tipos de Seguimiento de Visitas

	
	
	IF valor_retorno = '' THEN
		valor_retorno := 'true';
		RETURN valor_retorno;
	ELSE
		RETURN valor_retorno;
	END IF;
	
END;

$_$;


--
-- Name: erp_fn_validaciones_por_aplicativo_BK(text, integer, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public."erp_fn_validaciones_por_aplicativo_BK"(campos_data text, id_app integer, arreglo text[]) RETURNS text
    LANGUAGE plpgsql
    AS $_$

DECLARE

	espacio_tiempo_ejecucion timestamp with time zone := now();
	ano_actual integer:=0;
	mes_actual integer:=0;
	str_data text[];
	valor_retorno text := '';
	valor_retorno2 text := '';
	valor_retorno3 text := '';
	usuario_id integer;
	command_selected character varying:='';
	emp_id integer;
	suc_id integer;
	facpar record;--parametros de Facturacion
	
	valida_integridad integer;
	match_cadena boolean=false;
	
	titulo_mask character varying;
	adrdress_num_mask character varying;
	cp_mask character varying;
	colonia_mask character varying;
	calle_mask character varying;
	mask_general character varying;
	
	--nuevas variables
	str_filas text[];
	total_filas integer;--total de elementos de arreglo
	cont_fila integer;--contador de filas o posiciones del arreglo
	--Estas  se utilizan para la nomina
	str_percep text[];
	str_deduc text[];
	str_hrs_extras text[];
	str_incapa text[];
	
	str_filas2 text[];
	total_filas2 integer;--total de elementos de arreglo
	cont_fila2 integer;--contador de filas o posiciones del arreglo

	id_banco integer;
	
	--variable de entradas de mercancia
	numero_entrada character varying;
	fecha_caducidad character varying;
	
	--variable para prefactura
	total_existencia double precision;
	sql_formula text;
	tipo integer;
	formulacion record;
	cantidad_porcentaje double precision;
	cant_reservada_anterior double precision:=0;
	incluye_modulo_produccion boolean;
	incluye_modulo_contabilidad boolean;
	empresa_transportista boolean;
	--Indica si incluye nomina
	incluye_nomina  boolean:=false;
	--Variable que indica si se debe controlar las existencias por presentaciones
	controlExisPres boolean := false;
	--Veriable para indicar si debe validar la asignacion de lista de precio a los clientes
	validaListaPrecioCliente boolean:=false;
	cambiaUnidadMedida boolean:=false;
	
	
	tiene_pagos integer:=0;
	
	--Orden produccion subensamble
	ids_subensamble character varying :='';
	sql_select text;
	primero integer :=0;
	componente_id integer :=0;
	suma_componente double precision :=0;
	sku_componente character varying;
	id_almacen integer := 0;
	id_presentacion integer := 0;
	
	--variable para devolucion de mercancias
	saldo_fac double precision := 0;
	serie_folio_fac character varying:='';
	cant_disponible double precision := 0;
	
	--ordenes de entrada
	req_lote boolean := false;
	req_pedimento boolean := false;
	suma_lotes double precision:=0;
	
	--variable para devolucion de orden de produccion
	id_orden_produccion integer:=0;
	operador_id integer:=0;
	equipo_id integer:=0;
	equipo_adicional_id integer:=0;
	estado_calidad integer:=0;
	
	--variables para ordenes de Salida
	existe_lote integer:=0;--variable para verificar la existecia de un lote
	id_lote integer:=0;--almacena el id del lote
	cant_existencia_lote double precision:=0;--almacena la existencia que tiene el lote
	cant_sal_anterior double precision:=0;
	estatus_osal smallint:=0;
	
	--ajustes de inventario
	tipo_costo_movimiento integer := 0;
	grupo_movimiento integer := 0;
	existencia_producto double precision:=0;
	
	--orden de produccion y Cotizaciones
	record1 record;
	
	cuenta_mayor character varying:='';
	id_registro integer:=0;
	
	num_lista_precio integer:=0;
	descuento_producto double precision:=0;
	precio_producto double precision:=0;
	--Moneda del precio del producto
	mon_prec_prod integer:=0;
	--Tipo de cambio de la moneda del producto
	tc_mon_prod double precision:=0;
	descuento double precision:=0;
	precio_minimo double precision:=0;
	operacion_descuento double precision:=0;
	
	--dir_fiscal
	dir_fiscal character varying:='';
	
	--Id de la unidad de medida del producto
	idUnidadMedida integer:=0;
	--Nombre de la unidad de medida del producto
	nombreUnidadMedida character varying:='';
	--Id de la unidad de Medida de la Venta
	idUnidadMedidaVenta integer:=0;
	--Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantUnidadVenta double precision:=0;
	--Cantidad de la existencia convertida a la unidad de venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantExisUnidadVenta double precision:=0;
	
	--Numero de decimales permitidos para la unidad
	noDecUnidad integer:=0;
	--Densidad del producto
	densidadProd double precision:=0;
	--Existencia actual de la presentacion
	exisActualPres double precision:=0;
	--Equivalencia de la presentacion en la unidad del producto
	equivalenciaPres double precision:=0;
	--Cantidad que se esta Intentando traspasar
	cantPres double precision:=0;
	cantPresAsignado double precision:=0;
	cantPresReservAnterior double precision:=0;
	
	cadena character varying:='';
	exis integer:=0;
	registro_cancelado boolean:=false;
	
	idAdenda integer:=0;
BEGIN 
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;

	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- Comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	-- usuario que utiliza el aplicativo
	usuario_id := str_data[3]::integer;
	
	--RAISE EXCEPTION '%','usuario_id: '||usuario_id;
	/*
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id;
	*/
	
	--obtiene empresa_id, sucursal_id y sucursal_id
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id,inv_suc_alm.almacen_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id=usuario_id
	INTO emp_id, suc_id, id_almacen;
	--RAISE EXCEPTION '%','emp_id: '||emp_id;
	
	--Query para verificar si la empresa actual incluye Modulo de Contabilidad, Control de Existencias por Presentacion
	SELECT incluye_produccion, incluye_contabilidad, control_exis_pres, lista_precio_clientes, transportista, nomina FROM gral_emp WHERE id=emp_id 
	INTO incluye_modulo_produccion, incluye_modulo_contabilidad, controlExisPres, validaListaPrecioCliente, empresa_transportista, incluye_nomina;
	
	--Obtener parametros para la facturacion
	SELECT * FROM fac_par WHERE gral_suc_id=suc_id INTO facpar;
	
	--Asignar valor a variable que indica si el usuario puede cambiar la unidad de medida de venta
	cambiaUnidadMedida:=facpar.cambiar_unidad_medida;
	
	--catalogo de almacenes
	IF id_app=1 THEN
		
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloCorrerct'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'nombre:Nombre del Almacen No Valido___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numero:Numero No Valido___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;	
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valida___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CodigoPostalCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo Postal No Valido___';
		END IF;
		
		
		--pais
		IF str_data[10]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais___';
		END IF;
		
		--estado
		IF str_data[11]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado___';
		END IF;
		
		--municipio
		IF str_data[12]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio___';
		END IF;
		
		IF str_data[13]='' THEN
			valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el Numero Telefonico___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[13]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:Numero Telefonico no valido___';
			END IF;
		END IF;
		
		
		IF str_data[15]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'ext1:Numero de Extension No Valido___';
			END IF;
		END IF;

		
		--nombre del responsable
		IF str_data[17]=''  THEN
			valor_retorno := ''||valor_retorno||'responsable:Es necesario Ingresar el Nombre del Responsable___';
		END IF;
		
		--puesto del responsable
		IF str_data[18]='' THEN
			valor_retorno := ''||valor_retorno||'puesto:Es necesario Ingresar el Puesto del Responsable___';
		END IF;
		
		--email
		IF str_data[19]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_EmailCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[19]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:E-Mail No Valido___';
			END IF;
		END IF;
		
		--tipo de almacen 
		IF str_data[20]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'tipoalm:Es necesario seleccionar el Tipo de Almacen___';
		END IF;
		
		
		
		IF arreglo[1] = 'sin datos' THEN
			valor_retorno := ''||valor_retorno||'seleccionados:Es necesario Asignar por lo menos una Sucursal al almacen actual___';
		END IF;
		
		--RAISE EXCEPTION '%','str1: '||str_data[1];
		--valida la integridad de los datos, si el almacen es nuevo
		IF str_data[4] = '0' THEN
			--IF valor_retorno = 'true' THEN
				EXECUTE 'select count(id) from inv_alm where titulo ilike '''||str_data[5]||''' and borrado_logico=false;' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nombre:El nombre del almacen ingresado ya se encuentra registrado___';
				END IF;
			--END IF;
		END IF;
		
	END IF; --termina catalogo de Almacenes
	
	
	
	--Catalogo de proveedores
	IF id_app=2 THEN
		--rfc
		IF str_data[29]::integer = 1 OR str_data[29]::integer = 0 THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
			EXECUTE 'select '''||trim(str_data[6])||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'rfc:RFC No Valido___';
			END IF;
		END IF;
		
		--curp
		IF str_data[7] != ''  AND str_data[7] != ' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CurpCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'curp:La CURP ingresada no es no Valida___';
			END IF;
		END IF;
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonSocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rsocial:Razon Social No Valida___';
		END IF;
		
		--nombre comercial
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloCorrerct'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'ncomercial:Nombre Comercial No Valido___';
		END IF;
		
		--calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--num calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numcalle:Numero de Calle No Valida___';
		END IF;
		
		--colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[12]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CodigoPostalCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[13]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo Postal No Valido___';
		END IF;
		
		--pais
		IF str_data[15]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Proveedor___';
		END IF;
		
		--estado
		IF str_data[16]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Proveedor___';
		END IF;
		
		--municipio
		IF str_data[17]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Proveedor___';
		END IF;
		
		
		--telefono 1
		IF str_data[19]='' OR str_data[19]=' ' THEN
			valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el numero de Tel√©fono___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[19]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:Numero de Tel√©fono No Valido___';
			END IF;
		END IF;
		
		--e-mail
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_EmailCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[24]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'email:Correo Electronico No Valido___';
		END IF;
		
		--zona del proveedor
		IF str_data[27]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'zona:Es necesario seleccionar una Zona para el proveedor___';
		END IF;
		
		--grupo del proveedor
		IF str_data[28]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'grupo:Es necesario seleccionar un Grupo para el proveedor___';
		END IF;
		
		
		--tipo de proveedor
		IF str_data[29]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'provtipo:Es necesario seleccionar el Tipo de Proveedor___';
		END IF;
		
		--Clasificacion 1 del proveedor
		IF str_data[30]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'clasif1:Es necesario seleccionar un Clasificaci√≥n para el proveedor___';
		END IF;
		
		--Clasificacion 2 del proveedor
		IF str_data[31]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'clasif2:Es necesario seleccionar un Clasificaci√≥n para el proveedor___';
		END IF;
		
		--Clasificacion 3 del proveedor
		IF str_data[32]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'clasif3:Es necesario seleccionar un Clasificaci√≥n para el proveedor___';
		END IF;
		
		
		--moneda_id del proveedor
		IF str_data[33]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'moneda:Es necesario seleccionar una moneda para el proveedor___';
		END IF;
		
		
		--dias de credito
		IF str_data[37]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'credito:Es necesario seleccionar los D√≠as de Cr√©dito___';
		END IF;
		
		--inicio de credito
		IF str_data[39]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'inicred:Es necesario seleccionar el Inicio del Cr√©dito___';
		END IF;
		
		--contacto ventas
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ContactoCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[44]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'vcontacto:Ingrese el Nombre del contacto___';
		END IF;
		
		--Puesto del contacto ventas
		IF str_data[45] = '' OR str_data[45] = ' ' THEN
			valor_retorno := ''||valor_retorno||'vpuesto:Es Ingresar el Puesto del Contacto___';
		END IF;
		
		
		
		--e-mail ccontacto ventas
		IF str_data[59] != '' AND str_data[59] != ' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_EmailCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[59]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'vemail:E-mail del Contacto No Valido___';
			END IF;
		END IF;
		
		
		
		--valida la integridad de los datos, si el Proveedor es Nuevo
		IF str_data[4] = '0' THEN
			IF valor_retorno = '' THEN
				IF str_data[29]::integer=1 OR str_data[29]::integer=0 THEN
					EXECUTE 'select count(id) from cxp_prov where  rfc='''||str_data[6]||'''  and borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado ya se encuentra en uso___';
					END IF;
				END IF;
			END IF;
			IF valor_retorno = '' THEN
				EXECUTE 'select count(id) from cxp_prov where  razon_social='''||str_data[8]||''' and borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'rsocial:La Razon Social ingresada ya se encuentra en uso___';
				END IF;
			END IF;
			IF valor_retorno = '' THEN
				EXECUTE 'select count(id) from cxp_prov where clave_comercial='''||str_data[9]||''' and borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'ncomercial:El Nombre comercial ingresado ya se encuentra en uso___';
				END IF;
			END IF;
			IF valor_retorno = '' THEN
				EXECUTE 'select count(id) from cxp_prov where correo_electronico='''||str_data[24]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'email:El Correo Electr√≥nico ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de proveedores
	
	
	
	
	
	
	
	--monedas  0~^~xxx
	IF id_app=3 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','~^~');
		--nombre comercial
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'titulo:Titulo de la moneda No Valido~^~';
		END IF;
		
		IF str_data[1] = '0' THEN
			EXECUTE 'select count(id) from gral_mon where descripcion ilike '''||str_data[2]||''';' INTO valida_integridad;
			--RAISE EXCEPTION '%',valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'titulo:La moneda ingresada ya se encuentra en uso~^~';
			END IF;
		END IF;
	END IF;


	
	--Catalogo de empleados
	IF id_app=4 THEN
		--RAISE EXCEPTION '%',str_data[12]||' '||str_data[13]||' '||str_data[14]||' '||str_data[15]||' '||str_data[16]||' '||str_data[17];
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--nombre, 
		--RAISE EXCEPTION '%',str_data[3]; 
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NombreCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'nombre:Nombre No Valido___';
		END IF;
		
		--apellido paterno
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ApellidopaternoCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'apellidopaterno:Apellido paterno No Valido___';
		END IF;
		
		--apellido materno, 
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ApellidomaternoCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'apellidomaterno:Apellido materno No Valido___';
		END IF;
		
		--imss
		IF trim(str_data[8])<>'' THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ImssCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'imss:No.IMSS No Valido. Debe ser 11 digitos___';
			END IF;
		END IF;
		
		--infonavit
		IF trim(str_data[9])<>'' THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_InfonavitCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'infonavit:Numero de Infonavit No Valido___';
			END IF;
		END IF;
		
		--curp
		IF incluye_nomina THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CurpCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'curp:Curp No Valido___';
			END IF;
		ELSE
			IF trim(str_data[10])<>'' THEN 
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CurpCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'curp:Curp No Valido___';
				END IF;
			END IF;
		END IF;
		
		--rfc
		IF incluye_nomina THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'rfc:RFC No Valido___';
			END IF;
		ELSE
			IF trim(str_data[11])<>'' THEN 
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'rfc:RFC No Valido___';
				END IF;
			END IF;
		END IF;
		
		
		
		--fecha nacimiento
		--IF str_data[12]!='' AND str_data[12]!=' ' THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechaNacIngCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[12]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fechanacimiento:La fecha ingresada  No Valida___';
			END IF;
		--END IF;
		
		--fecha ingreso
		IF incluye_nomina THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechaNacIngCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[13]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fechaingreso:La fecha ingresada no es valida___';
			END IF;
		ELSE
			IF trim(str_data[13])<>'' THEN 
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechaNacIngCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[13]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'fechaingreso:La fecha ingresada no es valida___';
				END IF;
			END IF;
		END IF;
		
		--escolaridad
		IF str_data[14]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'escolaridad:La Escolaridad  NO es valida___';
		END IF;
		
		--sexo
		IF str_data[15]::integer= 0 THEN
			valor_retorno := ''||valor_retorno||'genero:El Genero NO es valido___';
		END IF;
		
		--edo civil
		IF str_data[16]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'civil:El estado civil NO es valido___';
		END IF;

		/*
		--religion
		IF str_data[17]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'religion:La religion NO es valida. ___';
		END IF;
		*/
		
		/*
		--sangre
		IF str_data[30]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'sangre:El tipo de sangre no es valido:___';
		END IF;
		*/
		
		--puesto
		IF str_data[33]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'puesto:El Puesto no es valido. Debe ser 10 digitos___';
		END IF;
		
		--sucursal
		IF str_data[34]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'sucursal:Debe ingresar una Sucursal___';
		END IF;
		
		/*
		--categoria
		IF str_data[35]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'categoria:Debe ingresar una Categoria___';
		END IF;
		*/
		
		--Nombre de usuario
		IF trim(str_data[37])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_UserCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[37]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email_usr:Introduzca un email de usuario___';
			END IF;
		END IF;
		
		--password
		--RAISE EXCEPTION '%',str_data[38];
		IF trim(str_data[37])<>'' THEN
			--Si existe nombre de usuario hay que validar que exista la contrase√±a
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PasswordCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[38]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena= false THEN
				valor_retorno := ''||valor_retorno||'password:Debe introducir una contrase√±a___';
			END IF;
		END IF;
		--RAISE EXCEPTION '%','arreglo: '||arreglo[1];
		--telefono
		IF trim(str_data[18])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[18]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'telefono:El numero telefonico no es valido. Debe ser 10 digitos___';
			END IF;
		END IF;
		
		--pais
		IF str_data[21]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Pais No Valido___';
		END IF;

		--estado
		IF str_data[22]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Estado No Valido___';
		END IF;
		
		--municipio
		IF str_data[23]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Municipio No Valido___';
		END IF;

		--calle
		IF str_data[24]!='' AND str_data[24]!=' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[24]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
			END IF;
		END IF;
		
		--numero
		IF str_data[25]!='' AND str_data[25]!=' ' THEN
			IF str_data[25]!='' AND str_data[25]!=' ' THEN
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[25]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'numero:Numero No Valido___';
				END IF;
			END IF;
		END IF;
		
		--colonia
		IF trim(str_data[26])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[26]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
			END IF;
		END IF;
		
		--cp
		IF trim(str_data[27])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[27]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'cp:CP No Valido___';
			END IF;
		END IF;
		
		--contacto emergencia
		/*
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NombreCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[28]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'ncontacto:Contacto No Valido___';
		END IF;
		*/
		
		--telefono emergencia
		IF trim(str_data[29])<>'' THEN 
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[29]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tcontacto:Telefono No Valido. Debe tener al menos 10 digitos___';
			END IF;
		END IF;



		IF incluye_nomina THEN 
			--Aqui solo entra si incluye nomina
			--no_int,--str_data[54],
			
			--str_data[55]::integer Regimen de Contratacion
			IF str_data[55]::integer=0 THEN
				valor_retorno := ''||valor_retorno||'regimencontratacio:Es necesario seleccionar el Regimen de Contratacion.___';
			END IF;
			
			--str_data[56]::integer Tipo de Contrato
			--str_data[57]::integer Tipo de Jornada
			--str_data[58]::integer Periodicidad del Pago
			--str_data[59]::integer Banco
			--str_data[60]::integer Rieso del Puesto
			--str_data[61]::double precision Salario Base
			--str_data[62]::double precision Salario Integrado
			--str_data[63] Registro Patronal
			--str_data[64] Clave
			
			
			--str_data[65] Percepciones
			IF trim(str_data[65])='' THEN
				valor_retorno := ''||valor_retorno||'percep:Es necesario seleccionar por lo menos un concepto de Percepcion.___';
			END IF;
			
			--str_data[66] deducciones
			IF trim(str_data[66])='' THEN
				valor_retorno := ''||valor_retorno||'deduc:Es necesario seleccionar por lo menos un concepto de Deduccion.___';
			END IF;
		END IF;
		
		
		IF str_data[1] = '0' THEN
			IF trim(str_data[10])<>'' THEN 
				EXECUTE 'select count(id) from gral_empleados where borrado_logico=false and gral_emp_id='||emp_id||' and curp ilike '''||str_data[10]||''';' INTO valida_integridad;
				--RAISE EXCEPTION '%',valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'curp:La curp ingresada ya se encuentra en uso___';
				END IF;
			END IF;
			
			valida_integridad:=0;

			IF trim(str_data[11])<>'' THEN 
				EXECUTE 'select count(id) from gral_empleados where borrado_logico=false and gral_emp_id='||emp_id||' and rfc ilike '''||str_data[11]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado ya se encuentra en uso___';
				END IF;
			END IF;
			
			valida_integridad:=0;
			IF trim(str_data[37])<>'' THEN 
				EXECUTE 'select count(id) from gral_usr where titulo ilike '''||str_data[37]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'email_usr:El usuario ingresado ya se encuentra en uso.___';
				END IF;
			END IF;
			
			IF trim(str_data[37])<>'' THEN
				--Si existe el nombre del usuario hay que validar la verificacion del Password
				valida_integridad:=0;
				IF str_data[38] <> str_data[39] THEN
					valor_retorno := ''||valor_retorno||'verificapass:La verificacion del password no coincide con la primera.___';
				END IF;
			END IF;

		END IF;
	END IF;
	
	
	
	
	
	--Catalogo de Clientes
	IF id_app=5 THEN
		
		--rfc
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
		END IF;
		
		--curp
		IF str_data[7]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CurpCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'curp:La curp ingresada no es valida___';
			END IF;
		END IF;

		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;
		
		--clave comercial
		IF str_data[9] = '' OR str_data[9] = ' ' THEN
			valor_retorno := ''||valor_retorno||'clavecomercial:La Clave Comercial es incorrecta___';
		END IF;
		
		--calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--num calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroint:Numero de Calle No Valida___';
		END IF;

		
		--colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[14]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--codigo postal
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--pais
		IF str_data[16]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Cliente___';
		END IF;
		
		--estado
		IF str_data[17]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Cliente___';
		END IF;
		
		--municipio
		IF str_data[18]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Cliente___';
		END IF;
		
		--telefono 1
		IF trim(str_data[6])<>'XEXX010101000' THEN 
			IF str_data[20]='' OR str_data[20]=' ' THEN
				valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el numero de Tel√©fono___';
			ELSE
				--telefono
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[20]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos___';
				END IF;
			END IF;
		END IF;
		
		--FAX, utiliza la misma mascara que telefono
		IF str_data[22]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[22]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fax:El numero de Fax no es valido. Debe ser 10 digitos___';
			END IF;
		END IF;
	

		--email
		IF str_data[25]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[25]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		
		--str_data[26] id agente
		IF str_data[26] = '0' THEN
			valor_retorno := ''||valor_retorno||'agente:Es necesario selecionar un Agente de Ventas para el cliente___';
		END IF;

		--zona
		IF str_data[28] = '0' THEN
			valor_retorno := ''||valor_retorno||'zona:Es necesario selecionar una Zona para el cliente___';
		END IF;

		--grupo
		IF str_data[29] = '0' THEN
			valor_retorno := ''||valor_retorno||'grupo:Es necesario selecionar un Grupo para el cliente___';
		END IF;

		--tipo CLIENTE
		IF str_data[30] = '0' THEN
			valor_retorno := ''||valor_retorno||'tipocliente:Es necesario selecionar el tipo de cliente___';
		END IF;

		--clasificacion 1
		IF str_data[31] = '0' THEN
			valor_retorno := ''||valor_retorno||'clasif1:Es necesario selecionar una Clasificacion para el cliente___';
		END IF;

		--clasificacion 2
		IF str_data[32] = '0' THEN
			valor_retorno := ''||valor_retorno||'clasif2:Es necesario selecionar una Clasificacion para el cliente___';
		END IF;

		--clasificacion 3
		IF str_data[33] = '0' THEN
			valor_retorno := ''||valor_retorno||'clasif3:Es necesario selecionar una Clasificacion para el cliente___';
		END IF;

		--moneda
		IF str_data[34] = '0' THEN
			valor_retorno := ''||valor_retorno||'moneda:Es necesario selecionar una Moneda para el cliente___';
		END IF;
		/*
		--impuesto
		IF str_data[37] = '0' THEN
			valor_retorno := ''||valor_retorno||'impuesto:Es necesario selecionar un Impuesto para el cliente___';
		END IF;
		*/

		IF str_data[39] = '0' THEN
			valor_retorno := ''||valor_retorno||'diascredito:Es necesario selecionar los dias de Credito para el cliente___';
		END IF;
		
		--inicio de credito
		IF str_data[41]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'inicred:Es necesario seleccionar el Inicio del Cr√©dito___';
		END IF;
		
		--e-mail contacto compras
		IF str_data[61] != '' AND str_data[61] != ' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[61]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'cemail:E-mail del Contacto No Valido___';
			END IF;
		END IF;
		
		--e-mail contacto pagos
		IF str_data[77] != '' AND str_data[77] != ' ' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[77]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'pemail:E-mail del Contacto No Valido___';
			END IF;
		END IF;
		
		--str_data[78] 	select_immex
		--str_data[79] 	retencion_immex
		--str_data[80] 	select_dia_revision
		--str_data[81] 	select_dia_pago
		
		IF str_data[78]::boolean=true THEN
			IF str_data[79]='' OR str_data[79]=' ' THEN
				valor_retorno := ''||valor_retorno||'retimmex:Es necesario ingresar la Tasa de Retenci&oacute;n IMMEX.___';
			ELSE
				IF str_data[79]::double precision > 100 THEN
					valor_retorno := ''||valor_retorno||'retimmex:La Tasa de Retenci&oacute;n IMMEX debe ser menor o igual a 100%.___';
				END IF;
				IF str_data[79]::double precision < 1 THEN
					valor_retorno := ''||valor_retorno||'retimmex:La Tasa de Retenci&oacute;n IMMEX debe ser mayor o igual a 1%.___';
				END IF;
			END IF;
		END IF;
		
		
		IF validaListaPrecioCliente THEN 
			--str_data[89] 	select_lista de precio
			IF str_data[89]='0' THEN
				valor_retorno := ''||valor_retorno||'lp:Es necesario seleccionar una Lista de Precio para el Cliente___';
			END IF;
		END IF;
		
		--str_data[90] 	select_metodo_pago
		IF str_data[90]='0' THEN
			valor_retorno := ''||valor_retorno||'metodopago:Es necesario seleccionar un M&eacute;todo de Pago para el Cliente___';
		END IF;
		
		IF str_data[4] = '0' THEN

			valida_integridad:=0;
			IF trim(str_data[6])<>'XEXX010101000' THEN 
				EXECUTE 'select count(id) from cxc_clie where rfc ilike '''||str_data[6]||''' AND borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado ya se encuentra en uso.___';
				END IF;
			END IF;
			
			valida_integridad:=0;
			EXECUTE 'select count(id) from cxc_clie where razon_social ilike '''||str_data[8]||''' AND borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social ingresada ya se encuentra en uso___';
			END IF;
			
			valida_integridad:=0;
			EXECUTE 'select count(id) from cxc_clie where clave_comercial ilike '''||str_data[9]||''' AND borrado_logico=false AND empresa_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'clavecomercial:La Clave Comercial ingresada ya se encuentra en uso___';
			END IF;
			/*
			valida_integridad:=0;
			EXECUTE 'select count(id) from cxc_clie where email ilike '''||str_data[25]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'email:El correo ingresado ya se encuentra en uso___';
			END IF;
			*/
		END IF;
	END IF;--termina validacion de clientes
	
	
	
	
	
	
	--parametros generales
	IF id_app=6 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');

		--calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[1]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;

		--colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;

		--codigo postal
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[3]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;

		--num calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numero:Numero de Calle No Valida___';
		END IF;

		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;

		--rfc
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
		END IF;

		--url facturacion electronica
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''isUrlCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
		END IF;

		--tasa retencion fletes
		IF str_data[12] = '' THEN
			valor_retorno := ''||valor_retorno||'tasafletes:Es necesario ingresar la tasa de retencion para fletes___';
		END IF;
	END IF;

	--bancos
	--nuevas variables que se agregaron para aplicativo bancos
	--str_filas text[];
	--total_filas integer;--total de elementos de arreglo
	--cont_fila integer;--contador de filas o posiciones del arreglo
	--id_banco integer;
	IF id_app=7 THEN

		--SELECT INTO str_filas string_to_array(campos_data,'|');
		
		--obtiene numero de elementos del arreglo str_filas
		total_filas:= array_length(str_filas,1);

		cont_fila:=1;
		FOR cont_fila IN 1 .. total_filas-1 LOOP
			--convertir en arreglo la cedena de cada posicion del arreglo str_filas
			SELECT INTO str_data string_to_array(str_filas[cont_fila],'___');
			IF cont_fila = 1 THEN
				--aqui entra para leer el indice 1 del arreglo, este arreglo debe tener solo tres posiciones
				--str_data[1]	id
				id_banco := str_data[1];
				--str_data[2] 	nombre del banco
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NombrebancoCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := 'nombre:Nombre de banco No Valido___';
				END IF;
				
				--str_data[3] 	clave del banco
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ClaveCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[3]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'clave:Clave no valida___';
				END IF;

				IF str_data[1] = '0' THEN
					EXECUTE 'select count(id) from erp_bancos where titulo ilike '''||str_data[2]||''';' INTO valida_integridad;
					--RAISE EXCEPTION '%',valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'nombre:El nombre del banco ingresado ya se encuentra en uso___';
					END IF;
				END IF;

				
			ELSE 
				--aqui entra para leer los registros  que son mayor que 1
				--RAISE EXCEPTION '%',str_filas[cont_fila];
				--str_data[1]	id_cuenta1
				--str_data[2] 	nocuenta1
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NocuentaCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'nocuenta'||cont_fila-1||':Cuenta no valida___';
				END IF;
				
				--str_data[3]	nosucursal1
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NosucursalCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[3]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'nosucursal'||cont_fila-1||':Numero de sucursal no valida___';
				END IF;
				
				--str_data[4]	sucursal1
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_SucursalCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[4]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'sucursal'||cont_fila-1||':Nombre de sucursal no valida___';
				END IF;
				
				--str_data[5]	dirsucursal1
				IF str_data[5] != '' THEN
					EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_DirsucursalCorrect'';' INTO mask_general;
					EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'dirsucursal'||cont_fila-1||':Direccion de sucursal no valida___';
					END IF;
				END IF;
				--str_data[6]	input_moneda1
				--str_data[7]	input_status1
				
				--str_data[8]	ejecutivo1
				IF str_data[8] != '' THEN
					EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NombreejecutivoCorrect'';' INTO mask_general;
					EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'ejecutivo'||cont_fila-1||':Nombre de ejecutivo no valido___';
					END IF;
				END IF;
				
				--str_data[9]	correo1
				IF str_data[9] != '' THEN
					EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
					EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'correo'||cont_fila-1||':Correo no valido___';
					END IF;
				END IF;
				
				--str_data[10] 	telefono1
				IF str_data[10] != '' THEN
					EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
					EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'telefono'||cont_fila-1||':Numero telefonico no valido___';
					END IF;
				END IF;
				
				IF str_data[1] = '0' THEN
					EXECUTE 'select count(id) from erp_cuentas where titulo ilike '''||str_data[2]||''' and banco_id='||id_banco INTO valida_integridad;
					--RAISE EXCEPTION '%',valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'nocuenta'||cont_fila-1||':La cuenta ingersada para este banco ya se encuentra en uso___';
					END IF;
				END IF;
				--RAISE EXCEPTION '%',str_data[2];
			END IF;
			
		END LOOP;
		
	END IF;
	
	
	
	
	--Productos
	IF id_app=8 THEN

		--query para verificar si la Empresa actual incluye Modulo de Produccion
		SELECT incluye_produccion, control_exis_pres FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, controlExisPres;
		
		--codigo producto,--str_data[31]
		IF str_data[31]='' OR str_data[31]=' ' THEN
			valor_retorno := ''||valor_retorno||'codigo:Es necesario C&oacute;digo del Producto.___';
		END IF;
		
		--descripcion,--str_data[5]
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloenCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'descripcion:La Descripcion igresada no es valida___';
		END IF;
		
		--tipo_de_producto_id,--str_data[18]::integer
		IF str_data[18]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'prodtipo:Es necesario seleccionar el Tipo de Producto.___';
		END IF;
		
		--str_data[20] 	unidad
		IF str_data[20]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'unidad:Es necesario seleccionar la Unidad de Mendida para el Producto.___';
		END IF;
		
		--Si el tiopo de producto es diferente de 3 y 4, hay que validar
		--tipo=3 Kit
		--tipo=4 Servicios
		IF str_data[18]::integer<>3 AND str_data[18]::integer<>4 THEN
			--inv_clas_id,--str_data[8]::integer
			IF str_data[8]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'clase:Clasificaci&oacute;n no valida.___';
			END IF;
			
			--inv_stock_clasif_id,--str_data[9]::integer
			IF str_data[9]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'stock:Es necesario seleecionar una Clasificaci&oacute;n de Stock.___';
			END IF;
			
			--inv_prod_familia_id,--str_data[11]::integer
			--IF str_data[11]::integer = 0 THEN
			--	valor_retorno := ''||valor_retorno||'familia:Es necesario seleccionar una Familia para el Producto.___';
			--END IF;
			
			--subfamilia_id,--str_data[12]::integer
			--IF str_data[12]::integer = 0 THEN
			--	valor_retorno := ''||valor_retorno||'subfamilia:Es necesario seleccionar una Subfamilia para el Producto.___';
			--END IF;
			
			--inv_prod_grupo_id,--str_data[13]::integer
			IF str_data[13]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'grupo:Es necesario seleccionar un Grupo para el Producto.___';
			END IF;
			
			/*
			--meta_impuesto,--str_data[15]::integer
			IF str_data[15]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'iva:Es necesario seleccionar el Impuesto para el Producto.___';
			END IF;
			*/
			--inv_prod_linea_id,--str_data[16]::integer
			IF str_data[16]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'linea:Es necesario seleccionar la L&iacute;nea para el Producto.___';
			END IF;
			
			--inv_mar_id,--str_data[17]::integer
			IF str_data[17]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'marca:Es necesario seleccionar la Marca para el Producto.___';
			END IF;
			
			--inv_seccion_id,--str_data[19]::integer
			IF str_data[19]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'seccion:Es necesario seleccionar la Secci&oacute;n para el Producto.___';
			END IF;
			
			--str_data[28] 	presentaciones del producto
			IF trim(str_data[28]) = '' THEN
				valor_retorno := ''||valor_retorno||'seleccionados:Es necesario seleccionar al menos una Presentaci&oacute;n para el Producto___';
			END IF;
			
			IF str_data[30]::double precision = 0 then 
				valor_retorno := ''|| valor_retorno||'densidad:Densidad debe ser mayor que 0___';
			END IF;
		END IF;
		
		--Presentacion Default--str_data[42]::integer
		IF str_data[42]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'presdefault:Es necesario seleccionar la Presentaci&oacute;n Default.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			IF str_data[31]!='' AND str_data[31]!=' ' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod WHERE sku='''||str_data[31]||''' AND borrado_logico=FALSE  AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'codigo:El C&oacute;digo del Producto ya se encuentra registrado.___';
				END IF;
			END IF;
			
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod WHERE descripcion = '''||str_data[5]||''' AND borrado_logico=FALSE  AND empresa_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'descripcion:La Descripci&oacute;n Ingresada ya se encuentra en uso.___';
				END IF;
			END IF;
						
		ELSE
			EXECUTE 'SELECT sku, id FROM inv_prod WHERE sku='''||str_data[31]||''' AND borrado_logico=FALSE  AND empresa_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'codigo:El C&oacute;digo del Producto ya se encuentra registrado.___';
			END IF;


			--RAISE EXCEPTION '%','controlExisPres: '||controlExisPres;
			--Verificar si hay que validar existencias de Presentaciones
			IF controlExisPres=true THEN 
				IF str_data[18]::integer<>3 AND str_data[18]::integer<>4 THEN
					IF trim(str_data[28]) <> '' THEN
						--convertir en arreglo los id de presentaciones de producto
						SELECT INTO str_filas2 string_to_array(str_data[28],',');
						
						--obtiene numero de elementos del arreglo str_pres
						total_filas2:= array_length(str_filas2,1);
						
						sql_select:='
						SELECT 
							presentacion_id,
							presentacion,
							sum(existencia) AS existencia
						FROM (
							SELECT 
								inv_prod_pres_x_prod.presentacion_id,
								inv_prod_presentaciones.titulo  AS presentacion,
								inv_exi_pres.inv_alm_id,
								(inv_exi_pres.inicial + inv_exi_pres.entradas - inv_exi_pres.reservado - inv_exi_pres.salidas) AS existencia
							FROM inv_prod_pres_x_prod 
							JOIN inv_exi_pres ON (inv_exi_pres.inv_prod_id=inv_prod_pres_x_prod.producto_id AND inv_exi_pres.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id)
							JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
							WHERE inv_prod_pres_x_prod.producto_id='||str_data[4]::integer||' 
						) AS sbt WHERE existencia>0
						GROUP BY presentacion_id, presentacion';

						--En esta cadena se almacenan las presentaciones que fueron eliminados y que tienen existencia
						cadena := '';
						
						FOR record1 IN EXECUTE(sql_select) LOOP
							exis:=0;
							cont_fila2:=1;
							FOR cont_fila2 IN 1 .. total_filas2 LOOP
								IF record1.presentacion_id=str_filas2[cont_fila2]::integer THEN 
									exis:= exis + 1;
								END IF;
							END LOOP;
							
							IF exis=0 THEN 
								cadena := cadena || record1.presentacion||',';
							END IF;
						END LOOP;
						
						IF trim(cadena)<>'' THEN
							valor_retorno := ''||valor_retorno||'seleccionados:Estas presentaciones('||cadena||') no se Pueden eliminar, tienen existencia.___';
						END IF;
						
					END IF;
				END IF;
			END IF;

		END IF;
		
		
		
		/*
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
				--ya no se valida nada
				--str_filas[1]	producto_ingrediente_id
				--str_filas[2] 	porcentaje
				--RAISE EXCEPTION '%',str_data[2];
				END IF;
				
			END LOOP;
			
		END IF;
		*/
	END IF;--termina productos
	
	
	/*
	str_data[1] 	app_selected
	str_data[2] 	command_selected
	str_data[3] 	id_usuario
	str_data[4] 	id_entrada
	str_data[5] 	id_proveedor
	str_data[6] 	factura
	str_data[7] 	expedicion
	str_data[8] 	numeroguia
	str_data[9] 	ordencompra
	str_data[10] 	denominacion
	str_data[11] 	tc
	str_data[12] 	observaciones
	str_data[13] 	fletera_id
	str_data[14] 	flete
	str_data[15] 	almacen_destino
	*/
	--entrada mercancias
	IF id_app=9 THEN
		--obtenemos el valor de control_exis_pres, para saber si es necesario validar existencias por presentaciones
		SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
		
		--id_entrada 	str_data[4]
		--id_proveedor	str_data[5] id_proveedor
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'noproveedor:Es necesario seleccionar un proveedor___';
		END IF;
		
		--factura	str_data[6]
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FacturaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
		END IF;
		
		--expedicion	str_data[7] expedicion
		IF str_data[7] = '' THEN
			valor_retorno := ''||valor_retorno||'expedicion:Es necesario seleccionar una fecha___';
		END IF;
		
		--numeroguia	str_data[8] numeroguia
		/*
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NoguiaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroguia:Numero de Guia no valido___';
		END IF;
		
		--ordencompra	str_data[9] ordencompra
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_OrdencompraCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'ordencompra:Numero de Guia no valido___';
		END IF;
		*/
		
		--denominacion	str_data[10] denominacion
		IF str_data[10]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'denominacion:Es necesario seleccionar una moneda___';
		END IF;
		
		--tipo cambio	str_data[11] tc
		IF str_data[11] = '' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		END IF;
		
		--observaciones	str_data[12]

		--str_data[13] fletera
		IF trim(str_data[13]) = '' THEN
			valor_retorno := ''||valor_retorno||'fletera:Es necesario seleccionar una compa√±ia___';
		END IF;
		
		--str_data[14] flete
		
		--str_data[15] almacen_destino
		
		
		IF trim(str_data[6])<>'' THEN
			valida_integridad:=0;
			EXECUTE 'SELECT count(id) FROM com_fac WHERE  proveedor_id='||str_data[5]||' AND factura ilike '''||str_data[6]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'factura:EL Folio ingresado ya se encuentra registrado___';
			END IF;
		END IF;
		
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--eliminado	str_filas[8]
				IF str_filas[8]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--no_partida 	str_filas[1]
					
					--costo		str_filas[3] costo
					IF str_filas[3] = ' ' OR str_filas[3] = '' THEN
						valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el costo___';
					ELSE
						IF str_filas[3]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'costo'||cont_fila||':El costo debe ser mayor que cero___';
						END IF;
					END IF;
					
					--cantidad	str_filas[2]  cantidad
					IF trim(str_filas[2])='' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[2]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad debe ser mayor que cero___';
						END IF;
					END IF;
					
					
					--Verificar si incluye control de existencias por presentacion
					IF controlExisPres=TRUE THEN 
						--Validar presentacion default
						SELECT cantidad FROM inv_prod_presentaciones WHERE id=str_filas[7]::integer 
						INTO equivalenciaPres;
						
						IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
						
						IF equivalenciaPres=0 THEN
							valor_retorno := ''||valor_retorno|| 'pres'||cont_fila||':Es necesario asignar la equivalencia a la presentacion.___';
						END IF;
					END IF;
					/*
					--caducidad	str_filas[10]
					IF trim(str_filas[10]) != ' ' THEN
						EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechacaducidadCorrect'';' INTO mask_general;
						EXECUTE 'select '''||str_filas[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
						IF match_cadena = false THEN
							valor_retorno := ''||valor_retorno|| 'caducidad'||cont_fila||':Fecha de caducidad no valida___';
						END IF;
					END IF;
					*/
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;
	
	

	--validacion de Traspasos
	IF id_app=10 THEN
		--str_data[4]	identificador
		--str_data[5]	select_suc_origen
		--str_data[6]	select_alm_origen
		--str_data[7]	select_suc_destino
		--str_data[8]	select_alm_destino
		--str_data[9]	observaciones
		--str_data[10]	fecha_traspaso
		
		IF str_data[5] = str_data[7] THEN 
			IF str_data[6] = str_data[8] THEN 
				valor_retorno := ''||valor_retorno||'almdestino:El almacen Destino NO debe ser igual al almacen Origen.___';
			END IF;
		END IF;
		
		IF str_data[8]='0' THEN 
			valor_retorno := ''||valor_retorno||'almdestino:Es necesario seleccionar el Almacen Destino.___';
		END IF;

		--obtenemos el valor de control_exis_pres, para saber si es necesario validar existencias por presentaciones
		SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				IF str_filas[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	idproducto[i]
					--str_filas[2]	cant_traspaso[i]
					--str_filas[3]	no_tr[i]
					--str_filas[4]	select_pres

					--buscar el numero de decimales de la unidad del producto
					SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=str_filas[1]::integer 
					INTO noDecUnidad;

					IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
					
					IF str_filas[2]='' OR str_filas[2]=' ' THEN 
						valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[3]||':Es necesario ingresar la CANTIDAD del para el Traspaso.___';
					ELSE
						IF str_filas[2]::double precision < 0.000001 THEN 
							valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[3]||':La CANTIDAD del Traspaso debe ser mayor que cero.___';
						ELSE
							SELECT (inv_exi.exi_inicial - inv_exi.transito - inv_exi.reservado + inv_exi.entradas_1 + inv_exi.entradas_2 + inv_exi.entradas_3 + inv_exi.entradas_4 + inv_exi.entradas_5 + inv_exi.entradas_6 + inv_exi.entradas_7 + inv_exi.entradas_8 + inv_exi.entradas_9 + inv_exi.entradas_10 + inv_exi.entradas_11 + inv_exi.entradas_12 - inv_exi.salidas_1 - inv_exi.salidas_2 - inv_exi.salidas_3 - inv_exi.salidas_4 - inv_exi.salidas_5 - inv_exi.salidas_6 - inv_exi.salidas_7 - inv_exi.salidas_8 - inv_exi.salidas_9 - inv_exi.salidas_10 - inv_exi.salidas_11 - inv_exi.salidas_12) AS existencia
							FROM inv_exi WHERE inv_prod_id=str_filas[1]::integer AND inv_alm_id=str_data[6]::integer AND ano=EXTRACT(YEAR FROM now())
							INTO existencia_producto;
							
							--redondeo de existencia
							existencia_producto := round((existencia_producto)::numeric, noDecUnidad)::double precision;
							
							IF existencia_producto < round((str_filas[2]::double precision)::numeric, noDecUnidad)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[3]||':La CANTIDAD para el Traspaso no debe ser mayor que la existencia actual.___';
							END IF;
						END IF;
					END IF;
					
					IF str_filas[4]::integer<=0 THEN 
						valor_retorno := ''||valor_retorno||'pres'||str_filas[3]||':Es necesario seleccionar la Presentaci&oacute;n en la que se realizar&aacute; el Traspaso.___';
					ELSE
						IF controlExisPres=true THEN
							--inicializar valor a cero
							equivalenciaPres:=0;
							
							--buscar la equivalencia de la Presentacion Origen en la Unidad del Producto
							SELECT cantidad AS equiv_pres FROM inv_prod_presentaciones WHERE id=str_filas[4]::integer 
							INTO equivalenciaPres;

							IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
							
							--Convertir la Cantidad de Unidades a su equivalencia en Cantidad de Presentaciones
							cantPres := round(str_filas[2]::numeric, noDecUnidad)::double precision / equivalenciaPres::double precision;

							--redondear la Cantidad de la Presentacion
							cantPres := round(cantPres::numeric,noDecUnidad)::double precision;
							
							--buscar Existencia de la Presentacion en el Almacen Origen
							SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exis 
							FROM inv_exi_pres  
							JOIN inv_prod ON inv_prod.id=inv_exi_pres.inv_prod_id  
							JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id  
							WHERE inv_exi_pres.inv_alm_id=str_data[6]::integer 
							AND inv_exi_pres.inv_prod_id=str_filas[1]::integer
							AND inv_exi_pres.inv_prod_presentacion_id=str_filas[4]::integer 
							INTO exisActualPres;
							
							IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
							
							--redondear la Existencia Actual de la Presentacion Origen
							exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;
							
							--validar si la Cantidad de la Presentaciona Traspasar es mayor que la Existencia Actual de la Presentacion en el Almacen origen
							IF cantPres::double precision > exisActualPres::double precision THEN 
								valor_retorno := ''||valor_retorno||'pres'||str_filas[3]||':La Presentaci&oacute;n tiene Existencia='||exisActualPres||',  Traspaso='||cantPres||'. No se puede raelizar el traspaso de una cantidad mayor a la Existencia.___';
							END IF;
						END IF;
					END IF;
					
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Traspasos


	
	
	
	--tipos de impuesto
	IF id_app=11 THEN
		--titulo
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TituloCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[2]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno|| 'titulo:Nombre del impuesto No Valido___';
		END IF;

		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ValorCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[3]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno|| 'valor:Valor del impuesto no valido___';
		END IF;
		
		IF str_data[1] = '0' THEN
			EXECUTE 'select count(id) from erp_ivatipos where titulo ilike '''||str_data[2]||''';' INTO valida_integridad;
			--RAISE EXCEPTION '%',valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'titulo:El impuesto ingresado ya se encuentra en uso___';
			END IF;
		END IF;
	END IF;
	
	
	--Cotizaciones
	IF id_app=12 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5] 	select_tipo_cotizacion
		--str_data[6]	id_cliente √≥ id_prospecto
		--str_data[7]	check_descripcion_larga
		--str_data[8]	observaciones
		--str_data[9]	tipo_cambio
		--str_data[10]	moneda_id
		--str_data[11]	fecha
		--str_data[12]  agente_id
		--str_data[13]  vigencia
		--str_data[14]  incluye_iva
		--str_data[15]  incoterms
		--str_data[16]  tc_usd
		
		--str_data[1] 	id_cliente
		IF str_data[6]='0' OR trim(str_data[6])='' THEN
			IF str_data[5]::integer=1 THEN 
				valor_retorno := ''||valor_retorno||'rfccliente:Es necesario seleccionar un Cliente___';
			ELSE
				valor_retorno := ''||valor_retorno||'rfccliente:Es necesario seleccionar un Prospecto___';
			END IF;
		END IF;
		
		--str_data[9] 	tipo_cambio
		IF str_data[9]!='' THEN
			IF str_data[9]::double precision <= 0 THEN 
				valor_retorno := ''||valor_retorno||'tc:El tipo de cambio debe ser mayor que cero.___';
			END IF;
		ELSE
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el Tipo de Cambio.___';
		END IF;


		--si el tipo de cotizacion es 1=Cliente, entonces hay que Obtener el numero de Lista de Precio
		IF str_data[5]::integer=1 THEN 
			--Obtener el numero de Lista de Precio Asignado al cliente
			select cxc_clie.lista_precio from cxc_clie where cxc_clie.id=str_data[6]::integer into num_lista_precio;
		END IF;
		
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	cantidad
					--str_filas[6]	precio
					--str_filas[7]	monedagrid
					--str_filas[8]	notr
					--str_filas[9]	id_imp_prod
					--str_filas[10]	valor_imp
					--str_filas[11]	select_umedida
					--str_filas[12]	stat_reg
					--str_filas[13]	precio_autorizado
					--str_filas[14]	id_user_aut
					--str_filas[15]	requiere_autorizacion
					--str_filas[16]	salvar_registro
					
					--RAISE EXCEPTION '%','str_filas[8]: '||str_filas[8];
					--str_filas[5]	cantidad
					IF trim(str_filas[5])='' THEN
						valor_retorno := ''||valor_retorno||'cant'||str_filas[8]||':Es necesario ingresar la cantidad.___';
					ELSE
						IF str_filas[5]::double precision <= 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cant'||str_filas[8]||':La cantidad debe ser mayor que cero.___';
						END IF;
					END IF;
					
					--str_filas[6]	precio
					IF trim(str_filas[6])='' THEN
						valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':Es necesario ingresar el Precio Unitario.___';
					ELSE
						IF str_filas[6]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':El Precio Unitario debe ser mayor que cero.___';
						ELSE
							--si el tipo de cotizacion es 1=Cliente, entonces hay que validar precios
							IF str_data[5]::integer=1 THEN 
								
								IF num_lista_precio > 0 THEN
									--Sacando el descuento y precio del producto de acuerdo a la presentacion seleccionada
									sql_select:='SELECT (CASE WHEN descuento_'||num_lista_precio||' IS NULL THEN 0 ELSE descuento_'||num_lista_precio||' END ),inv_pre.precio_'||num_lista_precio||', (CASE WHEN inv_pre.gral_mon_id_pre'||num_lista_precio||' IS NULL THEN 0 ELSE inv_pre.gral_mon_id_pre'||num_lista_precio||' END) FROM inv_pre where inv_prod_id='||str_filas[3]||' AND inv_prod_presentacion_id='||str_filas[4]||' AND borrado_logico=false;';
									--RAISE EXCEPTION '%',sql_select;
									EXECUTE sql_select INTO descuento_producto, precio_producto, mon_prec_prod;
									
									IF descuento_producto IS NULL THEN
										descuento_producto:=0;
									END IF;
									
									IF precio_producto IS NULL THEN
										precio_producto:=0;
									ELSE
										--RAISE EXCEPTION '%', 'MonCot:'||str_data[10]::integer||'       mon_prec_prod:'||mon_prec_prod;
										IF str_filas[7]::integer <> mon_prec_prod::integer THEN 
											/*
											IF mon_prec_prod::integer > 0 THEN 
												SELECT valor FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=mon_prec_prod ORDER BY momento_creacion DESC LIMIT 1 INTO tc_mon_prod;
											ELSE
												tc_mon_prod:=0;
											END IF;
											*/
											IF str_filas[7]::integer=1 AND mon_prec_prod::integer<>1 THEN 
												--si la moneda del pedido es pesos y la moneda del precio es diferente de Pesos,
												--entonces calculamos su equivalente a pesos
												precio_producto:= precio_producto * str_data[16]::double precision;
											END IF;
											
											IF str_filas[7]::integer<>1 AND mon_prec_prod::integer=1 THEN 
												--si la moneda del Pedido es Diferente de Pesos y la moneda del precio es Pesos,
												--entonces calculamos su equivalente a dolar
												precio_producto:= precio_producto / str_data[16]::double precision;
											END IF;
										END IF;
									END IF;
									
									--Redondear a 4 digitos el precio del producto
									precio_producto:=round((precio_producto)::numeric, 4)::double precision;
									
									--RAISE EXCEPTION '%',num_lista_precio;
									--Obteniendo el valor del descuento
									descuento := ((descuento_producto::double precision/100) * precio_producto);
									
									--Redondear a 4 digitos el descuento
									descuento:=round((descuento)::numeric, 4)::double precision;
									
									--Precio minimo
									precio_minimo := precio_producto - descuento;
									
									--Redondear a 2 digitos el Precio Minimo
									precio_minimo := round((precio_minimo)::numeric, 4)::double precision;
									
									--RAISE EXCEPTION '%', 'PrecioVista:'||round(str_filas[6]::numeric, 2)::double precision||'       PrecioMinimo:'||precio_minimo;
									
									IF round(str_filas[6]::numeric, 4)::double precision < precio_minimo THEN 
										--valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':No puede ser asignado este precio.___';
										
										--RAISE EXCEPTION '%','facpar.aut_precio_menor_cot: '||facpar.aut_precio_menor_cot;
										
										--Verificar si la configuraci√≥n permite la autorizacion de precios abajo de la lista de precio en cotizaciones
										if facpar.aut_precio_menor_cot then 
											--Verificar si hay que salvar aun cuando hay precios no autorizados
											if str_filas[16]::boolean=false then 
												--Verificar si est√° autorizado el precio menor
												if str_filas[12]::boolean then 

													--RAISE EXCEPTION '%','str_filas[6]:'||str_filas[6]||'     str_filas[13]:'||str_filas[13];
													
													--Verificar si el precio no es menor al precio autorizado
													if round(str_filas[6]::numeric,4)::double precision < round(str_filas[13]::numeric,4)::double precision then 
														valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':El Precio es menor al autorizado '||str_filas[13]||'.___';
														valor_retorno := ''||valor_retorno||'checkauth'||str_filas[8]||':true.___';
													else
														--Verificar si el precio autorizado no es menor al precio_minimo de venta
														sql_select := '
														SELECT 
															sbt.prod_id,
															sbt.pres_id,
															sbt.moneda_id, 
															(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS pmin  
														FROM (
															SELECT 
																inv_prod.id AS  prod_id,
																inv_prod_pres_x_prod.presentacion_id AS pres_id,
																(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
																(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
																(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
																(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic, 
																(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
																(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
																(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
															FROM inv_prod 
															JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
															JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
															LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
															LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
															WHERE inv_prod.borrado_logico=false AND inv_prod_cost_prom.ano='||ano_actual||' AND inv_prod.id='||str_filas[3]||' AND inv_prod_pres_x_prod.presentacion_id='||str_filas[4]||'  
														) AS sbt LIMIT 1;';
														
														--RAISE EXCEPTION '%','sql_select: '||sql_select;
														
														FOR record1 IN EXECUTE (sql_select) LOOP 
															IF str_filas[7]::integer <> record1.moneda_id::integer THEN 
																IF str_filas[7]::integer=1 AND record1.moneda_id<>1 THEN 
																	--si la moneda del pedido es pesos y la moneda del Costo es diferente de Pesos,
																	--entonces calculamos su equivalente a pesos
																	record1.pmin:= record1.pmin * str_data[16]::double precision;
																END IF;
																
																IF str_filas[7]::integer<>1 AND record1.moneda_id=1 THEN 
																	--si la moneda del Pedido es Diferente de Pesos y la moneda del Costo es Pesos,
																	--entonces calculamos su equivalente a dolar
																	record1.pmin:= record1.pmin / str_data[16]::double precision;
																END IF;
															end if;

															record1.pmin:=round(record1.pmin::numeric, 4)::double precision;

															--RAISE EXCEPTION '%','str_filas[6]:'||str_filas[6]||'     record1.pmin:'||record1.pmin;
															
															IF round(str_filas[6]::numeric, 4)::double precision < record1.pmin THEN 
																valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':El Precio es menor al costo '||record1.pmin||'.___';
															end if;
														END LOOP;
													end if;
												else
													valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':No puede ser asignado este precio.___';
													valor_retorno := ''||valor_retorno||'checkauth'||str_filas[8]||':true.___';
												end if;
											end if;
										else
											valor_retorno := ''||valor_retorno||'precio'||str_filas[8]||':No puede ser asignado este precio.___';
										end if;
									END IF;
									
								END IF;
								
							END IF;
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;
	--Termina Validacion de Cotizaciones
	
	
	
	
	--Prefacturas
	IF id_app=13 THEN
		--str_data[3]	id_usuario
		--str_data[4]	id_prefactura
		--str_data[5] 	id_cliente
		
		--Obtener valores para estas variables:incluye_modulo_produccion, controlExisPres
		SELECT incluye_produccion, control_exis_pres FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, controlExisPres;
		
		
		--obtener el id del almacen de donde se va a facturar
		SELECT inv_alm_id FROM erp_prefacturas WHERE id=str_data[4]::integer INTO id_almacen;
		
		IF str_data[5]::integer < 1 THEN
			valor_retorno := ''||valor_retorno||'rfccliente:Es necesario seleccionar un cliente___';
		END IF;
		
		--str_data[6]	id_moneda
		--str_data[7]	observaciones
		--str_data[8]	tipo_cambio_vista
		
		IF str_data[8] = '' OR str_data[8] = ' ' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		ELSE
			IF str_data[8]::double precision <= 0 THEN
				valor_retorno := ''||valor_retorno||'tc:El tipo de cambio debe ser mayor que cero___';
			ELSE
				IF str_data[8]::double precision > 100 THEN
					valor_retorno := ''||valor_retorno||'tc:El tipo de cambio debe ser mayor que 100___';
				END IF;
			END IF;
		END IF;
		
		--str_data[9]	id_vendedor
		IF str_data[9]='0' THEN
			valor_retorno := ''||valor_retorno||'agente:Es necesario seleccionar el Agente. Debe ir a Clientes y asignar el Agente, depues reiniciar el procesos de facturacion de Remision___';
		END IF;
		
		--str_data[10]	id_condiciones
		IF str_data[10]='0' THEN
			valor_retorno := ''||valor_retorno||'terminos:Es necesario seleccionar un Termino de Pago. Debe ir a Clientes y asignar los Dias de Credito, depues reiniciar el procesos de facturacion de Remision___';
		END IF;
		
		--str_data[11]	orden_compra
		--str_data[12]	refacturar
		--str_data[13]	id_metodo_pago
		--str_data[14]	no_cuenta
		--str_data[15]	select_tipo_documento
		--str_data[16]	folio_pedido
		--str_data[16]	
		
		--RAISE EXCEPTION '%',str_data[13];
		
		/*
		IF str_data[13]::integer=2 OR str_data[13]::integer=3 THEN		
			IF str_data[14]='' OR str_data[14]=' ' THEN
				valor_retorno := ''||valor_retorno||'digitos:Es necesario ingresar los ultimos 4 digitos de la tarjeta___';
			ELSE
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_DigitosTarjetaCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[14]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno|| 'digitos:Es necesario ingresar 4 digitos.___';
				END IF;
			END IF;
		END IF;
		*/

		
		--Aqui se validan los datos para la Adenda
		--Primero se verifica si en los parametros indica que se debe incluir la Adenda
		IF facpar.incluye_adenda THEN 
			--Verificar que exista un id de cliente valido
			IF str_data[5]::integer > 1 THEN
				--Buscar el numero de Adenda asignado al cliente.
				SELECT cxc_clie_tipo_adenda_id FROM cxc_clie WHERE id=str_data[5]::integer INTO idAdenda;
				
				--Varificar si tiene adenda asignada
				IF idAdenda > 0 THEN
					--Verificar el numero de adenda
					IF idAdenda=1 THEN 
						--Addenda FEMSA QUIMIPRODUCTOS
						
						--Si el numero de Adenda es 1, entonces solo debe se debe validar datos cuando el tipo de documento es igual a 3.
						--Tipo Documento 3=Factura de Remision
						IF str_data[15]::integer=3 THEN 
							--str_data[20]	NoEntrada
							--str_data[21]	NoRemision
							--str_data[22]	Consignacion
							--str_data[23]  CentroCostos
							--str_data[24]	FechaInicio
							--str_data[25]  FechaFin
							--str_data[26]  Orden Compra
							--str_data[27]  Moneda
							
							valor_retorno2 := '';
							IF trim(str_data[27])='' THEN 
								valor_retorno2 := ''||valor_retorno2||'campo8$La Moneda no debe quedar vacio.&&&&&';
								valor_retorno3 := ''||valor_retorno3||'Orden de Compra, ';
							END IF;
							
							IF trim(str_data[22])='true' THEN 
								--Aqui entra cuando es Consignacion
								IF trim(str_data[23])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo4$Es necesario ingresar el Centro de Costo.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'Centro de Costo, ';
								END IF;
								IF trim(str_data[24])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo5$Es necesario ingresar la Fecha de Inicio.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'Fecha Inicio, ';
								END IF;
								IF trim(str_data[25])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo6$Es necesario ingresar la Fecha de Fin.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'Fecha Fin.';
								END IF;
							ELSE
								IF trim(str_data[26])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo7$La Orden de Compra no debe estar vacio.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'Orden de Compra, ';
								ELSE
									IF char_length(str_data[26])<10 THEN
										valor_retorno2 := ''||valor_retorno2||'campo7$La Orden de Compra debe tener 10 digitos.&&&&&';
										valor_retorno3 := ''||valor_retorno3||'Orden de Compra, ';
									ELSE
										IF char_length(str_data[26])>10 THEN
											valor_retorno2 := ''||valor_retorno2||'campo7$La Orden de Compra debe tener 10 digitos.&&&&&';
											valor_retorno3 := ''||valor_retorno3||'Orden de Compra, ';
										END IF;
									END IF;
								END IF;

								
								IF trim(str_data[20])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo1$El Numero de Entrada no puede quedar vacio.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'No. Entrada, ';
								ELSE
									IF char_length(str_data[20])<10 THEN
										valor_retorno2 := ''||valor_retorno2||'campo1$Numero de Entrada debe tener 10 digitos.&&&&&';
										valor_retorno3 := ''||valor_retorno3||'No. Entrada, ';
									ELSE
										IF char_length(str_data[20])>10 THEN
											valor_retorno2 := ''||valor_retorno2||'campo1$Numero de Entrada debe tener 10 digitos.&&&&&';
											valor_retorno3 := ''||valor_retorno3||'No. Entrada, ';
										END IF;
									END IF;
								END IF;
								
								IF trim(str_data[21])='' THEN 
									valor_retorno2 := ''||valor_retorno2||'campo2$Es necesario ingresar el Numero de Remision.&&&&&';
									valor_retorno3 := ''||valor_retorno3||'No. Remision, ';
								END IF;
							END IF;
							
							IF valor_retorno2<>'' THEN 
								valor_retorno := ''||valor_retorno||'adenda1: Falta ';
								valor_retorno := ''||valor_retorno||valor_retorno3||'___';
								valor_retorno := ''||valor_retorno||'adenda2:'||valor_retorno2;
							END IF;
						END IF;
					END IF;
					--Termina Addenda FEMSA-QUIMIPRODUCTOS


					--Addenda SUN CHEMICAL
					IF idAdenda=2 THEN 
						IF trim(str_data[11])='' THEN 
							valor_retorno := ''||valor_retorno||'oc:Orden de Compra es obligatorio para la Addenda___';
						END IF;
					END IF;
					--Termina addenda SUN CHEMICAL
				END IF;
			END IF;
		END IF;
		--Termina validacion de datos para la Adenda
		
		--EXECUTE 'select '''||str_data[11]||''' ~ ''^[^@ ]+@[^@ ]+.[^@ .]+$'';' INTO match_cadena;
		--str_data[28]	rfc
		IF trim(str_data[28]) = '' THEN
			valor_retorno := ''||valor_retorno||'rfc:Se requiere el RFC del Cliente.___';
		ELSE
			EXECUTE 'select '''||str_data[28]||''' ~ ''^[A-Za-z0-9&]{3,4}[0-9]{6}[A-Za-z0-9]{3}$'';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'rfc:RFC No Valido.___';
			END IF;
		END IF;
		
		/*
		--str_data[29]	check_envio
		IF trim(str_data[29]) = 'true' THEN
			IF trim(str_data[30]) = '' THEN
				valor_retorno := ''||valor_retorno||'emailenvio:Se requiere el E-Mail para el envio.___';
			ELSE
				EXECUTE 'select '''||str_data[30]||''' ~ ''^[^@ ]+@[^@ ]+.[^@ .]+$'';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'emailenvio:E-Mail No Valido.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[30]	email_envio
		*/


		--str_data[30]	select_tmov
		--str_data[15]	select_tipo_documento
		--1=Factura, 2=Remision, 3=Factura de Remision
		
		if str_data[15]::integer=1 or str_data[15]::integer=3 then 
			if str_data[30]::integer<=0 then 
				--valor_retorno := ''||valor_retorno||'tmov:Seleccionar el Tipo de Movimiento.___';
			end if;
		end if;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] <> 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					--str_filas[8]	valor_impuesto
					--str_filas[9]	id_remision
					--str_filas[10]	costo_promedio
					
					--str_filas[11]	idUnidad
					--str_filas[12]	id_ieps
					--str_filas[13]	tasa_ieps
					--str_filas[14]	vdescto
					
					--Inicializar valores
					cantPresAsignado:=0;
					equivalenciaPres:=0;
					exisActualPres:=0;
					cantPresReservAnterior:=0;
					noDecUnidad:=0;
					cant_reservada_anterior:=0;
					total_existencia:=0;
					
					--str_filas[6]	cantidad
					IF trim(str_filas[6]) = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Es necesario ingresar la cantidad___';
					ELSE
						--Verificar que el campo sea numerico
						IF (SELECT trim(str_filas[6]) ~ '^([0-9]+[.]?[0-9]*|[.][0-9]+)$') THEN 
							
							--RAISE EXCEPTION '%',str_filas[6];
							IF str_filas[6]::double precision < 0.000001 THEN
								/*
								Se comento esta validacion porque ya se se puede facturar parcialmente un pedido
								y se puede dejar partidas en cero para no incluirla en la factura.
								*/
								--valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad debe ser mayor que cero___';
							ELSE	
								--si refacturar=false, valida existencias, si es refacturacion no se valida nada
								IF str_data[12] = 'false' THEN
									
									--obtener el tipo de producto y el numero de Decimales Permitidos
									SELECT 
										inv_prod.tipo_de_producto_id AS tipo_producto,
										(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec,
										inv_prod.unidad_id,
										inv_prod.densidad,
										(CASE WHEN inv_prod_unidades.titulo IS NULL THEN '' ELSE inv_prod_unidades.titulo END) AS unidad
									FROM inv_prod 
									LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
									WHERE inv_prod.id=str_filas[3]::integer 
									INTO tipo, noDecUnidad, idUnidadMedida, densidadProd, nombreUnidadMedida;
									
									IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
									
									--Verificar si se esta facturando en diferente unidad de medida
									IF idUnidadMedida::integer<>str_filas[11]::integer  THEN
										EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
										IF match_cadena=true THEN 
											--Convertir a Litros
											str_filas[6] := str_filas[6]::double precision / densidadProd;
										ELSE
											EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
											IF match_cadena=true THEN
												--Convertir a kilos
												str_filas[6] := str_filas[6]::double precision * densidadProd;
											END IF;
										END IF;
									END IF;
									
									
									--Redondear la Cantidad
									str_filas[6] := round(str_filas[6]::numeric,noDecUnidad)::double precision;
									
									
									--Si el tipo de producto es diferente de 4, hay que validar existencias
									--tipo=4 Servicios
									--para el tipo servicios no se debe validar existencias
									IF tipo<>4 THEN
										
										--Tipo de Documento diferente de 3(Facturacion de Remision)
										IF str_data[15]::integer<>3 THEN
											--tipo=1 Normal o Terminado
											--tipo=2 Subensable o Formulacion o Intermedio
											--tipo=5 Refacciones
											--tipo=6 Accesorios
											--tipo=7 Materia Prima
											--tipo=8 Prod. en Desarrollo
											IF tipo=1 OR tipo=2 OR tipo=5 OR tipo=6 OR tipo=7 OR tipo=8 THEN 
												--llamada a proc que devuelve la existencia del producto. 
												--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
												--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
												SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, id_almacen) INTO total_existencia;
												
												IF str_filas[2]::integer>0 THEN
													--buscamos la cantidad reservada anterior
													SELECT reservado FROM erp_prefacturas_detalles WHERE id=str_filas[2]::integer INTO cant_reservada_anterior;
													
													--Redondear la cantidad reservada anterior
													cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
													
													--le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
													total_existencia := total_existencia::double precision + cant_reservada_anterior::double precision;
												END IF;
												
												--Redondear la existencia actual
												total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
												
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':El producto tiene Existencia 0 en Almacen___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Disponibles '||total_existencia||',  usted esta intentando vender '||str_filas[6]||'___';
													END IF;
												END IF;
												
												--RAISE EXCEPTION '%' ,'controlExisPres: '||controlExisPres;
												--Verificar si hay que validar existencias de Presentaciones
												IF controlExisPres=true THEN 
													--Buscar la equivalencia de la Presentacion
													SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_filas[4]::integer 
													INTO equivalenciaPres;
													
													IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
													
													--Buscar la existencia actual de la Presentacion
													SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exi
													FROM inv_exi_pres WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=str_filas[3]::integer AND inv_prod_presentacion_id=str_filas[4]::integer 
													INTO exisActualPres;
													
													IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
													
													
													--Si la configuracion indica que se validan Presentaciones desde el Pedido,
													--entonces significa que hay reservados, por lo tanto hay que descontarlos para tener la existencia real
													IF facpar.validar_pres_pedido=true THEN 
														--Si la presentacion actual es igual a la presentacion  anterior, entonces calculamos la c
														cantPresReservAnterior := cant_reservada_anterior::double precision / equivalenciaPres::double precision;
														
														--redondear la Cantidad de la Presentacion reservada Anteriormente
														cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
														
														--sumar la cantidad reservada anterior para tener la existencia real
														exisActualPres = exisActualPres::double precision + cantPresReservAnterior::double precision;
													END IF;
													--RAISE EXCEPTION '%' ,'exisActualPres: '||exisActualPres;
													
													--Redondear la Existencia actual de Presentaciones
													exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision; 
													
													--Convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
													cantPresAsignado := str_filas[6]::double precision / equivalenciaPres::double precision;
													
													--Redondear la cantidad de Presentaciones Asignado en la partida
													cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision;
													--RAISE EXCEPTION '%' ,'cantPresAsignado: '||cantPresAsignado;

													
													IF exisActualPres <= 0 THEN
														valor_retorno := ''||valor_retorno||'presentacion'||cont_fila||':No hay existencia en esta Presentacion.___';
													ELSE
														IF exisActualPres::double precision < cantPresAsignado::double precision THEN
															valor_retorno := ''||valor_retorno||'presentacion'||cont_fila||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
														END IF;
													END IF;
													
												END IF;
												
											END IF;
										END IF;
										
									END IF;
								END IF;
							END IF;
							
						ELSE
							--Aqui entra porque el campo cantidad trae un valor no numerico
							valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':El valor para Cantidad es incorrecto, tiene mas de un punto('||str_filas[6]||')___';
						END IF;
						
					END IF;
					--valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el precio unitario___';
					--str_filas[7]	costo
					IF str_filas[7] = ' ' OR str_filas[7] = ''THEN
						valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el precio unitario___';
					ELSE
						IF str_filas[7]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'costo'||cont_fila||':El precio debe ser mayor que cero___';
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--termina prefacturas
	
	
	
	
	--registro de pagos
	--pendiente validacion
	IF id_app=14 THEN
		--str_data[4] 	cliente_id
		--str_data[5] 	deuda_pesos
		--str_data[6] 	deuda_usd
		--str_data[7] 	moneda
		--str_data[8] 	fecha
		--str_data[9] 	banco
		--str_data[10] 	observaciones
		--str_data[11] 	forma_pago
		--str_data[12] 	cheque
		--str_data[13] 	referencia
		--str_data[14] 	tarjeta
		
		--obtiene id de la forma de pago
		--SELECT id FROM erp_pagos_formas WHERE titulo ILIKE str_data[8] LIMIT 1 into id_forma_pago;
		--1 Efectivo
		--2 Cheque
		--3 Tarjeta
		--4 Transferencia
		
		IF str_data[11] = 'Efectivo' THEN
			--no se valida nada
		END IF;
		
		IF str_data[11] = 'Cheque' THEN
			IF str_data[9]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'bancos:Es necesario seleccionar el banco del cheque___';
			END IF;
			IF str_data[12] = '' THEN
				valor_retorno := ''||valor_retorno||'nocheque:Es necesario ingresar el numero de cheque___';
			END IF;
		END IF;
		IF str_data[11] = 'Tarjeta' THEN
			IF str_data[9]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'bancos:Es necesario seleccionar el banco de la tarjeta___';
			END IF;
			/*
			IF str_data[13] = '' THEN
				valor_retorno := ''||valor_retorno||'notarjeta:Es necesario ingresar el numero de la tarjeta___';
			END IF;
			*/
		END IF;
		
		IF str_data[11] = 'Transferencia' THEN
			IF str_data[9]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'bancos:Es necesario seleccionar el banco de la transferencia___';
			END IF;
			IF str_data[13] = '' THEN
				valor_retorno := ''||valor_retorno||'referencia:Es necesario ingresar el numero de referencia de la transferencia___';
			END IF;
		END IF;
		
		--str_data[15] 	antipo
		--str_data[16] 	monto_pago
		--str_data[17] 	fecha_deposito
		--str_data[18] 	ficha_movimiento_deposito
		--str_data[19] 	ficha_cuenta_deposito
		IF str_data[19]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'cuentaempresa:Es necesario seleccionar la cuenta en la que se realizo el deposito___';
		END IF;
		
		--str_data[20] 	ficha_banco_kemikal
		IF str_data[20]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'bancoempresa:Es necesario seleccionar el banco de la empresa donde se realizo el deposito___';
		END IF;
		--str_data[21] 	tipo_cambio
		--str_data[22] 	anticipo_gastado
		--str_data[23] 	no_transaccion_anticipo

		--obtener id del anticipo
		SELECT COUNT(id) FROM cxc_ant WHERE numero_transaccion=str_data[23]::bigint AND cliente_id=str_data[4]::integer AND borrado_logico=false INTO exis;
		IF exis > 0 THEN
			SELECT cancelado FROM cxc_ant WHERE numero_transaccion=str_data[23]::bigint AND cliente_id=str_data[4]::integer LIMIT 1 
			INTO registro_cancelado;

			IF registro_cancelado THEN 
				valor_retorno := ''||valor_retorno||'cancelado:No es posible aplicar &eacute;ste anticipo.<br>Es posible que haya sido cancelado por otro usuario en otro proceso.___';
			END IF;
		END IF;
		
		/*
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1]	factura_vista
				--str_filas[2]	saldado
				--str_filas[3]	saldo
				--str_filas[4]	tipocambio
				
			END LOOP;
		END IF;
		*/
		
	END IF;--termina carteras
	
	
	--registro de centro de costo
	IF id_app=15 THEN
		--str_data[4] 	id
		--str_data[5] 	titulo
		--str_data[6] 	descripcion
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'centrocosto:Es necesario ingresar el nombre del Centro de Costo___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM ctb_cc WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE;'  INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'centrocosto:El nombre del Centro de Costo ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;
	
	
	--validacion de tipos de poliza
	IF id_app=16 THEN
		--str_data[4] 	id
		--str_data[5] 	tipo
		--str_data[6] 	descripcion
		--str_data[7] 	grupo
		
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'tipo:Es necesario ingresar el Tipo de Poliza___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_TipoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tipo:El Tipo de poliza debe ser Numero___';
			END IF;
		END IF;
		
		
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		
		IF str_data[7]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'grupo:Es necesario seleccionar un Grupo';
		END IF;
		
		IF trim(str_data[4]) = '0' THEN
			--RAISE EXCEPTION '%',valida_integridad;
			IF trim(str_data[5])<>'' THEN
				
				EXECUTE 'SELECT count(id) FROM ctb_tpol WHERE tipo='||str_data[5]  INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'tipo:El tipo de Poliza ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
	END IF;

	--validacion de conceptos contables
	IF id_app=17 THEN
		--str_data[4] 	id
		--str_data[5] 	titulo
		--str_data[6] 	descripcion
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario ingresar el nombre del Concepto Contable___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion del Concepto Contable___';
		END IF;
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM ctb_con WHERE titulo = '''||str_data[5]||''';'  INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'concepto:El nombre del Concepto ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de conceptos contables
	
	
	
	
	--validacion de Clasificacion de Cuentas(Cuentas de Mayor)
	IF id_app=18 THEN
		--str_data[4]	id
		--str_data[5]	ctamayor
		--str_data[6]	clasificacion
		--str_data[7]	des_espanol
		--str_data[8]	des_ingles
		--str_data[9]	des_otro
		
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'ctamayor:Es necesario selecionar una Cuenta de Mayor___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'clasificacion:Es necesario ingresar la Clasificacion___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ClasificacionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'clasificacion:La Clasificacion debe ser Numero___';
			END IF;
		END IF;
		
		IF str_data[7] = '' THEN
			valor_retorno := ''||valor_retorno||'desesp:Es necesario ingresar la Descripcion en espa√±ol___';
		END IF;
	END IF;--termina validacion de Clasificacion de Cuentas(Cuentas de Mayor)

	--validacion de Catalogo de Agentes
	IF id_app=19 THEN
		--str_data[4]	id
		--str_data[5]	nombre_agente
		--str_data[6]	usuario_agente
		--str_data[7]	comision
		--str_data[8]	region
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'nombre:Es necesario ingresar el nombre completo del Agente___';
		END IF;
		
		IF str_data[6]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'user:Es necesario seleccionar un usuario para el Agente___';
		END IF;
		
		IF str_data[7] = '' OR str_data[7] = ' ' THEN
			valor_retorno := ''||valor_retorno||'comision:Es necesario ingresar la Comision___';
		ELSE
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ComisionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'comision:La Comision debe ser Numero___';
			END IF;
		END IF;
		
		IF str_data[8]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'region:Es necesario seleccionar una Region para el Agente___';
		END IF;
	END IF;--termina validacion de Catalogo de Agentes
	

	--validacion de Catalogo Clientes Clasificacion 1
	IF id_app=20 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from cxc_clie_clas1 where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina validacion Catalogo Clientes Clasificacion 1
	

	--validacion de Catalogo Clientes Clasificacion 2
	IF id_app=21 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from cxc_clie_clas2 where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina validacion Catalogo Clientes Clasificacion 2

	--validacion de Catalogo Clientes Clasificacion 3
	IF id_app=22 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from cxc_clie_clas3 where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina validacion Catalogo Clientes Clasificacion 3


	--validacion de Catalogo zonas de Clientes
        IF id_app=23 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxc_clie_zonas where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo zonas de clientes

        
        --validacion de Catalogo grupos de Clientes
        IF id_app=24 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxc_clie_grupos where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo grupos de clientes
	
	--validacion de Catalogo Proveedores Clasificacion 1
        IF id_app=25 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_clas1 where  titulo ilike '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Proveedores Clasificacion 1


        --validacion de Catalogo Proveedores Clasificacion 2
        IF id_app=26 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_clas2 where  titulo ilike '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Proveedores Clasificacion 2


        --validacion de Catalogo Proveedores Clasificacion 3
        IF id_app=27 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_clas3 where  titulo ilike '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Proveedores Clasificacion 3



	--validacion de Catalogo zonas de proveedores
        IF id_app=28 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_zonas where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Zonas de Proveedores
        

        --validacion de Catalogo grupo de proveedores
        IF id_app=29 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Clasificacion___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from cxp_prov_grupos where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo grupos de Proveedores
	
	
	
	/*
	str_data[1] 	app_selected
	str_data[2] 	command_selected
	str_data[3] 	id_usuario
	str_data[4]	id_factura+"___"+
	str_data[5]	id_proveedor+"___"+
	str_data[6]	tipo_factura+"___"+
	str_data[7]	observaciones.toUpperCase()+"___"+
	str_data[8]	factura+"___"+
	str_data[9]	expedicion+"___"+
	str_data[10]	tc+"___"+
	str_data[11]	denominacion+"___"+
	str_data[12]	numeroguia+"___"+
	str_data[13]	ordencompra+"___"+
	str_data[14]	fletera_id+"___"+
	str_data[15]	dias_credito_id+"___"+
	str_data[16]	flete;
	*/
	--facturas de proveedores
	IF id_app=30 THEN
		--RAISE EXCEPTION '%','campos_data: '||campos_data;
		--id_factura 	str_data[4]
		--id_proveedor	str_data[5] id_proveedor
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'rfcproveedor:Es necesario seleccionar un proveedor___';
		END IF;
		/*
		--factura	str_data[8]
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FacturaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
		END IF;
		*/
		--factura	str_data[8] expedicion
		IF str_filas[8] = ' ' OR str_data[8] = '' THEN
			valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
		END IF;
		/*
		--expedicion	str_data[9] expedicion
		IF str_filas[9] = ' ' OR str_data[9] = '' THEN
			valor_retorno := ''||valor_retorno||'expedicion:Es necesario seleccionar una fecha___';
		END IF;
		*/
		
		--denominacion	str_data[11] denominacion
		IF str_data[11]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'denominacion:Es necesario seleccionar una moneda___';
		END IF;
		
		--tipo cambio	str_data[10] tc
		IF str_filas[10] = ' ' OR str_data[10] = '' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		END IF;
		
		--observaciones	str_data[12]
		/*
		--str_data[14] fletera
		IF str_data[14] = '' THEN
			valor_retorno := ''||valor_retorno||'fletera:Es necesario seleccionar una compa√±ia___';
		END IF;
		*/
		--str_data[16] flete
		
		
		IF str_data[4] ='0' THEN
			IF str_data[8] != ' ' OR str_data[8] != '' THEN
				IF str_data[5] !='' THEN
					valida_integridad:=0;
					EXECUTE 'SELECT count(id) FROM cxp_facturas WHERE  cxc_prov_id='||str_data[5]||' AND serie_folio ilike '''||str_data[8]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'factura:La Factura ya se encuentra registrada___';
					END IF;
				END IF;
			END IF;
		END IF;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--eliminado	str_filas[9]
				IF str_filas[9]::integer <> 0 THEN--1: no esta eliminado, 0:eliminado
					--codigo_producto 	str_filas[1]
					IF trim(str_filas[1])='' THEN
						valor_retorno := ''||valor_retorno||'codigo'||cont_fila||':Es necesario ingresar el Codigo___';
					END IF;
					
					--descripcion_producto 	str_filas[2]
					IF trim(str_filas[2])='' THEN
						valor_retorno := ''||valor_retorno||'titulo'||cont_fila||':Es necesario ingresar la Descripcion___';
					END IF;
					
					--unidad 		str_filas[3]
					IF trim(str_filas[3])='' THEN
						valor_retorno := ''||valor_retorno||'unidad'||cont_fila||':Es necesario ingresar la Unidad___';
					END IF;
					
					--presentacion 		str_filas[4]
					--cantidad 		str_filas[5]
					IF trim(str_filas[5])='' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[5]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad debe ser mayor que cero___';
						END IF;
					END IF;
					
					--costo		str_filas[6]
					IF trim(str_filas[6])='' THEN
						valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el costo___';
					ELSE
						IF str_filas[6]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'costo'||cont_fila||':El costo debe ser mayor que cero___';
						END IF;
					END IF;

					
					--impuesto_id	str_filas[7]
					--valor_imp	str_filas[8]
					--eliminado	str_filas[9]
					--ieps_id	str_filas[10]
					--tasa_ieps	str_filas[11]
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;
	
	
	

	IF id_app=31 THEN
                                   --aplicacion
                                   --comando
                                   --usuario
                --str_data[4]        id
                --str_data[5]        titulo  topo mov
                --str_data[6]        descripcion descrip
                --str_data[7]        id_moneda
                
                IF str_data[5] = ''  THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del tipo de movimiento___';
                END IF;

                IF str_data[6] = ''  THEN
                        valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar el Titulo del tipo de movimiento___';
                END IF;
                
                IF str_data[4] = '0' THEN 
                        EXECUTE 'select count(id) from cxp_mov_tipos where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                        IF valida_integridad > 0 THEN
                                valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                        END IF;
                END IF;
        END IF;--termina validacion Catalogo tipos de movimientos de Proveedores
        
        
        IF id_app=32 THEN
                                   --aplicacion
                                   --comando
                                   --usuario
                --str_data[4]        id
                --str_data[5]        titulo  topo mov
                --str_data[6]        descripcion descrip
                --str_data[7]        id_moneda
                
                IF str_data[5] = ''  THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del tipo de movimiento___';
                END IF;
		
                IF str_data[6] = ''  THEN
                        valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar el Titulo del tipo de movimiento___';
                END IF;
                
                IF str_data[4] = '0' THEN 
                        EXECUTE 'select count(id) from cxc_mov_tipos where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                        IF valida_integridad > 0 THEN
                                valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                        END IF;
                END IF;
        END IF;--termina validacion Catalogo tipos de movimientos de clientes
	
	
	
	
	
	
	--validacion de Catalogo de tipos de movimientos inventario
	IF id_app=35 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	tipo
		--str_data[6]	descripcion
		--str_data[7]	mov_de_ajuste
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'tipo:Es necesario ingresar el titulo para el tipo de movimiento de inventario___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descripcion, para el tipo de movimiento de inventario___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM inv_mov_tipos WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false;' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'tipo:Ya existe un tipo de movimiento de inventario con el mismo nombre___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de Catalogo de tipos de movimientos inventario
	
	
	
	
	
	/*
	SELECT serie_folio FROM fac_docs WHERE id=100542
	SELECT count(serie_folio) FROM erp_pagos_detalles WHERE cancelacion=FALSE AND serie_folio='SEFAC22'
	SELECT count(serie_folio_factura) FROM fac_nota_credito WHERE serie_folio!='' AND cancelado=FALSE AND serie_folio_factura='SEFAC22'
	*/
	
	--Validacion de Cancelacion de Facturas
	IF id_app=36 THEN
		--str_data[4]	id_factura
		--str_data[5]	tipo_cancelacion
		--str_data[6]	motivo_cancelacion
		
		valor_retorno:='true';
		
		SELECT serie_folio FROM fac_docs WHERE id=str_data[4]::integer INTO serie_folio_fac;
		
		
		
		/*
		SELECT estatus FROM inv_osal WHERE folio_documento=serie_folio_fac AND tipo_documento=1 INTO estatus_osal;
		
		IF estatus_osal=2 THEN 
			IF str_data[5]::integer=1 THEN 
				valor_retorno := 'false___La marcanc&iacute;a se le dio salida del almacen, es necesario realizar una devoluci&oacute;n';
			END IF;
		END IF;
		*/
		
		--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
		IF upper(valor_retorno)='TRUE' THEN 
			--Verifica si hay pagos para la factura
			SELECT count(serie_folio) FROM erp_pagos_detalles WHERE cancelacion=FALSE AND serie_folio=serie_folio_fac INTO tiene_pagos;
			
			--Si tiene_pagos=0, tambien hay que checarsi no tiene notas de Credito aplicada a la factura
			IF tiene_pagos = 0 THEN
				SELECT count(serie_folio_factura) FROM fac_nota_credito WHERE serie_folio!='' AND cancelado=FALSE AND serie_folio_factura=serie_folio_fac INTO tiene_pagos;
				
				IF tiene_pagos > 0 THEN
					valor_retorno := 'false___La Factura '||serie_folio_fac||', tiene Notas de Credito aplicados.<br>Es necesario cancelar primeramente la Nota de Credito y despues cancelar la factura.';
				END IF;
			ELSE
				valor_retorno := 'false___La Factura '||serie_folio_fac||', tiene pagos aplicados.<br>Es necesario cancelar primeramente los pagos y despues cancelar la factura.';
			END IF;
			
		END IF;
		
		
	END IF;--termina validacion de Cancelacion de Facturas
	
	
	
	
	
	
	--validacion de Catalogo de invsecciones
	IF id_app=37 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		--str_data[7]	mov_de_ajuste
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para la seccion___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para la seccion___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM inv_secciones WHERE titulo ilike '''||str_data[5]||''' AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe una seccion con el mismo nombre___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de Catalogo de invsecciones
	
	
	--validacion de Catalogo inventario Marcas
	IF id_app=38 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion
		--str_data[6]	     estatus
		--str_data[7]	     url
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Marca___';
		END IF;
		
		IF str_data[7] = '' THEN
			valor_retorno := ''||valor_retorno||'url:Es necesario ingresar la url___';
		END IF;
		
		IF str_data[7] != '' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''isUrlCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'url:Url incorrecta___';
			END IF;	
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from inv_mar where  titulo ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion Catalogo inventario Marcas	
	
	
	--inicia Catalogo de inv_prod_lineas
	IF id_app=39 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		--str_data[7]	seccion
		--str_data[8]	marcas
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para la linea___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para la linea___';
		END IF;

		IF str_data[7] = '0'  THEN
			valor_retorno := ''||valor_retorno||'seccion:Es necesario seleccionar una seccion para la linea___';
		END IF;

		IF arreglo[1] = 'sin datos' THEN
			valor_retorno := ''||valor_retorno||'marca:Es necesario asignar porlomenos una marca para la linea___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM inv_prod_lineas WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe una linea con el mismo nombre___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina validacion de Catalogo de inv_prod_lineas
        
	
	
	
	 --validacion de Catalogo inventario Zonas de invetarios
	IF id_app=40 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion
		--str_data[6]	     estatus
		--str_data[7]	     zona
			
		IF str_data[7] = '' THEN				
			 valor_retorno := ''||valor_retorno||'zona:Es necesario ingresar la zona___';
		END IF;
		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la  descrpcion de la zona___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from inv_zonas where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'zona:La zona ingresada ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion Catalogo inventario Zonas	de inventarios





	--validacion de Catalogo de tes_mov_tipos
	IF id_app=41 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		--str_data[7]	grupo
		--str_data[8]	tipo
		--str_data[9]	conconsecutivo
		--str_data[10]	conciliacionautomatica
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para el tipo de movimiento___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para el tipo de movimiento___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM tes_mov_tipos WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe un tipo de movimiento con el mismo nombre___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina Catalogo tes_mov_tipos



	--validacion de Catalogo de tes_ban
	IF id_app=42 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		--str_data[7]	clave
		
		IF trim(str_data[5])='' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para el banco___';
		END IF;
		
		IF trim(str_data[6])='' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para el banco___';
		END IF;

		IF incluye_nomina THEN 
			IF trim(str_data[7])='' THEN
				valor_retorno := ''||valor_retorno||'clave:Es necesario ingresar la clave del Banco de acuerdo al catalogo del SAT.___';
			END IF;
		END IF;
		
		IF str_data[4] ='0' THEN
			IF trim(str_data[5])<>'' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM tes_ban WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe un banco con el mismo nombre___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina Catalogo tes_ban

	

	--validacion de Catalogo de Familias
	IF id_app=43 THEN
		--str_data[4] 	id
		--str_data[5] 	titulo
		--str_data[6] 	descripcion
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'familia:Es necesario ingresar el nombre de la Nueva Familia___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod_familias WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'familia:El nombre de la Familia ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de de Catalogo de Familias



	--validacion de Catalogo de Conceptos Bancarios(tes_con)
	IF id_app=44 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	descripcion
		
		IF str_data[5] = '' OR str_data[5] = ' ' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo para el concepto___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar una descriipcion para el concepto___';
		END IF;
		
		IF str_data[4] ='0' THEN
			IF str_data[5] != ' ' OR str_data[5] != '' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM tes_con WHERE titulo ilike '''||str_data[5]||''' and borrado_logico=false  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:Ya existe un concepto con el mismo nombre___';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina Catalogo tes_con
	
	
	
	--validacion de Catalogo producto grupos
        IF id_app=45 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        grupo
                --str_data[6]	     decripcion
                
		IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'grupo:Es necesario ingresar el grupo___';
		END IF;

                IF str_data[6] = ''  THEN
                        valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la  descripcion del grupo___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from inv_prod_grupos where  titulo ilike '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'grupo:El Grupo ingresado ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;              
                
        END IF;--termina validacion Catalogo producto grupos



	--validacion de Catalogo plazas en inventarios
        IF id_app=46 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        plaza
                --str_data[6]	     nombre
                --str_data[7]	     zonas
                --str_data[8]	     estatus
                
                IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'plaza:Es necesario ingresar la plaza___';
		END IF;

		IF str_data[7]::integer = 0 THEN				
			 valor_retorno := ''||valor_retorno||'zona:Es necesario elegir una zona___';
		END IF;
		
                IF str_data[6] = ''  THEN
                        valor_retorno := ''||valor_retorno||'nombre:Es necesario ingresar el nombre de la plaza___';
		ELSE
			IF str_data[4] = '0' THEN 
				EXECUTE 'select count(id) from gral_plazas where  titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'plaza:La plaza ingresada ya se encuentra en uso___';
				END IF;

				EXECUTE 'select count(id) from gral_plazas where  descripcion ilike '''||str_data[6]||''';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nombre:la descripcion de la plaza  ya se encuentra en uso__';
				END IF;
			END IF;
		END IF;
        END IF;--termina validacion Catalogo plazas en inventarios
	
	
	
	--validacion de Catalogo de inv_pre
	IF id_app=47 THEN
		SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		IF str_data[4] ='0' THEN
			IF str_data[5] != '0' THEN
				valida_integridad:=0;
				EXECUTE 'SELECT count(id) FROM inv_pre WHERE inv_prod_id='||str_data[5]::integer||' AND inv_prod_presentacion_id='||str_data[76]::integer||' AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'productosku:Ya existe una lista de precios para el producto con esta presentaci&oacute;n.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[5]	producto_id
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'productosku:Es necesario Seleccionar un producto___';
		END IF;
		
		--str_data[6]	lista1
		IF str_data[6] != '' THEN
			IF str_data[6]::double precision > 0 THEN
				--str_data[77]	select_moneda1
				IF str_data[77] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda1:Es necesario Seleccionar la Moneda para el Precio de la Lista 1.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[7]	lista2
		IF str_data[7] != '' THEN
			IF str_data[7]::double precision > 0 THEN
				--str_data[78]	select_moneda2
				IF str_data[78] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda2:Es necesario Seleccionar la Moneda para el Precio de la Lista 2.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[8]	lista3
		IF str_data[8] != '' THEN
			IF str_data[8]::double precision > 0 THEN
				--str_data[79]	select_moneda3
				IF str_data[79] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda3:Es necesario Seleccionar la Moneda para el Precio de la Lista 3.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[9]	lista4
		IF str_data[9] != '' THEN
			IF str_data[9]::double precision > 0 THEN
				--str_data[80]	select_moneda4
				IF str_data[80] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda4:Es necesario Seleccionar la Moneda para el Precio de la Lista 4.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[10]	lista5
		IF str_data[10] != '' THEN
			IF str_data[10]::double precision > 0 THEN
				--str_data[81]	select_moneda5
				IF str_data[81] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda5:Es necesario Seleccionar la Moneda para el Precio de la Lista 5.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[11]	lista6
		IF str_data[11] != '' THEN
			IF str_data[11]::double precision > 0 THEN
				--str_data[82]	select_moneda6
				IF str_data[82] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda6:Es necesario Seleccionar la Moneda para el Precio de la Lista 6.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[12]	lista7
		IF str_data[12] != '' THEN
			IF str_data[12]::double precision > 0 THEN
				--str_data[83]	select_moneda7
				IF str_data[83] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda7:Es necesario Seleccionar la Moneda para el Precio de la Lista 7.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[13]	lista8
		IF str_data[13] != '' THEN
			IF str_data[13]::double precision > 0 THEN
				--str_data[84]	select_moneda8
				IF str_data[84] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda8:Es necesario Seleccionar la Moneda para el Precio de la Lista 8.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[14]	lista9
		IF str_data[14] != '' THEN
			IF str_data[14]::double precision > 0 THEN
				--str_data[85]	select_moneda9
				IF str_data[85] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda9:Es necesario Seleccionar la Moneda para el Precio de la Lista 9.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[15]	lista10
		IF str_data[15] != '' THEN
			IF str_data[15]::double precision > 0 THEN
				--str_data[86]	select_moneda10
				IF str_data[86] = '0' THEN
					valor_retorno := ''||valor_retorno||'moneda10:Es necesario Seleccionar la Moneda para el Precio de la Lista 10.___';
				END IF;
			END IF;
		END IF;
		
		--str_data[76]	presentacion
		IF str_data[76] = '0' THEN
			valor_retorno := ''||valor_retorno||'presentacion:Es necesario seleccionar una Presentaci&oacute;n. Si no le muestra opciones tiene que ir al cat&aacute;logo de productos y asignar una presentaci&oacute;n.___';
		END IF;
		
		--str_data[77]	select_moneda1
		--str_data[78]	select_moneda2
		--str_data[79]	select_moneda3
		--str_data[80]	select_moneda4
		--str_data[81]	select_moneda5
		--str_data[82]	select_moneda6
		--str_data[83]	select_moneda7
		--str_data[84]	select_moneda8
		--str_data[85]	select_moneda9
		--str_data[86]	select_moneda10
		
	END IF;--termina Catalogo inv_pre



	--validacion de Catalogo de SubFamilias
	IF id_app=48 THEN
		--str_data[4] 	id
		--str_data[5] 	titulo
		--str_data[6] 	descripcion
		--str_data[7] 	select_familia
		
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'subfamilia:Es necesario ingresar el nombre de la Nueva Subfamilia___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		IF str_data[7]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'selfamilia:Es necesario Seleccionar una Familia___';
		END IF;
		
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod_familias WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE AND id!=identificador_familia_padre AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'subfamilia:El nombre de la Subfamilia ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de de Catalogo de SubFamilias
	
	
	--validacion Catalogo UNIDADES
	IF id_app=49 THEN
		--RAISE EXCEPTION '%' ,'str_data:'||str_data[5];
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'unidad:Es necesario ingresar la unidad___';
		END IF;
		IF str_data[6] = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion de la nueva unidad___';
		END IF;
		
		IF str_data[4] = '0' THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM inv_prod_unidades WHERE titulo_abr = '''||str_data[5]||'''   and borrado_logico=FALSE ' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'unidad:El nombre de la unidad ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion de de Catalogo de unidades



	

	
	--validacion de Catalogo Inventario Unidades
        IF id_app=50 THEN
                SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        titulo
                --str_data[6]	     descripcion
                IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'clasificacion:Es necesario ingresar la Clasificacion___';
		END IF;

		IF str_data[6] = '' THEN				
			 valor_retorno := ''||valor_retorno||'descripcion:Es necesario crear una descripcion para la Clasificacion___';
		ELSE
			IF str_data[4] = '0' THEN 
				--RAISE EXCEPTION '%','id de empleadooooooo???'||emp_id;
				EXECUTE 'select count(id) from inv_stock_clasificaciones where  titulo = '''||str_data[5]||''' and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'unidad:La unidad ingresada ya se encuentra en uso___';
				END IF;
				EXECUTE 'select count(id) from inv_stock_clasificaciones where  descripcion = '''||str_data[6]||'''  and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'descripcion:la descripcion de la unidad  ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
                
        END IF;--termina validacion Catalogo Inventario clasificacion stock
	
	
	
	
	--validacion de Catalogo de Comisiones
	--validacion de  Comisiones de arti-culos
	IF id_app=51 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id
		--str_data[5]	producto_id
		--str_data[6]	descripcion
		
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'productosku:Es necesario Seleccionar un producto___';
		END IF;

		IF str_data[6] = '' OR str_data[6] = ' ' THEN
			valor_retorno := ''||valor_retorno||'escala:Es necesario ingresar una escala___';
		END IF;
		
	END IF;--termina  Comisiones de arti-culos
	
	
	
	--validacion de Catalogo clasificacion
        IF id_app=52 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                --str_data[6]	     descripcion
                IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'clasificacion:Es necesario ingresar la Clasificacion___';
		END IF;
		
		IF str_data[6] = '' THEN				
			 valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		
		IF str_data[7] = '' THEN				
			 valor_retorno := ''||valor_retorno||'stock:Es necesario ingresar el stock de seguridad___';
		END IF;
		
		IF str_data[8] = '' THEN				
			 valor_retorno := ''||valor_retorno||'factor:Es necesario el factor de seguridad___';
		ELSE
			IF str_data[4] = '0' THEN 
				--RAISE EXCEPTION '%','id de empleadooooooo???'||emp_id;
				EXECUTE 'select count(id) from inv_clas where  titulo = '''||str_data[5]||''' and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'clasificacion:La clasificacion ingresada ya se encuentra en uso___';
				END IF;
				EXECUTE 'select count(id) from inv_clas where  descripcion = '''||str_data[6]||'''  and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'descripcion:la descripcion de la unidad  ya se encuentra en uso___';
				END IF;
				
				/*
				EXECUTE 'select count(id) from inv_clas where  stock_seguridad = '''||str_data[7]||'''  and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'stock:El stock de seguridad  ya se encuentra en uso___';
				END IF;
				
				EXECUTE 'select count(id) from inv_clas where  factor_maximo = '''||str_data[8]||'''  and  borrado_logico=false and gral_emp_id ='||emp_id INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'factor:El factor de seguridad  ya se encuentra en uso___';
				END IF;
				*/
			END IF;
		END IF;
                
        END IF;--termina validacion Catalogo Inventario clasificacion
	
	
	--validacion de  inv_pre_ofe
	IF id_app=53 THEN
		--str_data[4]	id
		--str_data[5]	producto_id
		--str_data[6]	descripcion
		
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'productosku:Es necesario Seleccionar un producto___';
		END IF;

		IF str_data[6] = '' OR str_data[6] = ' ' THEN
			valor_retorno := ''||valor_retorno||'fechainicial:Es necesario ingresar una fecha de inicio___';
		END IF;

		IF str_data[7] = '' OR str_data[7] = ' ' THEN
			valor_retorno := ''||valor_retorno||'fechafinal:Es necesario ingresar una fecha de final___';
		END IF;
		
	END IF;--termina  inv_pre_ofe
	
	
	
	
	--orden pre-subensambles
	IF id_app=55 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id
		--str_data[5]	folio
		--str_data[6]	observaciones
		--str_data[7]	select_almacen
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--eliminado	str_filas[10]
				IF str_filas[4]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--RAISE EXCEPTION '%','campos_data: '||str_filas[2];
					--cantidad	str_filas[2]
					--id_prod_grid	str_filas[3]
					--eliminado	str_filas[4]
					--select_pres	str_filas[5]
					
					IF cont_fila=1 THEN
						ids_subensamble:=ids_subensamble||str_filas[3];
					ELSE
						ids_subensamble:=ids_subensamble||','||str_filas[3];
					END IF;
					
					IF str_filas[2] = ' ' OR str_filas[2] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[3]||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[2]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[3]||':La cantidad debe ser mayor que cero___';
						END IF;
					END IF;
				END IF;
				
			END LOOP;
			
			
			--RAISE EXCEPTION '%','ids_subensamble: '||ids_subensamble;
			IF valor_retorno = '' THEN
				sql_select:='
				SELECT inv_kit.producto_kit_id AS id_prod_subensamble,
					inv_kit.producto_elemento_id, 
					inv_prod.sku,
					inv_kit.cantidad,
					(CASE WHEN inv_prod_presentaciones.id IS NULL THEN 0 ELSE inv_prod_presentaciones.id END) AS pres_def_id,
					(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
					(CASE WHEN inv_prod_unidades.decimales IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
				FROM inv_kit
				JOIN inv_prod ON inv_prod.id=inv_kit.producto_elemento_id
				LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod.inv_prod_presentacion_id
				LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				WHERE inv_kit.producto_kit_id IN ('||ids_subensamble||')
				ORDER BY producto_elemento_id';
				
				--RAISE EXCEPTION '%','sql_select: '||sql_select;
			
				primero:=0;
				componente_id:=0;
				sku_componente:='';
				suma_componente:=0;
				id_presentacion:=0;
				noDecUnidad:=0;
				
				FOR formulacion IN EXECUTE(sql_select) LOOP
					
					--Redondear la cantidad del producto componente
					formulacion.cantidad := round(formulacion.cantidad::numeric,formulacion.no_dec)::double precision;
					
					IF primero=0 THEN
						componente_id:=formulacion.producto_elemento_id;
						sku_componente:=formulacion.sku;
						id_presentacion:=formulacion.pres_def_id;
						noDecUnidad := formulacion.no_dec;
						primero:=1;
					END IF;
					
					IF componente_id = formulacion.producto_elemento_id THEN 
						total_filas:= array_length(arreglo,1);
						cont_fila:=1;
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
							--eliminado	str_filas[10]
							IF str_filas[4]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--RAISE EXCEPTION '%','campos_data: '||str_filas[2];
								--cantidad	str_filas[2]
								--id_prod_grid	str_filas[3]
								IF str_filas[3]::integer = formulacion.id_prod_subensamble THEN 
									suma_componente:=suma_componente + (formulacion.cantidad * str_filas[2]::double precision);
								END IF;
							END IF;
							
						END LOOP;
					ELSE
						--Redondear la cantidad del producto componente
						suma_componente := round(suma_componente::numeric,formulacion.no_dec)::double precision;
						
						--Llamada a proc que devuelve la existencia del producto. 
						--El tipo de busqueda de existencia es 1=Busqueda en el almacen que se le esta pasando como parametro
						--El valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
						SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, componente_id, usuario_id, str_data[7]::integer) INTO total_existencia; 

						--Redondear la existencia del producto componente
						total_existencia := round(total_existencia::numeric,formulacion.no_dec)::double precision;
						
						IF total_existencia<=0 THEN
							valor_retorno := ''||valor_retorno||'idprod_'||componente_id||':El Producto componente '||sku_componente||' tiene Existencia 0 en Almacen___';
						ELSE
							IF total_existencia < suma_componente THEN
								valor_retorno := ''||valor_retorno||'idprod_'||componente_id||':El Producto componente '||sku_componente||' tiene Existencia '||total_existencia||',  usted esta intentando utilizar '||suma_componente||'___';
							END IF;
						END IF;


						--Verificar si hay que validar existencias de Presentaciones
						IF controlExisPres=true THEN 
							exisActualPres:=0;
							
							IF id_presentacion > 0 THEN
								
								SELECT (CASE WHEN cantidad IS NULL THEN 0 ELSE cantidad END) FROM inv_prod_presentaciones WHERE id=id_presentacion INTO formulacion.cant_equiv;
								
								IF formulacion.cant_equiv > 0 THEN
									
									--Buscar la existencia actual de la Presentacion
									SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exi
									FROM inv_exi_pres 
									WHERE inv_alm_id=str_data[7]::integer 
									AND inv_prod_id=componente_id::integer 
									AND inv_prod_presentacion_id=id_presentacion::integer 
									INTO exisActualPres;
									
									IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
									
									IF exisActualPres > 0 THEN 
										--redondear la Existencia actual de Presentaciones
										exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision; 
										
										--convertir a su equivalencia en Presentacion, la cantidad del ultimo producto componente
										cantPresAsignado := suma_componente::double precision / formulacion.cant_equiv::double precision;
										
										--redondear la cantidad de Presentaciones Asignado en la partida
										cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
										
										IF exisActualPres::double precision < cantPresAsignado::double precision THEN
											valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':Disponibles='||exisActualPres||',  Produccion='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
										END IF;
									ELSE
										valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':No hay existencia en esta presentacion default del componente.___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':La equivalencia de la Presentacion debe ser mayor que cero.___';
								END IF;	
							ELSE
								valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':El Producto componente '||sku_componente||' no tiene presentacion default.___';
							END IF;			
						END IF;

						
						--toma nuevos valores
						componente_id:=formulacion.producto_elemento_id;
						sku_componente:=formulacion.sku;
						suma_componente:=0;
						id_presentacion:=formulacion.pres_def_id;
						noDecUnidad := formulacion.no_dec;
						
						total_filas:= array_length(arreglo,1);
						cont_fila:=1;
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
							--eliminado	str_filas[10]
							IF str_filas[4]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--RAISE EXCEPTION '%','campos_data: '||str_filas[2];
								--cantidad	str_filas[2]
								--id_prod_grid	str_filas[3]
								IF str_filas[3]::integer = formulacion.id_prod_subensamble THEN 
									suma_componente:=suma_componente + (formulacion.cantidad * str_filas[2]::double precision);
								END IF;
							END IF;
						END LOOP;
					END IF;
				END LOOP;
				
				
				--Redondear la cantidad del ultimo producto componente
				suma_componente := round(suma_componente::numeric,formulacion.no_dec)::double precision;
				
				--Llamada a proc que devuelve la existencia del producto. 
				--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
				--El valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
				SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, componente_id, usuario_id, str_data[7]::integer) INTO total_existencia;

				--Redondear la existencia del producto componente
				total_existencia := round(total_existencia::numeric,formulacion.no_dec)::double precision;
				
				IF total_existencia<=0 THEN
					valor_retorno := ''||valor_retorno||'idprod_'||componente_id||':El Producto componente '||sku_componente||' tiene Existencia 0 en Almacen___';
				ELSE
					IF total_existencia < suma_componente THEN
						valor_retorno := ''||valor_retorno||'idprod_'||componente_id||':El Producto componente '||sku_componente||' tiene Existencia '||total_existencia||',  usted esta intentando utilizar '||suma_componente||'___';
					END IF;
				END IF;

				--Verificar si hay que validar existencias de Presentaciones
				IF controlExisPres=true THEN 
					exisActualPres:=0;
					
					IF id_presentacion > 0 THEN
						--buscar la existencia actual de la Presentacion
						SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exi
						FROM inv_exi_pres 
						WHERE inv_alm_id=str_data[7]::integer 
						AND inv_prod_id=componente_id::integer 
						AND inv_prod_presentacion_id=id_presentacion::integer 
						INTO exisActualPres;
						
						IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
						
						IF exisActualPres > 0 THEN 
							--redondear la Existencia actual de Presentaciones
							exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision; 
							
							--buscar la equivalencia de la Presentacion
							SELECT cantidad  FROM inv_prod_presentaciones WHERE id=id_presentacion::integer 
							INTO equivalenciaPres;
							
							--convertir a su equivalencia en Presentacion, la cantidad del ultimo producto componente
							cantPresAsignado := suma_componente::double precision / equivalenciaPres::double precision;
							
							--redondear la cantidad de Presentaciones Asignado en la partida
							cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
							
							IF exisActualPres::double precision < cantPresAsignado::double precision THEN
								--RAISE EXCEPTION '%','id_presentacion: '||id_presentacion;
								valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':Disponibles='||exisActualPres||',  Produccion='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
							END IF;
						ELSE
							valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':No hay existencia en esta presentacion default del componente.___';
						END IF;
					ELSE
						valor_retorno := ''||valor_retorno||'presentacion_'||componente_id||':El Producto componente '||sku_componente||' no tiene presentacion default.___';
					END IF;
				END IF;
				
			END IF;
		ELSE
			valor_retorno := ''||valor_retorno||'subensambles:Es Necesario ingresar minimo un subensamble___';
		END IF;
		
	END IF;
	--termina orden subensambles
	
	
	
	
	--validacion Catalogo direcciones de proveedores
	IF id_app=56 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id                --str_data[5]        calle
		--str_data[6]	     codigoPostal      --str_data[7]        colonia
		--str_data[8]        entreCalles       --str_data[9]	     extDos
		--str_data[10]       extUno            --str_data[11]       numExterior
		--str_data[12]	     numInterior       --str_data[13]       proveedor
		--str_data[14]       id_estado         --str_data[15]	     id_municipio
		--str_data[16]       id_pais           --str_data[17]       telDos
		--str_data[18]	     telUno
		
		IF str_data[5] = '' THEN				
			 valor_retorno := ''||valor_retorno||'calle:Es necesario ingresar la calle___';
		END IF;
		
		IF str_data[6] = '' THEN					
			 valor_retorno := ''||valor_retorno||'codigoPostal:Es necesario ingresar el Codigo Postal___';
		END IF;

		IF str_data[7] = '' THEN				
			 valor_retorno := ''||valor_retorno||'colonia:Es necesario ingresar la colonia___';
		END IF;
		
		IF str_data[11] = '' THEN					
			 valor_retorno := ''||valor_retorno||'numExterior:Es necesario ingresar el numero exterior___';
		END IF;
		
		IF str_data[13]::integer = 0 THEN					
			 valor_retorno := ''||valor_retorno||'proveedor:Es necesario el nombre del proveedor___';
		END IF;
		
		IF str_data[14]::integer = 0 THEN					
			 valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado___';
		END IF;
		
		IF str_data[15]::integer = 0 THEN					
			 valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio___';
		END IF;
		
		IF str_data[16]::integer = 0 THEN					
			 valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pa√≠s___';
		END IF;
		
		IF str_data[18] = '' THEN				
			 valor_retorno := ''||valor_retorno||'telUno:Es necesario ingresar el Numero a Diez digitos___';
		END IF;

		IF str_data[18] != '' THEN				
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[18]||''' ~ '''||mask_general||''';' INTO match_cadena;
			--RAISE EXCEPTION '%','numeo de telefonooo::'||'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';';
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'telUno: Es necesario ingresar el Numero a Diez digitos___';
			END IF;
		END IF;
		
		IF str_data[6] != '' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CodigoPostalCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'codigoPostal:Codigo Postal No Valido___';
			END IF;
			
		
			IF str_data[10] != '' THEN				
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'extUno:Numero de Extension No Valido___';
				END IF;
			END IF;
			
			IF str_data[17] !='' THEN
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[17]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'teldos:Numero Telefonico no valido___';
				END IF;
			END IF;
			
			IF str_data[9]  != '' THEN				
				--valor_retorno := ''||valor_retorno||'extdos:Es necesario ingresar la extencion___';
				--ELSE
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'extDos:Numero de Extension No Valido___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion Catalogo direcciones de proveedores
	
	
	
	--Proceso de produccion de subensamble
	IF id_app=58 THEN
		--str_data[4]	id
		
		--Obtener el almacen de la para tomar las materias primas(es el mismo para destino de la produccion)
		select (CASE WHEN inv_alm_id IS NULL THEN 0 ELSE inv_alm_id END) AS alm_id from  inv_ord_subensamble 
		WHERE id=str_data[4]::integer
		INTO id_almacen;
		
		sql_select:='
		SELECT 
			comp_id_prod,
			sku, 
			comp_pres_def_id, 
			comp_equiv,
			comp_no_dec, 
			sum(comp_cant) AS comp_cant 
		FROM (
			SELECT 
				subensam_det.inv_prod_id_subensamble AS suben_id_prod, 
				subensam_det.cantidad AS suben_cant,
				inv_kit.producto_elemento_id AS comp_id_prod, 
				inv_prod.sku,
				(CASE WHEN pres_comp.id IS NULL THEN 0 ELSE pres_comp.id END) AS comp_pres_def_id,
				(CASE WHEN pres_comp.cantidad IS NULL THEN 0 ELSE pres_comp.cantidad END) AS comp_equiv,
				(CASE WHEN uni_comp.decimales IS NULL THEN 0 ELSE uni_comp.decimales END) AS comp_no_dec,
				(subensam_det.cantidad * inv_kit.cantidad) AS comp_cant 
			FROM inv_ord_subensamble_detalle AS subensam_det 
			JOIN inv_kit ON inv_kit.producto_kit_id=subensam_det.inv_prod_id_subensamble 
			JOIN inv_prod ON inv_prod.id=inv_kit.producto_elemento_id 
			LEFT JOIN inv_prod_presentaciones AS pres_comp ON pres_comp.id=inv_prod.inv_prod_presentacion_id 
			LEFT JOIN inv_prod_unidades AS uni_comp ON uni_comp.id=inv_prod.unidad_id 
			WHERE subensam_det.inv_ord_subensamble_id='||str_data[4]::integer||' 
		) AS sbt 
		GROUP BY comp_id_prod, sku, comp_pres_def_id, comp_equiv, comp_no_dec';
		
		FOR formulacion IN EXECUTE(sql_select) LOOP
			total_existencia:=0;
			
			--Llamada a proc que devuelve la existencia del producto componente.
			--El tipo de busqueda de existencia es 1=Busqueda en el almacen que se le esta pasando como parametro
			--El valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
			SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, formulacion.comp_id_prod, usuario_id, id_almacen) INTO total_existencia; 
			
			--Redondear el total de la existencia
			total_existencia := round(total_existencia::numeric,formulacion.comp_no_dec)::double precision;
			
			--Redondear la cantidad del producto componente
			formulacion.comp_cant := round(formulacion.comp_cant::numeric,formulacion.comp_no_dec)::double precision;
			
			IF total_existencia<=0 THEN
				valor_retorno := ''||valor_retorno||'cantidadcomp_'||formulacion.comp_id_prod||':El Producto componente '||formulacion.sku||' tiene Existencia 0 en Almacen___';
			ELSE
				IF total_existencia < formulacion.comp_cant THEN
					valor_retorno := ''||valor_retorno||'cantidadcomp_'||formulacion.comp_id_prod||':El Producto componente '||formulacion.sku||' tiene Existencia '||total_existencia||',  usted esta intentando utilizar '||formulacion.comp_cant||'___';
				END IF;
			END IF;
			
			
			--Verificar si hay que validar existencias de Presentaciones
			IF controlExisPres=true THEN 
				exisActualPres:=0;
				cantPresAsignado:=0;
				--Verificar qhe el producto componente que tenga asignado una presentacion default
				IF formulacion.comp_pres_def_id > 0 THEN
					--Verificar que la equivalencia de la presentacion default sea mayor que 0
					IF formulacion.comp_equiv > 0 THEN 
						--Buscar la existencia actual de la Presentacion del producto componente
						SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exi
						FROM inv_exi_pres 
						WHERE inv_alm_id=id_almacen::integer 
						AND inv_prod_id=formulacion.comp_id_prod::integer 
						AND inv_prod_presentacion_id=formulacion.comp_pres_def_id::integer 
						INTO exisActualPres;
						
						IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
						
						IF exisActualPres > 0 THEN 
							--redondear la Existencia actual de Presentaciones
							exisActualPres := round(exisActualPres::numeric,formulacion.comp_no_dec)::double precision; 
							
							--convertir a su equivalencia en Presentacion, la cantidad del ultimo producto componente
							cantPresAsignado := formulacion.comp_cant::double precision / formulacion.comp_equiv::double precision;
							
							--redondear la cantidad de Presentaciones Asignado en la partida
							cantPresAsignado := round(cantPresAsignado::numeric,formulacion.comp_no_dec)::double precision; 
							
							IF exisActualPres::double precision < cantPresAsignado::double precision THEN
								valor_retorno := ''||valor_retorno||'prescomp_'||formulacion.comp_id_prod||':Disponibles='||exisActualPres||',  Produccion='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
							END IF;
						ELSE
							valor_retorno := ''||valor_retorno||'prescomp_'||formulacion.comp_id_prod||':No hay existencia en esta presentacion default del componente.___';
						END IF;
					ELSE
						valor_retorno := ''||valor_retorno||'prescomp_'||formulacion.comp_id_prod||':La equivalencia de la Presentacion debe ser mayor que cero.___';
					END IF;	
				ELSE
					valor_retorno := ''||valor_retorno||'prescomp_'||formulacion.comp_id_prod||':El Producto componente '||formulacion.sku||' no tiene presentacion default.___';
				END IF;
				
			END IF;
			
		END LOOP;
		
	END IF;
	--Termina produccion de subensambles


	

		
	--validando campos de aplicativo tes chequera
	IF id_app=59 THEN
		--str_data[1]  app_selected                     str_data[11]  id_estado                         str_data[20]  nombre_sucursal
		--str_data[2]  command_selected			str_data[12]  id_moneda				str_data[21]  telefono1
		--str_data[3]  id_usuario			str_data[13]  id_banco				str_data[22]  extencion1
		--str_data[4]  id_chequera
		--str_data[5]  chequera				str_data[14]  chk_imprimir_chequeningles	str_data[23]  telefono2	
		--str_data[6]  chk_modificar_consecutivo 	str_data[15]  calle				str_data[24]  extencion2
		--str_data[7]  chk_modificar_fecha		str_data[16]  numero				str_data[25]  fax
		--str_data[8]  chk_modificar_cheque		str_data[17]  colonia				str_data[26]  gerente
		--str_data[9]  id_pais				str_data[18]  cp				str_data[27]  ejecutivo
		--str_data[10]  id_municipio			str_data[19]  numero_sucursal			str_data[28]  email;
		
		
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'chequera:Es necesario ingresar una chequera___';
		END IF;
		
		IF str_data[4]::integer = 0 THEN
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM tes_che WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'chequera:La Chequera ya se encuentra en uso___';
				END IF;
			END IF;
		END IF;
		
		
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'banco:Es necesario elegir un banco___';
		END IF;
		/*
		IF str_data[13] != '' THEN
			EXECUTE 'SELECT count(id) FROM tes_che WHERE tes_ban_id = '||str_data[13]||' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'banco:El banco elegido ya se encuentra en uso___';
			END IF;
		END IF;
		*/
		
		IF str_data[19]= '' THEN
			valor_retorno := ''||valor_retorno||'numero_sucursal:Es necesario Ingresar un numero para la sucursal___';
		END IF;
		/*
		IF str_data[19] != '' THEN
			EXECUTE 'SELECT count(id) FROM tes_che WHERE num_sucursal = '||str_data[19]||' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'numero_sucursal:El numero de la sucursal ya se encuentra registrado___';
			END IF;
		END IF;
		*/

		IF str_data[20]= '' THEN
			valor_retorno := ''||valor_retorno||'nombre_sucursal:Es necesario Ingresar nombre a la  sucursal___';
		END IF;

		/*
		IF str_data[20] != '' THEN
			EXECUTE 'SELECT count(id) FROM tes_che WHERE nombre_sucursal = '''||str_data[20]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'nombre_sucursal:El nombre de la sucursal ya se encuentra registrado___';
			END IF;
		END IF;
		*/
		IF str_data[15]= '' THEN
			valor_retorno := ''||valor_retorno||'calle:Es necesario Ingresar el nombre de la calle___';
		END IF;

		IF str_data[16]= '' THEN
			valor_retorno := ''||valor_retorno||'numero:Es necesario Ingresar el numero___';
		END IF;

		IF str_data[17]= '' THEN
			valor_retorno := ''||valor_retorno||'colonia:Es necesario Ingresar el nombre de la colonia___';
		END IF;

		IF str_data[18] = '' THEN
			valor_retorno := ''||valor_retorno||'codigo_postal:Error en el codigo Postal___';
		END IF;
		
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CodigoPostalCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[18]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'codigo_postal:Error en el codigo Postal___';
		END IF;

		IF str_data[9]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario elegir un Pais___';
		END IF;
		IF str_data[10]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario elegir un Municipio___';
		END IF;
		IF str_data[11]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'Estado:Es necesario elegir un Estado___';
		END IF;
		
		IF str_data[21] !='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[21]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:Numero Telefonico no valido___';
			END IF;
		END IF;
		
		
		IF str_data[22]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[22]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'ext1:Numero de Extension No Valido___';
			END IF;
		END IF;

		IF str_data[23] !='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[23]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel2:Numero Telefonico no valido___';
			END IF;
		END IF;
		
		IF str_data[24]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_NumeroExtensionCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[24]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'ext2:Numero de Extension No Valido___';
			END IF;
		END IF;
		
		IF str_data[25] !='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[25]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fax:Numero fax no valido___';
			END IF;
		END IF;
		--e-mail
		IF str_data[28] !='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_EmailCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[28]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo Electronico No Valido___';
			END IF;
		END IF;		
	END IF;
	--fin de la evaluacion de Tes chequera.





	--validacion de  pagos a proveedores
	IF id_app=60 THEN
		--str_data[4]	id_pago
		
		--str_data[5]	id_proveedor
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'idproveedor:Es necesario Seleccionar un Proveedor___';
		END IF;
		
		--str_data[6]	fecha_pago
		IF str_data[6] = '' OR str_data[6] = ' ' THEN
			valor_retorno := ''||valor_retorno||'fechapago:Es necesario ingresar la fecha de pago___';
		END IF;
		
		--str_data[7]	tipo_cambio
		IF str_data[7] = '' OR str_data[7] = ' ' THEN
			valor_retorno := ''||valor_retorno||'tipocambio:Es necesario ingresar el Tipo de Cambio.___';
		END IF;
		
		--str_data[8]	id_moneda
		IF str_data[8] = '0' THEN
			valor_retorno := ''||valor_retorno||'moneda:Es necesario Seleccionar la Moneda.___';
		END IF;
		
		--str_data[9]	forma_pago
		IF str_data[9] = '0' THEN
			valor_retorno := ''||valor_retorno||'formapago:Es necesario Seleccionar la Forma de Pago.___';
		END IF;
		
		
		IF str_data[9]<>'0' AND str_data[9]<>'1' AND str_data[9]<>'4'THEN	
			--str_data[10]	id_banco
			IF str_data[10] = '0' THEN
				valor_retorno := ''||valor_retorno||'bancoempresa:Es necesario Seleccionar la el Banco.___';
			END IF;
			
			--str_data[11]	id_no_cuenta
			IF str_data[11] = '0' THEN
				valor_retorno := ''||valor_retorno||'nocuenta:Es necesario Seleccionar la el Numero de Cuenta.___';
			END IF;
		END IF;
		
		/*
		--forma pago cheque
		IF str_data[9] = '2' THEN
			--str_data[12]	num_cheque
			IF str_data[12] = '' OR str_data[12] = ' ' THEN
				valor_retorno := ''||valor_retorno||'nocheque:Es necesario ingresar el Numero de Cheque.___';
			END IF;
		END IF;
		*/
		
		--forma pago Transferencia
		IF str_data[9] = '3' THEN
			--str_data[13]	referencia
			IF str_data[13] = '' OR str_data[13] = ' ' THEN
				valor_retorno := ''||valor_retorno||'referencia:Es necesario ingresar el la Referencia.___';
			END IF;
		END IF;
		
		--forma pago tarjeta
		IF str_data[9] = '4' THEN
			--str_data[14]	num_tarjeta
			IF str_data[14] = '' OR str_data[14] = ' ' THEN
				valor_retorno := ''||valor_retorno||'notarjeta:Es necesario ingresar el Numero de Tarjeta.___';
			END IF;
		END IF;
		
		--str_data[15]	monto_pago
		--str_data[16]	observaciones
		--str_data[17] concepto
		IF str_data[17] = '0' THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario Seleccionar el Concepto del Pago.___';
		END IF;
		
	END IF;--termina  validacion de  pagos a proveedores
	
	
	
	
	--validacion de  Anticipos a proveedores
	IF id_app=61 THEN
		--str_data[4]	id_anticipo
		
		--str_data[5]	id_proveedor
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'idproveedor:Es necesario Seleccionar un Proveedor___';
		END IF;
		
		--str_data[6]	id_moneda
		IF str_data[6] = '0' THEN
			valor_retorno := ''||valor_retorno||'moneda:Es necesario Seleccionar la Moneda.___';
		END IF;
		
		--str_data[7]	monto del anticipo
		IF str_data[7] <> ''  THEN
			IF str_data[7]::double precision < 1 THEN
				valor_retorno := ''||valor_retorno||'montoanticipo:El Monto del Anticipo debe ser mayor que cero.___';
			END IF;
		ELSE
			valor_retorno := ''||valor_retorno||'montoanticipo:Es necesario Ingresar el Monto del Anticipo.___';
		END IF;
		
		--str_data[8]	fecha_anticipo
		IF str_data[8] = '' OR str_data[8] = ' ' THEN
			valor_retorno := ''||valor_retorno||'fechaanticipo:Es necesario ingresar la fecha del Anticipo.___';
		END IF;
		
		--str_data[9]	observaciones
		
		--str_data[10]	forma_pago
		IF str_data[10] = '0' THEN
			valor_retorno := ''||valor_retorno||'formapago:Es necesario Seleccionar la Forma de Pago.___';
		END IF;
		
		--str_data[11]	id_banco
		IF str_data[11] = '0' THEN
			valor_retorno := ''||valor_retorno||'bancoempresa:Es necesario Seleccionar el Banco.___';
		END IF;
		
		--str_data[12]	id_chequera
		IF str_data[12] = '0' THEN
			valor_retorno := ''||valor_retorno||'nocuenta:Es necesario Seleccionar la Chequera.___';
		END IF;
		
		--forma pago Transferencia
		IF str_data[10] = '3' THEN
			--str_data[13]	referencia
			IF str_data[13] = '' OR str_data[13] = ' ' THEN
				valor_retorno := ''||valor_retorno||'referencia:Es necesario ingresar la Referencia.___';
			END IF;
		END IF;
		
		--str_data[14] concepto
		IF str_data[14] = '0' THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario Seleccionar el Concepto del Pago.___';
		END IF;
		
		/*
		--str_data[15] orden de compra
		IF str_data[15] = '0' THEN
			valor_retorno := ''||valor_retorno||'ardencompra:Es necesario Seleccionar la Orden de Compra para este Anticipo.___';
		END IF;
		*/
		
		--str_data[16]	tipo_cambio
		IF str_data[16] = '' OR str_data[16] = ' ' THEN
			valor_retorno := ''||valor_retorno||'tipocambio:Es necesario ingresar el Tipo de Cambio.___';
		END IF;
		
	END IF;--termina  validacion de  Anticipos a proveedores
	
	
	--validacion de  Parametros Anticipos a proveedores
	IF id_app=62 THEN
		--str_data[4]	identificador parametro
		
		--str_data[5]	id_sucursal
		IF str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'sucursal:Es necesario Seleccionar la Sucursal___';
		END IF;
		
		--str_data[6]	select movimiento anticipo
		IF str_data[6] = '0' THEN
			valor_retorno := ''||valor_retorno||'anticipo:Es necesario Seleccionar un Movimiento.___';
		END IF;
		
		--str_data[7]	select movimiento Aplicado Anticipo
		IF str_data[7] = '0' THEN
			valor_retorno := ''||valor_retorno||'aplanticipo:Es necesario Seleccionar un Movimiento.___';
		END IF;
		
		--str_data[8]	select movimiento Aplicado Factura
		IF str_data[8] = '0' THEN
			valor_retorno := ''||valor_retorno||'aplfactura:Es necesario Seleccionar un Movimiento.___';
		END IF;
		
		--str_data[9]	select movimiento Cancelacion
		IF str_data[9] = '0' THEN
			valor_retorno := ''||valor_retorno||'cancelacion:Es necesario Seleccionar un Movimiento.___';
		END IF;
		
		--validar integridad
		IF valor_retorno = '' AND str_data[4]='0' THEN
			--RAISE EXCEPTION '%','valor_retorno:'||valor_retorno;
			EXECUTE 'SELECT count(id) FROM cxp_ant_par WHERE borrado_logico=false AND cxp_mov_tipo_id='||str_data[6]||' AND gral_suc_id='||str_data[5]||' AND gral_emp_id='||emp_id INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'integridad:Ya existe un registro con &eacute;stos Par&aacute;metros para &eacute;sta Sucursal___';
			END IF;
		END IF;
		
	END IF;--termina  validacion de Parametros Anticipos a proveedores
	
	
	
	--Pedidos  de Clientes
	IF id_app=64 THEN
		--Obtener parametros para la facturacion
		--SELECT * FROM fac_par WHERE gral_suc_id=suc_id INTO facpar;
		
		--query para verificar si la Empresa actual incluye Modulo de Produccion
		SELECT incluye_produccion, control_exis_pres FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, controlExisPres;
		
		--tomar el id del almacen para ventas
		id_almacen := facpar.inv_alm_id;
		
		--str_data[3]	id_usuario
		--str_data[4]	id_pedido
		--str_data[5] 	id_cliente
		IF str_data[5]::integer < 1 THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un cliente___';
		END IF;

		-- trae la lista de precio del cliente------- str_data[5] idcliente
		select lista_precio from cxc_clie where id= str_data[5]::integer into num_lista_precio;

		
		--str_data[6]	select_moneda
		--str_data[7]	observaciones
		--str_data[8]	tipo_cambio
		IF str_data[8] = '' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		END IF;
		--str_data[9]	id_agente
		--str_data[10]	select_condiciones
		--str_data[11]	orden_compra
		
		--str_data[12]	fecha_compromiso
		IF str_data[12] = '' THEN
			valor_retorno := ''||valor_retorno||'fcompromiso:Es necesario ingresar la Fecha de Compromiso___';
		END IF;
		
		--str_data[13]	lugar_entrega
		--str_data[14]	transporte
		--str_data[15]	tasa_ret_immex
		--str_data[16]	select_metodo_pago
		--str_data[17]	no_cuenta
		
		--str_data[16]	id_metodo_pago
		--str_data[17]	no_cuenta
		IF str_data[16]::integer=2 OR str_data[16]::integer=3 THEN
			IF str_data[17]='' OR str_data[17]=' ' THEN
				valor_retorno := ''||valor_retorno||'nocuenta:Es necesario ingresar los ultimos 4 digitos de la tarjeta___';
			ELSE
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_DigitosTarjetaCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[17]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno|| 'nocuenta:Es necesario ingresar 4 digitos.___';
				END IF;
			END IF;
		END IF;

		
		IF empresa_transportista THEN
			--Aqui solo entra cuando la empresa es transportista
			IF str_data[22]='true' THEN
				--Aqui entra cuando el pedido es de flete.
				
				--str_data[23]	nombre_documentador
				--str_data[24]	valor_declarado
				--str_data[25]	select_tviaje
				--str_data[26]	remolque1
				--str_data[27]	remolque2
				--str_data[28]	id_vehiculo
				--str_data[29]	no_operador
				--str_data[30]	nombre_operador
				--str_data[31]	select_pais_origen
				--str_data[32]	select_estado_origen
				--str_data[33]	select_municipio_origen
				--str_data[34]	select_pais_dest
				--str_data[35]	select_estado_dest
				--str_data[36]	select_municipio_dest
				--str_data[37]	agena_id
				--str_data[38]	rem_id
				--str_data[39]	rem_dir_alterna
				--str_data[40]	dest_id
				--str_data[41]	dest_dir_alterna
				--str_data[42]	observaciones_transportista
				
				--str_data[23]	nombre_documentador
				IF str_data[23] = '' THEN
					valor_retorno := ''||valor_retorno||'documentador:Es necesario ingresar el nombre del Documentador.___';
				END IF;
				
				--str_data[24]	valor_declarado
				--str_data[25]	select_tviaje
				IF str_data[25]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'tviaje:Es necesario seleccionar el Tipo de Viaje..___';
				ELSE
					--str_data[26]	remolque1
					IF trim(str_data[26]) = '' THEN
						valor_retorno := ''||valor_retorno||'remolque1:Es necesario seleccionar ingresar el Remolque 1.___';
					END IF;
					
					IF str_data[25]::integer = 2 THEN
						--str_data[27]	remolque2
						IF trim(str_data[27]) = '' THEN
							valor_retorno := ''||valor_retorno||'remolque2:Es necesario seleccionar ingresar el Remolque 2.___';
						END IF;
					END IF;
				END IF;
				
				--str_data[28]	id_vehiculo
				IF str_data[28]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'noeconomico:Es necesario seleccionar una Unidad.___';
				END IF;
				
				--str_data[29]	no_operador
				--str_data[30]	nombre_operador
				IF trim(str_data[30]) = '' THEN
					valor_retorno := ''||valor_retorno||'operador:Es necesario ingresar el Nombre del Operador.___';
				END IF;
				
				--str_data[31]	select_pais_origen
				IF str_data[31]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'paisorig:Es necesario seleccionar el Pais Origen.___';
				END IF;
				
				--str_data[32]	select_estado_origen
				IF str_data[32]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'estadoorig:Es necesario seleccionar el Estado Origen.___';
				END IF;
				
				--str_data[33]	select_municipio_origen
				IF str_data[33]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'municipioorig:Es necesario seleccionar el Municipio Origen.___';
				END IF;
				
				--str_data[34]	select_pais_dest
				IF str_data[34]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'paisdest:Es necesario seleccionar el Pais Destino.___';
				END IF;
				
				--str_data[35]	select_estado_dest
				IF str_data[35]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'estadodest:Es necesario seleccionar el Estado Destino.___';
				END IF;
				
				--str_data[36]	select_municipio_dest
				IF str_data[36]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'municipiodest:Es necesario seleccionar el Municipio Destino.___';
				END IF;
				
				--str_data[37]	agena_id
				IF str_data[37]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'agenano:Es necesario seleccionar un Agente Aduanal.___';
				END IF;
				
				--str_data[38]	rem_id
				IF str_data[38]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'remid:Es necesario seleccionar un Remitente.___';
				END IF;
				
				--str_data[39]	rem_dir_alterna
				--str_data[40]	dest_id
				IF str_data[40]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'nodest:Es necesario seleccionar un Destinatario.___';
				END IF;
				
				--str_data[41]	dest_dir_alterna
				--str_data[42]	observaciones_transportista
			END IF;
		END IF;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					--str_filas[8]	valor_imp
					--str_filas[9]	noTr
					--str_filas[10]	seleccionado
					--str_filas[11]	unidad_medida
					--str_filas[12]	idIeps 
					--str_filas[13]	tasaIeps
					--str_filas[14]	vdescto
					--str_filas[15]	idcot
					--str_filas[16]	iddetcot
					--str_filas[17]	status_autorizacion
					--str_filas[18]	precio_autorizado
					--str_filas[19]	id_user_autoriza
					--str_filas[20]	reqauth
					--str_filas[21]	salvar_registro
					--str_filas[22]	retencion_id
					--str_filas[23]	retencion_tasa
					
					--str_filas[6]	cantidad
					IF trim(str_filas[6]) = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Es necesario ingresar la cantidad___';
					ELSE
						--Verificar que el campo sea numerico
						IF (SELECT trim(str_filas[6]) ~ '^([0-9]+[.]?[0-9]*|[.][0-9]+)$') THEN 
							
							--RAISE EXCEPTION '%',str_filas[6];
							IF str_filas[6]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':La cantidad debe ser mayor que cero___';
							ELSE
								--obtener el tipo de producto y el numero de Decimales Permitidos
								SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
								FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
								WHERE inv_prod.id=str_filas[3]::integer 
								INTO tipo, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
								
								--Tomamos la cantidad en la unidad de Venta seleccionada por el usuario
								cantUnidadVenta:=str_filas[6]::double precision;
								
								IF cambiaUnidadMedida THEN
									IF idUnidadMedida::integer<>str_filas[11]::integer THEN
										IF densidadProd IS NULL OR densidadProd=0 THEN
											densidadProd:=1;
										END IF;
										
										EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
										IF match_cadena=true THEN
											--Convertir a kilos
											str_filas[6] := str_filas[6]::double precision * densidadProd;
										ELSE
											EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
											IF match_cadena=true THEN
												--Convertir a Litros
												str_filas[6] := str_filas[6]::double precision / densidadProd;
											END IF;
										END IF;
									END IF;
								END IF;
								
								--Redondear la Cantidad
								str_filas[6] := round(str_filas[6]::numeric,noDecUnidad)::double precision; 
								cantUnidadVenta := round(cantUnidadVenta::numeric,noDecUnidad)::double precision; 
								
								--Si el tipo de producto es diferente de 4, hay que validar existencias
								--tipo=4 Servicios
								--para el tipo servicios no se debe validar existencias
								IF tipo<>4 THEN
									
									IF incluye_modulo_produccion=FALSE THEN
										--Aqui entra si la Empresa NO INCLUYE Modulo de Produccion
										--Se debe validar existencias de los productos tipo 1,2,5,6,7,8
										
										--tipo=1 Normal o Terminado
										--tipo=2 Subensable o Formulacion o Intermedio
										--tipo=5 Refacciones
										--tipo=6 Accesorios
										--tipo=7 Materia Prima
										--tipo=8 Prod. en Desarrollo
										IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=5 OR tipo::integer=6 OR tipo::integer=7 OR tipo::integer=8 THEN 
											--Llamada a proc que devuelve la existencia del producto. 
											--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
											--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
											SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, id_almacen) INTO total_existencia; 
											
											--Asignanos el total de la venta
											cantExisUnidadVenta:=total_existencia;
											
											IF cambiaUnidadMedida THEN
												IF idUnidadMedida::integer<>str_filas[11]::integer THEN
													EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
													IF match_cadena=true THEN
														--Convertir a litros la existencia para mostrar el warning
														cantExisUnidadVenta := cantExisUnidadVenta::double precision / densidadProd::double precision;
													ELSE
														EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
														IF match_cadena=true THEN 
															--Convertir a Kilos la existencia para mostrar el warning
															cantExisUnidadVenta := cantExisUnidadVenta::double precision * densidadProd::double precision;
														END IF;
													END IF;
												END IF;
											END IF;
											
											--si es diferente de cero estamos en editar
											IF str_filas[2]::integer > 0 THEN 
												--Buscamos la cantidad reservada anterior
												SELECT reservado FROM poc_pedidos_detalle WHERE id=str_filas[2]::integer INTO cant_reservada_anterior;
												
												--le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
												total_existencia := total_existencia::double precision + cant_reservada_anterior::double precision;
											END IF;
											
											--Redondear el total_existencia
											total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;

											/*
											IF total_existencia<=0 THEN
												valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen.___';
											ELSE
												IF total_existencia < str_filas[6]::double precision THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
												END IF;
											END IF;
											*/

											IF facpar.permitir_req_com THEN 
												--AQUI ENTRA CUANDO LA CONFIGURACION PERMITE GENERAR REQUISICION DE COMPRA
												--tipo=7 Materia Prima
												IF tipo::integer=7 THEN 
													--Seleccionado=0 indica que no se ha marcado para enviar a produccion la cantidad que falta
													IF str_filas[10]='0' THEN
														IF total_existencia < str_filas[6]::double precision THEN
															valor_retorno := ''||valor_retorno||'backorder:cantidad'||str_filas[9]||':'||cantExisUnidadVenta||'___';
														END IF;
														
														IF total_existencia<=0 THEN
															valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible=0,  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar una Requisici&oacute;n de Compra.___';
														ELSE
															IF total_existencia < str_filas[6]::double precision THEN
																valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible='||cantExisUnidadVenta||',  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar una Requisici&oacute;n de Compra.___';
															END IF;
														END IF;
													END IF;
												END IF;
												
												--Solo se debe validar existencias de productos tipo 5,6
												--tipo=5 Refacciones
												--tipo=6 Accesorios
												--IF tipo::integer=5 OR tipo::integer=6 THEN 
												IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=5 OR tipo::integer=6 OR tipo::integer=8 THEN 
													IF total_existencia<=0 THEN
														valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen.___';
													ELSE
														IF total_existencia < str_filas[6]::double precision THEN
															valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
														END IF;
													END IF;
												END IF;
											ELSE
												--AQUI ENTRA CUANDO LA CONFIGURACION NO PERMITE GENERAR REQUISICION DE COMPRA
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen.___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
													END IF;
												END IF;
											END IF;											
										END IF;
										
									ELSE
										--Aqui entra si la Empresa SI INCLUYE Modulo de Produccion
										--llamada a proc que devuelve la existencia del producto. 
										--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
										--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
										SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, id_almacen) INTO total_existencia; 
										--RAISE EXCEPTION '%','total_existencia: '||total_existencia;
										--Asignanos el total de la venta
										cantExisUnidadVenta:=total_existencia;
										
										IF cambiaUnidadMedida THEN
											IF idUnidadMedida::integer<>str_filas[11]::integer THEN
												EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
												IF match_cadena=true THEN
													--Convertir a litros la existencia para mostrar el warning
													cantExisUnidadVenta := cantExisUnidadVenta::double precision / densidadProd::double precision;
												ELSE
													EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
													IF match_cadena=true THEN 
														--Convertir a Kilos la existencia para mostrar el warning
														cantExisUnidadVenta := cantExisUnidadVenta::double precision * densidadProd::double precision;
													END IF;
												END IF;
											END IF;
										END IF;
										
										--Si es diferente de cero estamos en editar
										IF str_filas[2]::integer > 0 THEN 
											--buscamos la cantidad reservada anterior
											SELECT reservado FROM poc_pedidos_detalle WHERE id=str_filas[2]::integer INTO cant_reservada_anterior;
											--RAISE EXCEPTION '%','cant_reservada_anterior: '||cant_reservada_anterior;
											--le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
											total_existencia := total_existencia + cant_reservada_anterior;
										END IF;
										
										--Redondear el total_existencia
										total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
										
										--tipo=1 Normal o Terminado
										--tipo=2 Subensable o Formulacion o Intermedio
										--tipo=8 Prod. en Desarrollo
										IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=8 THEN 
											--seleccionado=0 indica que no se ha marcado para enviar a produccion la cantidad que falta
											IF str_filas[10]='0' THEN 
												IF total_existencia < str_filas[6]::double precision THEN
													valor_retorno := ''||valor_retorno||'backorder:cantidad'||str_filas[9]||':'||cantExisUnidadVenta||'___';
												END IF;
												
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible=0,  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar a producci&oacute;n.___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible='||cantExisUnidadVenta||',  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar a producci&oacute;n.___';
													END IF;
												END IF;
											END IF;
										END IF;
										
										--RAISE EXCEPTION '%','facpar.permitir_req_com: '||facpar.permitir_req_com;
										
										IF facpar.permitir_req_com THEN 
											--AQUI ENTRA CUANDO LA CONFIGURACION PERMITE GENERAR REQUISICION DE COMPRA
											--tipo=7 Materia Prima
											IF tipo::integer=7 THEN 

												--RAISE EXCEPTION '%','total_existencia: '||total_existencia||' < '||str_filas[6];
												
												--seleccionado=0 indica que no se ha marcado para enviar a produccion la cantidad que falta
												IF str_filas[10]='0' THEN
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'backorder:cantidad'||str_filas[9]||':'||cantExisUnidadVenta||'___';
													END IF;
													
													IF total_existencia<=0 THEN
														valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible=0,  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar una Requisici&oacute;n de Compra.___';
													ELSE
														IF total_existencia < str_filas[6]::double precision THEN
															valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':Disponible='||cantExisUnidadVenta||',  Pedido='||cantUnidadVenta||'. Seleccione la casilla para enviar una Requisici&oacute;n de Compra.___';
														END IF;
													END IF;
												END IF;
											END IF;
											
											--Solo se debe validar existencias de productos tipo 5,6
											--tipo=5 Refacciones
											--tipo=6 Accesorios
											IF tipo::integer=5 OR tipo::integer=6 THEN 
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
													END IF;
												END IF;
											END IF;
										ELSE
											--AQUI ENTRA CUANDO LA CONFIGURACION NO PERMITE GENERAR REQUISICION DE COMPRA
											--Solo se debe validar existencias de productos tipo 5,6,7
											--tipo=5 Refacciones
											--tipo=6 Accesorios
											--tipo=7 Materia Prima
											IF tipo::integer=5 OR tipo::integer=6 OR tipo::integer=7 THEN 
												IF total_existencia<=0 THEN
													valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El producto tiene Existencia 0 en Almacen___';
												ELSE
													IF total_existencia < str_filas[6]::double precision THEN
														valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles '||cantExisUnidadVenta||',  usted esta intentando vender '||cantUnidadVenta||'___';
													END IF;
												END IF;
											END IF;
										END IF;
										
									END IF;
									
									
									
									--verificar si hay que validar existencias de Presentaciones
									IF controlExisPres=true THEN 
										--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
										--TRUE = Validar presentaciones desde el Pedido
										--FALSE = No validar presentaciones desde el Pedido
										IF facpar.validar_pres_pedido=true THEN 
											--Buscar la existencia actual de la Presentacion
											SELECT (inicial::double precision + entradas::double precision - salidas::double precision -reservado::double precision) AS exi
											FROM inv_exi_pres WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=str_filas[3]::integer AND inv_prod_presentacion_id=str_filas[4]::integer 
											INTO exisActualPres;
											
											IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
											
											IF exisActualPres > 0 THEN 
												--Si es diferente de cero estamos en editar,por lo tanto hay que buscar la cantidad reservada anterior.
												IF str_filas[2]::integer > 0 THEN 
													--buscamos la cantidad reservada anterior
													SELECT (poc_pedidos_detalle.reservado::double precision / inv_prod_presentaciones.cantidad::double precision) AS cant_pres
													FROM poc_pedidos_detalle 
													JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=poc_pedidos_detalle.presentacion_id
													WHERE poc_pedidos_detalle.id=str_filas[2]::integer 
													INTO cantPresReservAnterior;
													
													--redondear la Cantidad de la Presentacion reservada Anteriormente
													cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
													
													--sumar la cantidad reservada anterior para tener la existencia real
													exisActualPres = exisActualPres::double precision + cantPresReservAnterior::double precision;
												END IF;
												
												--redondear la Existencia actual de Presentaciones
												exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision; 
												
												--buscar la equivalencia de la Presentacion
												SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_filas[4]::integer INTO equivalenciaPres;
												
												--convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
												cantPresAsignado := str_filas[6]::double precision / equivalenciaPres::double precision;
												
												--redondear la cantidad de Presentaciones Asignado en la partida
												cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
												
												IF exisActualPres::double precision < cantPresAsignado::double precision THEN
													IF incluye_modulo_produccion=true OR facpar.permitir_req_com=TRUE THEN 
														--Si incluye modulo de produccion √≥ la configuracion permite generar requisiciones cuando no hay exisencia
														IF incluye_modulo_produccion THEN 
															IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=8 THEN 
																IF str_filas[10]='0' THEN
																	valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
																END IF;
															END IF;
														END IF;
														--Si la configuracion permite generar requisiciones en automatico
														IF facpar.permitir_req_com THEN 
															IF tipo::integer=7 THEN 
																IF str_filas[10]='0' THEN
																	valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
																END IF;
															END IF;
														END IF;
														
														IF tipo::integer=5 OR tipo::integer=6 THEN 
															valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
														END IF;
														
													ELSE 
														valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':Disponibles='||exisActualPres||',  Venta='||cantPresAsignado||'. No hay existencia suficiente en esta presentacion.___';
													END IF;
												END IF;
											ELSE 
												IF incluye_modulo_produccion=true OR facpar.permitir_req_com=TRUE THEN 
													--Si incluye modulo de produccion √≥ la configuracion permite generar requisiciones cuando no hay exisencia
													
													IF incluye_modulo_produccion THEN 
														IF tipo::integer=1 OR tipo::integer=2 OR tipo::integer=8 THEN 
															IF str_filas[10]='0' THEN
																valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':No hay existencia en esta presentacion.___';
															END IF;
														END IF;
													END IF;

													IF facpar.permitir_req_com THEN 
														IF tipo::integer=7 THEN 
															IF str_filas[10]='0' THEN
																valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':No hay existencia en esta presentacion.___';
															END IF;
														END IF;
													END IF;
													
													IF tipo::integer=5 OR tipo::integer=6 THEN 
														valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':No hay existencia en esta presentacion.___';
													END IF;
												ELSE 
													valor_retorno := ''||valor_retorno||'presentacion'||str_filas[9]||':No hay existencia en esta presentacion.___';
												END IF;
											END IF;
										END IF;
										
									END IF;
								END IF;
							END IF;
						ELSE
							--Aqui entra porque el campo cantidad trae un valor no numerico
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[9]||':El valor para Cantidad es incorrecto, tiene mas de un punto('||str_filas[6]||')___';
						END IF;
					END IF;
					
					
					--str_filas[7]	costo
					IF trim(str_filas[7]) = '' THEN
						valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':Es necesario ingresar el precio unitario___';
					ELSE
						--Verificar que el campo sea numerico
						IF (SELECT trim(str_filas[7]) ~ '^([0-9]+[.]?[0-9]*|[.][0-9]+)$') THEN 
							IF str_filas[7]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':El precio debe ser mayor que cero___';
							ELSE
								IF num_lista_precio > 0 THEN
									--sacando el descuento y precio del producto de acuerdo a la presentacion seleccionada
									sql_select:='SELECT (CASE WHEN descuento_'||num_lista_precio||' IS NULL THEN 0 ELSE descuento_'||num_lista_precio||' END ),inv_pre.precio_'||num_lista_precio||', (CASE WHEN inv_pre.gral_mon_id_pre'||num_lista_precio||' IS NULL THEN 0 ELSE inv_pre.gral_mon_id_pre'||num_lista_precio||' END) FROM inv_pre where inv_prod_id='||str_filas[3]||' AND inv_prod_presentacion_id='||str_filas[4]||' AND borrado_logico=false;';
									
									--RAISE EXCEPTION '%',sql_select;
									EXECUTE sql_select INTO descuento_producto, precio_producto, mon_prec_prod;
									
									IF descuento_producto IS NULL THEN
										descuento_producto:=0;
									END IF;
									
									IF precio_producto IS NULL THEN
										precio_producto:=0;
									ELSE
										IF str_data[6]::integer <> mon_prec_prod::integer THEN 
											/*
											IF mon_prec_prod::integer > 0 THEN 
												SELECT valor FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=mon_prec_prod ORDER BY momento_creacion DESC LIMIT 1 INTO tc_mon_prod;
											ELSE
												tc_mon_prod:=0;
											END IF;
											*/
											
											IF str_data[6]::integer=1 AND mon_prec_prod::integer<>1 THEN 
												--si la moneda del pedido es pesos y la moneda del precio es diferente de Pesos,
												--entonces calculamos su equivalente a pesos
												precio_producto:= precio_producto * str_data[8]::double precision;
											END IF;

											IF str_data[6]::integer<>1 AND mon_prec_prod::integer=1 THEN 
												--si la moneda del Pedido es Diferente de Pesos y la moneda del precio es Pesos,
												--entonces calculamos su equivalente a dolar
												precio_producto:= precio_producto / str_data[8]::double precision;
											END IF;

											--tc str_data[8]
										END IF;
									END IF;
									
									--redondear a 4 digitos el precio del producto
									precio_producto:=round((precio_producto)::numeric, 4)::double precision;
									
									--RAISE EXCEPTION '%',num_lista_precio;
									--obteniendo el valor del descuento
									descuento := ((descuento_producto::double precision/100) * precio_producto);
									--redondear a 4 digitos el descuento
									descuento:=round((descuento)::numeric, 4)::double precision;
									
									--precio minimo
									precio_minimo := precio_producto - descuento;
									
									--redondear a 4 digitos el Precio Minimo
									precio_minimo := round((precio_minimo)::numeric,4)::double precision;

									--RAISE EXCEPTION '%', 'PrecioVista:'||round(str_filas[7]::numeric,4)::double precision||'\nPrecioMinimo:'||precio_minimo;
									
									IF round(str_filas[7]::numeric,4)::double precision < precio_minimo THEN
										--valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':No puede ser asignado este precio.___';
										
										--Verificar si la configuraci√≥n permite la autorizacion de precios abajo de la lista de precio en pedidos
										if facpar.aut_precio_menor_ped then 
											
											--Verificar si hay que salvar aun cuando hay precios no autorizados
											if str_filas[21]::boolean=false then 
												
												--Verificar si est√° autorizado el precio menor
												if str_filas[17]::boolean then 
													
													--RAISE EXCEPTION '%','str_filas[6]:'||str_filas[6]||'     str_filas[13]:'||str_filas[13];
													
													--Verificar si el precio no es menor al precio autorizado
													if round(str_filas[7]::numeric,4)::double precision < round(str_filas[18]::numeric,4)::double precision then 
														valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':El Precio es menor al autorizado '||str_filas[18]||'.___';
														valor_retorno := ''||valor_retorno||'checkauth'||str_filas[9]||':true.___';
													else
														--Verificar si el precio autorizado no es menor al precio_minimo de venta
														sql_select := '
														SELECT 
															sbt.prod_id,
															sbt.pres_id,
															sbt.moneda_id, 
															(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS pmin  
														FROM (
															SELECT 
																inv_prod.id AS  prod_id,
																inv_prod_pres_x_prod.presentacion_id AS pres_id,
																(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
																(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
																(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
																(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic, 
																(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
																(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
																(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
															FROM inv_prod 
															JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
															JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
															LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
															LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
															WHERE inv_prod.borrado_logico=false AND inv_prod_cost_prom.ano='||ano_actual||' AND inv_prod.id='||str_filas[3]||' AND inv_prod_pres_x_prod.presentacion_id='||str_filas[4]||'  
														) AS sbt LIMIT 1;';
														
														--RAISE EXCEPTION '%','sql_select: '||sql_select;
														
														FOR record1 IN EXECUTE (sql_select) LOOP 
															IF str_data[6]::integer <> record1.moneda_id::integer THEN 
																IF str_data[6]::integer=1 AND record1.moneda_id<>1 THEN 
																	--si la moneda del pedido es pesos y la moneda del Costo es diferente de Pesos,
																	--entonces calculamos su equivalente a pesos
																	record1.pmin:= record1.pmin * str_data[8]::double precision;
																END IF;
																
																IF str_data[6]::integer<>1 AND record1.moneda_id=1 THEN 
																	--si la moneda del Pedido es Diferente de Pesos y la moneda del Costo es Pesos,
																	--entonces calculamos su equivalente a dolar
																	record1.pmin:= record1.pmin / str_data[8]::double precision;
																END IF;
															end if;

															record1.pmin:=round(record1.pmin::numeric,4)::double precision;

															--RAISE EXCEPTION '%','str_filas[6]:'||str_filas[6]||'     record1.pmin:'||record1.pmin;
															
															IF round(str_filas[7]::numeric, 4)::double precision < record1.pmin THEN 
																valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':El Precio es menor al costo '||record1.pmin||'.___';
															end if;
														END LOOP;
													end if;
												else
													valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':No puede ser asignado este precio.___';
													valor_retorno := ''||valor_retorno||'checkauth'||str_filas[9]||':true.___';
												end if;
											end if;
										else
											valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':No puede ser asignado este precio.___';
										end if;
										
									END IF;	
								END IF;
								--RAISE EXCEPTION '%',descuento;
							END IF;
						ELSE
							--Aqui entra porque el campo cantidad trae un valor no numerico
							valor_retorno := ''||valor_retorno||'costo'||str_filas[9]||':El valor para Precio Unitario es incorrecto, tiene mas de un punto('||str_filas[7]||')___';
						END IF;
					END IF;
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--termina pedidos
	
	
	--Autorizacion de Pedidos de Clientes
	IF id_app=65 THEN 
		IF command_selected = 'autorizar' THEN 
			--str_data[4]::integer
			--Verificar si la configuraci√≥n permite la autorizacion de precios abajo de la lista de precio en pedidos
			if facpar.aut_precio_menor_ped then 
				if (select count(id) from poc_pedidos_detalle where poc_pedido_id=str_data[4]::integer and requiere_aut=true and autorizado=false)>0 then 
					valor_retorno := ''||valor_retorno||'checkauth:No es posible autorizar el pedido porque hay precios por debajo de la lista.<br>Regrese a la parte de edici&oacute;n del Pedido para pedir la autorizaci&oacute;n.___';
				end if;
			end if;
			--RAISE EXCEPTION '%','valor_retorno:'||valor_retorno;
		end if;
		
	END IF;--termina Autorizacion de Pedidos
	
	
	
	--Validacion de Remisiones
	IF id_app=66 THEN
		IF trim(str_data[5]) = ''  THEN
			--valor_retorno := ''||valor_retorno||'oc:Es necesario el Numero de la Orden de Compra.___';
		END IF;
	END IF;
	--Termina validacion de Remsiones
	

	
	
	
	--SQL PARA VALIDAR PRODUCCION
	--validacion de proceso de produccion
	IF id_app=67 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion
		--str_data[5]        id_producto
		--str_data[7]        dias_caducidad
		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo del proceso___';
		END IF;
		
		IF str_data[6] = '' or str_data[6] = '0'  THEN
			valor_retorno := ''||valor_retorno||'sku:Es necesario seleccionar un producto___';
		END IF;
		
		IF str_data[7]::integer <= 0  THEN
			valor_retorno := ''||valor_retorno||'dias:El numero de dias de caducidad debe ser mayor que cero.___';
		END IF;
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		IF total_filas < 1 THEN
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un subproceso___';
		END IF;
		
		IF str_data[4] = '0' THEN 
			--EXECUTE 'select count(id) from inv_prod_presentaciones where  titulo ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			--IF valida_integridad > 0 THEN
			--	valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
			--END IF;
		END IF;
	END IF;--termina validacion de proceso de produccion
	
	
	
	
	--validacion de Catalogo inventario presentaciones
	IF id_app=68 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion
		--str_data[6]        cantidad
		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el titulo de la presentacion___';
		END IF;
		
		IF trim(str_data[6]) = ''  THEN
			valor_retorno := ''||valor_retorno||'cant:Es necesario ingresar la Cantidad de la equivalencia de la Presentacion.___';
		ELSE
			IF str_data[6]::double precision <=0  THEN
				valor_retorno := ''||valor_retorno||'cant:La equivalencia debe ser mayor que cero.___';
			ELSE
				--Verificar si hay que validar existencias de Presentaciones
				IF controlExisPres=true THEN 
					IF trim(str_data[5])<>''  THEN
						SELECT count(id) FROM inv_prod_unidades WHERE titulo ILIKE '%'||str_data[5]||'%' AND borrado_logico=FALSE INTO exis;
						
						IF exis > 0 THEN 
							IF str_data[6]::double precision > 1  THEN
								valor_retorno := ''||valor_retorno||'cant:La equivalencia debe ser igual a 1.___';
							END IF;
						END IF;
					END IF;
				END IF;
			END IF;
		END IF;
		
		IF str_data[4] = '0' THEN 
			EXECUTE 'select count(id) from inv_prod_presentaciones where  titulo ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
			END IF;
		END IF;
		
	END IF;--termina validacion Catalogo inventario presentaciones	
	
	
	
	
	--validacion de proceso de formulas
	IF id_app=69 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  id_prod_master
		--str_data[6]  inv_prod_id
		--str_data[7]  nivel
		--str_data[8]  producto_elemento_id
		--str_data[9]  cantidad
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		
		
		IF str_data[5] = '' or str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'id_prod_master:Es necesario seleccionar un producto';
		END IF;
		
		IF str_data[6] = '' or str_data[6] = '0'  THEN
			valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto de salida___';
		END IF;
		
		IF str_data[7] = '' or str_data[7] = '0'  THEN
			valor_retorno := ''||valor_retorno||'paso_actual:Es necesario ingresar un numero de paso___';
		END IF;
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		IF total_filas < 1 THEN
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto en la configuracion___';
		END IF;
		
		IF str_data[4] = '0' THEN 

			IF str_data[6] = '' or str_data[6] = '0'  THEN
				valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto___';
			ELSE
				EXECUTE 'select count(id) from pro_estruc where inv_prod_id='||str_data[6]::integer||' and borrado_logico=false and gral_emp_id='||emp_id||';' INTO valida_integridad;
				--EXECUTE 'select count(id) from pro_estruc_det where  inv_prod_id_salida='||str_data[6]::integer||'  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'inv_prod_id:El producto de salida seleccionado, ya tiene un proceso___';
				END IF;
			END IF;
		END IF;
		
		
		-- validaciones para el grid --
		IF arreglo[1] != 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				----aqui se vuelven a crear los registros
				IF str_filas[4] != '0' THEN
					
					--VALIDACION PARA  EL GRID
					IF str_filas[2] = ' ' OR str_filas[2] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[2]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':La cantidad debe ser mayor a cero___';
						END IF;
					END IF;
					
					--para validar el numero de paso--
					IF str_filas[3] = ' ' OR str_filas[3] = '' THEN
						valor_retorno := ''||valor_retorno||'posicion'||str_filas[5]||':Es necesario ingresar la posicion___';
					ELSE
						IF str_filas[3]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'posicion'||str_filas[5]||':La posicion debe ser mayor a cero___';
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la configuracion___';
		END IF;
		
	END IF;--termina validacion de proceso de formulas





	--validacion de Aplicativo Notas de Credito
	IF id_app=70 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		
		--str_data[4]	identificador
		--str_data[5]	id_cliente
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones
		--str_data[9]	select_moneda
		--str_data[10]	select_vendedor
		--str_data[11]	concepto
		--str_data[12]	tipo_cambio
		--str_data[13]	importe
		--str_data[14]	impuesto
		--str_data[15]	retencion
		--str_data[16]	total
		--str_data[17]	factura
		
		IF str_data[5] = '0'  THEN
			valor_retorno := ''||valor_retorno||'rfccliente:Es necesario seleccionar un Cliente___';
		END IF;

		IF str_data[11] = ''  THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario el Concepto para la Nota de Credito___';
		END IF;

		IF str_data[12] = ''  THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario el tipo de Cambio___';
		END IF;

		IF str_data[13]='' OR str_data[13]='0' OR str_data[13]='0.00' THEN
			valor_retorno := ''||valor_retorno||'importe:Es necesario el Importe para la Nota de Credito___';
		END IF;
		
		IF str_data[17] = ''  THEN
			valor_retorno := ''||valor_retorno||'factura:Es necesario seleccionar una Factura___';
		END IF;
	END IF;--termina validacion de Aplicativo Notas de Credito


	
	
	
	
	--validacion de Catalogo de vehiculos
	IF id_app=73 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id
		--str_data[5]	select_tipo_unidad
		--str_data[6]	select_clase
		--str_data[7]	select_marca
		--str_data[8]	select_anio
		--str_data[9]	color
		--str_data[10]	no_economico
		--str_data[11]	select_tipo_placa
		--str_data[12]	placas
		--str_data[13]	no_serie
		--str_data[14]	select_tipo_rodada
		--str_data[15]	select_tipo_caja
		--str_data[16]	cap_volumen
		--str_data[17]	cap_peso
		--str_data[18]	select_clasif2
		--str_data[19]	id_prov
		--str_data[20]	id_operador
		--str_data[21]	comentarios
		
		
		IF str_data[5]=''  THEN
			valor_retorno := ''||valor_retorno||'tipounidad:Es necesario seleccionar el Tipo de Unidad.___';
		ELSE
			IF str_data[5]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'tipounidad:Es necesario seleccionar el Tipo de Unidad.___';
			END IF;
		END IF;

		IF str_data[6]=''  THEN
			valor_retorno := ''||valor_retorno||'clase:Es necesario seleccionar la Clase de Unidad.___';
		ELSE
			IF str_data[6]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'clase:Es necesario seleccionar la Clase de Unidad.___';
			END IF;
		END IF;	
		
		IF str_data[7]=''  THEN
			valor_retorno := ''||valor_retorno||'marca:Es necesario seleccionar la Marca.___';
		ELSE
			IF str_data[7]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'marca:Es necesario seleccionar la Marca.___';
			END IF;
		END IF;
		
		IF str_data[8]=''  THEN
			valor_retorno := ''||valor_retorno||'anio:Es necesario seleccionar el A&ntilde;o.___';
		ELSE
			IF str_data[8]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'anio:Es necesario seleccionar el A&ntilde;o.___';
			END IF;
		END IF;

		/*
		IF trim(str_data[9]) = ''  THEN
			valor_retorno := ''||valor_retorno||'color:Es necesario ingresar el Color de la Unidad.___';
		END IF;

		IF trim(str_data[10]) = ''  THEN
			valor_retorno := ''||valor_retorno||'noeconomico:Es necesario ingresar el No. Economico.___';
		END IF;
		*/

		IF str_data[11]=''  THEN
			valor_retorno := ''||valor_retorno||'tplaca:Es necesario seleccionar el Tipo de Placa.___';
		ELSE
			IF str_data[11]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'tplaca:Es necesario seleccionar el Tipo de Placa.___';
			END IF;
		END IF;

		IF trim(str_data[12]) = ''  THEN
			valor_retorno := ''||valor_retorno||'placa:Es necesario ingresar la Placa de la Unidad.___';
		END IF;

		IF trim(str_data[13]) = ''  THEN
			valor_retorno := ''||valor_retorno||'noserie:Es necesario ingresar el Numero de Serie de la Unidad.___';
		END IF;
		
		IF str_data[14]=''  THEN
			valor_retorno := ''||valor_retorno||'trodada:Es necesario seleccionar el Tipo de Rodada.___';
		ELSE
			IF str_data[14]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'trodada:Es necesario seleccionar el Tipo de Rodada.___';
			END IF;
		END IF;
		
		IF str_data[15]=''  THEN
			valor_retorno := ''||valor_retorno||'tcaja:Es necesario seleccionar el Tipo de Caja.___';
		ELSE
			IF str_data[15]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'tcaja:Es necesario seleccionar el Tipo de Caja.___';
			END IF;
		END IF;
		
		IF str_data[16]=''  THEN
			valor_retorno := ''||valor_retorno||'volumen:Es necesario ingresar una cantidad para la Capacidad en metros cubicos.___';
		ELSE
			IF str_data[16]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'volumen:La Capacidad en metros cubicos debe ser mayor a cero.___';
			END IF;
		END IF;
		
		IF str_data[16]=''  THEN
			valor_retorno := ''||valor_retorno||'peso:Es necesario ingresar una cantidad para la Capacidad Peso en toneladas.___';
		ELSE
			IF str_data[16]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'peso:La Capacidad peso en toneladas debe ser mayor a cero.___';
			END IF;
		END IF;
		
		--str_data[18]	select_clasif2
		IF str_data[18]::integer=1 THEN 
			--str_data[19]	id_prov
			IF str_data[19]=''  THEN
				valor_retorno := ''||valor_retorno||'notrans:Es necesario seleccionar el proveedor transportista.___';
			ELSE
				IF str_data[19]::integer=0  THEN
					valor_retorno := ''||valor_retorno||'notrans:Es necesario seleccionar el proveedor transportista.___';
				END IF;
			END IF;
		END IF;
		
		/*
		--str_data[20]	id_operador
		IF str_data[20]=''  THEN
			valor_retorno := ''||valor_retorno||'nooperador:Es necesario seleccionar el Operador de la Unidad.___';
		ELSE
			IF str_data[20]::integer=0  THEN
				valor_retorno := ''||valor_retorno||'nooperador:Es necesario seleccionar el Operador de la Unidad.___';
			END IF;
		END IF;
		*/
		IF trim(str_data[12])<>''  THEN
			valida_integridad:=0;
			EXECUTE 'select count(id) from log_vehiculos where placa ilike '''||str_data[12]||''' and borrado_logico=false and gral_emp_id='||emp_id||';' 
			INTO valida_integridad;
			IF valida_integridad > 0 THEN 
				valida_integridad:=0;
				EXECUTE 'select id from log_vehiculos where placa ilike '''||str_data[12]||''' and borrado_logico=false and gral_emp_id='||emp_id||' limit 1;'
				INTO valida_integridad;
				IF valida_integridad<>str_data[4]::integer THEN 
					valor_retorno := ''||valor_retorno||'placa:La Placa ingresada ya se ecuentra registrada para otra Unidad.___';
				END IF;
			END IF;
		END IF;
		
		IF trim(str_data[13])<>''  THEN
			valida_integridad:=0;
			EXECUTE 'select count(id) from log_vehiculos where numero_serie ilike '''||str_data[13]||''' and borrado_logico=false and gral_emp_id='||emp_id||';' 
			INTO valida_integridad;
			IF valida_integridad > 0 THEN 
				valida_integridad:=0;
				EXECUTE 'select id from log_vehiculos where numero_serie ilike '''||str_data[13]||''' and borrado_logico=false and gral_emp_id='||emp_id||' limit 1;'
				INTO valida_integridad;
				IF valida_integridad<>str_data[4]::integer THEN 
					valor_retorno := ''||valor_retorno||'noserie:El Numero de Serie ingresada ya se ecuentra registrada para otra Unidad..___';
				END IF;
			END IF;
		END IF;
	END IF;
	--Termina validacion Catalogo inventario vehiculos
	
	
	
	--validacion de Catalogo inventario puestos
        IF id_app=75 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        titulo                
                IF str_data[5] = ''  THEN
                        valor_retorno := ''||valor_retorno||'Puesto:Es necesario ingresar el nombre de un Puesto';
                END IF;
                        IF str_data[4] = '0' THEN
                                EXECUTE 'select count(titulo) 
                                from gral_puestos where  titulo ilike '''||str_data[5]||'''  
                                AND borrado_logico=false 
                                AND gral_emp_id='||emp_id||';' 
                                INTO valida_integridad;
                                
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'Puesto:El Puesto ya se encuentra registrado';
                                END IF;        
                        END IF;        
                        
        END IF;--termina validacion Catalogo PUESTOS
	
	
	
	
	--validacion de Aplicativo Devoluciones de Mercancia
	IF id_app=76 THEN
		--str_data[4]	id_factura
		--str_data[5]	id_cliente
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones
		--str_data[9]	select_moneda
		--str_data[10]	select_vendedor
		--str_data[11]	concepto
		--str_data[12]	tipo_cambio
		--str_data[13]	importe
		--str_data[14]	impuesto
		--str_data[15]	retencion
		--str_data[16]	total
		--str_data[17]	factura
		
		IF str_data[12] = ''  THEN
			valor_retorno := ''||valor_retorno||'tcnota:Es necesario ingresar el Tipo de Cambio para la Nota de Credito.___';
		ELSE
			IF str_data[12]::double precision < 1  THEN
				valor_retorno := ''||valor_retorno||'tcnota:El Tipo de Cambio debe ser mayor o igual a 1.___';
			END IF;
		END IF;
		
		IF str_data[11]='' OR str_data[11]=' '  THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario ingresar el Concepto para la Nota de Credito.___';
		END IF;
		
		IF str_data[16]::double precision > 0 THEN
			--obtener el saldo de la factura
			SELECT saldo_factura FROM erp_h_facturas WHERE serie_folio=str_data[17] INTO saldo_fac;

			str_data[16] := round((str_data[16]::double precision)::numeric, 2)::character varying;
			saldo_fac := round((saldo_fac::double precision)::numeric, 2)::double precision;
			
			--validar  que el monto de la nota de credito no sea mayor que el saldo de la factura
			IF str_data[16]::double precision > saldo_fac  THEN
				valor_retorno := ''||valor_retorno||'totalnota:El total de la devolucion no debe ser mayor que el Saldo de la Factura.___';
			END IF;
			
		END IF;
		
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] seleccionado
				IF str_filas[1]::integer != 0 THEN--1: no esta esta seleccionado, 0:No esta seleccionado
					--str_filas[2]	producto_id 
					--str_filas[3]	cantidad
					--str_filas[4]	cantidad_dev
					
					--str_filas[4]	cantidad_dev
					IF str_filas[4] = ' ' OR str_filas[4] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad_dev'||cont_fila||':Es necesario ingresar la cantidad a devolver.___';
					ELSE
						--RAISE EXCEPTION '%',str_filas[4];
						IF str_filas[4]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'cantidad_dev'||cont_fila||':La cantidad a devolver debe ser mayor que cero.___';
						ELSE
							--evaluar  que la cantidad a devolver no sea mayor que la cantidad de la partida
							IF str_filas[4]::double precision >  str_filas[3]::double precision THEN
								valor_retorno := ''||valor_retorno||'cantidad_dev'||cont_fila||':La cantidad a devolver no debe ser mayor que la cantidad de la partida.___';
							END IF;
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--Termina validacion de Aplicativo Devoluciones de Mercancia
	





	--validacion de Catalogo inventario escolaridades
	IF id_app=77 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'Escolaridad:Es necesario ingresar el nombre de una Escolaridad';
		END IF;
		
		EXECUTE 'select count(titulo) from gral_escolaridads 
		where  titulo ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'Escolaridad:La Escolaridad ingresada ya se encuentra registrada';
				END IF;		
	END IF;--termina validacion Catalogo inventario escolaridades  



	--validacion de Catalogo inventario religiones
	IF id_app=78 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'Religion:Es necesario ingresar el nombre de una Religion';
		END IF;
		
		EXECUTE 'select count(titulo) from gral_religions 
		where  titulo ilike '''||str_data[5]||''' AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'Religion:La Religion ingresada ya se encuentra registrada';
		END IF;	

	END IF;--termina validacion Catalogo inventario religiones
	
	
	--validacion de Catalogo inventario tipo de sangre
	IF id_app=79 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'tiposangre:Es necesario ingresar un Tipo de Sangre';
		END IF;
		EXECUTE 'select count(titulo) from gral_sangretipos 
		where  titulo ilike '''||str_data[5]||''' AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'tiposangre:El Tipo de Sangre ingresado ya se encuentra registrado';
		END IF;	

	END IF;--termina validacion Catalogo inventario tipo de sangre

	



	--validacion de Catalogo departamentos
	IF id_app=82 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'depto:Es necesario ingresar el nombre de un Departamento';
		END IF;	

		IF str_data[6] = ''  THEN
			valor_retorno := ''||valor_retorno||'costo:Es necesario ingresar el costo del Departamento';
		END IF;

				
		IF str_data[4] = '0' THEN 
			EXECUTE 'select count(titulo) 
			from gral_deptos where  titulo ilike '''||str_data[5]||''' AND borrado_logico=false  AND gral_emp_id='||emp_id||';' 
			INTO valida_integridad;
			
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'depto:El nombre del Departamento ingresado ya se encuentra en uso';
			END IF;
		END IF;		
	END IF;--termina validacion Catalogo departamentos


	--validacion de Catalogo tipoequipos
	IF id_app=83 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        titulo                
                IF str_data[5] = ''  THEN
                        valor_retorno := ''||valor_retorno||'tipoequipo:Es necesario ingresar el nombre de un Tipo de Equipo';
                END IF;
                IF str_data[4] = '0' THEN 
                        EXECUTE 'select count(titulo) 
                        from pro_tipo_equipo where  titulo ilike '''||str_data[5]||''' 
                        AND borrado_logico=false  
                        AND gral_emp_id='||emp_id||';' 
                        INTO valida_integridad;
                        
                        IF valida_integridad > 0 THEN
                                valor_retorno := ''||valor_retorno||'tipoequipo:El nombre del Tipo de Equipo ingresado ya se encuentra en uso';
                        END IF;
                END IF;
        END IF;--termina validacion Catalogo tipoequipos




	--validacion de Catalogo inventario dias no laborables----------------------------------------------------------------
	IF id_app=84 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        fecha_no_laborable
		--str_data[6]        descripcion		
		IF str_data[5] ='' THEN
			valor_retorno := ''||valor_retorno||'DNL:Es necesario ingresar la fecha no laborable___';
		ELSE
			IF str_data[4]::integer < 0 THEN
				EXECUTE 'select count(fecha_no_laborable) 
				from gral_dias_no_laborables where  fecha_no_laborable = '''||str_data[5]::date||'''  
				AND borrado_logico=false 
				AND gral_emp_id='||emp_id||';' 
				INTO valida_integridad;
			END IF;
		END IF;

		IF str_data[6] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la descripci√≥n___';
		END IF;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'DNL:El D√≠a ya se encuentra registrado___:';
		END IF;		
	END IF;--termina validacion Catalogo dias no laborables
	-----------------------------------------------------------------------------------------------------------







	--validacion de Catalogo categorias ---------------------------------------------------------------------------------------
	IF id_app=85 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        titulo(categ)
		--str_data[6]        sueldo_por_hora 	
		--str_data[7]        sueldo_por_horas_ext 
		--str_data[8]        gral_puesto_id (puesto)	
		IF str_data[5] = '' THEN
			valor_retorno := ''||valor_retorno||'categoria:Es necesario ingresar el nombre de una Categoria___';
		END IF;

		IF str_data[6] ::double precision = 0  THEN
			valor_retorno := ''||valor_retorno||'sueldo_hora:Es necesario ingresar el sueldo por hora___';
		END IF;

		IF str_data[7]::double precision = 0  THEN
			valor_retorno := ''||valor_retorno||'sueldo_hora_extra:Es necesario ingresar el sueldo por Horas Extras___';
		END IF;	

		IF str_data[8]::integer = 0  THEN
			valor_retorno := ''||valor_retorno||'puesto:Es necesario elegir un puesto___';
		END IF;		

		IF str_data[4] = '0' THEN	
			EXECUTE 'select count(titulo) 
			from gral_categ where  titulo ilike '''||str_data[5]||''' 
			AND borrado_logico=false  
			AND gral_emp_id='||emp_id||';' 
			INTO valida_integridad;
			
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'categoria:El nombre de la Categor√≠a ingresada ya se encuentra en uso___';
			END IF;	
		END IF;	
	END IF;--termina validacion de categorias -------------------------------------------------------------------------------------------------

	
	
	
	--validacion de Aplicativo Ordenes de Entrada
	IF id_app=87 THEN
		--str_data[4]	id_oent
		--str_data[5]	observaciones
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	eliminado[i]
					--str_filas[2]	tipo_registro[i]
					--str_filas[3]	id_detalle[i]
					--str_filas[4]	id_almacen[i]
					--str_filas[5]	id_prod_grid[i]
					--str_filas[6]	cantidad_fac[i]
					--str_filas[7]	cantidad_rec[i]
					--str_filas[8]	lote_prov[i]
					--str_filas[9]	pedimento[i]
					--str_filas[10]	caducidad[i]
					--str_filas[11]	no_tr[i]
					--str_filas[12]	req_lote[i]
					--str_filas[13]	oent_detalle_id
					
					SELECT requiere_pedimento,requiere_numero_lote FROM  inv_prod WHERE id=str_filas[5]::integer INTO req_pedimento, req_lote;
					
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='PED' THEN
						suma_lotes:=0;
						--RAISE EXCEPTION '%',str_filas[7];
						--str_filas[7]	cantidad_rec[i]
						IF str_filas[7] = ' ' OR str_filas[7] = '' THEN
							valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':Es necesario ingresar la Cantidad Recibida.___';
						ELSE
							--RAISE EXCEPTION '%',str_filas[7];
							IF str_filas[7]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':La Cantidad Recibida debe ser mayor que cero.___';
							END IF;
						END IF;
						
						
						--IF req_lote=TRUE THEN
							total_filas2:= array_length(arreglo,1);
							cont_fila2:=1;
							FOR cont_fila2 IN 1 .. total_filas2 LOOP
								SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
								
								--str_filas2[1] eliminado
								IF str_filas2[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
									IF str_filas2[2]='LOT' THEN
										--aqui se suman las cantidades de los lotes de la partida actual
										IF str_filas[13]=str_filas2[13] THEN
											suma_lotes := suma_lotes + str_filas2[7]::double precision;
										END IF;
									END IF;
								END IF;
							END LOOP;
							
							--RAISE EXCEPTION '%','suma_lotes:'||suma_lotes||'   Par:'||str_filas[7]::double precision;
							suma_lotes := round(suma_lotes::numeric,2)::double precision;
							
							--str_filas[7]	cantidad_rec[i]
							IF suma_lotes > round(str_filas[7]::numeric,2)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':La suma de los Lotes no debe ser Mayor que Cantidad de la partida.___';
							END IF;
							
							--str_filas[7]	cantidad_rec[i]
							IF suma_lotes < round(str_filas[7]::numeric,2)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':La suma de los Lotes no debe ser Menor que Cantidad de la partida.___';
							END IF;
						--END IF;
						
					ELSE
						IF req_lote=TRUE THEN
							IF str_filas[8]=' ' THEN
								valor_retorno := ''||valor_retorno||'lote_prov'||str_filas[11]||':Es necesario ingresar el numero de Lote.___';
							END IF;
						END IF;
						
						--str_filas[7]	cantidad_rec[i]
						IF str_filas[7] = ' ' OR str_filas[7] = '' THEN
							valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':Es necesario ingresar la Cantidad Recibida para el lote '||str_filas[8]||'.___';
						ELSE
							--RAISE EXCEPTION '%',str_filas[7];
							IF str_filas[7]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_rec'||str_filas[11]||':La Cantidad Recibida para el lote '||str_filas[8]||' debe ser mayor que cero.___';
							END IF;
						END IF;
						
						IF req_pedimento=TRUE THEN
							IF str_filas[9]=' ' OR str_filas[9]='' THEN
								valor_retorno := ''||valor_retorno||'pedimento'||str_filas[11]||':Es necesario ingresar el Pedimento.___';
							END IF;
						END IF;
						
						IF str_filas[10] != ' ' AND str_filas[10] != '' THEN
							EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FechacaducidadCorrect'';' INTO mask_general;
							EXECUTE 'select '''||str_filas[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
							IF match_cadena = false THEN
								valor_retorno := ''||valor_retorno|| 'caducidad'||str_filas[11]||':Fecha de caducidad no valida.___';
							END IF;
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--Termina validacion de Aplicativo Ordenes de Entrada
	
	
	
	--validacion de preorden de produccion
	IF id_app=89 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  tipoorden
		--str_data[6]  observaciones
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		
		IF str_data[5] = '' or str_data[5] = '0'  THEN
			valor_retorno := ''||valor_retorno||'sku:Es necesario seleccionar un producto___';
		END IF;
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		IF total_filas < 1 THEN
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto___';
		END IF;
		
		-- validaciones para el grid --
		IF arreglo[1] != 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				----aqui se vuelven a crear los registros
				IF str_filas[4] != '0' THEN
					
					--VALIDACION PARA  EL GRID
					IF str_filas[6] = ' ' OR str_filas[6] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[6]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':La cantidad debe ser mayor a cero___';
						END IF;
					END IF;
					
				END IF;
			END LOOP;
		ELSE
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la configuracion___';
		END IF;
		
	END IF;--validacion de preorden de produccion
	
	
	
	
	--Orden de Compra
	IF id_app=90 THEN
	--RAISE EXCEPTION '%','ESTA ENTRANDO AQUIIIII:';
		--str_data[3]	id_usuario
		--str_data[4]	id_orden_compra
		--str_data[5] 	id_proveedor
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'rfcproveed0r:Es necesario seleccionar un Proveedor___';
		ELSE
			IF trim(str_data[5])::integer <= 0 THEN
				valor_retorno := ''||valor_retorno||'rfcproveed0r:Es necesario seleccionar un Proveedor___';
			END IF;
		END IF;
		
		--str_data[6]	observaciones    select * from cxp_prov 
		--str_data[7]	select_moneda
		--str_data[8]	tipo_cambio
		IF trim(str_data[7])='' THEN 
			valor_retorno := ''||valor_retorno||'moneda:Es necesario seleccionar un tipo de Moneda___';
		ELSE 
			IF trim(str_data[7])::double precision<=0 THEN
				valor_retorno := ''||valor_retorno||'moneda:Es necesario seleccionar un tipo de Moneda___';
			END IF;
		END IF;
		
		IF trim(str_data[8]) = '' THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
		END IF;
		/*
		IF str_data[9] = '' THEN
			valor_retorno := ''||valor_retorno||'grupo:Es necesario ingresar el nombre del grupo___';
		END IF;
		
		IF str_data[11] = '' THEN
			valor_retorno := ''||valor_retorno||'consiganadoa:Es necesario ingresar a quien es consignada la O.C___';
		END IF;
		*/
		
		IF trim(str_data[13]) = '' THEN
			valor_retorno := ''||valor_retorno||'fentrega:Es necesario seleccionar la fecha requerida para la entrega de la mercancia.___';
		END IF;

		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					
					--str_filas[6]	cantidad
					IF trim(str_filas[6]) = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':Es necesario ingresar la cantidad___';
					ELSE
						--RAISE EXCEPTION '%',str_filas[6];
						IF str_filas[6]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad debe ser mayor que cero___';
						END IF;
					END IF;
					
					--str_filas[7]	costo
					IF trim(str_filas[7]) = '' THEN
						valor_retorno := ''||valor_retorno||'costo'||cont_fila||':Es necesario ingresar el precio unitario___';
					ELSE
						IF str_filas[7]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'costo'||cont_fila||':El precio debe ser mayor que cero___';
						END IF;
					END IF;
					
				END IF;
				
			END LOOP;
			
		END IF;
		
	END IF;--termina Orden de Compra
	
	
	
	
	
	
	
	
	--validacion de Catalogo turnos -------------------------------------------------------------------------------------------------
	IF id_app=92 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        turno
		--str_data[6]        hora_ini	
		--str_data[7]        hora_fin 
		--str_data[8]        gral_deptos_id (depto)	
		IF str_data[5]::integer = 0 THEN
			valor_retorno := 0||valor_retorno||'turno:Es necesario ingresar el n√∫mero del Turno___';
		END IF;

		IF str_data[6] = ''  THEN
			valor_retorno := ''||valor_retorno||'hora_inicial:Es necesario ingresar la hora de inicio___';
		END IF;

		IF str_data[7] = ''  THEN
			valor_retorno := ''||valor_retorno||'hora_final:Es necesario ingresar la hora final___';
		END IF;	

		IF str_data[8]::integer = 0  THEN
			valor_retorno := ''||valor_retorno||'depto:Es necesario elegir un departamento___';
		END IF;		
		
		IF str_data[4] = '0' THEN	
				EXECUTE 'select count(turno) 
				from gral_deptos_turnos where  turno = '''||str_data[5]::integer||''' 
				AND borrado_logico=false  
				AND gral_emp_id='||emp_id||';' 
				INTO valida_integridad;
				
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'0turno:El n√∫mero del turno ingresado ya se encuentra en uso___';
				END IF;	
		END IF;	
					
			
	END IF;--termina validacion de turnos -------------------------------------------------------------------------------------------------







	--validacion de orden de produccion
	IF id_app=93 THEN
		
		--obtenemos el id de el almacen de produccion
		select inv_alm_id from pro_par where gral_emp_id=emp_id limit 1 INTO id_almacen;
		
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  tipo_orden
		--str_data[6]  fecha_elavorar
		--str_data[7]  observaciones
		--str_data[8]  command_selected
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		--valida si tiene especificaciones o parametros
		
		IF str_data[8] = '1' OR str_data[8] = '2' OR str_data[8] = '3' THEN
			--RAISE EXCEPTION '%' ,str_data[4];
			IF trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'tipoorden:Es necesario seleccionar un tipo de orden___';
			END IF;
			
			IF trim(str_data[6]) = ''  THEN
				valor_retorno := ''||valor_retorno||'fecha_elavorar:Es necesario seleccionar una fecha de elaboracion___';
			END IF;
			
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			IF total_filas < 1 THEN
				valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto___';
			END IF;
			
			-- validaciones para el grid --
			IF arreglo[1] != 'sin datos' THEN
				total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
					----aqui se vuelven a crear los registros
					--RAISE EXCEPTION '%' ,str_filas[6];
					IF str_filas[1] != '0' THEN
						
						--eliminar[i] +"--1
						--___" + id_reg[i]+"--2
						--___" + inv_prod_id[i]+"--3
						--___" + subproceso_id[i]+"--4
						--___"+ pro_subproceso_prod_id[i]+"--5
						--___"+persona[i]+"--6
						--___"+ equipo[i]+"--7
						--___"+ eq_adicional[i]+"--8
						--___"+ cantidad[i]+"--9
						--___" + no_partida--10
						--VALIDACION PARA  EL GRID
						
						IF str_data[8] = '2' THEN
							--RAISE EXCEPTION '%' ,str_data[4];
							IF str_data[4] = '0' THEN 
								--RAISE EXCEPTION '%' ,str_data[4];
								IF trim(str_filas[6])<>'' THEN
									
									SELECT id FROM gral_empleados where gral_empleados.nombre_pila||' '||gral_empleados.apellido_paterno||' '||gral_empleados.apellido_materno ilike ''||str_filas[6]||'' and borrado_logico=false and gral_emp_id=emp_id INTO operador_id;
									
									IF operador_id is not null THEN

										EXECUTE  'select count(pro_orden_prod_det.id) as cantidad from pro_orden_prod_det 
										join 
										(select id, pro_proceso_id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' AND id <> '||str_data[4]::integer||' limit 1)  as tmp 
										ON pro_orden_prod_det.pro_orden_prod_id=tmp.id 
										join pro_proceso ON (pro_proceso.id=tmp.pro_proceso_id AND pro_proceso.pro_proceso_flujo_id in (2, 3))
										where pro_orden_prod_det.gral_empleados_id='||operador_id||';' INTO valida_integridad;
										
										/*
										--Commentado para que no calide operario-- 14/may/2013
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operador ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
										
									ELSE
										valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operario que selecciono no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operario que selecciono no se encontro___';
								END IF;
								
								IF trim(str_filas[7])<>='' THEN
									SELECT id FROM pro_equipos where titulo ilike ''||str_filas[7]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_id;
									IF equipo_id is not null THEN
										EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' limit 1) and pro_equipos_id='||equipo_id||';' INTO valida_integridad;
										/*
										--Commentado para que no calide equipo-- 14/may/2013
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
									ELSE
										valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo no se encontro___';
								END IF;

								--RAISE EXCEPTION '%' ,'str_filas[8]: HOLA';
								--RAISE EXCEPTION '%' ,'str_filas[8]: '||str_filas[8];
								
								IF trim(str_filas[8])<>'' THEN
									SELECT id FROM pro_equipos_adic where titulo ilike ''||str_filas[8]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_adicional_id;
									--RAISE EXCEPTION '%' ,str_filas[10];
									IF equipo_adicional_id is not null THEN
										EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' limit 1) and pro_equipos_adic_id='||equipo_adicional_id||';' INTO valida_integridad;
										/*
										--Commentado para que no valide equipo adicional-- 14/may/2013
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
									ELSE
										--RAISE EXCEPTION '%' ,str_filas[10];
										valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional no se encontro___';
									END IF;
								ELSE
									--RAISE EXCEPTION '%' ,str_filas[10];
									valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional no se encontro___';
								END IF;
							ELSE
								--RAISE EXCEPTION '%' ,str_filas[6];
								IF trim(str_filas[6])<>'' THEN
									
									SELECT id FROM gral_empleados where trim(gral_empleados.nombre_pila)||' '||trim(gral_empleados.apellido_paterno)||' '||trim(gral_empleados.apellido_materno) ilike ''||trim(str_filas[6])||'' and borrado_logico=false and gral_emp_id=emp_id INTO operador_id;

	--RAISE EXCEPTION '%' ,'SELECT id FROM gral_empleados where gral_empleados.nombre_pila'||' '||'gral_empleados.apellido_paterno'||' '||'gral_empleados.apellido_materno ilike '||trim(str_filas[6])||' and borrado_logico=false and gral_emp_id='||emp_id;
									--RAISE EXCEPTION '%' ,'operador_id: '||operador_id;
									IF operador_id is not null THEN
										
										EXECUTE  'select count(pro_orden_prod_det.id) as cantidad from pro_orden_prod_det 
										join 
										(select id, pro_proceso_id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' AND id <> '||str_data[4]::integer||' limit 1)  as tmp 
										ON pro_orden_prod_det.pro_orden_prod_id=tmp.id 
										join pro_proceso ON (pro_proceso.id=tmp.pro_proceso_id AND pro_proceso.pro_proceso_flujo_id in (2,3)) 
										where pro_orden_prod_det.gral_empleados_id='||operador_id||';' INTO valida_integridad;
										--RAISE EXCEPTION '%' ,valida_integridad;
										--EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										--(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										--borrado_logico=false and gral_emp_id='||emp_id||' and id<>'||str_data[4]::integer||'  limit 1) and gral_empleados_id='||operador_id||';' INTO valida_integridad;
										/*
										--Comentado para permitir repetir el operario
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operador ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
									ELSE
										--RAISE EXCEPTION '%' ,str_filas[10];
										valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operario que selecciono no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':El operario que selecciono no se encontro___';
								END IF;

								--RAISE EXCEPTION '%' ,str_filas[7];
								
								IF trim(str_filas[7])<>'' THEN
									SELECT id FROM pro_equipos where titulo ilike ''||str_filas[7]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_id;
									--RAISE EXCEPTION '%' ,'SELECT id FROM pro_equipos where titulo ilike '||str_filas[7]||' and borrado_logico=false and gral_emp_id='||emp_id;
									IF equipo_id is not null THEN
										--EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										--(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										--borrado_logico=false and gral_emp_id='||emp_id||' and id<>'||str_data[4]::integer||'  limit 1) and pro_equipos_id='||equipo_id||';' INTO valida_integridad;
										
										EXECUTE  'select count(pro_orden_prod_det.id) as cantidad from pro_orden_prod_det 
										join 
										(select id, pro_proceso_id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' AND id <> '||str_data[4]::integer||' limit 1)  as tmp 
										ON pro_orden_prod_det.pro_orden_prod_id=tmp.id 
										join pro_proceso ON (pro_proceso.id=tmp.pro_proceso_id AND pro_proceso.pro_proceso_flujo_id in (2,3)) 
										where pro_orden_prod_det.pro_equipos_id='||equipo_id||';' INTO valida_integridad;
										/*
										--Comentado para permitir repetir el equipo
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
										
									ELSE
										valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'equipo'||str_filas[10]||':El equipo no se encontro___';
								END IF;
								
								IF trim(str_filas[8])<>'' THEN
									SELECT id FROM pro_equipos_adic where titulo ilike ''||str_filas[8]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_adicional_id;
									--RAISE EXCEPTION '%' ,equipo_adicional_id;
									
									IF equipo_adicional_id is not null THEN
										--EXECUTE  'select count(id) as cantidad from pro_orden_prod_det where pro_orden_prod_id=
										--(select id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										--borrado_logico=false and gral_emp_id='||emp_id||' and id<>'||str_data[4]::integer||'  limit 1) and pro_equipos_adic_id='||equipo_adicional_id||';' INTO valida_integridad;
										
										EXECUTE  'select count(pro_orden_prod_det.id) as cantidad from pro_orden_prod_det 
										join 
										(select id, pro_proceso_id from pro_orden_prod where fecha_elavorar='''||str_data[6]||''' and 
										borrado_logico=false and gral_emp_id='||emp_id||' AND id <> '||str_data[4]::integer||' limit 1)  as tmp 
										ON pro_orden_prod_det.pro_orden_prod_id=tmp.id 
										join pro_proceso ON (pro_proceso.id=tmp.pro_proceso_id AND pro_proceso.pro_proceso_flujo_id in (2,3)) 
										where pro_orden_prod_det.pro_equipos_adic_id='||equipo_adicional_id||';' INTO valida_integridad;
										/*
										--Comentado para permitir repetir el mismo equipo adicional en el mismo dia
										IF valida_integridad > 0 THEN
											valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional ya se ecunrtra asignado en el mismo dia___';
										END IF;
										*/
									ELSE
										valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional no se encontro___';
									END IF;
								ELSE
									valor_retorno := ''||valor_retorno||'equipo_adicional'||str_filas[10]||':El equipo adicional no se encontro___';
								END IF;
							END IF;
							
							IF trim(str_filas[7])<>'' THEN
								IF trim(str_filas[6])='' THEN
									valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':Seleccione un operador___';
								END IF;
							END IF;
							
							IF trim(str_filas[8])<>'' THEN
								IF trim(str_filas[6])='' THEN
									valor_retorno := ''||valor_retorno||'apoerario'||str_filas[10]||':Seleccione un operador___';
								END IF;
							END IF;
							
						END IF;
						
						IF trim(str_filas[9]) = '' THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[10]||':Es necesario ingresar la cantidad___';
						ELSE
							IF str_filas[9]::double precision < 0.000001  THEN
								valor_retorno := ''||valor_retorno||'cantidad'||str_filas[10]||':La cantidad debe ser mayor a cero___';
							END IF;
						END IF;

						
						--En produccion, para verificar si una nueva requisicion tiene existencia
						IF str_data[8] = '3' THEN
							--almacena el proceso en el que se encuentra la orden de produccion
							valida_integridad := 0;
							
							--Query para verificar si la Empresa actual incluye Modulo de Produccion
							SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
							
							--RAISE EXCEPTION '%','controlExisPres: '||controlExisPres;
							
							IF str_data[9]='lotes' THEN
								
								IF str_filas[11] = '0' THEN
									
									IF str_filas[1] <> '0' THEN
										
										--IF str_filas[10] = '0' THEN
											----INSERT INTO pro_orden_detalle_mov(pro_orden_prod_det_id,cantidad,cantidad_adicional ,
											----	pro_subprocesos_id,num_lote,
											----	inv_prod_id,gral_empleados_id, elemento, inv_osal_id) 
											----	values(str_filas[8]::integer, str_filas[4]::double precision,
											----	str_filas[5]::double precision, 
											----	str_filas[9]::integer, str_filas[6],
											----	str_filas[3]::integer, usuario_ejecutor, (cont_fila1+1), str_filas[11]::integer);
											
											suma_componente := 0;
											IF str_filas[5] = '0' THEN
												suma_componente := str_filas[4]::double precision;
											ELSE
												suma_componente := str_filas[5]::double precision;
											END IF;
											
											EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
											
											EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
											
											--todos los pedidos, se tienen que hacer en kilos
											IF match_cadena = false THEN
												--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
												suma_componente := (suma_componente / (select densidad from inv_prod where id=str_filas[3]::integer));
											END IF;
											
											suma_componente := round((suma_componente)::numeric, 4)::double precision;
											
											SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, str_filas[12]::integer) INTO total_existencia; 

											--RAISE EXCEPTION '%' ,'total_existencia: '||total_existencia ||'       suma_componente: '||suma_componente;
											--IF total_existencia <= 0 THEN 
											--	RAISE EXCEPTION '%' ,id_almacen;
											--END IF;
											total_existencia := round((total_existencia)::numeric, 4)::double precision;
											
											cant_disponible:=0;
											
											select sku from inv_prod where id=str_filas[3]::integer INTO sku_componente;
											--Si no selecciono almacen
											IF str_filas[12]::integer = 0 THEN
												valor_retorno := ''||valor_retorno||'almacen1:Seleccione un almacen para '||sku_componente||'___';
											ELSE
												--si seleccion almacen, verificar existencia
												--Recorre todo el arreglo, para verificar si hay mas productos con la misma clave en el mismo almacen
												total_filas2:= array_length(arreglo,1);
												cont_fila2:=1;
												
												/*     Validaciones para la existencia por unidad de medida     */
												FOR cont_fila2 IN 1 .. total_filas2 LOOP
													SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
													
													IF str_filas2[1] != '0' THEN
														--id de el registro, si es cero, va a valida
														IF str_filas2[11] = '0' THEN
															IF str_filas[3]::integer=str_filas2[3]::integer AND str_filas[12]::integer=str_filas2[12]::integer THEN
																--Convertire a unidad de medida, la cantidad de la partida en posicion de str_filas2
																IF str_filas2[4]='' THEN
																	str_filas2[4] := '0';
																END IF;
																
																IF str_filas2[5]='' THEN
																	str_filas2[5] := '0';
																END IF;
																
																IF str_filas2[5] = '0' THEN
																	cant_disponible := str_filas2[4]::double precision;
																ELSE
																	cant_disponible := str_filas2[5]::double precision;
																END IF;
																
																EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas2[3]::integer)||'' INTO titulo_mask;
																
																--unidad de medida para el cmponente
																EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
																
																--todos los pedidos, se tienen que hacer en kilos
																IF match_cadena = false THEN
																	--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
																	cant_disponible := (cant_disponible::double precision / (select densidad from inv_prod where id=str_filas2[3]::integer));
																END IF;
																
																cant_disponible := round((cant_disponible)::numeric, 4)::double precision;
																
																--resta la cantidad de la partida a la existencia
																total_existencia := (total_existencia::double precision - cant_disponible::double precision);

																total_existencia := round((total_existencia)::numeric, 4)::double precision;
																
															END IF;	
														END IF;
													END IF;
													
												END LOOP;
												
												--Convertire a unidad de medida, la cantidad de la partida en posicion de str_filas
												IF str_filas[4]='' THEN
													str_filas[4] := '0';
												END IF;
												
												IF str_filas[5]='' THEN
													str_filas[5] := '0';
												END IF;
												
												IF str_filas[5] = '0' THEN
													cant_disponible := str_filas[4]::double precision;
												ELSE
													cant_disponible := str_filas[5]::double precision;
												END IF;
												
												EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
												
												--unidad de medida para el cmponente
												EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
												
												--todos los pedidos, se tienen que hacer en kilos
												IF match_cadena = false THEN
													--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
													cant_disponible := (cant_disponible / (select densidad from inv_prod where id=str_filas[3]::integer));
												END IF;
												
												cant_disponible := round((cant_disponible)::numeric, 4)::double precision;
												
												--RAISE EXCEPTION '%' ,'total_existencia: '||total_existencia ||'       cant_disponible: '||cant_disponible;
												
												--Suma la cantidad de la partida a la existecia, debido a que se le deconto al recorrer por segunda vez el arreglo
												total_existencia := total_existencia::double precision + cant_disponible::double precision;
												
												IF total_existencia < cant_disponible THEN
													IF total_existencia < 0 THEN
														total_existencia := 0;
													END IF;
													valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||total_existencia||' y necesita '||cant_disponible||'___';
												END IF;
												/*    Termina validaciones por unidad de medida, para la materia prima       */
												
												--RAISE EXCEPTION '%' ,'total_existencia: '||total_existencia ||'       cant_disponible: '||cant_disponible;
												
												
												
												/*     Validaciones para la existencia por presentacion por default     */
												--Convertire a unidad de medida, la cantidad de la partida en posicion de str_filas
												
												IF str_filas[4]='' THEN
													str_filas[4] := '0';
												END IF;
												
												IF str_filas[5]='' THEN
													str_filas[5] := '0';
												END IF;
												
												IF str_filas[5] = '0' THEN
													cant_disponible := str_filas[4]::double precision;
												ELSE
													cant_disponible := str_filas[5]::double precision;
												END IF;
												
												EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
												
												--unidad de medida para el cmponente
												EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
												
												--todos los pedidos, se tienen que hacer en kilos
												IF match_cadena = false THEN
													--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
													cant_disponible := (cant_disponible / (select densidad from inv_prod where id=str_filas[3]::integer));
												END IF;
												
												cant_disponible := round((cant_disponible)::numeric, 4)::double precision;
												
												--Suma la cantidad de la partida a la existecia, debido a que se le deconto al recorrer por segunda vez el arreglo
												total_existencia := total_existencia + cant_disponible;
												
												--RAISE EXCEPTION '%' ,str_filas[12];--2141
												
												--select * from inv_exi_pres where inv_prod_id=str_filas[3]::integer AND inv_alm_id=3 ;
												--buscar la existencia actual de la presentacion
												
												IF controlExisPres=true THEN 
													
													select cantidad from inv_prod_presentaciones where id=
													(Select inv_prod_presentacion_id from inv_prod where id=str_filas[3]::integer limit 1) INTO equivalenciaPres;

													--RAISE EXCEPTION '%' ,'equivalenciaPres: '||equivalenciaPres;
													
													IF equivalenciaPres is not null THEN
														
														sql_select:='select 
															(inv_exi_pres.inicial + inv_exi_pres.entradas - inv_exi_pres.reservado - inv_exi_pres.salidas) AS existencia 
															from (
															Select (CASE WHEN inv_prod_presentacion_id is null THEN 0 ELSE inv_prod_presentacion_id END) as presentacion_id, id from inv_prod where id='||str_filas[3]::integer||' 
															) as prod 
															JOIN inv_exi_pres 
															ON (inv_exi_pres.inv_prod_presentacion_id=prod.presentacion_id AND inv_exi_pres.inv_prod_id=prod.id ) 
															WHERE inv_exi_pres.inv_alm_id='||str_filas[12]::integer||' ';
														--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
														
														EXECUTE sql_select INTO cantPres;
														
														--RAISE EXCEPTION '%' ,'cantPres: '||cantPres||'     total_existencia:'||total_existencia;
														
														IF cantPres is not null OR cantPres > 0.00001 THEN
															--IF (total_existencia/cantPres) < cantPres THEN
															IF (total_existencia / equivalenciaPres::double precision) < cantPres::double precision THEN
																valor_retorno := ''||valor_retorno||'cantidad1:El producto '||sku_componente||', no tiene existencia suficiente en presentacion default.___';
															END IF;
														ELSE
															valor_retorno := ''||valor_retorno||'cantidad1:El producto '||sku_componente||', no tiene existencia suficiente en presentacion default.___';
														END IF;
														
													ELSE
														valor_retorno := ''||valor_retorno||'cantidad1:El producto '||sku_componente||', no tiene presentacion default.___';
													END IF;
													
													--RAISE EXCEPTION '%','controlExisPres: '||cantPres;
													
													IF total_existencia < cant_disponible THEN
														IF total_existencia < 0 THEN
															total_existencia := 0;
														END IF;
														valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||total_existencia||' y necesita '||cant_disponible||'___';															
													END IF;
													
												END IF;
												
												--str_filas[12]::integer
												--EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
												
												--RAISE EXCEPTION '%' ,'inv_alm_id:'||str_filas[12]::integer||' -  inv_prod_id:'||str_filas[3]::integer||' -  inv_prod_presentacion_id:'||str_filas[11]::integer;
												
											END IF;
											
											
											
											
											
											----llamada a proc que devuelve la existencia del producto. 
											----El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
											----el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
											
											
											--IF total_existencia < cant_disponible THEN
											--	valor_retorno := ''||valor_retorno||'cantidad1:El producto '||(select sku from inv_prod where id=str_filas[3]::integer)||' tiene Existencia 0 en Almacen___';
											--ELSE
											--	IF total_existencia < suma_componente THEN
											--		valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||(select sku from inv_prod where id=str_filas[3]::integer)||' es '||total_existencia||', necesita '||suma_componente||'___';
											--	END IF;
											--END IF;
											
										--END IF;
									END IF;
								END IF;
								
							END IF;
							
						END IF;
						
						
						--En produccion, para verificar hay especificaicones, asi como ordenes de salida 
						IF str_data[8] = '4' THEN
							--almacena el proceso en el que se encuentra la orden de produccion
							valida_integridad := 0;
							SELECT pro_proceso_id FROM pro_orden_prod WHERE id=str_data[4]::integer INTO valida_integridad;
							select pro_proceso_flujo_id from pro_proceso where id=valida_integridad INTO valida_integridad;
							IF valida_integridad = 3 THEN
								valida_integridad := 0;
								select count(opd.id), count(opde.pro_orden_prod_det_id) from (selecT id from pro_orden_prod_det where pro_orden_prod_id=str_data[4]::integer) as opd 
								left join pro_orden_prod_subp_esp as opde on opde.pro_orden_prod_det_id=opd.id where opde.pro_orden_prod_det_id is null INTO valida_integridad, primero;
								
								IF valida_integridad > primero THEN
									valor_retorno := ''||valor_retorno||'cantidad1:Debe capturar almenos un resultado de analisis por subproceso___';
								END IF;
								--RAISE EXCEPTION '%' ,primero;
							END IF;
						END IF;
						
					END IF;
				END LOOP;
			ELSE
				valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la orden___';
			END IF;
			
			
			-- validaciones verificar existrencia de la requisicion --
			IF arreglo[1] != 'sin datos' THEN
				total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					sku_componente:='';
					--RAISE EXCEPTION '%' ,arreglo[cont_fila];
					
					IF str_data[9]='lotes' THEN
						
						--SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
						----aqui se vuelven a crear los registros
						SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
						--RAISE EXCEPTION '%' ,str_filas[1];
						--nuevo registro
						IF str_filas[1] <> '0' THEN 

							--Obtiene el codigo de el producto
							select sku from inv_prod where id=str_filas[3]::integer INTO sku_componente;
							
							IF str_filas[4]<>'0' AND trim(str_filas[4])<>'' THEN
								
								--id de el registro, si es cero, va a valida
								--RAISE EXCEPTION '%' ,str_filas[10]||'Hola validador';
								IF str_filas[10] = '0' THEN
									
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, str_filas[12]::integer) INTO total_existencia;
									--RAISE EXCEPTION '%' ,total_existencia;
									




									EXECUTE 'select titulo from inv_prod_unidades where id='||(select unidad_id from inv_prod where id=str_filas[3]::integer)||'' INTO titulo_mask;
									
									--unidad de medida para el cmponente
									EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
									
									--todos los pedidos, se tienen que hacer en kilos
									IF match_cadena = false THEN
										--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
										total_existencia := (total_existencia * (select densidad from inv_prod where id=str_filas[3]::integer));
									END IF;
									
									total_existencia := round((total_existencia)::numeric, 4)::double precision;
									

									--RAISE EXCEPTION '%' ,'total_existencia: '||total_existencia;



									
									--IF total_existencia<=0 THEN
									--	valor_retorno := ''||valor_retorno||'cantidad1:El producto '||sku_componente||' tiene Existencia 0 en Almacen___';
									--ELSE
									--	IF total_existencia < str_filas[4]::double precision THEN
									--		valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||total_existencia||' y necesita '||str_filas[4]||'___';
									--	END IF;
									--END IF;
									
									
									--Si no selecciono almacen
									IF str_filas[12]::integer = 0 THEN
										valor_retorno := ''||valor_retorno||'almacen1:Seleccione un almacen para '||sku_componente||'___';
									ELSE
										--si seleccion almacen, verificar existencia
										--Recorre todo el arreglo, para verificar si hay mas productos con la misma clave en el mismo almacen
										total_filas2:= array_length(arreglo,1);
										cont_fila2:=1;
										FOR cont_fila2 IN 1 .. total_filas2 LOOP
											SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
											
											IF str_filas2[1] <> '0' THEN
												--id de el registro, si es cero, va a valida
												IF str_filas2[10] = '0' THEN
													IF str_filas[3]::integer=str_filas2[3]::integer AND str_filas[12]::integer=str_filas2[12]::integer THEN
														IF str_filas2[4]='' THEN
															str_filas2[4]:='0';
														END IF;
														IF str_filas2[5]='' THEN
															str_filas2[5]:='0';
														END IF;
														total_existencia := (total_existencia - (str_filas2[4]::double precision + str_filas2[5]::double precision));
													END IF;	
												END IF;
											END IF;
											
										END LOOP;
										
										
										--IF total_existencia < str_filas2[4]::double precision THEN
										IF total_existencia < 0 THEN
											valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||(total_existencia + str_filas[4]::double precision)||' y necesita '||str_filas[4]||'___';
										END IF;
										
										--IF total_existencia < str_filas2[5]::double precision THEN
										IF total_existencia < 0 THEN
											valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||sku_componente||' es '||(total_existencia + str_filas[4]::double precision)||' y necesita '||str_filas[4]||'___';
										END IF;
										
									END IF;



									
									/*
									total_filas2:= array_length(arreglo,1);
									cont_fila2:=1;
									FOR cont_fila2 IN 1 .. total_filas2 LOOP
										SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
										
										--str_filas2[1] eliminado
										IF str_filas2[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
											IF str_filas2[2]='LOT' THEN
												--aqui se suman las cantidades de los lotes de la partida actual
												IF str_filas[4]=str_filas2[4] THEN
													IF str_filas2[9]!='' AND  str_filas2[9]!=' ' THEN
														suma_lotes := suma_lotes + str_filas2[9]::double precision;
													END IF;
												END IF;
											END IF;
										END IF;
									END LOOP;
									*/
									
								END IF;
								
							ELSE
								IF str_filas[2]='' THEN str_filas[2]:='0'; END IF;
								IF str_filas[10]='' THEN str_filas[10]:='0'; END IF;
								IF str_filas[5]='' THEN str_filas[5]:='0'; END IF;
								
								IF str_filas[2]<>'0' AND str_filas[10]='0' THEN 
									--Aqui entra cuando es el Adicional de cualquiera de los productos ya registrados
									IF str_filas[5]='0' THEN 
										valor_retorno := ''||valor_retorno||'cantidad1:Es necesario ingresar la antidad Adicional en el nuevo registro para el componente '||sku_componente||'___';
									END IF;
								ELSE
									--Aqui entra cuando es nuevo producto o es uno existente pero la Cantidad viene en cero o vacio.
									valor_retorno := ''||valor_retorno||'cantidad1:Es necesario ingresar la Cantidad para el nuevo componente '||sku_componente||'___';
								END IF;
							END IF;
							
						END IF;
						
					END IF;
					
				END LOOP;
			END IF;	
		END IF;
		
		--aqui empieza comentarios para no validar existencias
		----validacion para enviar la requisicion
		--IF str_data[8] = '6' THEN
		--	total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		--	cont_fila:=1;
		--	FOR cont_fila IN 1 .. total_filas LOOP
		--		
		--		SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
		--		--eliminar_tmp+"___"+1
		--		--id_reg_requisicion+"___"+2
		--		--id_prod_requisicion+"___"+3
                --               --cantidad_requisicion+"___"+4
                --               --existencia_requisicion+"";5
		--		
		--		----aqui para validar que la existencia sea suficiente 
		--		--RAISE EXCEPTION '%' ,str_filas[6];
		--		IF str_filas[1] != '0' THEN
		--			
		--			EXECUTE 'select titulo from inv_prod_unidades where id=(select unidad_id from inv_prod where id='||str_filas[3]::integer||')' INTO titulo_mask;
		--			
		--			--EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
		--			--verificar existencia
		--			EXECUTE 'select '''||titulo_mask||''' ~* ''KILO*'';' INTO match_cadena;
		--			
		--			--todos los pedidos, se tienen que hacer en kilos
		--			IF match_cadena = true THEN
		--				--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad);
		--				suma_componente := str_filas[4]::double precision;
		--			ELSE
		--				--suma_componente := ( (record1.cantidad / 100) * formulacion.cantidad) * formulacion.densidad;
		--				--							obtiene la densidad de el producto
		--				suma_componente := str_filas[4]::double precision / (select densidad from inv_prod where id=str_filas[3]::integer);
		--			END IF;
		--			
		--			suma_componente := round((suma_componente)::numeric, 4)::double precision;
		--			
		--			--llamada a proc que devuelve la existencia del producto. 
		--			--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
		--			--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
		--			SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, str_data[3]::integer, id_almacen) INTO total_existencia; 
		--			
		--			total_existencia := round((total_existencia)::numeric, 4)::double precision;
		--			
		--			IF total_existencia<=0 THEN
		--				--								obtiene el codigo de el producto
		--				valor_retorno := ''||valor_retorno||'cantidad1:El producto '||(select sku from inv_prod where id=str_filas[3]::integer)||' tiene Existencia 0 en Almacen___';
		--			ELSE
		--				IF total_existencia < suma_componente THEN
		--					--									obtiene el codigo de el producto
		--					valor_retorno := ''||valor_retorno||'cantidad1:Disponibles para '||(select sku from inv_prod where id=str_filas[3]::integer)||' es '||total_existencia||', necesita '||suma_componente||'___';
		--				END IF;
		--			END IF;
		--			
		--		END IF;
		--		
		--	END LOOP;	
		--	--RAISE EXCEPTION '%' ,sql_formula;
		--	
		--END IF;
		--aqui termina comentarios para no validar existencias
		
		
		
		--aqui inicia validaciones de cantidades que se utilizaron en realidad
		----validacion para las cantidades que se utilizaron al final de la produccion
		IF str_data[8] = '9' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--eliminar_tmp+"___"+--1
				--id_reg_tmp+"___"+--2
				--id_prod_detalle_tmp+"___"+ --3
				--cantidad_elemento_tmp+"___"+--4
				--cantidad_adicional_tmp+"___"+--5
				--lote_tmp+"___"+//inv_osal_id--6
				--inv_prod_id_elemento_tmp+"___"+--7
				--id_reg_parent+"___"+--8
				--$subproceso_id.val()+"___"+--9
				--id_reg_det+"___"+--10
				--inv_osal_id+"___"+--11
				--almacen_id+"___"+--12
				--sucursal_id+"___"+--13
				--agregado+"___"+--14
				--cantidad_real_tmp--15
				
				IF ( str_filas[4]::double precision + str_filas[5]::double precision) < str_filas[15]::double precision THEN
					valor_retorno := ''||valor_retorno||'cantidad'||cont_fila||':La cantidad utilizada excede a la cantidad solicitada___';
				END IF;
				
				IF str_filas[6] = '' OR str_filas[6] = ' ' THEN
					valor_retorno := ''||valor_retorno||'lote'||cont_fila||':Debe hacer los trspasos de almacen___';
				END IF;
				
			END LOOP;
			--RAISE EXCEPTION '%' ,sql_formula;
			
		END IF;
		--aqui termina validaciones de cantidades que se utilizaron en realidad
		
		
		--valida si tiene especificaciones o parametros
		IF str_data[8] = '4' THEN
			--Obtener el status de calidad
			SELECT status_calidad FROM pro_orden_prod WHERE id=str_data[4]::integer limit 1 INTO estado_calidad;
			
			IF estado_calidad IS NULL THEN estado_calidad:=0; END IF;

			--1=Aceptado
			IF estado_calidad=1 THEN
				SELECT pro_proceso_id FROM pro_orden_prod WHERE id=str_data[4]::integer INTO valida_integridad;
				select pro_proceso_flujo_id from pro_proceso where id=valida_integridad INTO valida_integridad;
				IF valida_integridad = 3 THEN
					
					selecT inv_prod_id from pro_orden_prod_det where pro_orden_prod_id=str_data[4]::integer limit 1 INTO componente_id;
					
					--selecT count(id) as cantidad from pro_get_detalle_orden_produccion(componente_id,str_data[4]::integer,id_almacen, 0)  as 
					--foo(id integer, inv_prod_id integer, sku character varying,descripcion character varying, 
					--requiere_numero_lote boolean ,cantidad_adicional double precision,id_reg_det integer, 
					--cantidad double precision,elemento integer, lote character varying, inv_osal_id integer) where lote is null OR lote='' INTO valida_integridad;
					
					selecT count(id) as cantidad from pro_get_detalle_orden_produccionv2(componente_id,str_data[4]::integer,id_almacen, 0) 
					as foo(id integer, inv_prod_id integer, 
					sku character varying,descripcion character varying, requiere_numero_lote boolean ,cantidad_adicional double precision,
					id_reg_det integer, cantidad double precision,elemento integer, lote character varying, inv_osal_id integer, inv_alm_id integer, 
					gral_suc_id integer, agregado boolean,cantidad_usada double precision, guardado boolean) where lote is null OR lote='' INTO valida_integridad;
					
					
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'cantidad1:Debe darle salida a la materia prima___';
					END IF;
					
					valida_integridad := 0;
					----Se comento, por que esta validacion, ya no existira
					----SELECT count(prosal.pro_orden_prod_id) as cantidad from pro_ordenprod_invosal as prosal join inv_osal on (inv_osal.id=prosal.inv_osal_id and inv_osal.estatus=2)
					 ----where prosal.pro_orden_prod_id=str_data[4]::integer INTO valida_integridad;
					 
					 
					----IF valida_integridad <= 0 THEN
					----	valor_retorno := ''||valor_retorno||'cantidad1:Debe confirmar la salida de la materia prima___';
					----END IF;
					
					--RAISE EXCEPTION '%',valida_integridad;
					
				----	IF valor_retorno = '' OR valor_retorno is null THEN
				----		SELECT count(prosal.pro_orden_prod_id) as cantidad from pro_ordenprod_invosal as prosal join inv_osal on (inv_osal.id=prosal.inv_osal_id and inv_osal.estatus=2)
				----		 where prosal.pro_orden_prod_id=str_data[4]::integer  INTO valida_integridad;
				----		IF valida_integridad = 0 THEN
				----			valor_retorno := ''||valor_retorno||'cantidad1:Debe darle salida a la materia prima___';
				----		END IF;
				----	END IF;
				----	--valida que se capturaron los numero de lote en produccion
				----	--SELECT count(opdm.id) as cantidad from (SELECT id from pro_orden_prod_det where pro_orden_prod_id=str_data[4]::integer ) as tmp 
				----	--join pro_orden_detalle_mov as opdm on (opdm.pro_orden_prod_det_id= tmp.id AND (opdm.num_lote is not null AND opdm.num_lote = '')) INTO valida_integridad;
				----	
				----	SELECT count(pro_orden_detalle_mov.num_lote) from (
				----	selecT * from pro_get_detalle_orden_produccion(componente_id,str_data[4]::integer,1)  as foo(id integer, inv_prod_id integer, sku character varying,descripcion character varying, 
				----	requiere_numero_lote boolean ,cantidad_adicional double precision,id_reg_det integer, cantidad double precision,elemento integer, lote character varying)
				----	) as inv 
				----	join 
				----	pro_orden_detalle_mov on (pro_orden_detalle_mov.id=inv.id_reg_det AND pro_orden_detalle_mov.num_lote is not null AND pro_orden_detalle_mov.num_lote <> '' ) INTO valida_integridad;
				----	--RAISE EXCEPTION '%',str_data[4];
				----	IF valida_integridad = 0 THEN
				----		valor_retorno := ''||valor_retorno||'cantidad1:Debe capturar tods los lotes en produccion___';
				----	END IF;
					
					--valida que se capturaron especificaciones en produccion
					SELECT count(tmp.id), count(opdes.id) from (
					SELECT id from pro_orden_prod_det where pro_orden_prod_id=str_data[4]::integer ) as tmp
					left join pro_orden_prod_subp_esp as opdes on opdes.pro_orden_prod_det_id= tmp.id INTO valida_integridad, existe_lote;
					
					IF existe_lote = 0 THEN
						IF valida_integridad < existe_lote THEN
							valor_retorno := ''||valor_retorno||'cantidad1:Debe capturar las especificaciones para cada sumproceso___';
						END IF;
					END IF;
					
					valida_integridad:= 0;
					--valida que todas las cantidades usadas, se hallan guardado
					selecT count(id) as cantidad from pro_get_detalle_orden_produccionv2(componente_id,str_data[4]::integer,id_almacen, 0) 
					as foo(id integer, inv_prod_id integer, 
					sku character varying,descripcion character varying, requiere_numero_lote boolean ,cantidad_adicional double precision,
					id_reg_det integer, cantidad double precision,elemento integer, lote character varying, inv_osal_id integer, inv_alm_id integer, 
					gral_suc_id integer, agregado boolean,cantidad_usada double precision, guardado boolean) where guardado=false  INTO valida_integridad;
					
					--RAISE EXCEPTION '%' ,' componente_id:'||componente_id||' str_data[4]:'||str_data[4]::integer||' id_almacen:'||id_almacen;
					
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'cantidad1:Debe de guardar todas las cantidades reales usadas___';
					END IF;
					
				END IF;

			ELSE
				IF estado_calidad=0 THEN
					valor_retorno := ''||valor_retorno||'statuscalidad:La Orden debe ser Aceptada por personal de Calidad, no es posible terminar.___';
				END IF;

				IF estado_calidad=2 THEN
					valor_retorno := ''||valor_retorno||'statuscalidad:La Orden fue Rechazada por personal de calidad, no es posible terminar.___';
				END IF;
			END IF;
		END IF;
		
	END IF;
	--Termina validacion de orden de produccion


		
	

	
	
	--validacion de Aplicativo Ordenes de Salida
	IF id_app=94 THEN
		--str_data[4]	id_osal
		--str_data[5]	observaciones
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer <> 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	eliminado[i]
					--str_filas[2]	tipo_registro[i]
					--str_filas[3]	id_detalle_lot[i]
					--str_filas[4]	id_detalle_os[i]
					--str_filas[5]	id_almacen[i]
					--str_filas[6]	id_prod_grid[i]
					--str_filas[7]	lote_interno[i]
					--str_filas[8]	cantidad_fac[i]
					--str_filas[9]	cant_sur[i]
					--str_filas[10]	no_tr[i]

					--Inicializar variables
					tipo=0;
					idUnidadMedida=0;
					nombreUnidadMedida:='';
					densidadProd:=0;
					noDecUnidad:=0;
					idUnidadMedidaVenta:=0;
					cantUnidadVenta:=0;
					cantExisUnidadVenta:=0;
					
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='PAR' THEN
						suma_lotes:=0;
						--RAISE EXCEPTION '%',str_filas[9];
						--str_filas[9]	cant_sur[i]
						IF trim(str_filas[9])='' THEN
							valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':Es necesario ingresar la Cantidad Surtida.___';
						ELSE
							--RAISE EXCEPTION '%',str_filas[9];
							IF str_filas[9]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La Cantidad Surtida debe ser mayor que cero.___';
							ELSE
								IF str_filas[8]::double precision <> str_filas[9]::double precision THEN
									valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La Cantidad Surtida debe ser igual que la cantidad facturada para esta partida.___';
								END IF;
							END IF;
						END IF;
						
						
						total_filas2:= array_length(arreglo,1);
						cont_fila2:=1;
						FOR cont_fila2 IN 1 .. total_filas2 LOOP
							SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
							
							--str_filas2[1] eliminado
							IF str_filas2[1]::integer <> 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
								IF str_filas2[2]='LOT' THEN
									--Aqui se suman las cantidades de los lotes de la partida actual
									IF str_filas[4]=str_filas2[4] THEN
										IF trim(str_filas2[9])<>'' THEN
											suma_lotes := suma_lotes + str_filas2[9]::double precision;
										END IF;
									END IF;
								END IF;
							END IF;
						END LOOP;
						
						suma_lotes := round(suma_lotes::numeric,4)::double precision;
						
						IF trim(str_filas[9])<>'' THEN
							--str_filas[9]	cantidad_rec[i]
							IF suma_lotes > round(str_filas[9]::numeric,4)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La suma de los Lotes no debe ser Mayor que Cantidad Surtida en la Partida.___';
							END IF;
							
							--str_filas[9]	cantidad_rec[i]
							IF suma_lotes < round(str_filas[9]::numeric,4)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La suma de los Lotes no debe ser Menor que Cantidad Surtida en la Partida.___';
							END IF;
						END IF;
						
					ELSE
						--Aqui entra cuando el registro es un LOTE
						IF trim(str_filas[7])='' THEN
							valor_retorno := ''||valor_retorno||'lote_int'||str_filas[10]||':Es necesario ingresar un n&uacute;mero de Lote.___';
						ELSE
							--Busca el numero de lote.
							--El query retorna 0 si no se encuentra o si tiene existencia 0
							SELECT count(id) FROM (
								SELECT id, (inicial - salidas + entradas) AS existencia FROM inv_lote 
								WHERE lote_int=str_filas[7] AND inv_prod_id=str_filas[6]::integer AND inv_alm_id=str_filas[5]::integer 
							) AS sbt
							WHERE existencia > 0 INTO existe_lote;
							
							--RAISE EXCEPTION '%','lote_int: '||str_filas[7]||'         inv_prod_id: '||str_filas[6]||'           inv_alm_id: '||str_filas[5];
							
							--si exis_lote es mayor que cero quiere decir que el numero de lote si existe y tiene existencia
							IF existe_lote > 0 THEN

								--Obtener el tipo de producto y el numero de Decimales Permitidos
								SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
								FROM inv_prod 
								LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
								WHERE inv_prod.id=str_filas[6]::integer 
								INTO tipo, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;

								--Obtener la unidad de Medida del producto de esta partida(unidad de medida de la venta)
								SELECT inv_prod_unidad_id FROM inv_osal_detalle WHERE id=str_filas[4]::integer INTO idUnidadMedidaVenta;
								
								--Buscar la existencia actual del numero de Lote.
								SELECT id, (inicial - salidas + entradas - reservado) AS existencia 
								FROM inv_lote 
								WHERE lote_int=str_filas[7] AND inv_prod_id=str_filas[6]::integer AND inv_alm_id=str_filas[5]::integer
								INTO id_lote, cant_existencia_lote;
								
								cant_sal_anterior := 0.0;
								--Si el id_detalle del lote es mayor que cero, es editar
								IF str_filas[3]::integer > 0 THEN
									--Busca la cantidad  anterior de salida ingresada anteriormente
									SELECT cantidad_sal FROM inv_lote_detalle WHERE id=str_filas[3]::integer INTO cant_sal_anterior;
									--RAISE EXCEPTION '%','lote_int: '||cant_sal_anterior||'    exis:'||cant_existencia_lote||'     nuevo:'||(cant_existencia_lote + cant_sal_anterior);
								END IF;
								
								
								IF idUnidadMedidaVenta IS NOT NULL AND idUnidadMedidaVenta > 0 THEN
									IF idUnidadMedida<>idUnidadMedidaVenta THEN
										IF densidadProd IS NULL OR densidadProd=0 THEN
											densidadProd:=1;
										END IF;
										
										EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
										IF match_cadena=true THEN
											--Convertir a litros la existencia para mostrar el warning(Convertir a la Unidad de la Venta)
											cant_existencia_lote := cant_existencia_lote::double precision / densidadProd;
										ELSE
											EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
											IF match_cadena=true THEN
												--Convertir a Kilos la existencia para mostrar el warning(Convertir a la Unidad de la Venta)
												cant_existencia_lote := cant_existencia_lote::double precision * densidadProd;
											END IF;
										END IF;
									END IF;
								END IF;
								
								
								cant_existencia_lote := round((cant_existencia_lote + cant_sal_anterior::double precision)::numeric,4)::double precision;
								
								IF trim(str_filas[9])<>'' THEN
									IF round(str_filas[9]::numeric,4)::double precision > cant_existencia_lote THEN
										valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La existecncia del Lote es '||cant_existencia_lote||'. La Cantidad Surtida NO debe ser mayor que la existencia del Lote.___';
									END IF;
								END IF;
							ELSE
								valor_retorno := ''||valor_retorno||'lote_int'||str_filas[10]||':El n&uacute;mero de Lote no existe para este producto o No tiene Existencia.___';
							END IF;
						END IF;
						
						
						IF str_filas[9] = ' ' OR str_filas[9] = '' THEN
							valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':Es necesario ingresar la Cantidad Surtida para &eacute;ste lote.___';
						ELSE
							IF str_filas[9]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_sur'||str_filas[10]||':La Cantidad Surtida debe ser mayor que cero.___';
							END IF;
						END IF;
						
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Ordenes de Salida
	
	
	
	
	
	
	--validacion de Ajustes de Inventario
	IF id_app=95 THEN
		--str_data[4]	identificador
		--str_data[5]	select_tipo_mov
		--str_data[6]	observaciones

		SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	idproducto[i]
					--str_filas[2]	id_almacen[i]
					--str_filas[3]	cant_ajuste[i]
					--str_filas[4]	costo_ajuste[i]
					--str_filas[5]	no_tr[i]
					--str_filas[6]	select_pres
					
					SELECT tipo_costo, grupo FROM inv_mov_tipos WHERE id=str_data[5]::integer INTO tipo_costo_movimiento, grupo_movimiento;
					
					IF str_filas[3]='' OR str_filas[3]=' ' THEN 
						valor_retorno := ''||valor_retorno||'cant_ajuste'||str_filas[5]||':Es necesario ingresar la CANTIDAD del Ajuste.___';
					ELSE
						IF str_filas[3]::double precision < 0.000001 THEN 
							valor_retorno := ''||valor_retorno||'cant_ajuste'||str_filas[5]||':La CANTIDAD del ajuste debe ser mayor que cero.___';
						END IF;
					END IF;
					
					
					IF str_filas[6]::integer=0 THEN
						valor_retorno := ''||valor_retorno||'select_pres'||str_filas[5]||':Es necesario seleccionar la Presentacion.___';
					ELSE
						IF controlExisPres=true THEN
							--aqui entra si la configuracion indica que se debe controlar existencias por presentaciones
							
							--0=Entradas, 2=Salidas
							IF grupo_movimiento=2 THEN 
								
								IF trim(str_filas[3])!=''THEN 
									IF str_filas[3]::double precision > 0 THEN
										--buscar el numero de decimales de la unidad del producto
										SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
										WHERE inv_prod.id=str_filas[1]::integer 
										INTO noDecUnidad;

										IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
										
										--inicializar valor a cero
										equivalenciaPres:=0;
										
										--buscar la equivalencia de la Presentacion del Producto
										SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_filas[6]::integer 
										INTO equivalenciaPres;
										
										IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
										
										--inicializar valor
										exisActualPres:=0;
										
										--buscar la existencia actual de la presentacion
										SELECT (inicial::double precision + entradas::double precision - salidas::double precision - reservado::double precision) AS exis 
										FROM inv_exi_pres  
										WHERE inv_alm_id=str_filas[2]::integer 
										AND inv_prod_id=str_filas[1]::integer 
										AND inv_prod_presentacion_id=str_filas[6]::integer 
										INTO exisActualPres;
										
										IF exisActualPres IS NULL THEN exisActualPres:=0; END IF;
										
										--redondear la Existencia Actual de la Presentacion Origen
										exisActualPres := round(exisActualPres::numeric,noDecUnidad)::double precision;

										
										--convertir la Suma de Unidades en su equivalencia a la Presentacion Origen
										cantPresAsignado := str_filas[3]::double precision / equivalenciaPres::double precision;
										
										--redondear la Cantidad de Presentacion Asignado para Re-Envasar
										cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision;
										
										--validar si la Cantidad Asignada para para el ajuste Negativo
										IF cantPresAsignado::double precision > exisActualPres::double precision THEN 
											valor_retorno := ''||valor_retorno||'cantAjustePres'||str_filas[5]||':La CANTIDAD del Ajuste no debe ser mayor que la existencia actual.___';
										END IF;
									END IF;
								END IF;
							END IF;
						END IF;
					END IF;
					
					--0=Alimentado, 1=Promedio
					IF tipo_costo_movimiento=0 THEN 
						IF trim(str_filas[4])='' THEN 
							valor_retorno := ''||valor_retorno||'costo_ajuste'||str_filas[5]||':Es necesario ingresar COSTO del Ajuste.___';
						ELSE
							IF str_filas[4]::double precision < 0.000001 THEN 
								valor_retorno := ''||valor_retorno||'costo_ajuste'||str_filas[5]||':El COSTO del ajuste debe ser mayor que cero.___';
							END IF;
						END IF;
					END IF;
					
					
					--0=Entradas, 2=Salidas
					IF grupo_movimiento=2 THEN 
						SELECT (inv_exi.exi_inicial - inv_exi.transito - inv_exi.reservado + inv_exi.entradas_1 + inv_exi.entradas_2 + inv_exi.entradas_3 + inv_exi.entradas_4 + inv_exi.entradas_5 + inv_exi.entradas_6 + inv_exi.entradas_7 + inv_exi.entradas_8 + inv_exi.entradas_9 + inv_exi.entradas_10 + inv_exi.entradas_11 + inv_exi.entradas_12 - inv_exi.salidas_1 - inv_exi.salidas_2 - inv_exi.salidas_3 - inv_exi.salidas_4 - inv_exi.salidas_5 - inv_exi.salidas_6 - inv_exi.salidas_7 - inv_exi.salidas_8 - inv_exi.salidas_9 - inv_exi.salidas_10 - inv_exi.salidas_11 - inv_exi.salidas_12) AS existencia
						FROM inv_exi WHERE inv_prod_id=str_filas[1]::integer AND inv_alm_id=str_filas[2]::integer AND ano=EXTRACT(YEAR FROM now())
						INTO existencia_producto;
						
						IF trim(str_filas[3])!=''THEN 
							IF str_filas[3]::double precision > 0 THEN
								IF existencia_producto < str_filas[3]::double precision THEN
									valor_retorno := ''||valor_retorno||'cant_ajuste'||str_filas[5]||':La CANTIDAD del ajuste no debe ser mayor que la existencia actual.___';
								END IF;
							END IF;
						END IF;
					END IF;

					
					
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Ajustes de Inventario
	
	
	
	--validacion de proceso de productos equivalentes
	IF id_app=96 THEN 
		--str_data[1]  app_selected es 96
		--str_data[2]  command_selected = new    
		--str_data[3]  id_usuario es = 1
		--str_data[4]  identificador = 0 nuevo
		--str_data[5]  inv_prod_id 1127   select * from inv_prod_equiv
		
		IF str_data[5] = '' or str_data[5] = '0'  THEN
		--RAISE EXCEPTION 'ESTO TRAE EL 7     %   ',': '||str_data[5]; 
			valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto'; 
		END IF; 
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo 
		IF total_filas < 1 THEN 
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto en equivalente___'; 
		END IF; 
		
		IF str_data[4]::integer = 0 THEN  
			EXECUTE 'select count(inv_prod_id) 
			from inv_prod_equiv 
			where inv_prod_id='||str_data[5]::integer||';' 
			INTO valida_integridad; 
				--EXECUTE 'select count(id) from pro_estruc_det where  inv_prod_id_salida='||str_data[6]::integer||'  AND gral_emp_id='||emp_id||';' INTO valida_integridad; 
			IF valida_integridad > 0 THEN 
				valor_retorno := ''||valor_retorno||'codigo:El producto seleccionado, ya tiene sus equivalentes___'; 
			END IF; 
		END IF; 
		
		-- validaciones para el grid -- 
		IF arreglo[1] != 'sin datos' THEN 
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo 
			cont_fila:=1; 
			FOR cont_fila IN 1 .. total_filas LOOP 

			END LOOP; 
		ELSE 
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la configuracion___'; 
		END IF; 
	END IF;--termina validacion de proceso de productos equivalentes
	
	



	--Validacion de Aplicativo Ordenes de Devolucion
	IF id_app=100 THEN
		--str_data[4]	identificador
		--str_data[5]	observaciones
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	eliminado[i]
					--str_filas[2]	tipo_registro[i]
					--str_filas[3]	id_detalle[i]
					--str_filas[4]	id_almacen[i]
					--str_filas[5]	id_prod_grid[i]
					--str_filas[6]	lote_id[i]
					--str_filas[7]	lote_interno[i]
					--str_filas[8]	cant_dev[i]
					--str_filas[9]	no_tr[i]
					--str_filas[10]	id_partida[i]

					
					
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='PAR' THEN
						suma_lotes:=0;
						--RAISE EXCEPTION '%',str_filas[8];
						
						total_filas2:= array_length(arreglo,1);
						cont_fila2:=1;
						FOR cont_fila2 IN 1 .. total_filas2 LOOP
							SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
							
							--str_filas2[1] eliminado
							IF str_filas2[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
								IF str_filas2[2]='LOT' THEN
									--aqui se suman las cantidades de los lotes de la partida actual
									IF trim(str_filas[10])=trim(str_filas2[10]) THEN
										IF trim(str_filas2[8])<>'' THEN
											suma_lotes := suma_lotes + str_filas2[8]::double precision;
										END IF;
									END IF;
								END IF;
							END IF;
						END LOOP;
						
						suma_lotes := round(suma_lotes::numeric,4)::double precision;
						
						IF trim(str_filas[8])!='' THEN
							--str_filas[8]	cantidad_rec[i]
							IF suma_lotes > round(str_filas[8]::numeric,4)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[9]||':La suma de los Lotes no debe ser Mayor que la Cantidad a devolver de la Partida.___';
							END IF;
							
							--str_filas[8]	cantidad_rec[i]
							IF suma_lotes < round(str_filas[8]::numeric,4)::double precision THEN
								valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[9]||':La suma de los Lotes no debe ser Menor que la Cantidad a devolver de la Partida.___';
							END IF;
						END IF;
					ELSE
						IF trim(str_filas[8])='' THEN
							valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[9]||':Es necesario ingresar la Cantidad a Devolver para &eacute;ste lote.___';
						ELSE
							IF str_filas[8]::double precision < 0.000001 THEN
								valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[9]||':La Cantidad a Devolver debe ser mayor que cero.___';
							END IF;
						END IF;
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Ordenes de Devolucion
	

	
	
	
	--validacion de Aplicativo Notas de Credito Proveedores
	IF id_app=101 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]	id_nota_credito
		--str_data[5]	id_proveedor
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones.toUpperCase()
		--str_data[9]	select_moneda
		--str_data[10]	concepto.toUpperCase()
		--str_data[11]	tipo_cambio
		--str_data[12]	importe
		--str_data[13]	impuesto
		--str_data[14]	total
		--str_data[15]	factura
		--str_data[16]	fac_saldado
		--str_data[17]	folio_nota_credito
		--str_data[18]	fecha_expedicion
		
		IF str_data[5] = '0'  THEN
			valor_retorno := ''||valor_retorno||'noproveedor:Es necesario seleccionar un Proveedor___';
		END IF;
		
		IF str_data[10] = ''  THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario el Concepto para la Nota de Credito___';
		END IF;
		
		IF str_data[11] = ''  THEN
			valor_retorno := ''||valor_retorno||'tc:Es necesario el tipo de Cambio___';
		END IF;
		
		IF str_data[12]='' OR str_data[12]='0' OR str_data[12]='0.00' THEN
			valor_retorno := ''||valor_retorno||'importe:Es necesario el Importe para la Nota de Credito___';
		END IF;
		
		IF str_data[14]='' OR str_data[14]='0' OR str_data[14]='0.00' THEN
			valor_retorno := ''||valor_retorno||'total:Total no valido.___';
		END IF;
		
		IF str_data[15] = ''  THEN
			valor_retorno := ''||valor_retorno||'factura:Es necesario seleccionar una Factura___';
		END IF;
		
		IF str_data[17] = ''  THEN
			valor_retorno := ''||valor_retorno||'folionota:Es necesario seleccionar una Factura___';
		END IF;
		
		IF str_data[18] = ''  THEN
			valor_retorno := ''||valor_retorno||'expedicion:Es necesario ingresar la fecha de la Nota de Credito.___';
		END IF;
	END IF;--termina validacion de Aplicativo Notas de Credito Proveedores
	
	
	
	--validacion de Aplicativo Devoluciones de Mercancia a Proveedores
	IF id_app=102 THEN
		--str_data[4]	id_nota_credito
		--str_data[5]	id_proveedor
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones
		--str_data[9]	select_moneda
		--str_data[10]	concepto
		--str_data[11]	tipo_cambio
		--str_data[12]	importe
		--str_data[13]	impuesto
		--str_data[14]	total
		--str_data[15]	factura
		--str_data[16]	fac_saldado
		--str_data[17]	folio_nota_credito
		--str_data[18]	fecha_expedicion
		--str_data[19]	select_tipo_movimiento
		--str_data[20]	select_tipo_nota
		--str_data[21]	select_almacen
		
		IF str_data[10]='' OR str_data[10]=' '  THEN
			valor_retorno := ''||valor_retorno||'concepto:Es necesario ingresar el Concepto para la Nota de Cr&eacute;dito.___';
		END IF;
		
		IF str_data[11] = ''  THEN
			valor_retorno := ''||valor_retorno||'tcnota:Es necesario ingresar el Tipo de Cambio para la Nota de Cr&eacute;dito.___';
		ELSE
			IF str_data[11]::double precision < 1  THEN
				valor_retorno := ''||valor_retorno||'tcnota:El Tipo de Cambio debe ser mayor o igual a 1.___';
			END IF;
		END IF;
		
		IF str_data[14]::double precision > 0 THEN
			--obtener el saldo de la factura
			SELECT cxp_facturas.saldo_factura FROM cxp_facturas WHERE cxp_facturas.cxc_prov_id=str_data[5]::integer AND cxp_facturas.serie_folio=str_data[15] AND cxp_facturas.tipo_factura_proveedor=1 
			INTO saldo_fac;

			--validar  que el monto de la nota de credito no sea mayor que el saldo de la factura
			IF str_data[14]::double precision > saldo_fac  THEN
				valor_retorno := ''||valor_retorno||'totalnota:El total de la devoluci&oacute;n no debe ser mayor que el Saldo de la Factura.___';
			END IF;
			
		END IF;

		IF str_data[17]='' OR str_data[17]=' '  THEN
			valor_retorno := ''||valor_retorno||'folionota:Es necesario ingresar el N&uacute;mero de la Nota de Cr&eacute;dito.___';
		END IF;

		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	idproducto
				--str_filas[2]	cantidad
				--str_filas[3]	cant_devuelto
				--str_filas[4]	cant_dev
				--str_filas[5]	notr
				--str_filas[6]	iddetalle
				
				--str_filas[4]	cant_dev
				IF str_filas[4] = ' ' OR str_filas[4] = '' THEN
					valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[5]||':Es necesario ingresar la cantidad a devolver.___';
				ELSE
					--RAISE EXCEPTION '%',str_filas[4];
					IF str_filas[4]::double precision < 0.000001 THEN
						valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[5]||':La cantidad a devolver debe ser mayor que cero.___';
					ELSE
						SELECT round((cantidad - cantidad_devolucion)::numeric,2)::double precision FROM com_fac_detalle WHERE id=str_filas[6]::integer INTO cant_disponible;
						
						
						--evaluar  que la cantidad a devolver no sea mayor que la cantidad Disponible
						IF str_filas[4]::double precision > cant_disponible THEN
							valor_retorno := ''||valor_retorno||'cant_dev'||str_filas[5]||':La cantidad a devolver no debe ser mayor que la cantidad de la partida.___';
						END IF;
					END IF;
				END IF;
					
				
			END LOOP;
			
		END IF;
		
	END IF;--Termina validacion de Aplicativo Devoluciones de Mercancia a Proveedores
	
	
	
	
	
	
	--validacion de Aplicativo Ordenes de Traspaso
	IF id_app=105 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	select_alm_origen
		--str_data[6]	select_alm_destino
		--str_data[7]	observaciones
		--str_data[8]	fecha
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	no_tr[i]
				--str_filas[2]	tipotr[i]
				--str_filas[3]	idPartida[i]
				--str_filas[4]	idproducto[i]
				--str_filas[5]	lote_int[i]
				--str_filas[6]	cant_traspaso[i]
				IF str_filas[2]='PARTIDA' THEN
					suma_lotes:=0.0;
					total_filas2:= array_length(arreglo,1);
					cont_fila2:=1;
					FOR cont_fila2 IN 1 .. total_filas2 LOOP
						SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');
						IF str_filas2[2]='LOTE' THEN
							--aqui se suman las cantidades de los lotes de la partida actual
							IF str_filas[3]=str_filas2[3] THEN
								IF str_filas2[6]!='' AND  str_filas2[6]!=' ' THEN
									suma_lotes := suma_lotes + str_filas2[6]::double precision;
								END IF;
							END IF;
						END IF;
					END LOOP;
					
					--redondear a 4 digitos la Suma de Lotes
					suma_lotes := round(suma_lotes::numeric,4)::double precision;
					
					--str_filas[9]	cantidad_rec[i]
					IF suma_lotes > round(str_filas[6]::numeric,4)::double precision THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[1]||':La suma de los Lotes no debe ser Mayor que la Cantidad del Traspaso en la Partida.___';
					END IF;
					
					--str_filas[9]	cantidad_rec[i]
					IF suma_lotes < round(str_filas[6]::numeric,4)::double precision THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[1]||':La suma de los Lotes no debe ser Menor que la Cantidad del Traspaso en la Partida.___';
					END IF;
					
				ELSE
					--aqui entra cuando el registro es un LOTE
					IF str_filas[5] = ' ' OR str_filas[5] = '' THEN
						valor_retorno := ''||valor_retorno||'lote_int'||str_filas[1]||':Es necesario ingresar un n&uacute;mero de Lote.___';
					ELSE
						--busca el lote
						--el query retorna 0 si no se encuentra o si tiene existencia 0
						SELECT count(id) FROM ( SELECT id, (inicial - salidas + entradas - reservado) AS existencia FROM inv_lote WHERE lote_int=str_filas[5] AND inv_prod_id=str_filas[4]::integer AND inv_alm_id=str_data[5]::integer ) AS sbt
						WHERE existencia > 0 INTO existe_lote;
						
						--RAISE EXCEPTION '%','lote_int: '||str_filas[7]||'         inv_prod_id: '||str_filas[6]||'           inv_alm_id: '||str_filas[5];
						
						--si exis_lote es mayor que cero quiere decir que el numero de lote si existe y tiene existencia
						IF existe_lote > 0 THEN
							
							SELECT id, (inicial - salidas + entradas - reservado) AS existencia FROM inv_lote WHERE lote_int=str_filas[5] AND inv_prod_id=str_filas[4]::integer AND inv_alm_id=str_data[5]::integer
							INTO id_lote, cant_existencia_lote;
							
							--redondear a 4 digitos la existencia del lote
							cant_existencia_lote := round(cant_existencia_lote::numeric,4)::double precision;
							
							IF str_filas[6] != ' ' AND str_filas[6] != '' THEN
								IF round(str_filas[6]::numeric,4)::double precision > cant_existencia_lote THEN
									valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[1]||':La existecncia del Lote='||cant_existencia_lote||'. La Cantidad del traspaso NO debe ser mayor que la existencia del Lote.___';
								END IF;
							END IF;
						ELSE
							valor_retorno := ''||valor_retorno||'lote_int'||str_filas[1]||':El n&uacute;mero de Lote no existe para este producto en el almacen Origen o No tiene Existencia.___';
						END IF;
					END IF;
					
					
					IF str_filas[6] = ' ' OR str_filas[6] = '' THEN
						valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[1]||':Es necesario ingresar la Cantidad del Traspaso para &eacute;ste lote.___';
					ELSE
						IF str_filas[6]::double precision < 0.000001 THEN
							valor_retorno := ''||valor_retorno||'cant_traspaso'||str_filas[1]||':La Cantidad del Traspaso debe ser mayor que cero.___';
						END IF;
					END IF;
					
				END IF;--termina if de tipo tr
				
			END LOOP;
		END IF;
	END IF;--Termina validacion de Aplicativo Ordenes de Traspaso
	
	
	
	
	--validacion de Aplicativo Catalogo de Cuentas Contables
	IF id_app=106 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id
		--str_data[5]	cuenta
		--str_data[6]	scuenta
		--str_data[7]	sscuenta
		--str_data[8]	ssscuenta
		--str_data[9]	sssscuenta
		--str_data[10]	cuenta_mayor
		--str_data[11]	estatus
		--str_data[12]	cta_detalle
		--str_data[13]	descripcion_es
		--str_data[14]	descripcion_in
		--str_data[15]	descripcion_otro
		--str_data[16]	select_centro_costo
		--str_data[17]	select_sucursal
		--str_data[18]	select_nivel
		--str_data[19]	select_naturaleza
		--str_data[20]	select_tipo_cta
		
		cuenta_mayor := rpad(str_data[5], 4, '0')||lpad(str_data[6], 4, '0')||lpad(str_data[7], 4, '0')||lpad(str_data[8], 4, '0')||lpad(str_data[9], 4, '0');
		
		IF cuenta_mayor='00000000000000000000' THEN 
			valor_retorno := ''||valor_retorno||'cta:Es necesario ingresar la cuenta.___';
		ELSE
			EXECUTE 'select count(id) FROM ctb_cta WHERE cuenta='''||cuenta_mayor||''' AND gral_emp_id='||emp_id||' AND borrado_logico=false;' 
			INTO valida_integridad; 
			
			IF valida_integridad > 0 THEN 
				EXECUTE 'select id FROM ctb_cta WHERE cuenta='''||cuenta_mayor||''' AND gral_emp_id='||emp_id||' AND borrado_logico=false;' INTO id_registro; 
				IF id_registro != str_data[4]::integer THEN
					valor_retorno := ''||valor_retorno||'cta:La cuenta ya se encuentra registrado.___';
				END IF;
			END IF;
		END IF;
		
		IF trim(str_data[13])='' THEN 
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la descripcion.___';
		END IF;

		IF trim(str_data[17])::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'suc:Es necesario seleccionar la Sucursal.___';
		END IF;

		
		IF trim(str_data[18])::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'nivelcta:Seleccionar el Nivel.___';
		END IF;

		IF trim(str_data[19])::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'natcta:Seleccionar la Naturaleza de la cuenta.___';
		END IF;

		IF trim(str_data[20])::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipocta:Seleccionar el Tipo de la cuenta.___';
		END IF;
		
	END IF;--termina validacion de Catalogo de Cuentas Contables
	
	
	
	
	--################### validacion de proceso de formulas en desarrollo ##############
	--validacion de proceso de formulas en desarrollo
	IF id_app=108 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  id_prod_master
		--str_data[6]  inv_prod_id
		--str_data[7]  nivel
		--str_data[8]  producto_elemento_id
		--str_data[9]  cantidad
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		
		
		IF str_data[5] = '' or str_data[5] = '0' THEN
			valor_retorno := ''||valor_retorno||'id_prod_master:Es necesario seleccionar un producto';
		END IF;
		
		IF str_data[6] = '' or str_data[6] = '0'  THEN
			valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto de salida___';
		END IF;
		
		IF str_data[7] = '' or str_data[7] = '0'  THEN
			valor_retorno := ''||valor_retorno||'paso_actual:Es necesario ingresar un numero de paso___';
		END IF;
		
		total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
		IF total_filas < 1 THEN
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un producto en la configuracion___';
		END IF;
		
		IF str_data[4] = '0' THEN 
			
			IF str_data[5] = '' or str_data[5] = '0'  THEN
				valor_retorno := ''||valor_retorno||'id_prod_master:Es necesario seleccionar un producto___';
			ELSE
				EXECUTE 'select count(id) from pro_estruc where inv_prod_id='||str_data[5]::integer||' AND version='||str_data[9]::integer||' AND borrado_logico=false and gral_emp_id='||emp_id||';' INTO valida_integridad;
				--EXECUTE 'select count(id) from pro_estruc_det where  inv_prod_id_salida='||str_data[6]::integer||'  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'id_prod_master:El producto de salida seleccionado, ya tiene un proceso con la misma version___';
				END IF;
			END IF;
			
			/*//Comentado por la nueva version
			IF str_data[6] = '' or str_data[6] = '0'  THEN
				valor_retorno := ''||valor_retorno||'inv_prod_id:Es necesario seleccionar un producto___';
			ELSE
				EXECUTE 'select count(id) from pro_estruc where inv_prod_id='||str_data[6]::integer||' and borrado_logico=false and gral_emp_id='||emp_id||';' INTO valida_integridad;
				--EXECUTE 'select count(id) from pro_estruc_det where  inv_prod_id_salida='||str_data[6]::integer||'  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'inv_prod_id:El producto de salida seleccionado, ya tiene un proceso___';
				END IF;
			END IF;
			*/
		END IF;
		
		--esta parte es para validar que ninguna version de la formula, sea de tipo de producto terminado
		--y que no pueda gruardar si es asi
		IF str_data[4] <> '0' THEN 
			
			valida_integridad := 0;
			
			select count(inv_prod.id) from ( 
			select inv_prod_id from pro_estruc where  pro_estruc_id = ( 
			select pro_estruc_id from pro_estruc where id=str_data[4]::integer 
			) AND pro_estruc.borrado_logico=false ) as tmp_estruct join inv_prod ON inv_prod.id=tmp_estruct.inv_prod_id 
			where inv_prod.tipo_de_producto_id <> 8 INTO valida_integridad;
			
			IF valida_integridad > 0  THEN
				valor_retorno := ''||valor_retorno||'id_prod_master:Ya no se pueden hacer cambios, Existe una version terminada___';
			END IF;
			
		END IF;
		
		
		-- validaciones para el grid --
		IF arreglo[1] != 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				----aqui se vuelven a crear los registros
				IF str_filas[4] != '0' THEN
					
					--VALIDACION PARA  EL GRID
					IF str_filas[2] = ' ' OR str_filas[2] = '' THEN
						valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':Es necesario ingresar la cantidad___';
					ELSE
						IF str_filas[2]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[5]||':La cantidad debe ser mayor a cero___';
						END IF;
					END IF;
					
					--para validar el numero de paso--
					IF str_filas[3] = ' ' OR str_filas[3] = '' THEN
						valor_retorno := ''||valor_retorno||'posicion'||str_filas[5]||':Es necesario ingresar la posicion___';
					ELSE
						IF str_filas[3]::double precision < 0.000001  THEN
							valor_retorno := ''||valor_retorno||'posicion'||str_filas[5]||':La posicion debe ser mayor a cero___';
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			valor_retorno := ''||valor_retorno||'error_grid:Debe ingresar por lo menos un elemnto en la configuracion___';
		END IF;
		
	END IF;--termina validacion de proceso de formulas en desarrollo
	--termina validacion de proceso de formulas en desarrollo



	
	
	--validacion de Catalogo Motivos de Visita
	IF id_app=109 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar el motivo de visita';
		END IF;
		
		EXECUTE 'select count(descripcion) from crm_motivos_visita 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:El motivo de visita ingresada ya se encuentra registrada';
				END IF;		
	END IF;--termina validacion de Catalogo Motivos de Visita 

	--validacion de Formas Contacto
	IF id_app=110 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la forma de contacto';
		END IF;
		
		EXECUTE 'select count(descripcion) from crm_formas_contacto 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:La forma de contacto ingresada ya se encuentra registrada';
				END IF;		
	END IF;--termina validacion de Catalogo Formas Contacto 
	
	--validacion de Catalogo Motivos de Llamada
	IF id_app=111 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar el motivo de llamada';
		END IF;
		
		EXECUTE 'select count(descripcion) from crm_motivos_llamada 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:El motivo de llamada ingresado ya se encuentra registrada';
				END IF;		
	END IF;--termina validacion de Catalogo Motivos de Llamada

	--validacion de Catalogo Instrumentos Medicion
	IF id_app=112 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]        id
		--str_data[5]        descripcion		
		IF str_data[5] = ''  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la descripcion del instrumento';
		END IF;
		
		EXECUTE 'select count(descripcion) from pro_instrumentos 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:El instrumento ingresada ya se encuentra registrada';
		END IF;		
	END IF;--termina validacion de Catalogo Instrumentos Medicion  
	
	


	--CATALOGO DE PROSPECTOS(CRM)
	IF id_app=113 THEN
	        --RAISE EXCEPTION '%','total  de filas???'||str_data[1]||'___'||str_data[2]||'___'||str_data[3]||'___'||str_data[4]||'___'||str_data[5]||'___'||str_data[6]||'___'||str_data[7]||'___'||str_data[8]||'___'||str_data[9]||'___'||str_data[10];
		--RAISE EXCEPTION '%','total  de filas???'||str_data[11]||'___'||str_data[12]||'___'||str_data[13]||'___'||str_data[14]||'___'||str_data[15]||'___'||str_data[16]||'___'||str_data[17]||'___'||str_data[18]||'___'||str_data[19]||'___'||str_data[20];
		--RAISE EXCEPTION '%','total  de filas???'||str_data[21]||'___'||str_data[22]||'___'||str_data[23]||'___'||str_data[24]||'___'||str_data[25]||'___'||str_data[26]||'___'||str_data[27]||'___'||str_data[28]||'___'||str_data[29];
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;

		/*
		--rfc
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
		END IF;
		*/
		
		IF str_data[6]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'tipoestatus:Es necesario seleccionar una Etapa.___';
		END IF;

		/*
		IF str_data[7]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'tipoprospecto:Es necesario seleccionar el Tipo Prospecto___';
		END IF;
		
		--calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--num calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroint:Numero de Calle No Valida___';
		END IF;
		
		--colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[14]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--codigo postal
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--pais
		IF str_data[16]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Prospecto___';
		END IF;
		
		--estado
		IF str_data[17]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Prospecto___';
		END IF;
		
		--municipio
		IF str_data[18]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Prospecto___';
		END IF;
		
		--telefono 1
		IF str_data[20]='' OR str_data[20]=' ' THEN
			valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el numero de Tel√©fono___';
		ELSE
			--telefono
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[20]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos___';
			END IF;
		END IF;
		--FAX, utiliza la misma mascara que telefono
		IF str_data[22]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[22]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fax:El numero de Fax no es valido. Debe ser 10 digitos___';
			END IF;
		END IF;
	

		--email
		IF str_data[25]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[25]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		*/
		
		 --gral_emp_id
		IF str_data[4] = '0' THEN
			/*
			valida_integridad:=0;
			EXECUTE 'select count(id) from crm_prospectos where rfc ilike '''||str_data[8]||''' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado ya se encuentra en uso___';
			END IF;
			*/
			
			valida_integridad:=0;
			EXECUTE 'select count(id) from crm_prospectos where razon_social ilike '''||str_data[9]||''' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social ingresada ya se encuentra en uso___';
			END IF;

			/*
			valida_integridad:=0;
			EXECUTE 'select count(id) from crm_prospectos where email ilike '''||str_data[25]||''' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
			IF valida_integridad > 0 THEN
				valor_retorno := ''||valor_retorno||'email:El correo ingresado ya se encuentra en uso___';
			END IF;
			*/
		END IF;
	END IF;--termina validacion de prospectos(CRM)




	--catalogo de registro de llamadas
	IF id_app=114 THEN
		
		--str_data[5] id_agente
		IF str_data[5]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'agente:Es necesario seleccionar el un Agente de Ventas___';
		END IF;
		
		--str_data[6] id_contacto
		IF str_data[6] = '0' THEN
			valor_retorno := ''||valor_retorno||'contacto:Es necesario seleccionar un Contacto___';
		END IF;
		
		--str_data[7] fecha
		IF str_data[7]='' THEN
			valor_retorno := ''||valor_retorno||'fechallamada:Es necesario seleccionar la Fecha de la Llamada___';
		END IF;
		
		--str_data[8] hora_llamada
		IF str_data[8]='00:00' THEN
			valor_retorno := ''||valor_retorno||'horallamada:Es necesario Ingresar la Hora de la Llamada___';
		END IF;
		
		--str_data[9] hora_duracion
		IF str_data[9]='00:00' THEN
			valor_retorno := ''||valor_retorno||'duracionllamada:Es necesario Ingresar la Duracion de la Llamada___';
		END IF;

		IF str_data[12]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'seguimiento:Es necesario seleccionar el un Tipo de Seguimiento___';	
		END IF;

		IF str_data[11]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'calificacion:Es necesario seleccionar el una Calificacion___';	
		END IF;

		IF str_data[10]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'motivo:Es necesario seleccionar el un Motivo de Llamada___';	
		END IF;
		
		
		
		--str_data[15] resultado_llamada
		IF str_data[17]='' THEN
			valor_retorno := ''||valor_retorno||'resultadollamada:Es necesario llenar el campo Resultado de la Llamada___';
		END IF;
		
		
	END IF;


	
	
	--Validacion de Registro de Visitas(CRM)
	IF id_app=115 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		
		--str_data[5] id_agente
		IF str_data[5]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'agente:Es necesario seleccionar el un Agente de Ventas___';
		END IF;
		
		--str_data[6] id_contacto
		IF str_data[6] = '0' THEN
			valor_retorno := ''||valor_retorno||'contacto:Es necesario seleccionar un Contacto___';
		END IF;
		
		--str_data[7] fecha
		IF str_data[7]='' THEN
			valor_retorno := ''||valor_retorno||'fechavisita:Es necesario seleccionar la Fecha de la Visita___';
		END IF;
		
		--str_data[8] hora_visita
		IF str_data[8]='00:00' THEN
			valor_retorno := ''||valor_retorno||'horavisita:Es necesario Ingresar la Hora de la Visita___';
		END IF;
		
		--str_data[9] hora_duracion
		IF str_data[9]='00:00' THEN
			valor_retorno := ''||valor_retorno||'duracionvisita:Es necesario Ingresar la Duracion de la Visita___';
		END IF;
		
		--str_data[10] select_motivo_visita
		--str_data[11] select_calif_visita
		--str_data[12] select_tipo_seguimiento
		--str_data[13] select_oportunidad
		--str_data[14] recusrsos_visita
		
		--str_data[15] resultado_visita
		IF str_data[15]='' THEN
			valor_retorno := ''||valor_retorno||'resultadovisita:Es necesario llenar el campo Resultado de la Visita___';
		END IF;
		
		--str_data[16] observaciones_visita
		--str_data[17] fecha_proxima_visita
		--str_data[18] hora_proxima_visita
		--str_data[19] comentarios_proxima_visita
		
		
	END IF;--termina validacion de Registro de Visitas(CRM)
	
	
	
	
	--Catalogo de Direcciones Fiscales de Clientes
	IF id_app=118 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		--str_data[5] id_cliente
		
		--str_data[6] calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;

		--str_data[7] numero_int
		
		--str_data[8] numero_ext
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroext:Numero de Calle No Valida___';
		END IF;
		
		--str_data[9] colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--str_data[10] cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--str_data[11] select_pais
		IF str_data[11]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Cliente___';
		END IF;
		
		--str_data[12] select_estado
		IF str_data[12]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Cliente___';
		END IF;
		
		--str_data[13] select_municipio
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Cliente___';
		END IF;
		
		--str_data[14] entrecalles
		--str_data[21] contacto
		
		--str_data[15] tel1
		IF str_data[15]='' OR str_data[15]=' ' THEN
			valor_retorno := ''||valor_retorno||'tel1:Es necesario ingresar el numero de Tel√©fono___';
		ELSE
			--telefono
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos___';
			END IF;
		END IF;
		
		--str_data[16] ext1
		
		----str_data[17] fax utiliza la misma mascara que telefono
		IF str_data[17]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[17]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'fax:El numero de Fax no es valido. Debe ser 10 digitos___';
			END IF;
		END IF;

		--str_data[18] tel2
		--str_data[19] ext2

		--str_data[20] email
		IF str_data[20]!='' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[20]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		
		
		SELECT count(id) from cxc_clie_df 
		WHERE cxc_clie_id=str_data[5]::integer
		AND gral_pais_id=str_data[11]::integer
		AND gral_edo_id=str_data[12]::integer
		AND gral_mun_id=str_data[13]::integer
		AND replace(colonia,' ' ,'')=replace(str_data[9],' ' ,'')
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id from cxc_clie_df 
			WHERE cxc_clie_id=str_data[5]::integer
			AND gral_pais_id=str_data[11]::integer
			AND gral_edo_id=str_data[12]::integer
			AND gral_mun_id=str_data[13]::integer
			AND replace(colonia,' ' ,'')=replace(str_data[9],' ' ,'')
			INTO id_registro;
			
			--validar integridad
			IF str_data[4]::integer != id_registro THEN
				valor_retorno := ''||valor_retorno||'colonia:La direcci&oacute;n Fiscal con la misma colonia, Pa&iacute;s, Estado y Municipio ya existe para &eacute;ste Cliente.___';
			END IF;
			
		END IF;
		
	END IF;--termina validacion de Catalogo de Direcciones Fiscales de Clientes
	
	

	--validacion de Catalogo oportunidades
	IF id_app=120 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--120
                --str_data[4]        id
			--str_data[5]	contacto_id
			--str_data[6]	fecha_oportunidad
			--str_data[7]	fecha_cotizacion
			--str_data[8]	fecha_cierre
			--str_data[9]	monto
			--str_data[10]	empleado
			--str_data[11]	tipo_oportunidad
			--str_data[12]	etapa_venta
			--str_data[13]	estatus
			--str_data[14]	cierre_oportunidad
			--id+"___"+contacto_id+"___"+fecha_oportunidad+"___"+fecha_cotizacion
			--+"___"+fecha_cierre+"___"+monto+"___"+empleado+"___"+tipo_oportunidad+"___"+etapa_venta+"___"+
			--estatus+"___"+cierre_oportunidad;//6		
		--RAISE EXCEPTION '%',str_data[10];
		IF str_data[10] = '0' OR str_data[10] = ''  THEN
			valor_retorno := ''||valor_retorno||'empleado:Es necesario seleccionar un agente___';
		END IF;
		
		IF str_data[5] = '0' OR str_data[5] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'contacto:Ingrese un contacto___';
		END IF;
		
		IF str_data[6] = '' OR str_data[6] = ' '  THEN
			valor_retorno := ''||valor_retorno||'fecha_oportunidad:Ingrese una fecha de oportunidad___';
		END IF;
		

		IF str_data[12] = '0'  THEN
			valor_retorno := ''||valor_retorno||'etapa_venta:Seleccione una etapa de venta___';
		END IF;

		IF str_data[11] = '0'  THEN
			valor_retorno := ''||valor_retorno||'tipo_oportunidad:Seleccione un tipo de oportunidad___';
		END IF;
		
			
	END IF;--termina validacion de oportunidades


	--validaciones de Registro de Metas
	IF id_app = 123 THEN
		/*app_selected//1
		+"___"+command_selected//2
		+"___"+id_usuario//3
		+"___"+identificador//4
		+"___"+select_agente//5
		+"___"+opciones//6
		+"___"+cant_llamadas//7
		+"___"+cant_visitas//8
		+"___"+cant_prospectos//9
		+"___"+ano//10
		+"___"+mes//11
		+"___"+cant_cotizaciones	//12
		+"___"+cant_cotizaciones2//13
		+"___"+cant_oportunidades//14
		+"___"+cant_oportunidades2//15
		+"___"+monto_cotizaciones//16
		+"___"+monto_cotizaciones2//17
		+"___"+monto_oportunidades//18
		+"___"+monto_oportunidades2//19
		+"___"+ventas_clientes//20
		+"___"+ventas_opor_clientes//21	
		+"___"+ventas_prospecto;//22	*/
            
		

		
		
		IF str_data[7]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantllamadas:Ingrese una cantidad valida___';
		END IF;

		IF str_data[8]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantvisitas:Ingrese una cantidad valida___';
		END IF;

		IF str_data[9]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantprospectos:Ingrese una cantidad valida___';
		END IF;

		IF str_data[11]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'mes:Seleccione un mes valido___';
		END IF;

		IF str_data[12]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantcotizaciones:Ingrese una cantidad valida___';
		END IF;

		IF str_data[13]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantcotizaciones2:Ingrese una cantidad valida___';
		END IF;

		IF str_data[14]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantoportunidades:Ingrese una cantidad valida___';
		END IF;

		IF str_data[15]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'cantoportunidades2:Ingrese una cantidad valida___';
		END IF;

		IF str_data[16]::double precision = 0 THEN
			valor_retorno:=''||valor_retorno||'montocotizaciones:Ingrese una cantidad valida___';
		END IF;

		IF str_data[17]::double precision = 0 THEN
			valor_retorno:=''||valor_retorno||'montocotizaciones2:Ingrese una cantidad valida___';
		END IF;

		IF str_data[18]::double precision = 0 THEN
			valor_retorno:=''||valor_retorno||'montooportunidades:Ingrese una cantidad valida___';
		END IF;

		IF str_data[19]::double precision = 0 THEN
			valor_retorno:=''||valor_retorno||'montooportunidades2:Ingrese una cantidad valida___';
		END IF;

		IF str_data[20]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'ventclientesestablecidos:Ingrese una cantidad valida___';
		END IF;

		IF str_data[21]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'ventoporclientes:Ingrese una cantidad valida___';
		END IF;

		IF str_data[22]::integer = 0 THEN
			valor_retorno:=''||valor_retorno||'ventprospectos:Ingrese una cantidad valida___';
		END IF;
	END IF;
	



	--VALIDACIONES PARA EL APLICATIVO REGISTRO DE CASOS
	IF id_app=124 THEN
	/*     str_data[1] app_selected
	+"___"+str_data[2]command_selected
	+"___"+str_data[3]id_usuario
	+"___"+str_data[4]identificador
	+"___"+str_data[5]id_cliente_prospecto
	+"___"+str_data[6]select_estatus
	+"___"+str_data[7]select_prioridad
	+"___"+str_data[8]select_tipo_caso
	+"___"+str_data[9]fecha_cierre
	+"___"+str_data[10]descripcion.toUpperCase()
	+"___"+str_data[11]resolucion.toUpperCase()
	+"___"+str_data[13]tipo
	+"___"+str_data[14]gral_empleado_id
	;*/
		IF str_data[13]::integer = 0 THEN
			valor_retorno := 'opcion:Seleccione una opcion___';
		END IF;
		IF str_data[5]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'cliente_prospecto:El cliente ingresado no fue ingresado desde el pluguin____';
		END IF;
		IF str_data[6]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'estatus:Seleccione un Estatus___';
		END IF;
		IF str_data[7]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'prioridad:Seleccione una Prioridad___';
		END IF;
		IF str_data[8]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'tipocaso:Seleccione un tipo de Caso___';
		END IF;
		IF str_data[9] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'fecha_cierre:Es necesario ingresar la fecha___';
		END IF;
		IF str_data[10] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la Descripcion___';
		END IF;
		IF str_data[11] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'resolucion:Es necesario ingresar la Resolucion___';
		END IF;
		IF str_data[12] = '' OR str_data[5] = ' '  THEN
			valor_retorno := ''||valor_retorno||'tipo_observaciones_agente:Es necesario ingresar la observacion del Agente___';
		END IF;
	END IF;
	--FIN DE LAS VALIDACIONES PARA EL REGISTRO DE CASOS
	
	
	
	--validacion de Aplicativo Actualizador de Precios a partir de Precio Minimo
	IF id_app=126 THEN
		
		primero:=0;
		
		--str_data[11]	lista1
		IF str_data[11]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[12]	lista2
		IF str_data[12]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[13]	lista3
		IF str_data[13]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[14]	lista4
		IF str_data[14]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[15]	lista5
		IF str_data[15]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[16]	lista6
		IF str_data[16]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[17]	lista7
		IF str_data[17]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[18]	lista8
		IF str_data[18]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[19]	lista9
		IF str_data[19]::double precision > 0 THEN primero:=1; END IF;
		
		--str_data[20]	lista10
		IF str_data[20]::double precision > 0 THEN primero:=1; END IF;

		--si primero=0, quiere decir que ninguna lista trae valor mayor que cero, es decir no asignaron precio a ninguna lista
		IF primero=0 THEN
			valor_retorno := 'precio:Es necesario asignar precio a por lo menos a una Lista___';
		END IF;
		
	END IF;
	--Termina validacion de Actualizador de Precios a partir de Precio Minimo
	
	
	
	--validacion de Catalogo Contactos
	IF id_app=127 THEN
		--SELECT INTO str_data string_to_array(''||campos_data||'','___');
		--str_data[4]-- id
		--str_data[5]--tipo_contacto
		--str_data[6]--folio
                --str_data[7]--id_cliente
                --str_data[8]--nombre
                --str_data[9]--apellido_paterno
                --str_data[10]--apellido_materno
                --str_data[11]--telefono_1
                --str_data[12]--telefono_2
                --str_data[13]--fax
                --str_data[14--telefono_directo
                --str_data[15]--correo_1
                --str_data[16]--correo_2
                --str_data[18]	agente
		IF str_data[7] = '0'  THEN
			valor_retorno := ''||valor_retorno||'cliente:Es Necesario Seleccionar un cliente o prospecto___';
		END IF;
		
		IF str_data[8] = '' OR str_data[8] = ' '  THEN
			valor_retorno := ''||valor_retorno||'nombre:Es Necesario ingresar un nombre de contacto___';
		END IF;
		
		IF str_data[9] = '' OR str_data[9] = ' '  THEN
			valor_retorno := ''||valor_retorno||'apellido_materno:Es Necesario ingresar un apellido paterno de contacto___';
		END IF;
		
		IF str_data[11] = '' OR str_data[11] = ' '  THEN
			valor_retorno := ''||valor_retorno||'telefono_1:Es Necesario ingresar un telefono de contacto___';
		END IF;
		
		IF str_data[18]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'agente:Es Necesario seleccionar un agente.___';
		END IF;
		/*
		EXECUTE 'select count(descripcion) from pro_instrumentos 
		where  descripcion ilike '''||str_data[5]||'''  AND borrado_logico=false AND gral_emp_id='||emp_id||';' INTO valida_integridad;
		
		IF valida_integridad > 0 THEN
			valor_retorno := ''||valor_retorno||'descripcion:El instrumento ingresada ya se encuentra registrada';
		END IF;	
		*/	
	END IF;--termina validacion de Catalogo Contactos
	
	
	--validacion de Catalogo de Incoterms
	IF id_app=132 THEN
		--str_data[4] 	identificador
		--str_data[5] 	nombre
		--str_data[6] 	descripcion_es
		--str_data[7] 	descripcion_ing
		
		IF trim(str_data[5])=''  THEN
			valor_retorno := ''||valor_retorno||'nombre:Es Necesario ingresar el Nombre del Incoterm.___';
		END IF;
		
		IF trim(str_data[6])='' THEN
			valor_retorno := ''||valor_retorno||'descripciones:Es Necesario ingresar la Descripci&oacute;n espa&ntilde;ol.___';
		END IF;
		
		--aqui buscamos el nombre
		SELECT count(id) FROM poc_cot_incoterms 
		WHERE nombre=str_data[5] AND gral_emp_id=emp_id AND borrado_logico=false
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM poc_cot_incoterms 
			WHERE nombre=str_data[5] AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--validar integridad
			IF str_data[4]::integer != id_registro THEN
				valor_retorno := ''||valor_retorno||'nombre:El nombre del Incoterm ya se encuentra registrado.___';
			END IF;
		END IF;
		
		--aqui buscamos la descripcion
		SELECT count(id) FROM poc_cot_incoterms 
		WHERE upper(descripcion_esp)=upper(str_data[6]) AND gral_emp_id=emp_id AND borrado_logico=false
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM poc_cot_incoterms 
			WHERE upper(descripcion_esp)=upper(str_data[6]) AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--validar integridad
			IF str_data[4]::integer != id_registro THEN
				valor_retorno := ''||valor_retorno||'descripciones:La Descripci&oacute;n en espa&ntilde;ol ya se encuentra registrado.___';
			END IF;
		END IF;
	END IF;--termina validacion de Catalogo de Incoterms
	
	
	
	--VALIDACIONES PARA EL APLICATIVO CONFIGURACION DE CONSULTAS
        IF id_app=130 THEN
                
        END IF;--termina VALIDACIONES PARA EL APLICATIVO CONFIGURACION DE CONSULTAS
	
	
	--validacion de Catalogo Politicas de Pago.
        IF id_app=134 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Politica de Pago___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from poc_cot_politicas_pago where  descripcion ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo Politicas de Pago
	
	
	--validacion de Catalogo de comerciales)
        IF id_app=135 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF str_data[5] = '' OR str_data[5] = ' ' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Condicion de Venta___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from poc_cot_condiciones_com where  descripcion ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo de condiciones comerciales)
	
	


	--validacion de Catalogo de Equipos Adicionales)
        IF id_app=140 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                
                IF trim(str_data[5]) = '' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Equipo Adicional___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from pro_equipos_adic where  borrado_logico = false and titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
                
        END IF;--termina validacion Catalogo de Equipos Adicionales)

	

	--validacion de Catalogo de Equipos 
        IF id_app=141 THEN
                --str_data[4]        id
                --str_data[5]        titulo
                --str_data[7]        tipo
                
                IF trim(str_data[5]) = '' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Equipo___';
                ELSE
                        IF str_data[4] = '0' THEN 
                                EXECUTE 'select count(id) from pro_equipos where  borrado_logico=false and titulo ilike '''||str_data[5]||''';' INTO valida_integridad;
                                IF valida_integridad > 0 THEN
                                        valor_retorno := ''||valor_retorno||'titulo:El Titulo ingresado ya se encuentra en uso___';
                                END IF;
                        END IF;
                END IF;
		
		IF char_length(str_data[6])>10 THEN 
			valor_retorno := ''||valor_retorno||'nombrecorto:La longitud del Nombre Corto debe ser de diez caracteres como maximo.___';
		END IF;
		
		IF str_data[7]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipo:Es necesario seleccionar el Tipo de Equipo.___';
		END IF;
        END IF;--termina validacion Catalogo de Equipos 
	
	
	
	
	--aplicativo Consulta de Facturas
	--validacion para datos de Addendas 
        IF id_app=142 THEN
                --str_data[1]	app_selected
                --str_data[2]	command_selected
                --str_data[3]	id_usuario
                --str_data[4]	id_fac_doc
                --str_data[5]	tipo_addenda_id
                --str_data[6]	adenda_campo1
                --str_data[7]	adenda_campo2
                --str_data[8]	adenda_campo3
                --str_data[9]	adenda_campo4
                --str_data[10]	adenda_campo5
                --str_data[11]	adenda_campo6
                --str_data[12]	adenda_campo7
                --str_data[13]	adenda_campo8
                
                IF trim(str_data[5]) = '' THEN
                        valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Equipo___';
                ELSE
                        IF str_data[5]::integer > 0 THEN 
				IF str_data[5]::integer = 3 THEN 
					IF trim(str_data[6]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo1:Es necesario el Numero de Orden de Compra.___';
					END IF;

					IF trim(str_data[7]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo2:Es necesario el Correo del Emisor.___';
					END IF;

					IF trim(str_data[8]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo3:Es necesario ingresar la Moneda.___';
					END IF;
					
					IF trim(str_data[9]) = '' THEN 
						valor_retorno := ''||valor_retorno||'campo4:Es necesario ingresar un valor para Tipo de Cambio.___';
					else
						if str_data[9]::double precision <=0 then 
							valor_retorno := ''||valor_retorno||'campo4:El valor para Tipo de Cambio debe ser mayor a cero.___';
						end if;
					END IF;
					
					IF trim(str_data[10]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo5:Es necesario ingresar el Subtotal de la Factura.___';
					else
						if str_data[10]::double precision <=0 then 
							valor_retorno := ''||valor_retorno||'campo5:El valor para Subtotal debe ser mayor a cero.___';
						end if;
					END IF;

					IF trim(str_data[11]) = '' THEN
						valor_retorno := ''||valor_retorno||'campo6:Es necesario ingresar el Total de la Factura.___';
					else
						if str_data[11]::double precision <=0 then 
							valor_retorno := ''||valor_retorno||'campo6:El valor para Total debe ser mayor a cero.___';
						end if;
					END IF;
					
				END IF;
				--Termina validacion addeda=3
                        END IF;
                END IF;
		
                
        END IF;--termina validacion Addendas
	





	--Validacion de Aplicativo Captura de Costos
	IF id_app=145 THEN
		--str_data[4]	identificador
		
		total_filas:= array_length(arreglo,1);
		cont_fila:=1;
		IF arreglo[1] != 'sin datos' THEN
			
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	idreg[i]
				--str_filas[2]	idprod[i]
				--str_filas[3]	costo_ultimo[i]
				--str_filas[4]	selectMon[i]
				--str_filas[5]	tc[i]
				--str_filas[6]	notr[i]
				
				IF trim(str_filas[3])='' THEN
					valor_retorno := ''||valor_retorno||'costo_ultimo'||str_filas[6]||':El costo no debe quedar vacio.___';
				ELSE
					IF str_filas[3]::double precision<=0 THEN
						valor_retorno := ''||valor_retorno||'costo_ultimo'||str_filas[6]||':El costo debe ser mayor a cero.___';
					END IF;
				END IF;


				IF str_filas[4]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'selectMon'||str_filas[6]||':Debe seleccionar una moneda.___';
				END IF;


				IF trim(str_filas[5])='' THEN
					valor_retorno := ''||valor_retorno||'tc'||str_filas[6]||':El Tipo de Cambio no debe quedar vacio.___';
				ELSE
					IF str_filas[5]::double precision<=0 THEN
						valor_retorno := ''||valor_retorno||'tc'||str_filas[6]||':El Tipo de Cambio debe ser mayor a cero.___';
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;--Termina validacion de Captura de Costos
	





	
	
	--Cancelacion de Anticipos
        IF id_app=146 THEN
		--str_data[4]	identificador
		--str_data[5]	id_cliente
		--str_data[6]	monto
		--str_data[7]	fecha
		--str_data[8]	select_moneda
		--str_data[9]	observaciones
		
		exis:=0;
		IF str_data[4]::integer = 0 THEN 
                
			IF trim(str_data[5]) = '0' OR trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'cliente:Es necesario seleccionar un cliente.___';
			END IF;
			
			IF trim(str_data[6]) = '' THEN
				valor_retorno := ''||valor_retorno||'monto:Es necesario ingresar el monto del Anticipo.___';
			ELSE
				IF trim(str_data[6])::double precision = 0 THEN
					valor_retorno := ''||valor_retorno||'monto:El monto del Anticipo debe ser mayor que cero.___';
				END IF;
			END IF;
			
			IF trim(str_data[9]) = '' THEN
				valor_retorno := ''||valor_retorno||'observaciones:Es necesario ingresar las observaciones.___';
			END IF;
			
		ELSE
			SELECT count(erp_pagos_detalles.id) FROM erp_pagos
			JOIN erp_pagos_detalles ON erp_pagos_detalles.pago_id=erp_pagos.id
			WHERE erp_pagos.anticipo_id=str_data[4]::integer AND erp_pagos_detalles.cancelacion=false
			INTO exis;
			
			IF exis IS NULL THEN exis:=0; END IF;
			
			IF exis > 0 THEN 
				valor_retorno := ''||valor_retorno||'No es posible cancelar en anticipo porque ha sido aplicado a una o mas facturas';
			END IF;
		END IF;
	END IF;
	
	
	



	

	



	--Catalogo de Remitentes
	IF id_app=147 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		--str_data[5] remitente
		--str_data[6] rfc
		--str_data[7] select_tipo
		--str_data[8] calle
		--str_data[9] numero_int
		--str_data[10] numero_ext
		--str_data[11] colonia
		--str_data[12] cp
		--str_data[13] select_pais
		--str_data[14] select_estado
		--str_data[15] select_municipio
		--str_data[16] tel1
		--str_data[17] ext1
		--str_data[18] tel2
		--str_data[19] email
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;
		
		IF str_data[7]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipo:Es necesario seleccionar el tipo de Remitente(Nacional o Extranjero).___';
		ELSE
			IF str_data[7]::integer=1 THEN 
				--Validar Rfc solo cuando el remitente es Nacional
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
				EXECUTE 'select '''||str_data[6]||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
				END IF;
			END IF;
		END IF;
		
		
		--str_data[6] calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--str_data[10] numero_ext
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroext:Numero de Calle No Valida___';
		END IF;
		
		--str_data[11] colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--str_data[12] cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[12]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--str_data[13] select_pais
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Remitente.___';
		END IF;
		
		--str_data[14] select_estado
		IF str_data[14]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Remitente.___';
		END IF;
		
		--str_data[15] select_municipio
		IF str_data[15]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Remitente.___';
		END IF;

		--str_data[16] tel1
		IF trim(str_data[16])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[16]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos. Solo se permiten espacios en blanco y -.___';
			END IF;
		END IF;

		--str_data[19] email
		IF trim(str_data[19])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[19]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		
		--str_data[6] rfc
		--Aqui buscamos la Razon Social del Remitente
		SELECT count(id) FROM cxc_remitentes WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') AND gral_emp_id=emp_id AND borrado_logico=false 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM cxc_remitentes WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social del Remitente ya se encuentra registrado.___';
			END IF;
		END IF;

		--Validar integridad del RFC solo cuando el Remitente sea Nacional
		IF str_data[7]::integer=1 THEN 
			--Aqui buscamos el RFC del Remitente
			SELECT count(id) FROM cxc_remitentes WHERE rfc=str_data[6] AND gral_emp_id=emp_id AND borrado_logico=false
			INTO valida_integridad;
			
			IF valida_integridad>0 THEN 
				SELECT id FROM cxc_remitentes WHERE rfc=str_data[6] AND gral_emp_id=emp_id AND borrado_logico=false
				INTO id_registro;
				
				--Validar integridad
				IF str_data[4]::integer <> id_registro THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC del Remitente ya se encuantra registrado.___';
				END IF;
			END IF;
		END IF;
	END IF;--Termina validacion de Catalogo de Remitentes


	
	--Catalogo de Destinatarios
	IF id_app=148 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		--str_data[5] destinatario
		--str_data[6] rfc
		--str_data[7] select_tipo
		--str_data[8] calle
		--str_data[9] numero_int
		--str_data[10] numero_ext
		--str_data[11] colonia
		--str_data[12] cp
		--str_data[13] select_pais
		--str_data[14] select_estado
		--str_data[15] select_municipio
		--str_data[16] tel1
		--str_data[17] ext1
		--str_data[18] tel2
		--str_data[19] email
		--str_data[20] folio_ext
		--str_data[21] check_firma
		--str_data[22] check_sello
		--str_data[23] check_efectivo
		--str_data[24] id_cliente
		--str_data[25] check_cheque
		--str_data[26] select_serv
		--str_data[27] costo_serv
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;
		
		IF str_data[7]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipo:Es necesario seleccionar el tipo de Destinatario(Nacional o Extranjero).___';
		ELSE
			IF str_data[7]::integer=1 THEN 
				--Validar Rfc solo cuando el remitente es Nacional
				EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RFCCorrect'';' INTO mask_general;
				EXECUTE 'select '''||trim(str_data[6])||''' ~ '''||mask_general||''';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC ingresado NO es valido___';
				END IF;
			END IF;
		END IF;
		
		
		--str_data[6] calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		
		--str_data[10] numero_ext
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroext:Numero de Calle No Valida___';
		END IF;
		
		--str_data[11] colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		
		--str_data[12] cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[12]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		
		--str_data[13] select_pais
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Destinatario.___';
		END IF;
		
		--str_data[14] select_estado
		IF str_data[14]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Destinatario.___';
		END IF;
		
		--str_data[15] select_municipio
		IF str_data[15]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Destinatario.___';
		END IF;

		--str_data[16] tel1
		IF trim(str_data[16])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[16]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos. Solo se permiten espacios en blanco y -.___';
			END IF;
		END IF;

		--str_data[19] email
		IF trim(str_data[19])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[19]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;

		IF str_data[24]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar el Cliente al que pertenece el Destinatario.___';
		END IF;
		
		
		--str_data[6] rfc
		--Aqui buscamos la Razon Social del destinatario
		SELECT count(id) FROM cxc_destinatarios WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') and upper(folio_ext)=upper(str_data[20]) AND gral_emp_id=emp_id AND borrado_logico=false 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM cxc_destinatarios WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') and upper(folio_ext)=upper(str_data[20]) AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social del Destinatario ya se encuentra registrado con el mismo Folio Externo.___';
			END IF;
		END IF;
		
		--Validar integridad del RFC solo cuando el destinatario sea Nacional
		IF str_data[7]::integer=1 THEN 
			--Aqui buscamos el RFC del Remitente
			SELECT count(id) FROM cxc_destinatarios WHERE rfc=str_data[6] and upper(folio_ext)=upper(trim(str_data[20])) AND gral_emp_id=emp_id AND borrado_logico=false
			INTO valida_integridad;
			
			IF valida_integridad>0 THEN 
				SELECT id FROM cxc_destinatarios WHERE rfc=str_data[6] and upper(folio_ext)=upper(trim(str_data[20])) AND gral_emp_id=emp_id AND borrado_logico=false
				INTO id_registro;
				
				--Validar integridad
				IF str_data[4]::integer <> id_registro THEN
					valor_retorno := ''||valor_retorno||'rfc:El RFC del Destinatario ya se encuantra registrado con el mismo Folio Externo.___';
				END IF;
			END IF;
		END IF;

		--str_data[20] folio_ext
		--str_data[24] id_cliente
		--Aqui buscamos el folio externo del destinatario si no esta vacia
		if trim(str_data[20])<>'' then 
			if str_data[20]::integer>0 then 
				SELECT count(cxc_destinatarios.id) FROM cxc_destinatarios join cxc_clie_dest on cxc_clie_dest.cxc_destinatario_id=cxc_destinatarios.id WHERE upper(cxc_destinatarios.folio_ext)=upper(str_data[20]) and cxc_clie_dest.cxc_clie_id=str_data[24]::integer AND cxc_destinatarios.gral_emp_id=emp_id AND cxc_destinatarios.borrado_logico=false 
				INTO valida_integridad;
				
				IF valida_integridad>0 THEN 
					--valor_retorno := ''||valor_retorno||'folioext:El Folio Externo Ya se encuentra registrado para el cliente seleccionado.___';
					
					SELECT cxc_destinatarios.id FROM cxc_destinatarios join cxc_clie_dest on cxc_clie_dest.cxc_destinatario_id=cxc_destinatarios.id WHERE upper(cxc_destinatarios.folio_ext)=upper(str_data[20]) and cxc_clie_dest.cxc_clie_id=str_data[24]::integer AND cxc_destinatarios.gral_emp_id=emp_id AND cxc_destinatarios.borrado_logico=false limit 1 
					INTO id_registro;
					
					--Validar integridad
					IF str_data[4]::integer <> id_registro THEN
						valor_retorno := ''||valor_retorno||'folioext:El Folio Externo Ya se encuentra registrado para el cliente seleccionado.___';
					END IF;
					
				END IF;
			end if;
		end if;
		
	END IF;--Termina validacion de Catalogo de Destinatarios
	
	
	
	
	--Catalogo de Agentes Aduanales
	IF id_app=149 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] identificador
		--str_data[5] Agente Aduanal
		--str_data[6] select_tipo
		--str_data[7] calle
		--str_data[8] numero_int
		--str_data[9] numero_ext
		--str_data[10] colonia
		--str_data[11] cp
		--str_data[12] select_pais
		--str_data[13] select_estado
		--str_data[14] select_municipio
		--str_data[15] tel1
		--str_data[16] ext1
		--str_data[17] tel2
		--str_data[18] email
		
		--razon social
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_RazonsocialCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[5]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := 'razonsocial:Razon social no No Valido___';
		END IF;

		
		IF str_data[6]::integer=0 THEN 
			valor_retorno := ''||valor_retorno||'tipo:Es necesario seleccionar el tipo de Agente Aduanal(Nacional o Extranjero).___';
		END IF;
		

		/*
		--str_data[6] calle
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CalleCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[7]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'calle:Calle No Valida___';
		END IF;
		*/
		
		/*
		--str_data[9] numero_ext
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_AddressNumberCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[9]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'numeroext:Numero de Calle No Valida___';
		END IF;
		*/
		
		/*
		--str_data[10] colonia
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_ColoniaCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[10]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'colonia:Colonia No Valido___';
		END IF;
		*/

		/*
		--str_data[11] cp
		EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CpCorrect'';' INTO mask_general;
		EXECUTE 'select '''||str_data[11]||''' ~ '''||mask_general||''';' INTO match_cadena;
		IF match_cadena = false THEN
			valor_retorno := ''||valor_retorno||'cp:Codigo postal No Valido___';
		END IF;
		*/
		
		/*
		--str_data[12] select_pais
		IF str_data[12]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais del Agente Aduanal.___';
		END IF;
		
		--str_data[13] select_estado
		IF str_data[13]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado del Agente Aduanal.___';
		END IF;
		
		--str_data[14] select_municipio
		IF str_data[14]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio del Agente Aduanal.___';
		END IF;
		*/
		
		--str_data[15] tel1
		IF trim(str_data[15])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_PhoneCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[15]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'tel1:El numero telefonico no es valido. Debe ser de 10 digitos. Solo se permiten espacios en blanco y -.___';
			END IF;
		END IF;

		--str_data[18] email
		IF trim(str_data[18])<>'' THEN
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_CorreoCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[18]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'email:Correo No Valido___';
			END IF;
		END IF;
		
		--Aqui buscamos la Razon Social del destinatario
		SELECT count(id) FROM cxc_destinatarios WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') AND gral_emp_id=emp_id AND borrado_logico=false 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id FROM cxc_destinatarios WHERE replace(razon_social,' ' ,'')=replace(str_data[5],' ' ,'') AND gral_emp_id=emp_id AND borrado_logico=false
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				valor_retorno := ''||valor_retorno||'razonsocial:La razon social del Agente Aduanal ya se encuentra registrado.___';
			END IF;
		END IF;
	END IF;--Termina validacion de Catalogo de Agentes Aduanales
	
	
	
	--Validacion de Asignacion de Remitentes
	IF id_app=150 THEN
		--str_data[4]        identificador
		--str_data[5]        id_cliente		
		IF trim(str_data[5])='0' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un cliente.';
		END IF;
	END IF;--Termina validacion de Asignacion de Remitentes

	--Catalogo de Operadores
	IF id_app=154 THEN
		--nombre operador
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombre:Ingresar Nombre___';
		END IF;

		--apellido paterno operador
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'paterno:Ingresar Apellido Paterno___';
		END IF;
	END IF;--termina validacion de Catalogo de Operadores



	--Validacion para Aplicativo para cambiar contrase√±a de usuario
	IF id_app=155 THEN
		IF trim(str_data[4])='' THEN 
			valor_retorno := ''||valor_retorno||'passant:Es necesario ingresar Contrase&ntilde;a anterior.___';
		ELSE
			--Obtener la contrase√±a actual del usuario
			select "password" from gral_usr where id=str_data[3]::integer into cadena;
			
			IF cadena IS NULL THEN 
				valor_retorno := ''||valor_retorno||'passant:No existe la Contrase&ntilde;a anterior.___';
			ELSE
				IF cadena<>str_data[4] THEN 
					valor_retorno := ''||valor_retorno||'passant:Contrase&ntilde;a anterior ingresada no corresponde.___';
				END IF;
			END IF;
		END IF;
		
		IF trim(str_data[5])='' THEN 
			valor_retorno := ''||valor_retorno||'passnew:Es necesario ingresar Contrase&ntilde;a Nueva.___';
		ELSE
			IF trim(str_data[6])='' THEN 
				valor_retorno := ''||valor_retorno||'passnew2:Es necesario Repetir Contrase&ntilde;a Nueva.___';
			ELSE
				IF str_data[5]<>str_data[6] THEN 
					valor_retorno := ''||valor_retorno||'passnew2:No es igual a la Nueva Contrase&ntilde;a.___';
				END IF;
			END IF;
		END IF;
	END IF;--termina validacion Aplicativo para cambiar contrase√±a de usuario

	





	--validacion de Catalogo inventario Ieps
        IF id_app=167 THEN
                --SELECT INTO str_data string_to_array(''||campos_data||'','___');
                --str_data[4]        id
                --str_data[5]        titulo 
                --str_data[6]        descripcion 
                --str_data[7]        tasa 

                               
                     --titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombreieps:Es necesario ingresar la descripcion del Ieps.___';
		END IF;
		
                  --descripcion
                  /*
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Es necesario ingresar la descripcion del Ieps.___';
		END IF;
		*/
		
                --tasa
		IF trim(str_data[7]) = '' THEN
			valor_retorno := ''||valor_retorno||'tasa:Es necesario ingresar la tasa del Ieps.___';
		END IF;
             

		IF str_data[4] = '0' THEN
			IF str_data[7]!='' AND str_data[7]!=' ' THEN
				EXECUTE 'SELECT count(id) FROM gral_ieps WHERE tasa='''||str_data[7]::double precision||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'tasa:La Tasa ya se encuentra registrada.___'; 
				END IF;
			END IF;
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM gral_ieps WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nombreieps:El Titulo del Ieps ya se encuentra registrada.___';
				END IF;
			END IF;
			--titulo			
		ELSE
			EXECUTE 'SELECT titulo, id FROM gral_ieps WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'nombreieps:El Titulo del Ieps ya se encuentra registrada.___';
			END IF;

			EXECUTE 'SELECT tasa, id FROM gral_ieps WHERE tasa='''||str_data[7]::double precision||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'tasa:La Tasa ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;
        --Termina validacion Catalogo Ieps



	--Validacion de Catalogo Percepciones
        IF id_app=170 THEN
                --str_data[4]   id
		--str_data clave nuevo_folio
		--str_data[5]	titulo
		--str_data[6]	activo
		--str_data[7]	tipopercepciones
                               
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Percepci&oacute;n.___';
		END IF;

           
                --tipopercepciones
		IF str_data[7]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'percepcion:Es necesario seleccionar un tipo de Percepci&oacute;n.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM nom_percep WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Percepci&oacute;n ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM nom_percep WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Percepci&oacute;n ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo Percepciones


        --Validacion de Catalogo Deducciones
        IF id_app=171 THEN
                --str_data[4]   id
		--str_data clave nuevo_folio
		--str_data[5]	titulo
		--str_data[6]	activo
		--str_data[7]	tipodeducciones
		
                --titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Deducci&oacute;n.___';
		END IF;

           
                --tipodeducciones
		IF str_data[7]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'deduccion:Es necesario seleccionar un tipo de Deducci&oacute;n.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM nom_deduc WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Percepci&oacute;n ya se encuentra registrada.___';
				END IF;
			END IF;
			--titulo			
		ELSE
			EXECUTE 'SELECT titulo, id FROM nom_deduc WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Percepci&oacute;n ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;
        --Termina Validacion Catalogo Deducciones

	
	
	--validacion de Catalogo Periodicidad de Pago
        IF id_app=172 THEN
                --str_data[4]  id
                --str_data[5]  titulo 
                --str_data[6]  no_periodos
		--str_data[7]  activo
		
                 --titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo de la Periodicidad de Pago.___';
		END IF;
		
		--no_periodos
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'periodos:Es necesario ingresar el N&uacute;mero del Peridodo.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--no_periodos
			IF str_data[6]!='' AND str_data[6]!=' ' THEN
				
			EXECUTE 'SELECT count(id) FROM nom_periodicidad_pago WHERE no_periodos = '''||str_data[6]::integer||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'periodos:El N&uacute;mero del Periodo ya se encuentra registrada.___'; 
				END IF;
			END IF;
			
			--titulo
			IF str_data[5] != '' THEN

			EXECUTE 'SELECT count(id) FROM nom_periodicidad_pago WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Periodicidad de Pago ya se encuentra registrada.___';
				
				END IF;
			END IF;
			--titulo			
		ELSE
			EXECUTE 'SELECT titulo, id FROM nom_periodicidad_pago WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Periodicidad de Pago ya se encuentra registrada.___';
			END IF;
			--no_periodos
			EXECUTE 'SELECT no_periodos, id FROM nom_periodicidad_pago WHERE no_periodos='''||str_data[6]::integer||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'periodos:El N&uacute;mero del Periodo ya se encuentra registrada.___';
			END IF;
		END IF;
        END IF;
        --Termina validacion Periodicidad de Pago



	
	--Validacion de Facturacion de Nomina
        IF id_app=173 THEN
		IF command_selected='new' OR command_selected='edit' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5]	comp_tipo
			--str_data[6]	comp_forma_pago
			--str_data[7]	comp_tc
			--str_data[8]	comp_no_cuenta
			--str_data[9]	fecha_pago
			--str_data[10]	select_comp_metodo_pago
			--str_data[11]	select_comp_moneda
			--str_data[12]	select_comp_periodicidad
			--str_data[13]	select_no_periodo


			 --str_data[5]	comp_tipo
			IF trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'comptipo: Se requiere el Tipo de Comprobante.___';
			END IF;
			
			--str_data[6]	comp_forma_pago
			IF trim(str_data[6]) = '' THEN
				valor_retorno := ''||valor_retorno||'compformapago:Se requiere la Forma de Pago.___';
			END IF;
			
			--str_data[9]	fecha_pago
			IF trim(str_data[9]) = '' THEN
				valor_retorno := ''||valor_retorno||'compfechapago:Se requiere la Fecha de Pago.___';
			END IF;

			--str_data[10]	select_comp_metodo_pago
			IF trim(str_data[10]) = '' THEN
				valor_retorno := ''||valor_retorno||'compmetodopago:Se requiere el Metodo de Pago.___';
			ELSE
				IF str_data[10]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'compmetodopago:Se requiere el Metodo de Pago.___';
				END IF;
			END IF;

			
			--str_data[11]	select_comp_moneda
			IF trim(str_data[11]) = '' THEN
				valor_retorno := ''||valor_retorno||'compmoneda:Se requiere la Moneda.___';
			ELSE
				IF str_data[11]::integer=0 THEN
					valor_retorno := ''||valor_retorno||'compmoneda:Se requiere la Moneda.___';
				END IF;
			END IF;
			
			--str_data[12]	select_comp_periodicidad 
			IF trim(str_data[12]) <> '' THEN
				IF str_data[12]::integer = 0 THEN
					valor_retorno := ''||valor_retorno||'compperiodicidad:Se requiere la Periodicidad de Pago.___';
				END IF;
			ELSE
				valor_retorno := ''||valor_retorno||'compperiodicidad:Se requiere la Periodicidad de Pago.___';
			END IF;
			
			
			
			IF str_data[4]='0' THEN
				--str_data[13]	select_no_periodo
				IF trim(str_data[13])<>'' AND trim(str_data[13])<>'0' THEN
					EXECUTE 'SELECT count(id) FROM fac_nomina WHERE nom_periodos_conf_det_id='||str_data[13]::integer||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
					IF valida_integridad > 0 THEN
						valor_retorno := ''||valor_retorno||'compnoperiodo:Ya existe una N&oacute;mina con el N&uacute;mero del Periodo seleccionado.___'; 
					END IF;
				END IF;
			ELSE
				
			END IF;

			
		END IF;




		
		IF command_selected='new_nomina' OR command_selected='edit_nomina' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5]	id_reg
			--str_data[6]	id_empleado
			IF trim(str_data[6])='' OR trim(str_data[6])='0'THEN
				valor_retorno := ''||valor_retorno||'noempleado:Se requiere seleccionar un empleado valido.___';
			END IF;
			
			--str_data[7]	no_empleado
			IF trim(str_data[7]) = '' THEN
				valor_retorno := ''||valor_retorno||'noempleado:Se requiere la Clave del Empleado.___';
			END IF;
			
			--str_data[8]	rfc_empleado
			IF trim(str_data[8]) = '' THEN
				valor_retorno := ''||valor_retorno||'rfcempleado:Se requiere el RFC del Empleado.___';
			ELSE
				EXECUTE 'select '''||str_data[8]||''' ~ ''^[A-Za-z0-9&]{3,4}[0-9]{6}[A-Za-z0-9]{3}$'';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'rfcempleado:RFC No Valido.___';
				END IF;
			END IF;
			
			--str_data[9]	nombre_empleado
			IF trim(str_data[9]) = '' THEN
				valor_retorno := ''||valor_retorno||'nombreempleado:Se requiere el Nombre completo del Empleado.___';
			END IF;
			
			--str_data[10]	select_departamento
			--str_data[11]	select_puesto
			--str_data[12]	fecha_contrato
			
			--str_data[13]	antiguedad
			IF trim(str_data[13]) = '' THEN
				valor_retorno := ''||valor_retorno||'antiguedad:Se requiere la Antig&uuml;edad en n&uacute;mero de semanas.___';
			ELSE
				IF str_data[13]::double precision<=0 THEN 
					valor_retorno := ''||valor_retorno||'antiguedad:La Antig&uuml;edad en n&uacute;mero de semanas debe ser mayor a cero.___';
				END IF;
			END IF;
			
			--str_data[14]	curp
			IF trim(str_data[14]) = '' THEN
				valor_retorno := ''||valor_retorno||'curp:Se requiere la CURP del Empleado.___';
			ELSE
				EXECUTE 'select '''||str_data[14]||''' ~ ''^[A-Za-z]{4}[0-9]{6}[A-Za-z]{6}[A-Za-z0-9]{1}[0-9]{1}$'';' INTO match_cadena;
				IF match_cadena = false THEN
					valor_retorno := ''||valor_retorno||'curp:Curp No Valido___';
				END IF;
			END IF;
			
			--str_data[15]	select_reg_contratacion
			IF str_data[15]::integer=0 THEN
				valor_retorno := ''||valor_retorno||'regimencontratacio:Se requiere el R&eacute;gimen de Contrataci&oacute;n del Empleado.___';
			END IF;
			
			--str_data[16]	select_tipo_contrato
			--str_data[17]	select_tipo_jornada
			--str_data[18]	select_preriodo_pago
			IF str_data[18]::integer=0 THEN
				valor_retorno := ''||valor_retorno||'periodicidadpago:Se requiere la Periodicidad del Pago.___';
			END IF;
			
			--str_data[19]	clabe
			--str_data[20]	select_banco
			--str_data[21]	select_riesgo_puesto
			--str_data[22]	imss
			--str_data[23]	reg_patronal
			--str_data[24]	salario_base
			--str_data[25]	fecha_ini_pago
			IF trim(str_data[25])='' THEN
				valor_retorno := ''||valor_retorno||'fechainipago:Se requiere Fecha Inicial del Periodo de Pago.___';
			END IF;
			
			--str_data[26]	fecha_fin_pago
			IF trim(str_data[26]) = '' THEN
				valor_retorno := ''||valor_retorno||'fechafinpago:Se requiere Fecha Final del Periodo de Pago.___';
			END IF;
			
			--str_data[27]	salario_integrado
			--str_data[28]	no_dias_pago
			IF trim(str_data[28])='' THEN
				valor_retorno := ''||valor_retorno||'nodiaspago:Se requiere el N&uacute;mero de D&iacute;as Pagados.___';
			ELSE
				IF str_data[28]::integer<=0 THEN
					valor_retorno := ''||valor_retorno||'nodiaspago:Se requiere el N&uacute;mero de D&iacute;as Pagados.___';
				END IF;
			END IF;
			
			--str_data[29]	concepto_descripcion
			IF trim(str_data[29]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_descripcion:Se requiere el Concepto para el Comprobante.___';
			END IF;
			
			--str_data[30]	concepto_unidad
			IF trim(str_data[30]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_unidad:Se requiere la Unidad.___';
			END IF;
			--str_data[31]	concepto_cantidad
			IF trim(str_data[31]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_cantidad:Se requiere la Cantidad.___';
			ELSE 
				IF str_data[31]::double precision <=0 THEN
					valor_retorno := ''||valor_retorno||'grid__concepto_cantidad:La Cantidad debe ser mayor a cero.___';
				END IF;
			END IF;
			--str_data[32]	concepto_valor_unitario
			IF trim(str_data[32]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_valor_unitario:Se requiere el Valor Unitario del Concepto.___';
			ELSE 
				IF str_data[32]::double precision <=0 THEN
					valor_retorno := ''||valor_retorno||'grid__concepto_valor_unitario:El Valor Unitario debe ser mayor a cero.___';
				END IF;
			END IF;
			
			--str_data[33]	concepto_importe
			IF trim(str_data[33]) = '' THEN
				valor_retorno := ''||valor_retorno||'grid__concepto_importe:Se requiere el Importe del Concepto.___';
			ELSE 
				IF str_data[33]::double precision <=0 THEN
					valor_retorno := ''||valor_retorno||'grid__concepto_importe:El Importe debe ser mayor a cero.___';
				END IF;
			END IF;
			
			--str_data[34]	descuento
			--str_data[35]	motivo_descuento
			--str_data[36]	select_impuesto_retencion
			IF str_data[36]::integer=0 THEN
				valor_retorno := ''||valor_retorno||'selectimpuestoret:Se requiere el impuesto de la retenci&oacute;n.___';
			END IF;
			--str_data[37]	importe_retencion
			IF trim(str_data[37]) = '' THEN
				valor_retorno := ''||valor_retorno||'importeisr:Se requiere el Monto de la Retenci&oacute;n.___';
			ELSE
				IF str_data[37]::double precision<=0 THEN
					valor_retorno := ''||valor_retorno||'importeisr:Se requiere el Monto de la Retenci&oacute;n.___';
				END IF;
			END IF;
			
			--str_data[38]	comp_subtotal
			--str_data[39]	comp_descuento
			--str_data[40]	comp_retencion
			--str_data[41]	comp_total
			--str_data[42]	percep_total_gravado
			--str_data[43]	percep_total_excento
			--str_data[44]	deduc_total_gravado
			--str_data[45]	deduc_total_excento
			--str_data[46]	percepciones
			
			--str_data[46]	percepciones
			IF str_data[46] is not null AND str_data[46]<>'' THEN 
				--Convertir en arreglo la cadena de Percepciones
				SELECT INTO str_percep string_to_array(str_data[46],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_percep,1) .. array_upper(str_percep,1) LOOP
					SELECT INTO str_filas string_to_array(str_percep[cont_fila],'|');
					--str_filas[1]	id_percep
					--str_filas[2]	noTrPercep
					--str_filas[3]	percep_monto_gravado
					--str_filas[4]	percep_monto_excento
					
					--str_data[3]	percep_monto_gravado
					IF trim(str_filas[3]) = '' THEN
						--valor_retorno := ''||valor_retorno||'grid2__percep_monto_gravado'||str_filas[2]||':Se requiere el Importe del Concepto.___';
					ELSE 
						IF str_filas[3]::double precision <=0 THEN
							--valor_retorno := ''||valor_retorno||'grid2__percep_monto_gravado'||str_filas[2]||':El Importe debe ser mayor a cero.___';
						END IF;
					END IF;
					
				END LOOP;
			END IF;
			--str_data[47]	deducciones
			--str_data[48]	hrs_extras
			--str_data[49]	incapacidades
			
		END IF;
        END IF;
        --Termina validacion Periodicidad de Pago




	--validacion de Catalogo de Configuraci√≥n Periodicidad de Pago
        IF id_app=174 THEN
                --str_data[4]  id
                --str_data[5]  a√±o 
                --str_data[6]  periodicidad de pago
		--str_data[7]  titulo

	      --a√±o
		IF str_data[5]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'select_anio:Es necesario seleccionar un A&ntilde;o.___';
		END IF;

		  --periodicidad de Pago
		IF str_data[6]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'periodo:Es necesario seleccionar un tipo de Periodicidad de Pago.___';
		END IF;

		
		IF str_data[4] = '0' THEN
			--anio
			IF str_data[5] != ' ' THEN
				EXECUTE 'SELECT count(id) FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id = '''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'select_anio:El A&ntilde;o ya se encuentra registrado.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT ano, id FROM nom_periodos_conf WHERE ano='''||str_data[5]||''' AND nom_periodicidad_pago_id = '''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'select_anio:El A&ntilde;o ya se encuentra registrado.___';
			END IF;
		END IF;

		IF str_data[4] = '0' THEN
			--periodicidad de pago
			IF str_data[6] != ' ' THEN
				EXECUTE 'SELECT count(id) FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id = '''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'periodo:La Periodicidad de Pago ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT nom_periodicidad_pago_id, id FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id='''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'periodo:La Periodicidad de Pago ya se encuentra registrada.___';
			END IF;
		END IF;

		
		IF str_data[4] = '0' THEN
			--prefijo
			IF str_data[7] != ' ' THEN
				EXECUTE 'SELECT count(id) FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id='''||str_data[6]||''' AND prefijo = '''||str_data[7]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:EL Prefijo ya se encuentra registrado1.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT prefijo, id FROM nom_periodos_conf WHERE ano = '''||str_data[5]||''' AND nom_periodicidad_pago_id='''||str_data[6]||''' AND prefijo='''||str_data[7]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:EL Prefijo ya se encuentra registrado2.___';
			END IF;
		END IF;

		-- validaciones para el grid --
		IF arreglo[1] <> 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	id_reg 
				--str_filas[2]	id_periodo 
				--str_filas[3]	folio 
				--str_filas[4]	tituloperiodo
				--str_filas[5]	fecha_inicio 
				--str_filas[6]	fecha_final
				--str_filas[7]	noTr

				---VALIDACION PARA  EL GRID
				IF str_filas[5] = ' ' OR str_filas[5] = '' THEN
					valor_retorno := ''||valor_retorno||'fechainicial'||str_filas[7]||':Es necesario ingresar la fecha inicial.___';
				END IF;

				IF str_filas[6] = ' ' OR str_filas[6] = '' THEN
					valor_retorno := ''||valor_retorno||'fechafinal'||str_filas[7]||':Es necesario ingresar la fecha final.___';
				END IF;
				
				IF trim(str_filas[4])='' THEN 
					valor_retorno := ''||valor_retorno||'tituloperiodo'||str_filas[7]||':Es necesario ingresar un titulo.___';

				END IF;

				--str_filas[4]	tituloperiodo
				--str_filas[7]	noTr
				
				cont_fila2:=1;
				FOR cont_fila2 IN 1 .. array_length(arreglo,1) LOOP
					SELECT INTO str_filas2 string_to_array(arreglo[cont_fila2],'___');

					--str_filas2[4]	tituloperiodo
					--str_filas2[7]	noTr
					--Aqui se verifica en el listado si existe un elemento con la misma descripcion
					IF str_filas[4]=str_filas2[4] THEN
						--Si existe entra aqu√≠
						--Hay que verificar que no sea el mismo elemento
						IF str_filas[7]<>str_filas2[7] THEN
							valor_retorno := ''||valor_retorno||'tituloperiodo'||str_filas[7]||':Es necesario ingresar un titulo diferente'||str_filas2[4]||'.___';

						END IF;
					END IF;

				END LOOP;

				IF str_filas[1] = '0' THEN
				--tituloperiodo
					IF str_filas[4] != ' ' THEN
						EXECUTE 'SELECT count(id) FROM nom_periodos_conf_det WHERE titulo = '''||str_filas[4]||''' AND nom_periodos_conf_id = '''||str_filas[2]||''' ;' INTO valida_integridad;
						IF valida_integridad > 0 THEN
							valor_retorno := ''||valor_retorno||'tituloperiodo'||str_filas[7]||':El Titulo ya se encuentra en uso.___';
						END IF;
					END IF;
				ELSE
					EXECUTE 'SELECT titulo, id FROM nom_periodos_conf_det WHERE  titulo='''||str_filas[4]||''' AND nom_periodos_conf_id = '''||str_filas[2]||''' ;' INTO titulo_mask, valida_integridad;
					IF str_filas[1]::integer != valida_integridad THEN
						valor_retorno := ''||valor_retorno||'tituloperiodo'||str_filas[7]||':El Titulo ya se encuentra registrado.___';
					END IF;
				END IF;
				
			END LOOP;
		
		END IF;
		
        END IF;
        --validacion de Catalogo de Configuraci√≥n Periodicidad de Pago




	--validacion de Parametros de Facturacion
        IF id_app=175 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected
		--str_data[3]  id_usuario 
		--str_data[4]  identificador
		--str_data[5]  identificador_suc
		--str_data[6]  correo_envio
		--str_data[7]  passwd_correo_envio
		--str_data[8]  passwd2_correo_envio
		--str_data[9]  servidor_correo_envio
		--str_data[10]  puerto_correo_envio
		--str_data[11]  correo_cco
		--str_data[12]  select_almacen_ventas
		--str_data[13]  select_formato_pedido
		
                 --correo_envio
		IF trim(str_data[6]) <> '' THEN
			EXECUTE 'select '''||str_data[6]||''' ~ ''^[^@ ]+@[^@ ]+.[^@ .]+$'';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'correoenvio:Correo Electr&oacute;nico No Valido.___';
			ELSE
				IF trim(str_data[11]) <> '' THEN
					EXECUTE 'select '''||str_data[11]||''' ~ ''^[^@ ]+@[^@ ]+.[^@ .]+$'';' INTO match_cadena;
					IF match_cadena = false THEN
						valor_retorno := ''||valor_retorno||'correocco:Correo Electr&oacute;nico para env&iacute;o de copia oculta No Valido.___';
					END IF;
				END IF;
			END IF;
			
			IF trim(str_data[7]) = '' THEN
				valor_retorno := ''||valor_retorno||'passwd:Ingresar Contrase&ntilde;a.___';
			ELSE
				IF trim(str_data[8]) = '' THEN
					valor_retorno := ''||valor_retorno||'passwd2:Repetir Contrase&ntilde;a.___';
				ELSE
					IF trim(str_data[7])<>trim(str_data[8]) THEN
						valor_retorno := ''||valor_retorno||'passwd2:La Contrase&ntilde;a no coincide con la primera.___';
					END IF;
				END IF;
			END IF;

			IF trim(str_data[9]) = '' THEN
				valor_retorno := ''||valor_retorno||'servidorenvio:Es necesario el servidor SMTP para el env&iacute;o. Ejemplo: smtp.gmail.com___';
			END IF;

			IF trim(str_data[10]) = '' THEN
				valor_retorno := ''||valor_retorno||'puertoenvio:Es necesario el puerto para el env&iacute;o.___';
			END IF;
		END IF;
		
		IF str_data[12]::integer=0 THEN
			valor_retorno := ''||valor_retorno||'almventas:Es necesario seleccionar el almacen para ventas.___';
		END IF;

		IF str_data[13]::integer=0 THEN
			valor_retorno := ''||valor_retorno||'formatopedido:Es necesario seleccionar el formato para el PDF del pedido.___';
		END IF;
		
        END IF;
        --Termina validacion de Parametros de Facturacion





        --validacion de Catalogo de Descuentos
        IF id_app=176 THEN
                --str_data[4]  id
                --str_data[5]  nocliente 
                --str_data[6]  valor
                
                --cliente
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Ingresar el n&uacute;mero de control del cliente.___';
		
		END IF;
                
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'valor:Se requiere el valor del Descuento.___';
		ELSE 
			IF str_data[6]::double precision <=0 THEN
				valor_retorno := ''||valor_retorno||'valor:El valor del descuento debe ser mayor a cero.___';
			END IF;
		END IF;
		
		
		
		IF str_data[4] = '0' THEN
			--cliente
			IF trim(str_data[5])<>'' THEN
				EXECUTE 'SELECT count(id) FROM cxc_clie_descto WHERE cxc_clie_id = '''||str_data[5]::integer||''' ;' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nocliente:El Cliente ya se encuentra registrado.___'; 
				END IF;
			END IF;			
		ELSE
			--cliente
			EXECUTE 'SELECT cxc_clie_id, id FROM cxc_clie_descto WHERE cxc_clie_id='''||str_data[5]::integer||''' ;' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'nocliente:El Cliente ya se encuentra registrado.___';
			END IF;
		END IF;
        END IF;
        --Termina validacion Catalogo de Descuentos




        --Validacion de Aplicativo de Polizas Contables
        IF id_app=179 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	select_sucursal
		--str_data[6]	select_mes
		--str_data[7]	select_anio
		--str_data[8]	select_tipo
		--str_data[9]	select_moneda
		--str_data[10]	select_concepto
		--str_data[11]	fecha
		--str_data[12]	descripcion
		--str_data[13]	observacion
                
                --select_sucursal
		IF trim(str_data[5])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'sucursal:Seleccione una Sucursal.___';
		END IF;

                --select_mes
		IF trim(str_data[6])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'mes:Seleccione el Mes.___';
		END IF;


                --select_anio
		IF trim(str_data[7])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'anio:Seleccione el A&ntilde;o.___';
		END IF;


                --select_tipo
		IF trim(str_data[8])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'tipo:Seleccione el Tipo de P&oacute;liza.___';
		END IF;


                --select_moneda
		IF trim(str_data[9])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'moneda:Seleccione la Moneda.___';
		END IF;

                --select_concepto
		IF trim(str_data[10])::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'concepto:Seleccione el Concepto.___';
		END IF;
		
		--fecha
		IF trim(str_data[11]) = '' THEN
			valor_retorno := ''||valor_retorno||'fecha:Seleccione la Fecha.___';
		END IF;



		/*

		*/
		/*
		--debe
		IF trim(str_data[15]) = '' THEN
			valor_retorno := ''||valor_retorno||'debe:Ingrese una cantidad para Debe.___';
		END IF;


		--haber
		IF trim(str_data[16]) = '' THEN
			valor_retorno := ''||valor_retorno||'haber:Ingrese una cantidad para Haber.___';
		END IF;
		*/
		
		--str_data[17]	id_cta

		/*
		IF trim(str_data[5])::integer<>0 THEN
			IF trim(str_data[6])::integer<>0 THEN
				IF trim(str_data[7])::integer<>0 THEN
					IF trim(str_data[17])::integer<>0 THEN
						EXECUTE 'SELECT count(id) FROM ctb_pol WHERE gral_suc_id='||str_data[5]::integer||' and ano='||str_data[7]::integer||' and mes='||str_data[6]::integer||' and ctb_cta_id='||str_data[17]::integer||' and borrado_logico=false;' INTO valida_integridad;
						IF valida_integridad > 0 THEN
							EXECUTE 'SELECT id FROM ctb_pol WHERE gral_suc_id='||str_data[5]::integer||' and ano='||str_data[7]::integer||' and mes='||str_data[6]::integer||' and ctb_cta_id='||str_data[17]::integer||' and borrado_logico=false;' INTO id_registro;

							--RAISE EXCEPTION '%','id_registro='||id_registro||'    str_data[4]='||str_data[4];
							
							IF id_registro<>str_data[4]::integer THEN
								valor_retorno := ''||valor_retorno||'cta:La poliza para esta cuenta ya se encuentra registrada.___'; 
							END IF;
						END IF;
					END IF;
				END IF;
			END IF;
		END IF;
		*/



		-- validaciones para el grid --
		IF arreglo[1]<>'sin datos' THEN
			
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	eliminado
				--str_filas[2]	id_det
				--str_filas[3]	select_tmov
				--str_filas[4]	id_cta
				--str_filas[5]	select_cc
				--str_filas[6]	debe
				--str_filas[7]	haber
				--str_filas[8]	cta
				--str_filas[9]	no_tr

				--Verificar que el registro no se haya eliminado del grid
				IF str_filas[1]::integer > 0 then
					IF str_filas[3]::integer <= 0 then
						valor_retorno := ''||valor_retorno||'select_tmov'||str_filas[9]||':Es necesario seleccionar e Tipo de Movimiento.___';
					END IF;
					
					IF str_filas[4]::integer <= 0 then
						valor_retorno := ''||valor_retorno||'cta'||str_filas[9]||':Es necesario la cuenta.___';
					END IF;

					
					IF trim(str_filas[6])='' AND trim(str_filas[7])='' THEN
						valor_retorno := ''||valor_retorno||'debe'||str_filas[9]||':Es necesario ingresar una cantidad para alguno de los dos campos: Debe o Haber.___';
						valor_retorno := ''||valor_retorno||'haber'||str_filas[9]||':Es necesario ingresar una cantidad para alguno de los dos campos: Debe o Haber.___';
					ELSE
						IF trim(str_filas[6])::double precision<=0 AND trim(str_filas[7])::double precision<=0 THEN
							valor_retorno := ''||valor_retorno||'debe'||str_filas[9]||':Es necesario ingresar una cantidad para alguno de los dos campos: Debe o Haber.___';
							valor_retorno := ''||valor_retorno||'haber'||str_filas[9]||':Es necesario ingresar una cantidad para alguno de los dos campos: Debe o Haber.___';
						END IF;
					END IF;
				END IF;
			END LOOP;
		END IF;
        END IF;
        --Termina validacion del Aplicativo de Polizas Contables

        
	--Validacion Aplicativo Carga de Documentos(LOG)
	IF id_app=180 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected
		--str_data[3]  id_usuario
		--str_data[4]  id_emp
		--str_data[5]  id_suc
		--str_data[6]  id_cliente

		IF trim(str_filas[6])='' then 
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
		else
			IF str_filas[6]::integer <= 0 then
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			END IF;
		end if;
		
		IF arreglo[1]<>'sin datos' THEN
			cont_fila:=1;
			FOR cont_fila IN 1 .. array_length(arreglo,1) LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	elim
				--str_filas[2]	noTr
				--str_filas[3]	iddet
				--str_filas[4]	iduni
				--str_filas[5]	idruta
				
				IF str_filas[1]::integer=1 THEN 
					IF trim(str_filas[4])='' then 
						valor_retorno := ''||valor_retorno||'.no_uni'||str_filas[2]||':Es necesario seleccionar una Unidad(Vehiculo).___';
					else
						IF str_filas[4]::integer <= 0 then
							valor_retorno := ''||valor_retorno||'.no_uni'||str_filas[2]||':Es necesario seleccionar una Unidad(Vehiculo).___';
						END IF;
					end if;
					
					IF trim(str_filas[4])='' then 
						valor_retorno := ''||valor_retorno||'.no_ruta'||str_filas[2]||':Es necesario seleccionar una Ruta.___';
					else
						IF str_filas[5]::integer <= 0 then
							valor_retorno := ''||valor_retorno||'.no_ruta'||str_filas[2]||':Es necesario seleccionar una Ruta.___';
						END IF;
					end if;
				END IF;
			END LOOP;
		END IF;
		
	end if;
	--Termina validacion de carga de DocumentosLOG()


        
        --Validacion Aplicativo Administrador de Viajes(LOG)
        IF id_app=181 THEN
                --str_data[1]  app_selected
                --str_data[2]  command_selected 
                --str_data[3]  id_usuario
                
		if str_data[2]='new' or str_data[2]='edit' or str_data[2]='confirm' then 
			--str_data[4]  identificador
			--str_data[5]  fecha
			--str_data[6]  hora
			--str_data[7]  sucursal
			--str_data[8]  id_vehiculo
			--str_data[9]  observaciones
			--str_data[10]  adicionales
			--str_data[11]  id_ruta
			--str_data[12]  id_almacen_salida
			--str_data[13]  suma_precio_venta
			--str_data[14]  select_tipo_dist
			
			--fecha
			IF trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'fecha:Ingresar la Fecha del Viaje.___';
			END IF;

			IF trim(str_data[7])::integer<1 THEN
				valor_retorno := ''||valor_retorno||'idsuc:Seleccionar la Sucursal.___';
			END IF;
			
			IF trim(str_data[8]) = '' THEN
				valor_retorno := ''||valor_retorno||'idvehiculo:Seleccionar la Unidad.___';
			END IF;
			
			IF trim(str_data[11]) = '' THEN
				valor_retorno := ''||valor_retorno||'noruta:Es necesario seleccionar una Ruta para el viaje.___';
			else
				IF str_data[11]::integer <= 0 THEN
					valor_retorno := ''||valor_retorno||'noruta:Es necesario seleccionar una Ruta para el viaje.___';
				end if;
			END IF;	
			
			IF str_data[12]::integer <= 0 THEN
				valor_retorno := ''||valor_retorno||'almacen:Seleccionar el Almacen de salida.___';
			end if;
			
			IF trim(str_data[14])::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'tdist:Es neleccionar el Tipo de Distribucion.___';
			END IF;
			
			--Validar que los pedidos no hayan sido confirmados anteriormente en otro viaje
			if trim(str_data[2])='confirm' then 
				IF arreglo[1]<>'sin datos' THEN
					cont_fila:=1;
					FOR cont_fila IN 1 .. array_length(arreglo,1) LOOP
						SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
						--str_filas[1]	elim
						--str_filas[2]	iddet
						--str_filas[3]	idcga
						--str_filas[4]	idped
						--str_filas[5]	iddest
						--str_filas[6]	idmun
						--str_filas[7]	selec
						--str_filas[8]	selec_chk_firma
						--str_filas[9]	selec_chk_sello
						--str_filas[10]	selec_chk_efectivo
						--str_filas[11]	selec_chk_cheque
						IF str_filas[7]::integer=1 THEN 
							if (select count(id) from log_doc_ped where id=str_filas[4]::integer and log_status_id>=1)>0 then 
								--Aqu√≠ entra porque el pedido ya ha sido enviado en un viaje
								valor_retorno := ''||valor_retorno||'PED_REP:'||str_filas[4]||'___';
							end if;
						end if;
					END LOOP;
				END IF;
			end if;
			
			--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
			
			--RAISE EXCEPTION '%','str_data[10]='||str_data[10];
			IF trim(str_data[10])<>'' THEN
				--Validar Servicios Adicionales
				
				--Convertir en arreglo la cadena de Adicionales
				SELECT INTO str_filas string_to_array(str_data[10],'|');
				
				cont_fila=1;
				FOR cont_fila IN array_lower(str_filas,1) .. array_upper(str_filas,1) LOOP
					SELECT INTO str_filas2 string_to_array(str_filas[cont_fila],'&&');
					--str_filas2[1]	idreg
					--str_filas2[2]	del
					--str_filas2[3]	noTr
					--str_filas2[4]	idprod
					--str_filas2[5]	precio

					if str_filas2[2]::integer=1 then
						--str_data[5]	precio
						IF trim(str_filas2[5]) = '' THEN
							valor_retorno := ''||valor_retorno||'precio'||str_filas2[3]||':Se requiere el Precio.___';
						ELSE 
							IF str_filas2[5]::double precision <=0 THEN
								valor_retorno := ''||valor_retorno||'precio'||str_filas2[3]||':El Precio debe ser mayor a cero.___';
							END IF;
						END IF;
					end if;
				END LOOP;
			END IF;
		else
			if trim(str_data[2])='cancel' then 
				--Aqui entra cuando la opcion seleccionda es cancelar
				
			end if;
			
			if trim(str_data[2])='guardar_rechazos' then 
				--Aqui entra para validar los datos de rechazos de productos.
				
				--str_data[4]  id_det_viaje
				--str_data[5]  select_almacen_destino
				--str_data[6]  almacen_origen
				IF trim(str_data[5])::integer<1 THEN
					valor_retorno := ''||valor_retorno||'almacenrechazo:Seleccionar almacen donde se almacenara el rechazo.___';
				END IF;
				
				--Validaciones para el grid de productos--
				IF arreglo[1]<>'sin datos' THEN
					
					total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
					cont_fila:=1;
					
					FOR cont_fila IN 1 .. total_filas LOOP
						SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
						--str_filas[1]	noTr
						--str_filas[2]	id_det_ped
						--str_filas[3]	cant_uni_dev
						--str_filas[4]	select_tr
						--str_filas[5]	precio_unitario_mn
						--str_filas[6]	id_prod
						
						--Validar cantidad de unidades
						if trim(str_filas[3])='' then
							valor_retorno := ''||valor_retorno||'cant_uni_dev'||str_filas[1]||':Es necesario ingresar la Cantidade de Unidades Rechazadas.___';
						else
							if str_filas[3]::double precision<=0 then
								valor_retorno := ''||valor_retorno||'cant_uni_dev'||str_filas[1]||':La Cantidad de Rechazados debe ser mayor a cero.___';
							end if;
						end if;
						
						--Validar tipo de rechazo
						if str_filas[4]::integer<=0 then
							valor_retorno := ''||valor_retorno||'select_tr'||str_filas[1]||':Es necesario seleccionar el Tipo de Rechazo___';
						end if;
						
					END LOOP;
				END IF;
			end if;
		end if;
        END IF;
        --Termina validacion Aplicativo Administrador de Viajes(LOG)




 	--Validacion de Catalogo de Vehiculo Marca
        IF id_app=182 THEN
                --str_data[4]   id
		--str_data[5]	titulo
                               
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Marca.___';
		END IF;

           
                
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM log_vehiculo_marca WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Marca ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_vehiculo_marca WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Marca ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo de Vehiculo Marca


	--Validacion de Catalogo de Vehiculo Tipo Rodada
        IF id_app=183 THEN
                --str_data[4]   id
		--str_data[5]	titulo
                               
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Rodada.___';
		END IF;

           
                
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM log_vehiculo_tipo_rodada WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Rodada ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_vehiculo_tipo_rodada WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Rodada ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo Vehiculo Tipo Rodada


        --Validacion de Catalogo de Vehiculo Tipo Caja
        IF id_app=184 THEN
                --str_data[4]   id
		--str_data[5]	titulo
                               
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Caja.___';
		END IF;

           
                
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM log_vehiculo_tipo_caja WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Caja ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_vehiculo_tipo_caja WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Caja ya se encuentra registrada.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo de Vehiculo Tipo Caja





        --Validacion Catalogo de Servicios Adicionales(LOG)
        IF id_app=185 THEN
		
		IF arreglo[1]<>'sin datos' THEN
			cont_fila:=1;
			FOR cont_fila IN 1 .. array_length(arreglo,1) LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	idreg
				--str_filas[2]	idprod
				--str_filas[3]	elim
				--str_filas[4]	noTr
				IF str_filas[3]::integer=1 THEN 
					EXECUTE 'SELECT count(id) FROM log_serv_adic WHERE inv_prod_id='||str_filas[2]||';' INTO valida_integridad;
					IF valida_integridad > 0 THEN 
						valida_integridad:=0;

						--Buscar el id del registro encontrado
						EXECUTE 'SELECT id FROM log_serv_adic WHERE inv_prod_id='||str_filas[2]||' limit 1;' INTO valida_integridad;

						--Si es diferente al registro actual quiere decir que lo estamos queriando repetir por lo tanto no debe pasar
						if valida_integridad<>str_filas[1]::integer then 
							valor_retorno := ''||valor_retorno||'idreg'||str_filas[4]||':El servicio ya fue se encuentra registrado.___'; 
						end if;
					END IF;
				END IF;
			END LOOP;
		END IF;
        END IF;
        --Termina validacion Catalogo de Servicios Adicionales(LOG)


        

	--Validacion de Catalogo de Tipos de Unidades
        IF id_app=187 THEN
                --str_data[4]   id
		--str_data[5]	titulo
		--str_data[6]	volumeninicio
		--str_data[7]	volumenfin
		--str_data[8]	kginicio
		--str_data[9]	kgfin
		                       
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo a la Unidad.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5] != '' THEN
				EXECUTE 'SELECT count(id) FROM log_vehiculo_tipo WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Unidad ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_vehiculo_tipo WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo de la Unidad ya se encuentra registrada.___';
			END IF;
		END IF;

		IF trim(str_data[6])=''  THEN
			valor_retorno := ''||valor_retorno||'volumeninicio:Es necesario ingresar una cantidad para la Capacidad en metros cubicos.___';
		ELSE 
			/*
			IF str_data[6]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'volumeninicio:La Capacidad en metros cubicos debe ser mayor a cero.___';
			END IF;
			*/
		END IF;
		
		IF trim(str_data[7])=''  THEN
			valor_retorno := ''||valor_retorno||'volumenfin:Es necesario ingresar una cantidad para la Capacidad en metros cubicos.___';
		ELSE
			/*
			IF str_data[7]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'volumenfin:La Capacidad en metros cubicos debe ser mayor a cero.___';
			END IF;
			*/
		END IF;

		IF trim(str_data[8])=''  THEN
			valor_retorno := ''||valor_retorno||'kginicio:Es necesario ingresar una cantidad para la Capacidad Peso en Kilogramos.___';
		ELSE
			/*
			IF str_data[8]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'kginicio:La Capacidad peso en Kilogramos debe ser mayor a cero.___';
			END IF;
			*/
		END IF;
		
		IF trim(str_data[9])=''  THEN
			valor_retorno := ''||valor_retorno||'kgfin:Es necesario ingresar una cantidad para la Capacidad Peso en Kilogramo.___';
		ELSE
			/*
			IF str_data[9]::double precision=0  THEN
				valor_retorno := ''||valor_retorno||'kgfin:La Capacidad peso en Kilogramos debe ser mayor a cero.___';
			END IF;
			*/
		END IF;
        END IF;--Termina Validacion Catalogo de Tipos de Unidades





        --Validacion de Aplicativo de Registro de Cargas(LOG)
        IF id_app=188 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	no_carga
		--str_data[6]	fecha_entrega
		--str_data[7]	select_almacen
		--str_data[8]	id_cliente
		--str_data[9]	observaciones

		if str_data[2]='new' or str_data[2]='edit' or str_data[2]='delete' then 
			--no_carga
			IF trim(str_data[5])='' THEN
				valor_retorno := ''||valor_retorno||'nocarga:Es necesario ingresar el No. de Carga.___';
			END IF;

			--fecha_entrega
			IF trim(str_data[6])='' THEN
				valor_retorno := ''||valor_retorno||'fecha:Es necesario ingresar la Fecha de Entrega.___';
			END IF;

			--select_almacen
			IF trim(str_data[7])::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'almacen:Es necesario seleccionar el Almacen.___';
			END IF;

			--id_cliente
			IF trim(str_data[8])='' THEN
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			END IF;

			
			--Validaciones para el grid de pedidos--
			IF arreglo[1]<>'sin datos' THEN
				
				total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	tipoTr
					--str_filas[3]	noTr
					--str_filas[4]	iddet
					--str_filas[5]	iddest
					--str_filas[6]	no_pedido
					--str_filas[7]	no_fac
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						if trim(str_filas[2])='PAR' then
							--El campo No. de Pedido solo se debe validar cuando la fila es tipo partida
							if trim(str_filas[6])='' then
								valor_retorno := ''||valor_retorno||'no_pedido'||str_filas[3]||':Es necesario ingresar el No. de Pedido.___';
							end if;
						end if;
						
						if trim(str_filas[7])='' then
							valor_retorno := ''||valor_retorno||'no_fac'||str_filas[3]||':Es necesario ingresar el No. de Factura.___';
						end if;
					END IF;
				END LOOP;
			END IF;
		else
			--Aqui entra para validar detalles del pedido

			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5]	almacen_destino
			--str_data[6]	tipo_carga
			
			--Validaciones para el grid de productos--
			IF arreglo[1]<>'sin datos' THEN
				
				total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	noTr
					--str_filas[3]	iddet
					--str_filas[4]	id_prod
					--str_filas[5]	id_uni
					--str_filas[6]	cant
					--str_filas[7]	peso
					--str_filas[8]	volumen
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						--Validar cantidad de unidades
						if trim(str_filas[6])='' then
							valor_retorno := ''||valor_retorno||'cant'||str_filas[2]||':Es necesario ingresar la Cantidad de unidades.___';
						else 
							if str_filas[6]::double precision<=0 then
								valor_retorno := ''||valor_retorno||'cant'||str_filas[2]||':La Cantidad debe ser mayor a cero.___';
							else 
								--Verificar si es necesario revisar existencias en inventario del de producto
								if str_data[6]::boolean=false then 
									exis:=0;
									total_existencia:=0;
									cant_reservada_anterior:=0;
									
									select count(log_entrada_det.cantidad) as exis from log_entrada_det where log_entrada_det.inv_prod_id=str_filas[4]::integer and log_entrada_det.cantidad > log_entrada_det.entregado 
									into exis;
									
									if exis > 0 then 
										select sum(log_entrada_det.cantidad) as existencia  
										from log_entrada_det 
										where log_entrada_det.inv_prod_id=str_filas[4]::integer and log_entrada_det.cantidad > log_entrada_det.entregado 
										into total_existencia;

										if str_filas[3]::integer > 0 then 
											--Buscar la cantidad en el detalle del pedido
											select cantidad from log_doc_ped_det where id=str_filas[3]::integer into cant_reservada_anterior;
										end if;
										
										total_existencia:=total_existencia + cant_reservada_anterior::double precision;

										--Redondeo de existencia
										total_existencia := round((total_existencia)::numeric,4)::double precision;
										
										if total_existencia < round(str_filas[6]::numeric,4)::double precision then 
											valor_retorno := ''||valor_retorno||'cant'||str_filas[2]||':Existencia='||total_existencia||', no se puede incluir una cantidad mayor al pedido.___';
										end if;
									end if;
								end if;
							end if;
						end if;
						
						--Validar peso
						if trim(str_filas[7])='' then
							valor_retorno := ''||valor_retorno||'peso'||str_filas[2]||':Es necesario ingresar el Peso.___';
						else
							if str_filas[7]::double precision<=0 then
								valor_retorno := ''||valor_retorno||'peso'||str_filas[2]||':La Peso debe ser mayor a cero.___';
							end if;
						end if;

						--Validar volumen
						if trim(str_filas[8])='' then
							valor_retorno := ''||valor_retorno||'volumen'||str_filas[2]||':Es necesario ingresar el Volumen.___';
						else
							if str_filas[8]::double precision<=0 then
								valor_retorno := ''||valor_retorno||'volumen'||str_filas[2]||':El Volumen debe ser mayor a cero.___';
							end if;
						end if;
					END IF;
				END LOOP;
			END IF;
			
		end if;
        END IF;
        --Termina validacion del Aplicativo de Registro de Cargas(LOG)


	

	--validacion de Aplicativo Tarifario
        IF id_app=189 THEN
                --str_data[4]  id
                --str_data[5]  nombreruta 
                --str_data[6]  select_tiporuta
		--str_data[7]  kilometros
		
		--nombreruta
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombreruta:Es necesario ingresar un Titulo a la Ruta.___';
		END IF;

		--tiporuta
		IF str_data[6]::integer =0 THEN
			valor_retorno := ''||valor_retorno||'select_tiporuta:Es necesario seleccionar un tipo de Ruta.___';
		END IF;

		--kilometros
		IF trim(str_data[7]) = '' THEN
			valor_retorno := ''||valor_retorno||'kilometros:Es necesario ingresar el N&uacute;mero de Kilometros.___';
		END IF;


		IF str_data[4] = '0' THEN
			--nombreruta
			IF str_data[6] != ' ' THEN
				EXECUTE 'SELECT count(id) FROM log_ruta WHERE titulo = '''||str_data[5]||''' AND log_ruta_tipo_id = '''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'nombreruta:El Titulo de la Ruta ya se encuentra registrada.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_ruta WHERE titulo = '''||str_data[5]||''' AND log_ruta_tipo_id='''||str_data[6]||''' AND borrado_logico=FALSE AND gral_suc_id='||str_data[8]||' AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'nombreruta:El Titulo de la Ruta ya se encuentra registrada.___';
			END IF;
		END IF;

		-- Validaciones para el Grid Tipo de Unidades --
		IF arreglo[1] <> 'sin datos' THEN
			total_filas:= array_length(arreglo,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	id_reg 
				--str_filas[2]	eliminado 
				--str_filas[3]	id_tipounidad
				--str_filas[4]	costo 
				--str_filas[5]	noTr 
				--str_filas[6]	costo hot shot 
				
				---costo directo
				IF trim(str_filas[4]) = '' THEN
					valor_retorno := ''||valor_retorno||'costo'||str_filas[5]||':Es necesario ingresar un costo.___';
				ELSE 
					/*
					IF str_filas[4]::double precision <=0 THEN
						valor_retorno := ''||valor_retorno||'costo'||str_filas[5]||':El Costo debe ser mayor a cero.___';
					END IF;
					*/
				END IF;
				
				---costo hot shot
				IF trim(str_filas[4]) = '' THEN
					valor_retorno := ''||valor_retorno||'costo_hs'||str_filas[5]||':Es necesario ingresar el Costo Hot Shot.___';
				ELSE 
					/*
					IF str_filas[4]::double precision <=0 THEN
						valor_retorno := ''||valor_retorno||'costo_hs'||str_filas[5]||':El Costo Hot Shot debe ser mayor a cero.___';
					END IF;
					*/
				END IF;
				
			END LOOP;
		END IF;

		IF trim(str_data[9])<>'' THEN
			--Validar Poblaciones
			
			--Convertir en arreglo la cadena de Poblaciones
			SELECT INTO str_filas string_to_array(str_data[9],'|');
			
			cont_fila=1;
			FOR cont_fila IN array_lower(str_filas,1) .. array_upper(str_filas,1) LOOP
				SELECT INTO str_filas2 string_to_array(str_filas[cont_fila],'&&');

				--str_filas2[1]	idreg
				--str_filas2[2]	eliminado
				--str_filas2[3]	notr
				--str_filas2[4]	id_mun
				--str_filas2[5]	select_localidad
				--str_filas2[6]	select_entidad
				--str_filas2[7]	select_pais


				IF str_filas2[2]::integer > 0 then
					--select_localidad
					IF str_filas2[5]::integer <= 0 THEN
						valor_retorno := ''||valor_retorno||'select_municipio'||str_filas2[3]||':Es necesario seleccionar un Municipio.___';
					END IF;
					
					--select_entidad
					IF str_filas2[6]::integer <= 0 THEN
						valor_retorno := ''||valor_retorno||'select_entidad'||str_filas2[3]||':Es necesario seleccionar una Entidad.___';
					END IF;
					
					--select_pais
					IF str_filas2[7]::integer <= 0 THEN
						valor_retorno := ''||valor_retorno||'select_pais'||str_filas2[3]||':Es necesario seleccionar un Pais.___';
					END IF;
				END IF;
			END LOOP;
		END IF;
		
        END IF;
        --validacion de Aplicativo Tarifario

        
	--Validacion de Catalogo de Tipo de Rechazo
        IF id_app=190 THEN
                --str_data[4]   id
		--str_data[5]	titulo
		
		--titulo
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar un Titulo al Tipo de Rechazo.___';
		END IF;
		
		IF str_data[4] = '0' THEN
			--titulo
			IF str_data[5]!='' THEN
				EXECUTE 'SELECT count(id) FROM log_tipo_rechazo WHERE titulo = '''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO valida_integridad;
				IF valida_integridad > 0 THEN
					valor_retorno := ''||valor_retorno||'titulo:El Titulo del Tipo de Rechazo ya se encuentra registrado.___';
				END IF;
			END IF;
		ELSE
			EXECUTE 'SELECT titulo, id FROM log_tipo_rechazo WHERE titulo='''||str_data[5]||''' AND borrado_logico=FALSE  AND gral_emp_id='||emp_id||';' INTO titulo_mask, valida_integridad;
			IF str_data[4]::integer != valida_integridad THEN
				valor_retorno := ''||valor_retorno||'titulo:El Titulo del Tipo de Rechazo ya se encuentra registrado.___';
			END IF;
		END IF;
                        
        END IF;--Termina Validacion Catalogo de Tipo de Rechazo


	
	
	
	--Validacion de Aplicativo de Captura de Evidencias(LOG)
        IF id_app=191 THEN
		--str_data[1]   app_selected
		--str_data[2]   command_selected
		--str_data[3]   id_usuario 
		--str_data[4]   id_factura
		--str_data[5]   id_carga
		--str_data[6]   id_pedido
		--str_data[7]   id_det_viaje
		--str_data[8]   chk_firma
		--str_data[9]   chk_sello
		--str_data[10]   chk_cheque
		--str_data[11]   chk_eftvo
		--str_data[12]   no_che
		--str_data[13]   monto
		--str_data[14]   no_tr
		--str_data[15]   con_evidencia

		/*
		--str_data[4]   id_factura
		IF trim(str_data[4]) = '' THEN
			valor_retorno := ''||valor_retorno||'factura:No existe numero de factura.___';
		END IF;

		--Validar solo cuando hay evidencias
		if str_data[15]::boolean then 
			--str_data[10]   chk_cheque
			if str_data[10]::boolean then
				if trim(str_data[12])='' then 
					valor_retorno := ''||valor_retorno||'evidencia_no_che'||str_data[14]||':Es necesario ingresar el Numero de Cheque.___';
				end if;
				
				if trim(str_data[13])='' then 
					valor_retorno := ''||valor_retorno||'evidencia_monto'||str_data[14]||':Es necesario ingresar el Monto.___';
				else
					if str_data[13]::double precision<=0 then 
						valor_retorno := ''||valor_retorno||'evidencia_monto'||str_data[14]||':El Monto debe ser mayor a cero.___';
					end if;
				end if;
			else
				--Validar si se selecciono el checkbox para efectivo
				if str_data[11]::boolean then
					if trim(str_data[13])='' then 
						valor_retorno := ''||valor_retorno||'evidencia_monto'||str_data[14]||':Es necesario ingresar el Numero de Cheque.___';
					else
						if str_data[13]::double precision<=0 then 
							valor_retorno := ''||valor_retorno||'evidencia_monto'||str_data[14]||':El monto debe ser mayor a cero.___';
						end if;
					end if;
				end if;
			end if;
		end if;
		*/
		
		IF arreglo[1]<>'sin datos' THEN
			
			cont_fila:=1;
			FOR cont_fila IN array_lower(arreglo,1) .. array_upper(arreglo,1) LOOP
				SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
				--str_filas[1]	notr
				--str_filas[2]	id_factura
				--str_filas[3]	id_carga
				--str_filas[4]	id_pedido
				--str_filas[5]	id_det_viaje
				--str_filas[6]	chk_firma
				--str_filas[7]	chk_sello
				--str_filas[8]	chk_cheque
				--str_filas[9]	chk_eftvo
				--str_filas[10]	no_che
				--str_filas[11]	monto
				--str_filas[12]	fecha
				--str_filas[13]	con_evidencia

				--str_data[2]   id_factura
				IF trim(str_filas[2]) = '' THEN
					valor_retorno := ''||valor_retorno||'notr'||str_filas[1]||':No existe numero de factura.___';
				END IF;
				
				--Validar solo cuando hay evidencias
				if str_filas[13]::boolean then 
					--str_data[8]   chk_cheque
					if str_filas[8]::boolean then
						if trim(str_filas[10])='' then 
							valor_retorno := ''||valor_retorno||'.evidencia_no_che'||str_filas[1]||':Es necesario ingresar el Numero de Cheque.___';
						end if;
						
						if trim(str_filas[11])='' then 
							valor_retorno := ''||valor_retorno||'.evidencia_monto'||str_filas[1]||':Es necesario ingresar el Monto.___';
						else
							if str_filas[11]::double precision<=0 then 
								valor_retorno := ''||valor_retorno||'.evidencia_monto'||str_filas[1]||':El Monto debe ser mayor a cero.___';
							end if;
						end if;
					else
						--Validar si se selecciono el checkbox para efectivo
						if str_filas[9]::boolean then
							if trim(str_filas[11])='' then 
								valor_retorno := ''||valor_retorno||'.evidencia_monto'||str_filas[1]||':Es necesario ingresar el Numero de Cheque.___';
							else
								if str_filas[11]::double precision<=0 then 
									valor_retorno := ''||valor_retorno||'.evidencia_monto'||str_filas[1]||':El monto debe ser mayor a cero.___';
								end if;
							end if;
						end if;
					end if;
				end if;
				
			END LOOP;
		END IF;
		
        END IF;--Termina Validacion  Captura de Evidencias(LOG)



        
	--Validacion de Tarifario de Venta por POBLACION
        IF id_app=194 THEN
                --str_data[4]   id
		--str_data[5]	id_cliente
		--str_data[6]	select_pais
		--str_data[7]	select_estado
		--str_data[8]	select_municipio

		--id_cliente
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
		else
			IF str_data[5]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			end if;
		END IF;
		
		--select_pais
		IF str_data[6]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'pais:Es necesario seleccionar el Pais.___';
		END IF;

		--select_estado
		IF str_data[7]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'estado:Es necesario seleccionar el Estado.___';
		END IF;
		
		--select_municipio
		IF str_data[8]::integer = 0 THEN
			valor_retorno := ''||valor_retorno||'municipio:Es necesario seleccionar el Municipio o Poblacion.___';
		END IF;


		
		SELECT count(id) from log_tarifario_venta WHERE cxc_clie_id=str_data[5]::integer AND gral_mun_id=str_data[8]::integer 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT id from log_tarifario_venta WHERE cxc_clie_id=str_data[5]::integer AND gral_mun_id=str_data[8]::integer 
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				--valor_retorno := ''||valor_retorno||'noruta:Ya esxiste un registro con la misma Ruta.___';
				valor_retorno := ''||valor_retorno||'nocliente:Ya esxiste un registro con el mismo Cliente.___';
			END IF;
		END IF;
        END IF;--Termina Validacion de Tarifario de Venta por POBLACION

	

	--Validacion de Tarifario de Venta por RANGO
        IF id_app=195 THEN
		--str_data[4]   id
		--str_data[5]	id_cliente
		--str_data[6]	vigencia_ini
		--str_data[7]	vigencia_fin
		--str_data[8]	select_tipo_tarifa
		
		--id_cliente
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
		else
			IF str_data[5]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			end if;
		END IF;
		
		SELECT count(log_tarifario_venta.id) from log_tarifario_venta 
		join log_tarifario_venta_det on (log_tarifario_venta_det.log_tarifario_venta_id=log_tarifario_venta.id and log_tarifario_venta_det.log_tarifa_tipo_id=str_data[8]::integer and log_tarifario_venta_det.fecha_inicio=str_data[6]::date and log_tarifario_venta_det.fecha_fin=str_data[7]::date)
		WHERE log_tarifario_venta.cxc_clie_id=str_data[5]::integer 
		INTO valida_integridad;
		
		IF valida_integridad>0 THEN 
			SELECT log_tarifario_venta.id from log_tarifario_venta join log_tarifario_venta_det on (log_tarifario_venta_det.log_tarifario_venta_id=log_tarifario_venta.id and log_tarifario_venta_det.log_tarifa_tipo_id=str_data[8]::integer and log_tarifario_venta_det.fecha_inicio=str_data[6]::date and log_tarifario_venta_det.fecha_fin=str_data[7]::date)
			WHERE cxc_clie_id=str_data[5]::integer
			INTO id_registro;
			
			--Validar integridad
			IF str_data[4]::integer <> id_registro THEN
				valor_retorno := ''||valor_retorno||'nocliente:Ya esxiste un registro con el mismo Cliente, Tipo de Tarifa y Vigencia.___';
			END IF;
		END IF;
		
		--str_filas[1]	notr 
		--str_filas[2]	iddet 
		--str_filas[3]	elim
		--str_filas[4]	titulo_rango 
		--str_filas[5]	valor1 
		--str_filas[6]	valor2 
		--str_filas[7]	precio 
        END IF;--Termina Validacion de Tarifario de Venta por RANGO





	/*
	str_data[1] 	app_selected
	str_data[2] 	command_selected
	str_data[3] 	id_usuario
	str_data[4]	id_factura+"___"+
	str_data[5]	id_proveedor+"___"+
	str_data[6]	tipo_factura+"___"+
	str_data[7]	observaciones.toUpperCase()+"___"+
	str_data[8]	factura+"___"+
	str_data[9]	expedicion+"___"+
	str_data[10]	tc+"___"+
	str_data[11]	denominacion+"___"+
	str_data[12]	numeroguia+"___"+
	str_data[13]	ordencompra+"___"+
	str_data[14]	fletera_id+"___"+
	str_data[15]	dias_credito_id+"___"+
	str_data[16]	flete;
	*/
	
	--facturas de proveedores version 2 para Logistik
	IF id_app=196 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id_factura
		--str_data[5]	id_proveedor
		--str_data[6]	tipo_factura
		--str_data[7]	observaciones
		--str_data[8]	factura
		--str_data[9]	expedicion
		--str_data[10]	tc
		--str_data[11]	denominacion
		--str_data[12]	numeroguia
		--str_data[13]	ordencompra
		--str_data[14]	fletera_id
		--str_data[15]	dias_credito_id
		--str_data[16]	flete
		
		if trim(str_data[2])<>'cancelar' then 
			--Aqui solo debe entrar cuando es new y edit
			
			--id_proveedor	str_data[5] id_proveedor
			IF trim(str_data[5]) = '' THEN
				valor_retorno := ''||valor_retorno||'noproveedor:Es necesario seleccionar un proveedor___';
			END IF;
			/*
			--factura	str_data[8]
			EXECUTE 'select mask_regex from erp_mascaras_para_validaciones_por_app where app_id='||id_app||' and mask_name ilike ''is_FacturaCorrect'';' INTO mask_general;
			EXECUTE 'select '''||str_data[8]||''' ~ '''||mask_general||''';' INTO match_cadena;
			IF match_cadena = false THEN
				valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
			END IF;
			*/
			--factura	str_data[8] expedicion
			IF trim(str_filas[8])='' THEN
				valor_retorno := ''||valor_retorno||'factura:Numero de factura no valido___';
			END IF;
			/*
			--expedicion	str_data[9] expedicion
			IF str_filas[9] = ' ' OR str_data[9] = '' THEN
				valor_retorno := ''||valor_retorno||'expedicion:Es necesario seleccionar una fecha___';
			END IF;
			*/
			
			--denominacion	str_data[11] denominacion
			IF str_data[11]::integer = 0 THEN
				valor_retorno := ''||valor_retorno||'denominacion:Es necesario seleccionar una moneda___';
			END IF;
			
			--tipo cambio	str_data[10] tc
			IF trim(str_filas[10])='' THEN
				valor_retorno := ''||valor_retorno||'tc:Es necesario ingresar el tipo de cambio___';
			END IF;
			
			--observaciones	str_data[12]
			/*
			--str_data[14] fletera
			IF str_data[14] = '' THEN
				valor_retorno := ''||valor_retorno||'fletera:Es necesario seleccionar una compa√±ia___';
			END IF;
			*/
			--str_data[16] flete
			
			
			IF str_data[4] ='0' THEN
				IF trim(str_data[8])<>'' THEN
					IF str_data[5] !='' THEN
						valida_integridad:=0;
						EXECUTE 'SELECT count(id) FROM cxp_facturas WHERE  cxc_prov_id='||str_data[5]||' AND serie_folio ilike '''||str_data[8]||''' AND empresa_id='||emp_id||';' INTO valida_integridad;
						IF valida_integridad > 0 THEN
							valor_retorno := ''||valor_retorno||'factura:La Factura ya se encuentra registrada___';
						END IF;
					END IF;
				END IF;
			END IF;
			
			total_filas:= array_length(arreglo,1);
			cont_fila:=1;
			IF trim(arreglo[1])<>'sin datos' THEN
				
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(arreglo[cont_fila],'___');
					--str_filas[1]	eliminado[i]
					--str_filas[2]	det_id[i]
					--str_filas[3]	prod_id[i]
					--str_filas[4]	pres_id[i]
					--str_filas[5]	cantidad[i]
					--str_filas[6]	costo[i]
					--str_filas[7]	select_iva[i]
					--str_filas[8]	iva_tasa[i]
					--str_filas[9]	select_ieps[i]
					--str_filas[10]	ieps_tasa[i]
					--str_filas[11]	ret_id[i]
					--str_filas[12]	ret_tasa[i]
					--str_filas[13]	no_tr
					
					--eliminado	str_filas[1]
					IF str_filas[1]::integer <> 0 THEN--1: no esta eliminado, 0:eliminado
						
						--cantidad 		str_filas[5]
						IF trim(str_filas[5])='' THEN
							valor_retorno := ''||valor_retorno||'cantidad'||str_filas[13]||':Es necesario ingresar la cantidad___';
						ELSE
							IF str_filas[5]::double precision < 0.000001  THEN
								valor_retorno := ''||valor_retorno||'cantidad'||str_filas[13]||':La cantidad debe ser mayor que cero___';
							END IF;
						END IF;
						
						--costo		str_filas[6]
						IF trim(str_filas[6])='' THEN
							valor_retorno := ''||valor_retorno||'costo'||str_filas[13]||':Es necesario ingresar el costo___';
						ELSE
							IF str_filas[6]::double precision < 0.000001  THEN
								valor_retorno := ''||valor_retorno||'costo'||str_filas[13]||':El costo debe ser mayor que cero___';
							END IF;
						END IF;
						
						--impuesto_id	str_filas[7]
						--valor_imp	str_filas[8]
						--eliminado	str_filas[9]
						--ieps_id	str_filas[10]
						--tasa_ieps	str_filas[11]
					END IF;
					
				END LOOP;
				
			END IF;
		else
			if trim(str_data[2])='cancelar' then 
				serie_folio_fac:='';
				tiene_pagos:=0;

				select serie_folio from cxp_facturas where id=str_data[4]::integer and cxc_prov_id=str_data[5]::integer into serie_folio_fac;

				if serie_folio_fac is null then serie_folio_fac:=''; end if;

				--Verificar si la factura tiene pagos registrados	
				select count(cxp_pagos.id) as tiene_pagos 
				from cxp_pagos 
				join cxp_pagos_detalles on (cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id and cxp_pagos_detalles.serie_folio=serie_folio_fac and cxp_pagos_detalles.cancelacion=false)
				where cxp_pagos.cxp_prov_id=str_data[5]::integer and cxp_pagos.cancelacion=false 
				into tiene_pagos;
				
				if tiene_pagos>0 then 
					valor_retorno := ''||valor_retorno||'cancelacion:No es posible cancelar la Factura '|| serie_folio_fac ||' porque tiene pagos aplicados.___';
				end if;
				
				--inicializar variable
				tiene_pagos:=0;
				
				--Verificar si no tiene notas de credito aplicadas
				select count(cxp_nota_credito.id) as tiene_nc 
				from cxp_nota_credito 
				where cxp_nota_credito.cxp_prov_id=str_data[5]::integer and cxp_nota_credito.factura=serie_folio_fac and cxp_nota_credito.cancelado=false 
				into tiene_pagos;
				
				if tiene_pagos>0 then 
					valor_retorno := ''||valor_retorno||'cancelacion:No es posible cancelar la Factura '|| serie_folio_fac ||' porque tiene Notas de Credito aplicados.___';
				end if;
				
			end if;
		end if;
	END IF;
	--Termina Validacion para Facturas de Provedores version 2 para Logistik



	--Validacion de Entradas al Almacen(LOG)
        IF id_app=197 THEN
		--str_data[1]   app_selected
		--str_data[2]   command_selected
		--str_data[3]   id_usuario
		--str_data[4]   id_emp
		--str_data[5]   select_sucursal
		--str_data[6]   id_cliente
		--str_data[7]   observaciones
		--str_data[8]   select_almacen
		--str_data[9]   fecha
		--str_data[10]   select_tipo_dist
		--str_data[11]   ident_uni
		--str_data[12]   select_tipo_unidad
		--str_data[13]   id_ruta
		--str_data[14]   costo_ruta
		
		--select_sucursal
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'idsuc:Es necesario la Sucursal.___';
		else
			IF str_data[5]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'idsuc:Seleccionar Sucursal.___';
			end if;
		END IF;
		
		--id_cliente
		IF trim(str_data[6])='' THEN
			valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
		else
			IF str_data[6]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'nocliente:Es necesario seleccionar un Cliente.___';
			end if;
		END IF;

		--select_almacen
		IF trim(str_data[8])='' THEN
			valor_retorno := ''||valor_retorno||'almacen:Es necesario el Almacen.___';
		else
			IF str_data[8]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'almacen:Es necesario seleccionar un Almacen.___';
			end if;
		END IF;

		--fecha
		IF trim(str_data[9])='' THEN
			valor_retorno := ''||valor_retorno||'fecha:Es necesario ingresar la Fecha.___';
		END IF;

		--select_tipo_dist
		IF trim(str_data[8])='' THEN
			valor_retorno := ''||valor_retorno||'tdist:Es necesario el Tipo de viaje.___';
		else
			IF str_data[8]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'tdist:Es necesario seleccionar el Tipo de viaje.___';
			end if;
		END IF;

		
		--ident_uni
		IF trim(str_data[11])='' THEN
			valor_retorno := ''||valor_retorno||'idvehiculo:Es necesario seleccionar la Unidad de Transporte.___';
		else
			IF str_data[11]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'idvehiculo:Es necesario seleccionar la Unidad de Transporte.___';
			end if;
		END IF;

		--select_tipo_unidad
		IF trim(str_data[12])='' THEN
			valor_retorno := ''||valor_retorno||'tipounidad:Es necesario el Tipo de Unidad.___';
		else
			IF str_data[12]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'tipounidad:Es necesario seleccionar el Tipo de Unidad.___';
			end if;
		END IF;

		--id_ruta
		IF trim(str_data[13])='' THEN
			valor_retorno := ''||valor_retorno||'noruta:Es necesario seleccionar la Ruta.___';
		else
			IF str_data[13]::integer<=0 THEN
				valor_retorno := ''||valor_retorno||'noruta:Es necesario seleccionar la Ruta.___';
			end if;
		END IF;

		--costo_ruta
		IF trim(str_data[14])='' THEN
			valor_retorno := ''||valor_retorno||'costoruta:Es necesario el Costo de la Ruta.___';
		else
			IF str_data[14]::double precision<=0 THEN
				valor_retorno := ''||valor_retorno||'costoruta:El Costo de la Ruta debe ser mayor a cero.___';
			end if;
		END IF;
        END IF;--Termina Validacion de Entradas al Almacen(LOG)


        
        IF id_app=203 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	nombre
		--str_data[6]	select_fecha
		--str_data[7]	select_pol_num
		--str_data[8]	select_tipo

		--Nombre del asiento
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombre:Es necesario ingresar el Nombre del Asiento.___';
		END IF;
        end if;


	--Validacion de Catalogo de IVA Trasladado
        IF id_app=204 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	tasa
		--str_data[7]	cta_id

		--Titulo del Impuesto
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Impuesto.___';
		END IF;

		--Tasa del Impuesto
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'tasa:Es necesario ingresar la Tasa del Impuesto.___';
		END IF;

		if incluye_modulo_contabilidad then 
			--Tasa del Impuesto
			IF trim(str_data[7]) = '' THEN
				valor_retorno := ''||valor_retorno||'cta:Es necesario seleccionar la Cuenta Contable para el Impuesto.___';
			else
				if str_data[7]::integer=0 then 
					valor_retorno := ''||valor_retorno||'cta:Es necesario seleccionar la Cuenta Contable para el Impuesto.___';
				end if;
			END IF;
		end if;
		
        end if;
        --Termina Validacion de Catalogo de IVA Trasladado





	--Validacion de Catalogo de IVA Retenido
        IF id_app=205 THEN
		--str_data[4]	id
		--str_data[5]	titulo
		--str_data[6]	tasa
		--str_data[7]	cta_id

		--Titulo del Impuesto
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Es necesario ingresar el Titulo del Impuesto.___';
		END IF;

		--Tasa del Impuesto
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'tasa:Es necesario ingresar la Tasa del Impuesto.___';
		END IF;

		if incluye_modulo_contabilidad then 
			--Tasa del Impuesto
			IF trim(str_data[7]) = '' THEN
				valor_retorno := ''||valor_retorno||'cta:Es necesario seleccionar la Cuenta Contable para el Impuesto.___';
			else
				if str_data[7]::integer=0 then 
					valor_retorno := ''||valor_retorno||'cta:Es necesario seleccionar la Cuenta Contable para el Impuesto.___';
				end if;
			END IF;
		end if;
		
        end if;
        --Termina Validacion de Catalogo de IVA Retenido



        
	--Validacion Aplicativo de Registro de Proyectos(CRM)
        IF id_app=207 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	nombre
		--str_data[6]	descripcion
		--str_data[7]	select_agente
		--str_data[8]	id_contacto
		--str_data[9]	id_prov
		--str_data[10]	fecha_inicio
		--str_data[11]	fecha_fin
		--str_data[12]	select_estatus
		--str_data[13]	select_prioridad
		--str_data[14]	select_muestra
		--str_data[15]	observaciones
		
		--Nombre del proyecto
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'nombre:Ingresar el Nombre &oacute; Titulo del Proyecto.___';
		END IF;

		--descripcion
		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'descripcion:Debe ingresar la Descripci&oacute;n del Proyecto.___';
		END IF;

		--select_agente
		if str_data[7]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'agente:Seleccione un Agente de Ventas.___';
		end if;
		
		--id_contacto
		if str_data[8]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'contacto:Seleccione un Contacto.___';
		end if;
		/*
		--id_prov
		if str_data[9]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'proveedor:Seleccione un Proveedor.___';
		end if;
		*/

		--str_data[12]	select_estatus
		if str_data[12]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'estatus:Asigne un Estatus.___';
		end if;
		
		--str_data[13]	select_prioridad
		if str_data[13]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'prioridad:Asigne una Prioridad.___';
		end if;
		
		--str_data[14]	select_muestra
		if str_data[14]::integer<=0 then 
			valor_retorno := ''||valor_retorno||'muestra:Asigne una Muestra.___';
		end if;

		if (select count(id) from crm_registro_proyecto where lower(trim(titulo))=lower(trim(str_data[5])))>0 then 
			if str_data[4]::integer >0 then 
				select id from crm_registro_proyecto where lower(trim(titulo))=lower(trim(str_data[5])) limit 1 into id_registro;
				--Verificar si el registro que se encontr√≥ no es el mismo que se est√° actualizando
				if id_registro<>str_data[4]::integer then 
					valor_retorno := ''||valor_retorno||'nombre:El Nombre o Titulo del Proyecto ya se encuentra registrado.___';
				end if;
			else
				valor_retorno := ''||valor_retorno||'nombre:El Nombre o Titulo del Proyecto ya se encuentra registrado.___';
			end if;
			
		end if;
		
        end if;
        --Termina Validacion de Catalogo de Registro de Proyectos(CRM)
	
	
	--Validacion Aplicativo Tipos de Seguimiento de Visitas
        IF id_app=208 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	titulo
		
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Ingresar Titulo del Tipo de Seguimiento de Visitas.___';
		END IF;
		
		if (select count(id) from crm_tipos_seguimiento_visita where lower(trim(titulo))=lower(trim(str_data[5])))>0 then 
			if str_data[4]::integer >0 then 
				select id from crm_tipos_seguimiento_visita where lower(trim(titulo))=lower(trim(str_data[5])) limit 1 into id_registro;
				--Verificar si el registro que se encontr√≥ no es el mismo que se est√° actualizando
				if id_registro<>str_data[4]::integer then 
					valor_retorno := ''||valor_retorno||'titulo:El Titulo del Tipo de Seguimiento de Visita ya se encuentra registrado.___';
				end if;
			else
				valor_retorno := ''||valor_retorno||'titulo:El Titulo del Tipo de Seguimiento de Visita ya se encuentra registrado.___';
			end if;
			
		end if;
		
        end if;
        --Termina Validacion de Catalogo Tipos de Seguimiento de Visitas


	--Validacion Aplicativo Tipos de Seguimiento de Visitas
        IF id_app=209 THEN
		--str_data[4]	id
		--str_data[5]	clave
		--str_data[6]	titulo
		
		IF trim(str_data[5]) = '' THEN
			valor_retorno := ''||valor_retorno||'clave:Ingresar Clave.___';
		END IF;

		IF trim(str_data[6]) = '' THEN
			valor_retorno := ''||valor_retorno||'titulo:Ingresar Titulo.___';
		END IF;

		if (select count(id) from fac_metodos_pago where lower(trim(clave_sat))=lower(trim(str_data[5])) and borrado_logico=false and gral_emp_id=emp_id)>0 then 
			if str_data[4]::integer >0 then 
				select id from fac_metodos_pago where lower(trim(clave_sat))=lower(trim(str_data[5])) and borrado_logico=false and gral_emp_id=emp_id limit 1 into id_registro;
				
				--Verificar si el registro que se encontr√≥ no es el mismo que se est√° actualizando
				if id_registro<>str_data[4]::integer then 
					valor_retorno := ''||valor_retorno||'clave:La Clave del SAT ya se encuentra registrado.___';
				end if;
			else
				valor_retorno := ''||valor_retorno||'clave:La Clave del SAT ya se encuentra registrado.___';
			end if;
		end if;
		
		if (select count(id) from fac_metodos_pago where lower(trim(titulo))=lower(trim(str_data[6])) and borrado_logico=false and gral_emp_id=emp_id)>0 then 
			if str_data[4]::integer >0 then 
				select id from fac_metodos_pago where lower(trim(titulo))=lower(trim(str_data[6])) and borrado_logico=false and gral_emp_id=emp_id limit 1 into id_registro;
				
				--Verificar si el registro que se encontr√≥ no es el mismo que se est√° actualizando
				if id_registro<>str_data[4]::integer then 
					valor_retorno := ''||valor_retorno||'titulo:El Titulo del Metodo de Pago ya se encuentra registrado.___';
				end if;
			else
				valor_retorno := ''||valor_retorno||'titulo:El Titulo del Metodo de Pago ya se encuentra registrado.___';
			end if;
		end if;
		
        end if;
        --Termina Validacion de Catalogo Tipos de Seguimiento de Visitas










	
	
	IF valor_retorno = '' THEN
		valor_retorno := 'true';
		RETURN valor_retorno;
	ELSE
		RETURN valor_retorno;
	END IF;
	
END;

$_$;


--
-- Name: fac_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.fac_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$


DECLARE
	str_data text[];
	str_filas text[];
	--Total de elementos de arreglo
	total_filas integer;
	--Contador de filas o posiciones del arreglo
	cont_fila integer;
	--Estas  se utilizan para la nomina
	str_percep text[];
	str_deduc text[];
	str_hrs_extras text[];
	str_incapa text[];
	refId character varying:='';
	
	valor_retorno character varying = '';
	ultimo_id integer:=0;
	ultimo_id_det integer:=0;
	id_tipo_consecutivo integer=0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
	ultimo_id_proceso integer =0;

	tipo_de_documento integer =0;
	fila_fac_rem_doc record;
	
	app_selected integer;
	command_selected text;
	usuario_ejecutor integer:=0;
	emp_id integer:=0;
	suc_id integer:=0;
	suc_id_consecutivo integer:=0; --sucursal de donde se tomara el consecutivo
	id_almacen integer;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer:=0;
	mes_actual integer:=0;
	factura_fila record;
	prefactura_fila record;
	prefactura_detalle record;
	factura_detalle record;
	formulacion record;
	tiene_pagos integer:=0;
	identificador_nuevo_movimiento integer;
	tipo_movimiento_id integer:=0;
	exis integer:=0;
	sql_insert text;
	sql_update text;
	sql_select text;
	sql_select2 character varying:='';
	cantidad_porcentaje double precision:=0;
	id_proceso integer;
	bandera_tipo_4 boolean;--bandera que identifica si el producto es tipo 4, true=tipo 4, false=No es tipo4
	serie_folio_fac character varying:='';
	refact character varying :='';
	tipo_cam double precision := 0;
	
	numero_dias_credito integer:=0;
	fecha_de_vencimiento timestamp with time zone;
	
	importe_del_descto_partida double precision := 0;
	importe_partida_con_descto double precision := 0;
	suma_descuento double precision := 0;
	suma_subtotal_con_descuento double precision := 0;
	
	importe_partida double precision := 0;
	importe_ieps_partida double precision := 0;
	impuesto_partida double precision := 0;
	monto_subtotal double precision := 0;
	suma_ieps double precision := 0;
	suma_total double precision := 0;
	monto_impuesto double precision := 0;
	total_retencion double precision := 0;
	retener_iva boolean := false;
	tasa_retencion double precision := 0;
	retencion_partida double precision := 0;
	suma_retencion_de_partidas double precision := 0;
	suma_retencion_de_partidas_globlal double precision:= 0;
	
	--Estas variables se utilizan en caso de que se facture un pedido en otra moneda
	suma_descuento_global double precision := 0;
	suma_subtotal_con_descuento_global double precision := 0;
	monto_subtotal_global double precision := 0;
	suma_ieps_global double precision := 0;
	monto_impuesto_global double precision := 0;
	total_retencion_global double precision := 0;
	suma_total_global double precision := 0;
	cant_original double precision := 0;
	
	serie_folio_nota_credito  character varying:='';
	fecha_nota_credito timestamp with time zone;
	concepto_nota_credito character varying:='';
	aplicativo_id integer := 0; --aqui se guarda el id del aplicativo que genero la nota de credito
	
	total_factura double precision;
	id_moneda_factura integer:=0;
	suma_pagos double precision:=0;
	suma_notas_credito double precision:=0;
	nuevacantidad_monto_pago double precision:=0;
	nuevo_saldo_factura double precision:=0;
	
	costo_promedio_actual double precision:=0;
	costo_referencia_actual double precision:=0;
	
	id_osal integer := 0;
	nuevo_folio_osal character varying:='';
	fila record;
	fila_detalle record;
	facpar record;--parametros de Facturacion
	
	id_df integer:=0;--id de la direccion fiscal
	result character varying:='';

	noDecUnidad integer:=0;--numero de decimales permitidos para la unidad
	exisActualPres double precision:=0;--existencia actual de la presentacion
	equivalenciaPres double precision:=0; --equivalencia de la presentacion en la unidad del producto
	cantPres double precision:=0; --Cantidad que se esta Intentando traspasar
	cantPresAsignado double precision:=0;
	cantPresReservAnterior double precision:=0;
	
	controlExisPres boolean; --Variable que indica  si se debe controlar Existencias por Presentacion
	partida_facturada boolean;--Variable que indica si la cantidad de la partida ya fue facturada en su totalidad
	actualizar_proceso boolean; --Indica si hay que actualizar el flujo del proceso. El proceso se debe actualizar cuando ya no quede partidas vivas
	id_pedido integer;--Id del Pedido que se esta facturando
	--Id de la unidad de medida del producto
	idUnidadMedida integer:=0;
	--Nombre de la unidad de medida del producto
	nombreUnidadMedida character varying:=0;
	--Densidad del producto
	densidadProd double precision:=0;
	--Cantidad en la unidad del producto
	cantUnidadProd double precision:=0;
	--Id de la unidad de Medida de la Venta
	idUnidadMedidaVenta integer:=0;
	--Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantUnidadVenta double precision:=0;
	--Cantidad de la existencia convertida a la unidad de venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantExisUnidadVenta double precision:=0;
	match_cadena boolean:=false;
	
	--Numero de Adenda
	idAdenda integer:=0;
	moneda_iso_4217 character varying:='';
	valor_campo1 character varying:='';
	id2 integer:=0;
BEGIN
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- aplicativo que manda a llamar este procedimiento almacenado
	app_selected := str_data[1]::integer;
	
	-- comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	-- usuario que utiliza el aplicativo
	usuario_ejecutor := str_data[3]::integer;
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--obtener id de empresa, sucursal
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id
  	FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	INTO emp_id, suc_id;
	
	--Obtener parametros para la facturacion
	SELECT * FROM fac_par WHERE gral_suc_id=suc_id INTO facpar;
	
	--tomar el id del almacen para ventas
	id_almacen := facpar.inv_alm_id;
	
	--√©ste consecutivo es para el folio de Remisi√≥n y folio para BackOrder(poc_ped_bo)
	suc_id_consecutivo := facpar.gral_suc_id_consecutivo;

	--query para verificar si la Empresa actual incluye Modulo de Produccion y control de Existencias por Presentacion
	SELECT control_exis_pres FROM gral_emp WHERE id=emp_id INTO controlExisPres;
	
	--Inicializar en cero
	id_pedido:=0;
	
	--RAISE EXCEPTION '%','app_selected: '||app_selected;
	-- Prefacturas(Facturacion)
	IF app_selected = 13 THEN
		
		--Aqui entra al guardar datos de remisiones  antes de facturarlas
		IF command_selected = 'new' THEN
			--str_data[4]	id_prefactura
			--str_data[5]	id_cliente
			--str_data[6]	id_moneda
			--str_data[7]	observaciones
			--str_data[8]	tipo_cambio_vista
			--str_data[9]	id_vendedor
			--str_data[10]	id_condiciones
			--str_data[11]	orden_compra
			--str_data[12]	refacturar
			--str_data[13]	id_metodo_pago
			--str_data[14]	no_cuenta
			--str_data[15]	select_tipo_documento
			--str_data[16]	folio_pedido
			--str_data[17]	select_almacen
			--str_data[18]	id_moneda_original
			--str_data[19]	id_df
			
			--str_data[20]	NoEntrada
			--str_data[21]	NoRemision
			--str_data[22]	Consignacion
			--str_data[23]  CentroCostos
			--str_data[24]	FechaInicio
			--str_data[25]  FechaFin
			--str_data[26]  Orden Compra
			--str_data[27]  Moneda
			
			--str_data[28]  rfc
			--str_data[29]  permitir_descto
			--str_data[30]  select_tmov
			
			--crea registro en tabla erp_proceso y retorna el id del registro creado. El flujo del proceso es 2=Facturacion
			INSERT INTO  erp_proceso(proceso_flujo_id,empresa_id,sucursal_id)VALUES(2, emp_id, suc_id) RETURNING id into ultimo_id_proceso;
			
			INSERT INTO erp_prefacturas(
				cliente_id,--str_data[5]::integer,
				moneda_id, --str_data[6]::integer,
				observaciones, --str_data[7]::text,
				tipo_cambio,--str_data[8]::double precision,
				empleado_id,--str_data[9]::integer,
				terminos_id,--str_data[10]::integer,
				orden_compra,--str_data[11],
				refacturar,--str_data[12]::boolean,
				fac_metodos_pago_id,--str_data[13]::integer,
				no_cuenta,--str_data[14]::character varying,
				tipo_documento,--str_data[15]::smallint,
				folio_pedido,--str_data[16],
				inv_alm_id,--str_data[17]::smallint,
				cxc_clie_df_id,--str_data[19]::integer,
				ctb_tmov_id,--str_data[30]::integer,
				tasa_retencion_immex,--0,
				subtotal,--0,
				impuesto,--0,
				monto_retencion,--0,
				total,--0,
				proceso_id,--ultimo_id_proceso,
				borrado_logico,--false,
				momento_creacion,--espacio_tiempo_ejecucion,
				id_usuario_creacion,--usuario_ejecutor
				monto_ieps--0
			)VALUES(str_data[5]::integer, str_data[6]::integer, str_data[7]::text, str_data[8]::double precision, str_data[9]::integer, str_data[10]::integer, str_data[11], str_data[12]::boolean, str_data[13]::integer, str_data[14]::character varying, str_data[15]::smallint, str_data[16], str_data[17]::smallint, str_data[19]::integer, str_data[30]::integer, 0, 0, 0, 0, 0, ultimo_id_proceso, false, espacio_tiempo_ejecucion, usuario_ejecutor, 0)
			RETURNING id INTO ultimo_id;
			
			
			
			
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			--Inicia gaurdar datos para la Adenda
			--Primero se verifica si en los parametros indica que se debe incluir la Adenda
			IF facpar.incluye_adenda THEN 
				--Verificar que exista un id de cliente valido
				IF str_data[5]::integer > 1 THEN 
					--Buscar el numero de Adenda asignado al cliente.
					SELECT cxc_clie_tipo_adenda_id FROM cxc_clie WHERE id=str_data[5]::integer INTO idAdenda;
					
					--Varificar si tiene adenda asignada
					IF idAdenda > 0 THEN 
						--Verificar el numero de adenda
						--Addenda FEMSA-QUIMIPRODUCTOS
						IF idAdenda=1 THEN 
							--Si el numero de Adenda es 1, entonces solo debe se debe validar datos cuando el tipo de documento es igual a 3.
							--Tipo Documento 3=Factura de Remision
							IF str_data[15]::integer=3 THEN 
								INSERT INTO fac_docs_adenda(
									prefactura_id,--ultimo_id, 
									fac_docs_id,--0, 
									cxc_clie_adenda_tipo_id,--idAdenda, 
									valor1, --str_data[20],
									valor2,--str_data[21], 
									valor3,--str_data[22], 
									valor4,--str_data[23], 
									valor5,--str_data[24], 
									valor6,--str_data[25], 
									valor7,--str_data[26], 
									valor8--str_data[27]
								)
								VALUES(ultimo_id, 0, idAdenda, str_data[20], str_data[21], str_data[22], str_data[23], str_data[24], str_data[25], str_data[26], str_data[27]);
							END IF;
						END IF;
						--Termina Addenda FEMSA-QUIMIPRODUCTOS

						--Addenda SUN CHEMICAL
						IF idAdenda=2 THEN 
							--Tipo Documento 3=Factura de Remision
							IF str_data[15]::integer=3 THEN 
								INSERT INTO fac_docs_adenda(prefactura_id, fac_docs_id, cxc_clie_adenda_tipo_id, valor1)
								VALUES(ultimo_id, 0, idAdenda, str_data[11]);
							END IF;
						END IF;
						--Termina Addenda SUN CHEMICAL
					END IF;
				END IF;
			END IF;
			--Termina Guardar datos Adenda
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			
			
			suma_retencion_de_partidas:=0;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				retencion_partida:=0;
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer <> 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					--str_filas[8]	valor_impuesto
					--str_filas[9]	id_remision
					--str_filas[10]	costo_promedio
					--str_filas[11]	idUnidad
					--str_filas[12]	id_ieps
					--str_filas[13]	tasa_ieps
					--str_filas[14]	vdescto
					--str_filas[15]	retencion_id
					--str_filas[16]	retencion_tasa
					
					IF str_filas[13]::double precision>0 THEN 
						str_filas[13]:=str_filas[13]::double precision/100;
					END IF;

					--Tasa retencion de la partida
					IF str_filas[16]::double precision>0 THEN 
						str_filas[16]:=str_filas[16]::double precision/100;
					END IF;
					
					--Obtener el costo referencia de la partida de la remision
					SELECT costo_referencia FROM fac_rems_detalles WHERE fac_rems_id=str_filas[9]::integer AND inv_prod_id=str_filas[3]::integer AND inv_prod_presentacion_id=str_filas[4]::integer 
					INTO costo_referencia_actual;
					
					--Verificar que no tenga valor null
					IF costo_referencia_actual IS NULL OR costo_referencia_actual<=0 THEN costo_referencia_actual:=0; END IF;
					
					--Crear registros en erp_prefacturas_detalles
					INSERT INTO erp_prefacturas_detalles(prefacturas_id,producto_id,presentacion_id,tipo_impuesto_id, cantidad, cant_facturar, precio_unitario, valor_imp, costo_promedio, costo_referencia, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, gral_imptos_ret_id, tasa_ret)
					VALUES(ultimo_id, str_filas[3]::integer, str_filas[4]::integer, str_filas[5]::integer, str_filas[6]::double precision, str_filas[6]::double precision, str_filas[7]::double precision, str_filas[8]::double precision, str_filas[10]::double precision, costo_referencia_actual, str_filas[11]::integer, str_filas[12]::integer, str_filas[13]::double precision, str_filas[14]::double precision, str_filas[15]::integer, str_filas[16]::double precision);
					
					--Calcular y Redondear el importe de la partida
					importe_partida := round((str_filas[6]::double precision * str_filas[7]::double precision)::numeric,4)::double precision;
					
					--Calcular y redondear el IEPS de la partida
					importe_ieps_partida := round((importe_partida::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
					
					--Calcula el IVA de la Partida
					impuesto_partida := round(((importe_partida::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision)::numeric,4)::double precision;
					
					--RAISE EXCEPTION '%','str_data[29]: '||str_data[29]||'     str_filas[14]: '||str_filas[14];

					--Calcular el importe de la retencion de la partida si existe la tasa de retencion
					if str_filas[16]::double precision>0 then 
						retencion_partida := round((importe_partida::double precision * str_filas[16]::double precision)::numeric,4)::double precision;
					end if;
					
					IF lower(trim(str_data[29]))='true' THEN
						IF str_filas[14]::double precision>0 THEN
							importe_del_descto_partida = round((importe_partida * (str_filas[14]::double precision/100))::numeric,4)::double precision;

							importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
							
							--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
							importe_ieps_partida := round((importe_partida_con_descto::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
							
							--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
							impuesto_partida := round(((importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision)::numeric,4)::double precision;

							--Reclacular el nuevo el importe de la retencion de la partida si existe la tasa de retencion
							if str_filas[16]::double precision>0 then 
								retencion_partida := round((importe_partida_con_descto::double precision * str_filas[16]::double precision)::numeric,4)::double precision;
							end if;
						END IF;
					END IF;
					
					suma_descuento = suma_descuento + importe_del_descto_partida::double precision;
					suma_subtotal_con_descuento = suma_subtotal_con_descuento + importe_partida_con_descto::double precision;
					
					monto_subtotal := monto_subtotal + importe_partida::double precision;
					suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
					monto_impuesto := monto_impuesto + impuesto_partida::double precision;
					suma_retencion_de_partidas := suma_retencion_de_partidas + retencion_partida::double precision;
					
					--Busca la remision si ya esta en la tabla 
					SELECT count(fac_rem_id) FROM fac_rems_docs WHERE fac_rem_id=str_filas[9]::integer INTO exis;
					
					IF exis <= 0 THEN
						INSERT INTO fac_rems_docs(fac_rem_id, erp_proceso_id)VALUES(str_filas[9]::integer, ultimo_id_proceso);
					END IF;
					/*
					INSERT INTO fac_rem_doc_det(fac_doc_id, fac_rem_id, fac_doc_det_id,fac_rem_det_id)
					VALUES(0, str_filas[9]::integer, 0, str_filas[2]::integer);
					*/
				END IF;
			END LOOP;
			
			--verificar si hay que retener iva para este cliente
			SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex/100 end FROM cxc_clie WHERE id=str_data[5]::integer INTO retener_iva, tasa_retencion;

			--RAISE EXCEPTION '%','str_data[29]: '||str_data[29]||'     suma_descuento: '||suma_descuento;
			
			IF lower(trim(str_data[29]))='true' AND suma_descuento>0 THEN
				IF retener_iva=true THEN
					total_retencion := suma_subtotal_con_descuento::double precision * tasa_retencion;
				ELSE
					total_retencion :=0;
				END IF;

				if suma_retencion_de_partidas > 0 then 
					total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
				end if;

				--Calcula el monto de la prefactura
				suma_total:= suma_subtotal_con_descuento::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
				
				--Actualiza campos subtotal, impuesto, retencion, total de tabla erp_prefacturas
				UPDATE erp_prefacturas SET 
					subtotal=suma_subtotal_con_descuento, 
					monto_ieps=suma_ieps, 
					impuesto=monto_impuesto, 
					monto_retencion=total_retencion, 
					total=suma_total, 
					--fac_subtotal=suma_subtotal_con_descuento, 
					--fac_monto_ieps=suma_ieps,
					--fac_impuesto=monto_impuesto, 
					--fac_monto_retencion=total_retencion, 
					--fac_total=suma_total, 
					tasa_retencion_immex=tasa_retencion,
					--fac_monto_descto=suma_descuento 
					monto_descto=suma_descuento 
				WHERE id=ultimo_id;
			ELSE
				IF retener_iva=true THEN
					total_retencion := monto_subtotal::double precision * tasa_retencion;
				ELSE
					total_retencion :=0;
				END IF;

				if suma_retencion_de_partidas > 0 then 
					total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
				end if;
				
				--Calcula el monto de la prefactura
				suma_total:= monto_subtotal::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
				
				--Actualiza campos subtotal, impuesto, retencion, total de tabla erp_prefacturas
				UPDATE erp_prefacturas SET 
					subtotal=monto_subtotal, 
					monto_ieps=suma_ieps, 
					impuesto=monto_impuesto, 
					monto_retencion=total_retencion, 
					total=suma_total, 
					--fac_subtotal=monto_subtotal, 
					--fac_monto_ieps=suma_ieps,
					--fac_impuesto=monto_impuesto, 
					--fac_monto_retencion=total_retencion, 
					--fac_total=suma_total, 
					tasa_retencion_immex=tasa_retencion, 
					fac_monto_descto=0,
					monto_descto=0 
				WHERE id=ultimo_id;
			END IF;
			
			valor_retorno := '1:'||nuevo_folio;
		END IF;--termina nueva prefactura
		
		
		
		
		--Aqui entra antes de generar Remision y Factura
		IF command_selected = 'actualizar' THEN
			/*
			Aqu√≠ se actualizan los datos de la PREFACTURA, esto es antes de facturar, terminando este proceso se genera la FACTURA
			Solo se actualizan los datos del header de la prefactura, lo datos del grid se deja  como viene del pedido
			*/
			--str_data[3]	id_usuario
			--str_data[4]	id_prefactura
			--str_data[5]	id_cliente
			--str_data[6]	id_moneda
			--str_data[7]	observaciones
			--str_data[8]	tipo_cambio_vista
			--str_data[9]	id_vendedor
			--str_data[10]	id_condiciones
			--str_data[11]	orden_compra
			--str_data[12]	refacturar
			--str_data[13]	id_metodo_pago
			--str_data[14]	no_cuenta
			--str_data[15]	select_tipo_documento
			--str_data[16]	folio_pedido
			--str_data[17]	select_almacen
			--str_data[18]	id_moneda_original
			
			--Actualizar tabla erp_prefacturas
			UPDATE erp_prefacturas SET moneda_id=str_data[6]::integer, observaciones=str_data[7], tipo_cambio=str_data[8]::double precision, empleado_id=str_data[9]::integer, terminos_id=str_data[10]::integer, orden_compra=str_data[11], refacturar=str_data[12]::boolean, fac_metodos_pago_id=str_data[13]::integer, no_cuenta=str_data[14], tipo_documento=str_data[15]::integer, id_moneda_pedido=str_data[18]::integer, id_usuario_actualizacion=usuario_ejecutor, momento_actualizacion=espacio_tiempo_ejecucion
			WHERE id = str_data[4]::integer;

			suma_descuento:=0;
			suma_subtotal_con_descuento:=0;
			suma_retencion_de_partidas:=0;
			
			--Verificar si la moneda del Pedido es diferente a la moneda de la Prefactura
			IF str_data[6]::integer <> str_data[18]::integer THEN
				--eliminar los registros de erp_prefacturas_detalles
				--delete from erp_prefacturas_detalles where prefacturas_id=str_data[4]::integer;

				--Inicializar variables
				monto_subtotal_global:=0;
				monto_impuesto_global:=0;
				total_retencion_global:=0;
				suma_total_global:=0;
				suma_ieps_global:=0;
				suma_descuento_global = 0;
				suma_subtotal_con_descuento_global = 0;
				
				--si es diferente hay que actualizar los registros de prefacturas detalles
				--Esto es para que se conserve la Moneda seleccionada al momento de Realizar la Facturacion
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					retencion_partida:=0;
					
					--str_filas[1] eliminado
					IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
						--str_filas[2]	iddetalle
						--str_filas[3]	idproducto
						--str_filas[4]	id_presentacion
						--str_filas[5]	id_impuesto
						--str_filas[6]	cantidad
						--str_filas[7]	costo
						--str_filas[8]	valor_impuesto
						--str_filas[9]	id_remision
						--str_filas[10]	costo_promedio
						--str_filas[11]	idUnidad
						--str_filas[12]	id_ieps
						--str_filas[13]	tasa_ieps
						--str_filas[14]	vdescto
						--str_filas[15]	retencion_id
						--str_filas[16]	retencion_tasa
						
						select * from inv_obtiene_costo_promedio_actual(str_filas[3]::integer, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
						
						--Inicializar
						cant_original:=0;

						--Tasa del ieps de la partida
						IF str_filas[13]::double precision>0 THEN 
							str_filas[13]:=str_filas[13]::double precision/100;
						END IF;
						
						--Tasa retencion de la partida
						IF str_filas[16]::double precision>0 THEN 
							str_filas[16]:=str_filas[16]::double precision/100;
						END IF;
						
						--Actualizar los registros en erp_prefacturas_detalles
						UPDATE erp_prefacturas_detalles SET cant_facturar=str_filas[6]::double precision, valor_imp=str_filas[8]::double precision, precio_unitario=str_filas[7]::double precision 
						WHERE id=str_filas[2]::integer 
						RETURNING cantidad INTO cant_original;
						
						IF cant_original IS NULL THEN cant_original:=0; END IF;
						
						--crear registros en erp_prefacturas_detalles
						--INSERT INTO erp_prefacturas_detalles(prefacturas_id, producto_id, presentacion_id, tipo_impuesto_id, cant_facturar, precio_unitario, valor_imp, costo_promedio)
						--VALUES(str_data[4]::integer, str_filas[3]::integer, str_filas[4]::integer, str_filas[5]::integer, str_filas[6]::double precision, str_filas[7]::double precision, str_filas[8]::double precision, costo_promedio_actual);
						
						--Inicializar variables para rautilizar en calculo de totales de lo que se va a facturar
						importe_partida := 0;
						impuesto_partida := 0;
						importe_ieps_partida:=0;
						suma_descuento = 0;
						suma_subtotal_con_descuento = 0;
						
						--Calcular y Redondear el importe de la partida
						importe_partida := round((str_filas[6]::double precision * str_filas[7]::double precision)::numeric,4)::double precision;
						
						--Calcular y redondear el IEPS de la partida
						importe_ieps_partida := round((importe_partida::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
						
						--Calcula el IVA de la Partida
						impuesto_partida := round(((importe_partida::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision)::numeric,4)::double precision;

						--Calcular el importe de la retencion de la partida si existe la tasa de retencion
						if str_filas[16]::double precision>0 then 
							retencion_partida := round((importe_partida::double precision * str_filas[16]::double precision)::numeric,4)::double precision;
						end if;
						
						IF lower(trim(str_data[29]))='true' THEN
							IF str_filas[14]::double precision>0 THEN
								importe_del_descto_partida = round((importe_partida * (str_filas[14]::double precision/100))::numeric,4)::double precision;

								importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
								
								--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
								importe_ieps_partida := round((importe_partida_con_descto::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
								
								--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
								impuesto_partida := round(((importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision)::numeric,4)::double precision;

								--Reclacular el nuevo el importe de la retencion de la partida si existe la tasa de retencion
								if str_filas[16]::double precision>0 then 
									retencion_partida := round((importe_partida_con_descto::double precision * str_filas[16]::double precision)::numeric,4)::double precision;
								end if;
							END IF;
						END IF;
						
						suma_descuento = suma_descuento + importe_del_descto_partida::double precision;
						suma_subtotal_con_descuento = suma_subtotal_con_descuento + importe_partida_con_descto::double precision;

						monto_subtotal := monto_subtotal + importe_partida::double precision;
						suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
						monto_impuesto := monto_impuesto + impuesto_partida::double precision;
						suma_retencion_de_partidas := suma_retencion_de_partidas + retencion_partida::double precision;
						
						
						--Inicializar variables para reutilizar en calculo de totales General
						importe_partida := 0;
						impuesto_partida := 0;
						importe_ieps_partida:=0;
						retencion_partida:=0;
						
						importe_partida := round((cant_original::double precision * str_filas[7]::double precision)::numeric,4)::double precision;
						
						--Calcular y redondear el IEPS de la partida
						importe_ieps_partida := round((importe_partida::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
						
						--Calcula el IVA de la Partida
						impuesto_partida := (importe_partida::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision;
						
						--Calcular el importe de la retencion de la partida si existe la tasa de retencion
						if str_filas[16]::double precision>0 then 
							retencion_partida := round((importe_partida::double precision * str_filas[16]::double precision)::numeric,4)::double precision;
						end if;
						
						IF lower(trim(str_data[29]))='true' THEN
							IF str_filas[14]::double precision>0 THEN
								importe_del_descto_partida = round((importe_partida * (str_filas[14]::double precision/100))::numeric,4)::double precision;

								importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
								
								--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
								importe_ieps_partida := round((importe_partida_con_descto::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
								
								--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
								impuesto_partida := round(((importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision)::numeric,4)::double precision;

								--Calcular el importe de la retencion de la partida si existe la tasa de retencion
								if str_filas[16]::double precision>0 then 
									retencion_partida := round((importe_partida_con_descto::double precision * str_filas[16]::double precision)::numeric,4)::double precision;
								end if;
							END IF;
						END IF;
						
						suma_descuento_global = suma_descuento_global + importe_del_descto_partida::double precision;
						suma_subtotal_con_descuento_global = suma_subtotal_con_descuento_global + importe_partida_con_descto::double precision;
						monto_subtotal_global := monto_subtotal_global + importe_partida::double precision;
						suma_ieps_global := suma_ieps_global + importe_ieps_partida::double precision; 
						monto_impuesto_global := monto_impuesto_global + impuesto_partida::double precision;
						suma_retencion_de_partidas_globlal := suma_retencion_de_partidas_globlal + retencion_partida::double precision;
					END IF;
				END LOOP;
				
				--verificar si hay que retener iva para este cliente
				SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex/100 end FROM cxc_clie WHERE id=str_data[5]::integer INTO retener_iva, tasa_retencion;


				IF lower(trim(str_data[29]))='true' AND suma_descuento>0 THEN
					IF retener_iva=true THEN 
						total_retencion := suma_subtotal_con_descuento * tasa_retencion;
						total_retencion_global := monto_subtotal_global * tasa_retencion;
					ELSE
						total_retencion :=0;
						total_retencion_global :=0;
					END IF;
					
					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					if suma_retencion_de_partidas_globlal > 0 then 
						total_retencion_global := round((total_retencion_global + suma_retencion_de_partidas_globlal)::numeric,4)::double precision;
					end if;
					
					--Calcula el total de lo que se esta facturando
					suma_total:= suma_subtotal_con_descuento + suma_ieps + monto_impuesto - total_retencion::double precision;
					
					--Calcula el total global de la Prefactura
					suma_total_global:= suma_subtotal_con_descuento_global + suma_ieps_global + monto_impuesto_global - total_retencion_global::double precision;
					
					--Actualiza campos subtotal, monto_ieps, impuesto, retencion, total de tabla erp_prefacturas
					UPDATE erp_prefacturas SET subtotal=suma_subtotal_con_descuento_global, monto_ieps=suma_ieps_global, impuesto=monto_impuesto_global, monto_retencion=total_retencion_global, total=suma_total_global, monto_descto=suma_descuento_global, fac_subtotal=suma_subtotal_con_descuento, fac_monto_ieps=suma_ieps,fac_impuesto=monto_impuesto, fac_monto_retencion=total_retencion, fac_total=suma_total, tasa_retencion_immex=tasa_retencion, fac_monto_descto=suma_descuento 
					WHERE id=str_data[4]::integer;
				ELSE
					IF retener_iva=true THEN
						total_retencion := monto_subtotal * tasa_retencion;
						total_retencion_global := monto_subtotal_global * tasa_retencion;
					ELSE
						total_retencion :=0;
						total_retencion_global :=0;
					END IF;
					
					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					if suma_retencion_de_partidas_globlal > 0 then 
						total_retencion_global := round((total_retencion_global + suma_retencion_de_partidas_globlal)::numeric,4)::double precision;
					end if;
					
					--Calcula el total de lo que se esta facturando
					suma_total:= monto_subtotal + suma_ieps + monto_impuesto - total_retencion::double precision;
					
					--Calcula el total global de la Prefactura
					suma_total_global:= monto_subtotal_global + suma_ieps_global + monto_impuesto_global - total_retencion_global::double precision;
					
					--Actualiza campos subtotal, monto_ieps, impuesto, retencion, total de tabla erp_prefacturas
					UPDATE erp_prefacturas SET subtotal=monto_subtotal_global, monto_ieps=suma_ieps_global, monto_descto=0, impuesto=monto_impuesto_global, monto_retencion=total_retencion_global, total=suma_total_global, fac_subtotal=monto_subtotal, fac_monto_ieps=suma_ieps,fac_impuesto=monto_impuesto, fac_monto_retencion=total_retencion, fac_total=suma_total, tasa_retencion_immex=tasa_retencion, fac_monto_descto=0 
					WHERE id=str_data[4]::integer;
				END IF;
				
			ELSE
				suma_retencion_de_partidas:=0;
				suma_retencion_de_partidas_globlal:=0;
				
				--Si la moneda de la prefactura es igual a la Moneda del pedido, entonces solo debemos actualizar las cantidades a facturar
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					
					--str_filas[1] eliminado
					IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
						--str_filas[2]	iddetalle
						--str_filas[3]	idproducto
						--str_filas[4]	id_presentacion
						--str_filas[5]	id_impuesto
						--str_filas[6]	cantidad
						--str_filas[7]	costo
						--str_filas[8]	valor_impuesto
						--str_filas[9]	id_remision
						--str_filas[10]	costo_promedio
						
						--str_filas[12]	id_ieps
						--str_filas[13]	tasa_ieps
						--str_filas[14]	vdescto
						--str_filas[15]	retencion_id
						--str_filas[16]	retencion_tasa

						importe_partida:=0;
						importe_ieps_partida:=0;
						impuesto_partida:=0;
						importe_del_descto_partida:=0;
						importe_partida_con_descto:=0;
						retencion_partida:=0;

						--Tasa de IEPS
						IF str_filas[13]::double precision>0 THEN 
							str_filas[13]:=str_filas[13]::double precision/100;
						END IF;

						--Tasa retencion de IVA de la partida
						IF str_filas[16]::double precision>0 THEN 
							str_filas[16]:=str_filas[16]::double precision/100;
						END IF;
						
						select * from inv_obtiene_costo_promedio_actual(str_filas[3]::integer, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
						
						--Actualizar los registros en erp_prefacturas_detalles
						UPDATE erp_prefacturas_detalles SET cant_facturar=str_filas[6]::double precision  WHERE id=str_filas[2]::integer;
						
						--Calcular y Redondear el importe de la partida
						importe_partida := round((str_filas[6]::double precision * str_filas[7]::double precision)::numeric,4)::double precision;
						
						--Calcular y redondear el IEPS de la partida
						importe_ieps_partida := round((importe_partida::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
						
						--Calcula el IVA de la Partida
						impuesto_partida := (importe_partida::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision;
						
						--Calcular el importe de la retencion de la partida si existe la tasa de retencion
						if str_filas[16]::double precision>0 then 
							retencion_partida := round((importe_partida::double precision * str_filas[16]::double precision)::numeric,4)::double precision;
						end if;
						
						IF lower(trim(str_data[29]))='true' THEN
							IF str_filas[14]::double precision>0 THEN
								importe_del_descto_partida = round((importe_partida * (str_filas[14]::double precision/100))::numeric,4)::double precision;

								importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
								
								--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
								importe_ieps_partida := round((importe_partida_con_descto::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
								
								--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
								impuesto_partida := round(((importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision)::numeric,4)::double precision;

								--Reclacular el nuevo el importe de la retencion de la partida si existe la tasa de retencion
								if str_filas[16]::double precision>0 then 
									retencion_partida := round((importe_partida_con_descto::double precision * str_filas[16]::double precision)::numeric,4)::double precision;
								end if;
							END IF;
						END IF;

						suma_descuento = suma_descuento + importe_del_descto_partida::double precision;
						suma_subtotal_con_descuento = suma_subtotal_con_descuento + importe_partida_con_descto::double precision;
						monto_subtotal := monto_subtotal + importe_partida::double precision;
						suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
						monto_impuesto := monto_impuesto + impuesto_partida::double precision;
						suma_retencion_de_partidas := suma_retencion_de_partidas + retencion_partida::double precision;
					END IF;
				END LOOP;
				
				--verificar si hay que retener iva para este cliente
				SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex/100 end FROM cxc_clie WHERE id=str_data[5]::integer INTO retener_iva, tasa_retencion;


				IF lower(trim(str_data[29]))='true' AND suma_descuento>0 THEN
					IF retener_iva=true THEN
						total_retencion := suma_subtotal_con_descuento * tasa_retencion;
					ELSE
						total_retencion :=0;
					END IF;

					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					--Calcula el monto de la prefactura
					suma_total:= suma_subtotal_con_descuento::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
					
					--Actualiza campos subtotal, impuesto, retencion, total de tabla erp_prefacturas
					UPDATE erp_prefacturas SET fac_subtotal=suma_subtotal_con_descuento, fac_monto_ieps=suma_ieps, fac_impuesto=monto_impuesto, fac_monto_retencion=total_retencion, fac_total=suma_total, tasa_retencion_immex=tasa_retencion, fac_monto_descto=suma_descuento  
					WHERE id=str_data[4]::integer;
				ELSE
					IF retener_iva=true THEN
						total_retencion := monto_subtotal * tasa_retencion;
					ELSE
						total_retencion :=0;
					END IF;

					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					--Calcula el monto de la prefactura
					suma_total:= monto_subtotal::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
					
					--Actualiza campos subtotal, impuesto, retencion, total de tabla erp_prefacturas
					UPDATE erp_prefacturas SET fac_subtotal=monto_subtotal, fac_monto_ieps=suma_ieps, fac_impuesto=monto_impuesto, fac_monto_retencion=total_retencion, fac_total=suma_total, tasa_retencion_immex=tasa_retencion
					WHERE id=str_data[4]::integer;
				END IF;


				

				
				
				/*
				Verificar si se est√° llevando control de existencias por Presentaciones. 
				Si no se lleva control de presentaciones, por ningun motivo podr√° ser cambiada la presentacion, por lo tanto no es necesario actualizar
				*/
				IF controlExisPres=true THEN 
					IF facpar.validar_pres_pedido=false THEN 
						total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
						cont_fila:=1;
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							
							IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
								--Aqu√≠ se actualiza la presentaci√≥n porque puede que haya cambiado antes de facturar o remisionar
								UPDATE erp_prefacturas_detalles SET presentacion_id=str_filas[4]::integer 
								WHERE id=str_filas[2]::integer;
							END IF;
						END LOOP;
					END IF;
				END IF;
			END IF;
			
			
			
			--RAISE EXCEPTION '%','facpar.incluye_adenda: '||facpar.incluye_adenda;
			
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			--Inicia gaurdar datos para la Adenda
			--Primero se verifica si en los parametros indica que se debe incluir la Adenda
			IF facpar.incluye_adenda THEN 
				--Verificar que exista un id de cliente valido
				IF str_data[5]::integer > 1 THEN 
					--Buscar el numero de Adenda asignado al cliente.
					SELECT cxc_clie_tipo_adenda_id FROM cxc_clie WHERE id=str_data[5]::integer INTO idAdenda;
					
					--Varificar si tiene adenda asignada
					IF idAdenda > 0 THEN 
						--Verificar el numero de adenda
						IF idAdenda=1 THEN 
							--Si el numero de Adenda es 1, entonces solo debe se debe validar datos cuando el tipo de documento es igual a 3.
							--Tipo Documento 3=Factura de Remision
							IF str_data[15]::integer=3 THEN 
								--RAISE EXCEPTION '%','str_data[27]: '||str_data[27];
								
								--Buscar la codificacion de la moneda por si el usuario la cambio al momento de actualizar
								SELECT iso_4217_anterior::character varying FROM gral_mon WHERE id=str_data[6]::integer INTO moneda_iso_4217;
								str_data[27]:=moneda_iso_4217;
								
								--Verificar si ya hay un registro de la Adenda y que no este ligado a una factura, es decir no ha sido facturado
								IF (SELECT count(id) FROM fac_docs_adenda WHERE prefactura_id=str_data[4]::integer AND fac_docs_id=0)>0 THEN 
									--Actualizar datos de la adenda porque ya existe un registro
									UPDATE fac_docs_adenda SET valor1=str_data[20], valor2=str_data[21], valor3=str_data[22], valor4=str_data[23], valor5=str_data[24], valor6=str_data[25], valor7=str_data[26], valor8=str_data[27] 
									WHERE prefactura_id=str_data[4]::integer AND fac_docs_id=0;
								ELSE
									--Crear el registro porque no existe
									INSERT INTO fac_docs_adenda(prefactura_id, fac_docs_id, cxc_clie_adenda_tipo_id, valor1, valor2, valor3, valor4, valor5, valor6, valor7, valor8 )
									VALUES(str_data[4]::integer, 0, idAdenda, str_data[20], str_data[21], str_data[22], str_data[23], str_data[24], str_data[25], str_data[26], str_data[27]);
								END IF;
							END IF;
						END IF;
						--Termina Addenda FEMSA-QUIMIPRODUCTOS
						
						
						--Addenda SUN CHEMICAL
						IF idAdenda=2 THEN 
							
							--Tipo Documento 1=Factura, 3=Factura de Remision
							IF str_data[15]::integer=1 OR str_data[15]::integer=3 THEN 
								--Verificar si ya hay un registro de la Adenda y que no este ligado a una factura, es decir no ha sido facturado
								IF (SELECT count(id) FROM fac_docs_adenda WHERE prefactura_id=str_data[4]::integer AND fac_docs_id=0)>0 THEN 
									--Actualizar datos de la adenda porque ya existe un registro
									UPDATE fac_docs_adenda SET valor1=str_data[11] 
									WHERE prefactura_id=str_data[4]::integer AND fac_docs_id=0;
								ELSE
									--Crear el registro porque no existe
									INSERT INTO fac_docs_adenda(prefactura_id, fac_docs_id, cxc_clie_adenda_tipo_id, valor1)
									VALUES(str_data[4]::integer, 0, idAdenda, str_data[11]);
								END IF;
							END IF;
						END IF;
						--Termina Addenda SUN CHEMICAL
					END IF;
				END IF;
			END IF;
			--Termina Guardar datos Adenda
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			
			
			
			
			
			--RAISE EXCEPTION '%','tipo_documento: '||str_data[15];
			--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			--:::::: AQUI ENTRA PARA GENERAR UNA REMISION:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			IF str_data[15]::integer=2 THEN
				id_tipo_consecutivo:=10;--Folio Remision de Clientes
				
				--aqui entra para tomar el consecutivo del folio de la remision de la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				--suc_id_consecutivo
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del pedido
				nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
				
				--extraer datos de la Prefactura
				SELECT * FROM erp_prefacturas WHERE id=str_data[4]::integer INTO prefactura_fila;
				
				IF prefactura_fila.moneda_id=1 THEN 
					--IF prefactura_fila.moneda_id != prefactura_fila.id_moneda_pedido THEN
					--	tipo_cam:=prefactura_fila.tipo_cambio;
					--ELSE
						tipo_cam:=1;
					--END IF;
				ELSE
					tipo_cam:=prefactura_fila.tipo_cambio;
				END IF;
				
				INSERT INTO fac_rems(
					folio,--nuevo_folio,
					folio_pedido,--prefactura_fila.folio_pedido,
					cxc_clie_id,--prefactura_fila.cliente_id,
					moneda_id,--prefactura_fila.moneda_id,
					subtotal,--prefactura_fila.fac_subtotal,
					monto_ieps,--prefactura_fila.fac_monto_ieps,
					impuesto,--prefactura_fila.fac_impuesto,
					monto_retencion,--prefactura_fila.fac_monto_retencion,
					total,--prefactura_fila.fac_total,
					tasa_retencion_immex,--prefactura_fila.tasa_retencion_immex,
					tipo_cambio,--tipo_cam,
					fac_metodos_pago_id,--prefactura_fila.fac_metodos_pago_id,
					no_cuenta,--prefactura_fila.no_cuenta,
					proceso_id,--prefactura_fila.proceso_id,
					cxc_agen_id,--prefactura_fila.empleado_id,
					cxc_clie_credias_id,--prefactura_fila.terminos_id,
					orden_compra,--prefactura_fila.orden_compra,
					observaciones,--prefactura_fila.observaciones,
					inv_alm_id,--prefactura_fila.inv_alm_id,
					cxc_clie_df_id,--prefactura_fila.cxc_clie_df_id,
					momento_creacion,--espacio_tiempo_ejecucion,
					gral_usr_id_creacion,--usuario_ejecutor
					monto_descto, --prefactura_fila.fac_monto_descto 
					motivo_descto --prefactura_fila.motivo_descto 
				)VALUES(nuevo_folio, prefactura_fila.folio_pedido, prefactura_fila.cliente_id, prefactura_fila.moneda_id, prefactura_fila.fac_subtotal, prefactura_fila.fac_monto_ieps, prefactura_fila.fac_impuesto, prefactura_fila.fac_monto_retencion, prefactura_fila.fac_total, prefactura_fila.tasa_retencion_immex, tipo_cam, prefactura_fila.fac_metodos_pago_id, prefactura_fila.no_cuenta, prefactura_fila.proceso_id, prefactura_fila.empleado_id, prefactura_fila.terminos_id, prefactura_fila.orden_compra, prefactura_fila.observaciones, prefactura_fila.inv_alm_id, prefactura_fila.cxc_clie_df_id, espacio_tiempo_ejecucion, usuario_ejecutor, prefactura_fila.fac_monto_descto, prefactura_fila.motivo_descto ) 
				RETURNING id INTO ultimo_id;
				
				tipo_movimiento_id:=5;--Salida por Venta
				id_tipo_consecutivo:=21; --Folio Orden de Salida
				id_almacen := prefactura_fila.inv_alm_id;
				
				--aqui entra para tomar el consecutivo del folio  la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				--suc_id_consecutivo
				
				--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				nuevo_folio_osal := prefijo_consecutivo || nuevo_consecutivo::character varying;
				
				--Crea registro en tabla inv_osal(Orden de Salida)
				INSERT INTO inv_osal(folio,estatus,erp_proceso_id,inv_mov_tipo_id,tipo_documento,folio_documento,fecha_exp,gral_app_id,cxc_clie_id,inv_alm_id,subtotal,monto_iva,monto_retencion,monto_total,folio_pedido,orden_compra,moneda_id,tipo_cambio,momento_creacion,gral_usr_id_creacion, gral_emp_id, gral_suc_id, monto_ieps)
				VALUES(nuevo_folio_osal,0,prefactura_fila.proceso_id,tipo_movimiento_id,str_data[15]::integer,nuevo_folio,espacio_tiempo_ejecucion,app_selected,prefactura_fila.cliente_id,id_almacen,prefactura_fila.subtotal,prefactura_fila.impuesto,prefactura_fila.monto_retencion,prefactura_fila.total,prefactura_fila.folio_pedido,prefactura_fila.orden_compra,prefactura_fila.moneda_id,tipo_cam,espacio_tiempo_ejecucion,usuario_ejecutor, emp_id, suc_id, prefactura_fila.monto_ieps)
				RETURNING id INTO id_osal;
				
				--Crea registro del movimiento
				INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id, gral_app_id,inv_mov_tipo_id, referencia, fecha_mov ) 
				VALUES(prefactura_fila.observaciones,espacio_tiempo_ejecucion,usuario_ejecutor,app_selected, tipo_movimiento_id, nuevo_folio, espacio_tiempo_ejecucion) 
				RETURNING id INTO identificador_nuevo_movimiento;
				
				--bandera que identifica si el producto es tipo 4
				--si es tipo 4 no debe existir movimientos en inventario
				bandera_tipo_4=TRUE;

				--Bandera que indica si se debe actualizar el flujo del proceso.
				--El proceso solo debe actualizarse cuando no quede ni una sola partida viva
				actualizar_proceso:=true;
				
				--Extraer datos de erp_prefacturas_detalles
				sql_select:='
				SELECT  erp_prefacturas_detalles.id AS id_det,
					erp_prefacturas_detalles.producto_id,
					erp_prefacturas_detalles.presentacion_id,
					erp_prefacturas_detalles.cantidad AS cant_pedido,
					erp_prefacturas_detalles.cant_facturado,
					erp_prefacturas_detalles.cant_facturar AS cantidad,
					erp_prefacturas_detalles.tipo_impuesto_id,
					erp_prefacturas_detalles.valor_imp,
					erp_prefacturas_detalles.precio_unitario,
					inv_prod.tipo_de_producto_id AS tipo_producto,
					erp_prefacturas_detalles.costo_promedio,
					erp_prefacturas_detalles.reservado,
					erp_prefacturas_detalles.reservado AS nuevo_reservado,
					0::double precision AS descontar_reservado,
					(CASE WHEN inv_prod_presentaciones.id IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
					(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec,
					inv_prod.unidad_id AS id_uni_prod,
					inv_prod.densidad AS densidad_prod,
					inv_prod_unidades.titulo AS nombre_unidad,
					erp_prefacturas_detalles.inv_prod_unidad_id,
					erp_prefacturas_detalles.gral_ieps_id, 
					erp_prefacturas_detalles.valor_ieps,
					(CASE WHEN erp_prefacturas_detalles.descto IS NULL THEN 0 ELSE erp_prefacturas_detalles.descto END) AS descto,
					erp_prefacturas_detalles.gral_imptos_ret_id, 
					erp_prefacturas_detalles.tasa_ret 
				FROM erp_prefacturas_detalles 
				JOIN inv_prod ON inv_prod.id=erp_prefacturas_detalles.producto_id
				LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=erp_prefacturas_detalles.presentacion_id 
				WHERE erp_prefacturas_detalles.cant_facturar>0 
				AND erp_prefacturas_detalles.prefacturas_id='||str_data[4]::integer||';';
				
				FOR prefactura_detalle IN EXECUTE (sql_select) LOOP
					--Inicializar valores
					cantPresReservAnterior:=0;
					cantPresAsignado:=0;
					partida_facturada:=false;
					cantUnidadProd:=0;
					
					idUnidadMedida:=prefactura_detalle.id_uni_prod;
					densidadProd:=prefactura_detalle.densidad_prod;
					nombreUnidadMedida:=prefactura_detalle.nombre_unidad;
					IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
					
					cantUnidadProd := prefactura_detalle.cantidad::double precision;
					
					IF facpar.cambiar_unidad_medida THEN
						IF idUnidadMedida::integer<>prefactura_detalle.inv_prod_unidad_id THEN
							EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
							IF match_cadena=true THEN
								--Convertir a kilos
								cantUnidadProd := cantUnidadProd::double precision * densidadProd;
							ELSE
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
								IF match_cadena=true THEN 
									--Convertir a Litros
									cantUnidadProd := cantUnidadProd::double precision / densidadProd;
								END IF;
							END IF;
						END IF;
					END IF;
					
					prefactura_detalle.cant_pedido := round(prefactura_detalle.cant_pedido::numeric,prefactura_detalle.no_dec)::double precision;
					prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
					prefactura_detalle.cantidad := round(prefactura_detalle.cantidad::numeric,prefactura_detalle.no_dec)::double precision;
					prefactura_detalle.reservado := round(prefactura_detalle.reservado::numeric,prefactura_detalle.no_dec)::double precision;
					prefactura_detalle.nuevo_reservado := round(prefactura_detalle.nuevo_reservado::numeric,prefactura_detalle.no_dec)::double precision;
					cantUnidadProd := round(cantUnidadProd::numeric,prefactura_detalle.no_dec)::double precision;
					
					IF (cantUnidadProd::double precision <= prefactura_detalle.reservado::double precision) THEN 
						--Asignar la cantidad para descontar de reservado
						prefactura_detalle.reservado := cantUnidadProd::double precision;
					END IF;
					
					--Calcular la nueva cantidad reservada
					prefactura_detalle.nuevo_reservado := prefactura_detalle.nuevo_reservado::double precision - prefactura_detalle.reservado::double precision;
					
					--Redondaer la nueva cantidad reservada
					prefactura_detalle.nuevo_reservado := round(prefactura_detalle.nuevo_reservado::numeric,prefactura_detalle.no_dec)::double precision;
					
					--Obtener costo promedio actual del producto
					SELECT * FROM inv_obtiene_costo_promedio_actual(prefactura_detalle.producto_id, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
					
					--Verificar que no tenga valor null
					IF costo_promedio_actual IS NULL OR costo_promedio_actual<=0 THEN costo_promedio_actual:=0; END IF;
					
					--Obtener el costo ultimo actual del producto. Este costo es convertido a pesos
					sql_select2 := 'SELECT (CASE WHEN gral_mon_id_'||mes_actual||'=1 THEN costo_ultimo_'||mes_actual||'  ELSE costo_ultimo_'||mes_actual||' * (CASE WHEN gral_mon_id_'||mes_actual||'=1 THEN 1 ELSE tipo_cambio_'||mes_actual||' END) END) AS costo_ultimo FROM inv_prod_cost_prom WHERE inv_prod_id='||prefactura_detalle.producto_id||' AND ano='||ano_actual||';';
					EXECUTE sql_select2 INTO costo_referencia_actual;
					--RAISE EXCEPTION '%',cadena_sql;
					
					--Verificar que no tenga valor null
					IF costo_referencia_actual IS NULL OR costo_referencia_actual<=0 THEN costo_referencia_actual:=0; END IF;
					
					--Crea registros para tabla fac_rems_detalles
					INSERT INTO fac_rems_detalles(fac_rems_id,inv_prod_id,inv_prod_presentacion_id,gral_imp_id,valor_imp,cantidad,precio_unitario, costo_promedio, costo_referencia, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, gral_imptos_ret_id, tasa_ret)
					VALUES(ultimo_id,prefactura_detalle.producto_id,prefactura_detalle.presentacion_id,prefactura_detalle.tipo_impuesto_id,prefactura_detalle.valor_imp,prefactura_detalle.cantidad,prefactura_detalle.precio_unitario, costo_promedio_actual, costo_referencia_actual, prefactura_detalle.inv_prod_unidad_id, prefactura_detalle.gral_ieps_id, prefactura_detalle.valor_ieps, prefactura_detalle.descto, prefactura_detalle.gral_imptos_ret_id, prefactura_detalle.tasa_ret);
					
					--RAISE EXCEPTION '%','prefactura_detalle.tipo_producto: '||prefactura_detalle.tipo_producto;
					--Si el tipo de producto es diferente de 4, hay que descontar existencias y generar Movimientos
					--tipo=4 Servicios
					--para el tipo servicios NO debe generar movimientos NI descontar existencias
					IF prefactura_detalle.tipo_producto::integer<>4 THEN
						
						bandera_tipo_4=FALSE;--indica que por lo menos un producto es diferente de tipo4, por lo tanto debe generarse movimientos
						
						--tipo=1 Normal o Terminado
						--tipo=2 Subensable o Formulacion o Intermedio
						--tipo=5 Refacciones
						--tipo=6 Accesorios
						--tipo=7 Materia Prima
						--tipo=8 Prod. en Desarrollo
						IF prefactura_detalle.tipo_producto=1 OR prefactura_detalle.tipo_producto=2 OR prefactura_detalle.tipo_producto=5 OR prefactura_detalle.tipo_producto=6 OR prefactura_detalle.tipo_producto=7 OR prefactura_detalle.tipo_producto=8 THEN
							--genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id, costo, inv_prod_presentacion_id)
							VALUES(prefactura_detalle.producto_id, id_almacen,0, cantUnidadProd, identificador_nuevo_movimiento, costo_promedio_actual, prefactura_detalle.presentacion_id);
							
							--query para descontar producto de existencias y descontar existencia reservada porque ya se Remision√≥
							sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||cantUnidadProd||'), 
							reservado=(reservado::double precision - '||prefactura_detalle.reservado||'::double precision), momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
							WHERE inv_alm_id='||id_almacen||'::integer AND inv_prod_id='||prefactura_detalle.producto_id||'::integer AND ano='||ano_actual||'::integer;';
							EXECUTE sql_update;
							
							--Crear registro en orden salida detalle, se crea el registo con la cantidad en unidad de venta
							INSERT INTO inv_osal_detalle(inv_osal_id,inv_prod_id,inv_prod_presentacion_id,cantidad,precio_unitario,inv_prod_unidad_id, gral_ieps_id, valor_ieps)
							VALUES(id_osal,prefactura_detalle.producto_id,prefactura_detalle.presentacion_id,prefactura_detalle.cantidad,prefactura_detalle.precio_unitario,prefactura_detalle.inv_prod_unidad_id, prefactura_detalle.gral_ieps_id, prefactura_detalle.valor_ieps);
							
							--Verificar si se est√° llevando el control de existencias por Presentaciones
							IF controlExisPres=true THEN 
								--Si la configuracion indica que se validan Presentaciones desde el Pedido,entonces significa que hay reservados, por lo tanto hay que descontarlos
								IF facpar.validar_pres_pedido=true THEN 
									--Convertir la cantidad reservada a su equivalente en presentaciones
									cantPresReservAnterior := prefactura_detalle.reservado::double precision / prefactura_detalle.cant_equiv::double precision;
									
									--redondear la Cantidad de la Presentacion reservada Anteriormente
									cantPresReservAnterior := round(cantPresReservAnterior::numeric,prefactura_detalle.no_dec)::double precision; 
								END IF;
								
								--Convertir la cantidad de la partida a su equivalente a presentaciones
								cantPresAsignado := cantUnidadProd::double precision / prefactura_detalle.cant_equiv::double precision;
								
								--Redondear la cantidad de Presentaciones asignado en la partida
								cantPresAsignado := round(cantPresAsignado::numeric,prefactura_detalle.no_dec)::double precision;
								
								--Sumar salidas de inv_exi_pres
								UPDATE inv_exi_pres SET 
									salidas=(salidas::double precision + cantPresAsignado::double precision), 
									reservado=(reservado::double precision - cantPresReservAnterior::double precision), 
									momento_actualizacion=espacio_tiempo_ejecucion, 
									gral_usr_id_actualizacion=usuario_ejecutor 
								WHERE inv_alm_id=prefactura_fila.inv_alm_id 
								AND inv_prod_id=prefactura_detalle.producto_id 
								AND inv_prod_presentacion_id=prefactura_detalle.presentacion_id;
								--Termina sumar salidas
							END IF;
							
							--::Aqui inica calculos para el control de facturacion por partida::::::::
							--Calcular la cantidad facturada
							prefactura_detalle.cant_facturado:=prefactura_detalle.cant_facturado::double precision + prefactura_detalle.cantidad::double precision;
							
							--Redondear la cantidad facturada
							prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
							
							IF prefactura_detalle.cant_pedido <= prefactura_detalle.cant_facturado THEN 
								partida_facturada:=true;
							ELSE
								--Si entro aqui quiere decir que por lo menos una partida esta quedando pendiente de facturar por completo.
								actualizar_proceso:=false;
							END IF;
							
							--Actualizar el registro de la partida
							UPDATE erp_prefacturas_detalles SET cant_facturado=prefactura_detalle.cant_facturado, facturado=partida_facturada, cant_facturar=0, reservado=prefactura_detalle.nuevo_reservado 
							WHERE id=prefactura_detalle.id_det;
							
							
							--Obtener el id del pedido que se esta facturando
							SELECT id FROM poc_pedidos WHERE folio=prefactura_fila.folio_pedido ORDER BY id DESC LIMIT 1 INTO id_pedido;
							
							IF id_pedido IS NULL THEN id_pedido:=0; END IF;
							
							IF id_pedido<>0 THEN 
								--Actualizar el registro detalle del Pedido
								UPDATE poc_pedidos_detalle SET reservado=prefactura_detalle.nuevo_reservado 
								WHERE poc_pedido_id=id_pedido AND inv_prod_id=prefactura_detalle.producto_id AND presentacion_id=prefactura_detalle.presentacion_id;
							END IF;
							
						END IF;--termina tipo producto 1, 2, 7
					ELSE
						
						IF prefactura_detalle.tipo_producto::integer=4 THEN
							--Aqu√≠ solo entre cuando es un Servicio
							--::Aqui inica calculos para el control de remision por partida::::::::
							--Calcular la cantidad facturada
							prefactura_detalle.cant_facturado:=prefactura_detalle.cant_facturado::double precision + prefactura_detalle.cantidad::double precision;
							
							--Redondear la cantidad facturada
							prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
							
							IF prefactura_detalle.cant_pedido <= prefactura_detalle.cant_facturado THEN 
								partida_facturada:=true;
							END IF;
							
							--Actualizar el registro de la partida
							UPDATE erp_prefacturas_detalles SET cant_facturado=prefactura_detalle.cant_facturado, facturado=partida_facturada, cant_facturar=0, reservado=0 
							WHERE id=prefactura_detalle.id_det;
						END IF;
					END IF;
					
				END LOOP;
				
				--si bandera tipo 4=true, significa el producto que se esta facturando son servicios;
				--por lo tanto hay que eliminar el movimiento de inventario
				IF bandera_tipo_4=TRUE THEN 
					DELETE FROM inv_mov WHERE id=identificador_nuevo_movimiento;
				END IF;
				
				IF (SELECT count(prefact_det.id) FROM erp_prefacturas_detalles AS prefact_det JOIN inv_prod ON inv_prod.id=prefact_det.producto_id WHERE prefact_det.prefacturas_id=str_data[4]::integer AND inv_prod.tipo_de_producto_id<>4 AND prefact_det.facturado=false )>=1 THEN
					actualizar_proceso:=false;
				END IF;
				
				--Verificar si hay que actualizar el flujo del proceso
				IF actualizar_proceso THEN 
					--Actualiza el flujo del proceso a 5=Remision
					UPDATE erp_proceso SET proceso_flujo_id=5 WHERE id=prefactura_fila.proceso_id;
				ELSE
					--Actualiza el flujo del proceso a 8=REMISION PARCIAL
					UPDATE erp_proceso SET proceso_flujo_id=8 WHERE id=prefactura_fila.proceso_id;
				END IF;
				
				--Una vez terminado el Proceso se asignan ceros a estos campos
				UPDATE erp_prefacturas SET fac_subtotal=0, fac_monto_ieps=0, fac_impuesto=0, fac_monto_retencion=0, fac_total=0, fac_monto_descto=0 
				WHERE id=str_data[4]::integer;
				
			END IF;
			--::::::TERMINA GENERACION DE REMISION:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			
			valor_retorno := '1:'||nuevo_folio;
		END IF;--termina edit prefactura
		
		
		
		
		
		
		
		
		--RAISE EXCEPTION '%','command_selected: '||command_selected;
		--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		--:::::: GENERAR UNA FACTURA VERSION CFDI CONECTOR FISCAL:::::::::::::::::::::::::::::::::::::::::::::::::
		--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		IF command_selected='facturar_cfdi' THEN
			--str_data[3]	id_usuario
			--str_data[4]	id_prefactura
			--str_data[5] 	tipo_facturacion
			--str_data[6]	Serie
			--str_data[7]	Folio
			--str_data[8]	refacturar
			--str_data[9]	select_tipo_documento
			
			tipo_de_documento := 1;--Factura
			
			serie_folio_fac:= str_data[6]||str_data[7];
			refact := str_data[8];
			
			--extraer datos de la Prefactura
			SELECT * FROM erp_prefacturas WHERE id=str_data[4]::integer INTO prefactura_fila;
			
			SELECT dias FROM cxc_clie_credias WHERE id=prefactura_fila.terminos_id INTO numero_dias_credito;
			
			--calcula la fecha de vencimiento a partir de la fecha de la factura
			SELECT (to_char(espacio_tiempo_ejecucion,'yyyy-mm-dd')::DATE + numero_dias_credito)::timestamp with time zone AS fecha_vencimiento INTO fecha_de_vencimiento;
			
			IF prefactura_fila.moneda_id=1 THEN 
				tipo_cam:=1;
			ELSE
				tipo_cam:=prefactura_fila.tipo_cambio;
			END IF;
			
			--crea registro en erp_h_facturas
			INSERT INTO erp_h_facturas(
				cliente_id,--prefactura_fila.cliente_id,
				cxc_agen_id,--prefactura_fila.empleado_id,
				serie_folio,--serie_folio_fac,
				monto_total,--prefactura_fila.fac_total,
				saldo_factura,--prefactura_fila.fac_total,
				moneda_id,--prefactura_fila.moneda_id,
				tipo_cambio,--tipo_cam,
				momento_facturacion,--espacio_tiempo_ejecucion,
				fecha_vencimiento,--fecha_de_vencimiento,
				subtotal,--prefactura_fila.subtotal,
				impuesto,--prefactura_fila.impuesto,
				retencion,--prefactura_fila.monto_retencion,
				orden_compra,--prefactura_fila.orden_compra,
				id_usuario_creacion, --usuario_ejecutor,
				empresa_id, --emp_id,
				sucursal_id--suc_id
			)VALUES(prefactura_fila.cliente_id, prefactura_fila.empleado_id, serie_folio_fac, prefactura_fila.fac_total, prefactura_fila.fac_total, prefactura_fila.moneda_id, tipo_cam, espacio_tiempo_ejecucion, fecha_de_vencimiento, prefactura_fila.fac_subtotal, prefactura_fila.fac_impuesto, prefactura_fila.fac_monto_retencion, prefactura_fila.orden_compra, usuario_ejecutor, emp_id, suc_id);
			
			--crea registros en la tabla fac_docs
			INSERT INTO fac_docs(
				serie_folio,--serie_folio_fac,
				folio_pedido,--prefactura_fila.folio_pedido,
				cxc_clie_id,--prefactura_fila.cliente_id,
				moneda_id,--prefactura_fila.moneda_id,
				subtotal,--prefactura_fila.fac_subtotal,
				monto_descto,--prefactura_fila.fac_monto_descto,
				impuesto,--prefactura_fila.fac_impuesto,
				monto_retencion,--prefactura_fila.fac_monto_retencion,
				total,--prefactura_fila.fac_total,
				tasa_retencion_immex,--prefactura_fila.tasa_retencion_immex,
				tipo_cambio,--tipo_cam,
				proceso_id,--prefactura_fila.proceso_id,
				cxc_agen_id,--prefactura_fila.empleado_id,
				terminos_id,--prefactura_fila.terminos_id,
				fecha_vencimiento,--fecha_de_vencimiento
				orden_compra,--prefactura_fila.orden_compra,
				observaciones, --prefactura_fila.observaciones,
				fac_metodos_pago_id, --prefactura_fila.fac_metodos_pago_id,
				no_cuenta, --prefactura_fila.no_cuenta,
				enviar_ruta,--prefactura_fila.enviar_ruta,
				inv_alm_id,--prefactura_fila.inv_alm_id
				cxc_clie_df_id,--prefactura_fila.cxc_clie_df_id,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion--usuario_ejecutor
			)VALUES(serie_folio_fac, prefactura_fila.folio_pedido, prefactura_fila.cliente_id, prefactura_fila.moneda_id, prefactura_fila.fac_subtotal, prefactura_fila.fac_monto_descto, prefactura_fila.fac_impuesto, prefactura_fila.fac_monto_retencion, prefactura_fila.fac_total, prefactura_fila.tasa_retencion_immex, tipo_cam, prefactura_fila.proceso_id, prefactura_fila.empleado_id, prefactura_fila.terminos_id, fecha_de_vencimiento, prefactura_fila.orden_compra, prefactura_fila.observaciones, prefactura_fila.fac_metodos_pago_id, prefactura_fila.no_cuenta, prefactura_fila.enviar_ruta, prefactura_fila.inv_alm_id, prefactura_fila.cxc_clie_df_id, espacio_tiempo_ejecucion, usuario_ejecutor)
			RETURNING id INTO ultimo_id;
			
			--bandera que identifica si el producto es tipo 4
			--si es tipo 4 no debe existir movimientos en inventario
			bandera_tipo_4=TRUE;
			tipo_movimiento_id:=5;--Salida por Venta
			id_tipo_consecutivo:=21; --Folio Orden de Salida
			id_almacen := prefactura_fila.inv_alm_id;
			
			--Bandera que indica si se debe actualizar el flujo del proceso.
			--El proceso solo debe actualizarse cuando no quede ni una sola partida viva
			actualizar_proceso:=true;
			
			--refact=false:No es refacturacion
			--tipo_documento=1:Factura
			IF refact='false' AND prefactura_fila.tipo_documento::integer=1 THEN
				
				--aqui entra para tomar el consecutivo del folio  la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				--suc_id_consecutivo
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
				
				--genera registro en tabla inv_osal(Orden de Salida)
				INSERT INTO inv_osal(folio,estatus,erp_proceso_id,inv_mov_tipo_id,tipo_documento,folio_documento,fecha_exp,gral_app_id,cxc_clie_id,inv_alm_id,subtotal,monto_iva,monto_retencion,monto_total,folio_pedido,orden_compra,moneda_id,tipo_cambio,momento_creacion,gral_usr_id_creacion, gral_emp_id, gral_suc_id)
				VALUES(nuevo_folio,0,prefactura_fila.proceso_id,tipo_movimiento_id,tipo_de_documento,serie_folio_fac,espacio_tiempo_ejecucion,app_selected,prefactura_fila.cliente_id,id_almacen, prefactura_fila.fac_subtotal, prefactura_fila.fac_impuesto, prefactura_fila.fac_monto_retencion, prefactura_fila.fac_total, prefactura_fila.folio_pedido,prefactura_fila.orden_compra,prefactura_fila.moneda_id,tipo_cam,espacio_tiempo_ejecucion,usuario_ejecutor, emp_id, suc_id)
				RETURNING id INTO id_osal;
				
				--genera registro del movimiento
				INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id, gral_app_id,inv_mov_tipo_id, referencia, fecha_mov ) 
				VALUES(prefactura_fila.observaciones,espacio_tiempo_ejecucion,usuario_ejecutor,app_selected, tipo_movimiento_id, serie_folio_fac, espacio_tiempo_ejecucion) 
				RETURNING id INTO identificador_nuevo_movimiento;
				
			END IF;
			
			
			--tipo_documento 3=Factura de remision
			IF prefactura_fila.tipo_documento::integer=3 THEN 
				--buscar numero de remision que se incluyeron en esta factura
				sql_select:='SELECT DISTINCT fac_rem_id FROM fac_rems_docs WHERE erp_proceso_id = '||prefactura_fila.proceso_id;
				
				FOR fila_fac_rem_doc IN EXECUTE(sql_select) LOOP
					--asignar facturado a cada remision
					UPDATE fac_rems SET facturado=TRUE WHERE id=fila_fac_rem_doc.fac_rem_id;
				END LOOP;
			END IF;
			
			
			--obtiene lista de productos de la prefactura
			sql_select:='';
			sql_select:='
			SELECT  erp_prefacturas_detalles.id AS id_det,
				erp_prefacturas_detalles.producto_id,
				erp_prefacturas_detalles.presentacion_id,
				erp_prefacturas_detalles.cantidad AS cant_pedido,
				erp_prefacturas_detalles.cant_facturado,
				erp_prefacturas_detalles.cant_facturar AS cantidad,
				erp_prefacturas_detalles.tipo_impuesto_id,
				erp_prefacturas_detalles.valor_imp,
				erp_prefacturas_detalles.precio_unitario,
				inv_prod.tipo_de_producto_id as tipo_producto,
				erp_prefacturas_detalles.costo_promedio,
				erp_prefacturas_detalles.reservado,
				erp_prefacturas_detalles.reservado AS nuevo_reservado,
				(CASE WHEN inv_prod_presentaciones.id IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
				(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec,
				(CASE WHEN erp_prefacturas_detalles.descto IS NULL THEN 0 ELSE erp_prefacturas_detalles.descto END) AS descto 
			FROM erp_prefacturas_detalles 
			JOIN inv_prod ON inv_prod.id=erp_prefacturas_detalles.producto_id
			LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
			LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=erp_prefacturas_detalles.presentacion_id 
			WHERE erp_prefacturas_detalles.cant_facturar>0 
			AND erp_prefacturas_detalles.prefacturas_id='||str_data[4]::integer;
			--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
			
			FOR prefactura_detalle IN EXECUTE(sql_select) LOOP
				--Inicializar valores
				cantPresReservAnterior:=0;
				cantPresAsignado:=0;
				partida_facturada:=false;
				
				--tipo_documento 3=Factura de remision
				IF prefactura_fila.tipo_documento::integer=3 THEN 
					--toma el costo promedio que viene de la prefactura
					costo_promedio_actual := prefactura_detalle.costo_promedio;
				ELSE
					--obtener costo promedio actual del producto
					SELECT * FROM inv_obtiene_costo_promedio_actual(prefactura_detalle.producto_id, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
				END IF;
				
				--Redondear cantidades
				prefactura_detalle.cant_pedido := round(prefactura_detalle.cant_pedido::numeric,prefactura_detalle.no_dec)::double precision;
				prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
				prefactura_detalle.cantidad := round(prefactura_detalle.cantidad::numeric,prefactura_detalle.no_dec)::double precision;
				prefactura_detalle.reservado := round(prefactura_detalle.reservado::numeric,prefactura_detalle.no_dec)::double precision;
				prefactura_detalle.nuevo_reservado := round(prefactura_detalle.nuevo_reservado::numeric,prefactura_detalle.no_dec)::double precision;
				
				IF (prefactura_detalle.cantidad::double precision <= prefactura_detalle.reservado::double precision) THEN 
					--Asignar la cantidad para descontar de reservado
					prefactura_detalle.reservado := prefactura_detalle.cantidad::double precision;
				END IF;
				
				--Calcular la nueva cantidad reservada
				prefactura_detalle.nuevo_reservado := prefactura_detalle.nuevo_reservado::double precision - prefactura_detalle.reservado::double precision;
				
				--Redondaer la nueva cantidad reservada
				prefactura_detalle.nuevo_reservado := round(prefactura_detalle.nuevo_reservado::numeric,prefactura_detalle.no_dec)::double precision;
				
				--crea registro en fac_docs_detalles
				INSERT INTO fac_docs_detalles(fac_doc_id,inv_prod_id,inv_prod_presentacion_id,gral_imptos_id,valor_imp,cantidad,precio_unitario,costo_promedio, descto)
				VALUES(ultimo_id,prefactura_detalle.producto_id,prefactura_detalle.presentacion_id,prefactura_detalle.tipo_impuesto_id,prefactura_detalle.valor_imp,prefactura_detalle.cantidad,prefactura_detalle.precio_unitario, costo_promedio_actual, prefactura_detalle.descto);
				
				IF refact='false'  AND prefactura_fila.tipo_documento::integer=1 THEN
					--Si el tipo de producto es diferente de 4 el hay que descontar existencias y generar Movimientos
					--tipo=4 Servicios
					--para el tipo servicios NO debe generar movimientos NI descontar existencias
					IF prefactura_detalle.tipo_producto::integer<>4 THEN
						
						bandera_tipo_4=FALSE;--indica que por lo menos un producto es diferente de tipo4, por lo tanto debe generarse movimientos
						
						--tipo=1 Normal o Terminado
						--tipo=2 Subensable o Formulacion o Intermedio
						--tipo=5 Refacciones
						--tipo=6 Accesorios
						--tipo=7 Materia Prima
						--tipo=8 Prod. en Desarrollo
						
						--tipo=3 Kit
						--tipo=4 Servicios
						--IF prefactura_detalle.tipo_producto=1 OR prefactura_detalle.tipo_producto=2 OR prefactura_detalle.tipo_producto=5 OR prefactura_detalle.tipo_producto=6 OR prefactura_detalle.tipo_producto=7 OR prefactura_detalle.tipo_producto=8 THEN
						IF prefactura_detalle.tipo_producto::integer<>3 AND prefactura_detalle.tipo_producto::integer<>4 THEN
							--genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id, costo, inv_prod_presentacion_id)
							VALUES(prefactura_detalle.producto_id, id_almacen,0, prefactura_detalle.cantidad, identificador_nuevo_movimiento, costo_promedio_actual, prefactura_detalle.presentacion_id);
							
							--query para descontar producto de existencias y descontar existencia reservada porque ya se Factur√≥
							sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||prefactura_detalle.cantidad||'::double precision), 
							reservado=(reservado::double precision - '||prefactura_detalle.reservado||'::double precision), momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
							WHERE inv_alm_id='||id_almacen||'::integer AND inv_prod_id='||prefactura_detalle.producto_id||'::integer AND ano='||ano_actual||'::integer;';
							EXECUTE sql_update;
							IF FOUND THEN
								--RAISE EXCEPTION '%','FOUND'||FOUND;
							ELSE
								RAISE EXCEPTION '%','NOT FOUND:'||FOUND||'   No se pudo actualizar inv_exi';
							END IF;
							
							--crear registro en orden salida detalle
							INSERT INTO inv_osal_detalle(inv_osal_id,inv_prod_id,inv_prod_presentacion_id,cantidad,precio_unitario)
							VALUES(id_osal,prefactura_detalle.producto_id,prefactura_detalle.presentacion_id,prefactura_detalle.cantidad,prefactura_detalle.precio_unitario);
							
							
							--Verificar si se est√° llevando el control de existencias por Presentaciones
							IF controlExisPres=true THEN 
								--Si la configuracion indica que se validan Presentaciones desde el Pedido,entonces significa que hay reservados, por lo tanto hay que descontarlos
								IF facpar.validar_pres_pedido=true THEN 
									--Convertir la cantidad reservada a su equivalente en presentaciones
									cantPresReservAnterior := prefactura_detalle.reservado::double precision / prefactura_detalle.cant_equiv::double precision;
									
									--redondear la Cantidad de la Presentacion reservada Anteriormente
									cantPresReservAnterior := round(cantPresReservAnterior::numeric,prefactura_detalle.no_dec)::double precision; 
								END IF;
								
								--Convertir la cantidad de la partida a su equivalente a presentaciones
								cantPresAsignado := prefactura_detalle.cantidad::double precision / prefactura_detalle.cant_equiv::double precision;
								
								--Redondear la cantidad de Presentaciones asignado en la partida
								cantPresAsignado := round(cantPresAsignado::numeric,prefactura_detalle.no_dec)::double precision;
								
								--Sumar salidas de inv_exi_pres
								UPDATE inv_exi_pres SET 
									salidas=(salidas::double precision + cantPresAsignado::double precision), reservado=(reservado::double precision - cantPresReservAnterior::double precision), 
									momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
								WHERE inv_alm_id=id_almacen AND inv_prod_id=prefactura_detalle.producto_id AND inv_prod_presentacion_id=prefactura_detalle.presentacion_id;
								--Termina sumar salidas
							END IF;


							
							--::Aqui inica calculos para el control de facturacion por partida::::::::
							--Calcular la cantidad facturada
							prefactura_detalle.cant_facturado:=prefactura_detalle.cant_facturado::double precision + prefactura_detalle.cantidad::double precision;
							
							--Redondear la cantidad facturada
							prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
							
							IF prefactura_detalle.cant_pedido <= prefactura_detalle.cant_facturado THEN 
								partida_facturada:=true;
							ELSE
								--Si entro aqui quiere decir que por lo menos una partida esta quedando pendiente de facturar por completo.
								actualizar_proceso:=false;
							END IF;
							
							--Actualizar el registro de la partida
							UPDATE erp_prefacturas_detalles SET cant_facturado=prefactura_detalle.cant_facturado, facturado=partida_facturada, cant_facturar=0, reservado=prefactura_detalle.nuevo_reservado 
							WHERE id=prefactura_detalle.id_det;
							
							--Obtener el id del pedido que se esta facturando
							SELECT id FROM poc_pedidos WHERE folio=prefactura_fila.folio_pedido ORDER BY id DESC LIMIT 1 INTO id_pedido;
							
							IF id_pedido IS NULL THEN id_pedido:=0; END IF;
							
							IF id_pedido<>0 THEN 
								--Actualizar el registro detalle del Pedido
								UPDATE poc_pedidos_detalle SET reservado=prefactura_detalle.nuevo_reservado 
								WHERE poc_pedido_id=id_pedido AND inv_prod_id=prefactura_detalle.producto_id AND presentacion_id=prefactura_detalle.presentacion_id;
							END IF;
							
						END IF;--termina tipo producto 1, 2, 7
						
					END IF;
				END IF; --termina if que verifica si es refacturacion
				
			END LOOP;
			
			--si bandera tipo 4=true, significa el producto que se esta facturando son servicios;
			--por lo tanto hay que eliminar el movimiento de inventario
			IF bandera_tipo_4=TRUE THEN 
				--refact=false:No es refacturacion
				--tipo_documento=1:Factura
				IF refact='false' AND prefactura_fila.tipo_documento=1 THEN
					DELETE FROM inv_mov WHERE id=identificador_nuevo_movimiento;
				END IF;
			END IF;

			IF (SELECT count(id) FROM erp_prefacturas_detalles  WHERE erp_prefacturas_detalles.prefacturas_id=str_data[4]::integer AND facturado=false)>=1 THEN
				actualizar_proceso:=false;
			END IF;

			--Verificar si hay que actualizar el flujo del proceso
			IF actualizar_proceso THEN 
				--Actualiza el flujo del proceso a 3=Facturado
				UPDATE erp_proceso SET proceso_flujo_id=3 WHERE id=prefactura_fila.proceso_id;
			ELSE
				--Actualiza el flujo del proceso a 7=FACTURA PARCIAL
				UPDATE erp_proceso SET proceso_flujo_id=7 WHERE id=prefactura_fila.proceso_id;
			END IF;

			
			--Una vez terminado el Proceso se asignan ceros a estos campos
			UPDATE erp_prefacturas SET fac_subtotal=0, fac_impuesto=0, fac_monto_retencion=0, fac_total=0
			WHERE id=str_data[4]::integer;

			/*
			fac_subtotal
			fac_impuesto
			fac_monto_retencion
			fac_total
			tasa_retencion_immex
			*/
			--Aqu√≠ se actualiza el Consecutivo del Folio de la Factura. √âsta actualizacion es por empresa-sucursal
			UPDATE fac_cfds_conf_folios SET folio_actual=(folio_actual+1) WHERE id=(SELECT fac_cfds_conf_folios.id FROM fac_cfds_conf JOIN fac_cfds_conf_folios ON fac_cfds_conf_folios.fac_cfds_conf_id=fac_cfds_conf.id WHERE fac_cfds_conf_folios.proposito='FAC' AND fac_cfds_conf.empresa_id=emp_id AND fac_cfds_conf.gral_suc_id=suc_id);
			
			valor_retorno := '1:'||ultimo_id;--retorna el id de fac_docs
		END IF;
		--:::::: TERMINA GENERACION DE FACTURA VERSION CFDI CONECTOR FISCAL ::::::::::::::::::::::::::::::::::::::::::::
		--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		
		
		
		
		--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		--:::::: GENERAR UNA FACTURA VERSION CFDI TIMBRE FISCAL  :::::::::::::::::::::::::::::::::::::::::::::::::
		--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		IF command_selected='facturar_cfditf' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	prefactura_id
			--str_data[5]	pop.getRfc_receptor()
			--str_data[6]	pop.getSerie()
			--str_data[7]	pop.getFolio()
			--str_data[8]	pop.getNoAprobacion()
			--str_data[9]	pop.getTotal()
			--str_data[10]	pop.getTotalImpuestosTrasladados()
			--str_data[11]	estado_comprobante
			--str_data[12]	xml_file_name
			--str_data[13]	pop.getFecha()
			--str_data[14]	pop.getRazon_social_receptor()
			--str_data[15]	pop.getTipoDeComprobante()
			--str_data[16]	this.getProposito()
			--str_data[17]	pop.getAnoAprobacion()
			--str_data[18]	cadena_conceptos
			--str_data[19]	cadena_imp_trasladados
			--str_data[20]	cadena_imp_retenidos
			--str_data[21]	Integer.parseInt(id_moneda)
			--str_data[22]	tipo_cambio
			--str_data[23]	refacturar
			--str_data[24]	regimen_fiscal
			--str_data[25]	metodo_pago
			--str_data[26]	num_cuenta
			--str_data[27]	lugar_de_expedicion
			--str_data[28]	ref_id
			--str_data[29]	xml_timbrado
			--str_data[30]	get_subtotal_con_descuento
			
			tipo_de_documento := 1;--Factura
			--tipo_documento := str_data[9]::integer;
			
			serie_folio_fac:= str_data[6]||str_data[7];
			refact := str_data[23];
			
			--extraer datos de la Prefactura
			SELECT * FROM erp_prefacturas WHERE id=str_data[4]::integer INTO prefactura_fila;
			
			--Obtener el numero de dias de credito
			SELECT dias FROM cxc_clie_credias WHERE id=prefactura_fila.terminos_id INTO numero_dias_credito;
			
			--calcula la fecha de vencimiento a partir de la fecha de la factura
			SELECT (to_char(espacio_tiempo_ejecucion,'yyyy-mm-dd')::DATE + numero_dias_credito)::timestamp with time zone AS fecha_vencimiento INTO fecha_de_vencimiento;
			
			IF prefactura_fila.moneda_id=1 THEN 
				tipo_cam:=1;
			ELSE
				tipo_cam:=prefactura_fila.tipo_cambio;
			END IF;
			
			--Toma la fecha de la Facturaci√≥n. √âsta fecha es la misma que se le asigno al xml
			espacio_tiempo_ejecucion := translate(str_data[13],'T',' ')::timestamp with time zone;
			
			--crea registro en fac_cfds
			INSERT INTO fac_cfds(
				rfc_cliente,--str_data[5],
				serie,--str_data[6],
				folio_del_comprobante_fiscal,--str_data[7],
				numero_de_aprobacion,--str_data[8],
				monto_de_la_operacion,--str_data[9]::double precision,
				monto_del_impuesto,--str_data[10]::double precision,
				estado_del_comprobante,--str_data[11],
				nombre_archivo,--str_data[12],
				momento_expedicion,--str_data[13],
				razon_social,--str_data[14],
				tipo_comprobante,--str_data[15],
				proposito,--str_data[16],
				anoaprovacion, --str_data[17],
				serie_folio, --serie_folio_fac,
				conceptos, --str_data[18],
				impuestos_trasladados, --str_data[19],
				impuestos_retenidos, --str_data[20],
				regimen_fiscal, --str_data[24],
				metodo_pago, --str_data[25],
				numero_cuenta, --str_data[26],
				lugar_expedicion,--str_data[27],
				tipo_de_cambio,--tipo_cam,
				gral_mon_id,--prefactura_fila.moneda_id,
				id_user_crea,--str_data[3]::integer,
				empresa_id,--emp_id,
				sucursal_id,--suc_id,
				proceso_id--prefactura_fila.proceso_id
			    ) VALUES(str_data[5], str_data[6], str_data[7], str_data[8], str_data[9]::double precision, str_data[10]::double precision, str_data[11], str_data[12], str_data[13], str_data[14], str_data[15], str_data[16], str_data[17], serie_folio_fac, str_data[18], str_data[19], str_data[20], str_data[24], str_data[25], str_data[26], str_data[27], tipo_cam, prefactura_fila.moneda_id, str_data[3]::integer, emp_id, suc_id, prefactura_fila.proceso_id);
			
			
			--crea registro en erp_h_facturas
			INSERT INTO erp_h_facturas(
				cliente_id,--prefactura_fila.cliente_id,
				cxc_agen_id,--prefactura_fila.empleado_id,
				serie_folio,--serie_folio_fac,
				monto_total,--prefactura_fila.fac_total,
				saldo_factura,--prefactura_fila.fac_total,
				moneda_id,--prefactura_fila.moneda_id,
				tipo_cambio,--tipo_cam,
				momento_facturacion,--espacio_tiempo_ejecucion,
				fecha_vencimiento,--fecha_de_vencimiento,
				subtotal,--prefactura_fila.fac_subtotal,
				monto_ieps, --prefactura_fila.fac_monto_ieps,
				impuesto,--prefactura_fila.fac_impuesto,
				retencion,--prefactura_fila.fac_monto_retencion,
				orden_compra,--prefactura_fila.orden_compra,
				id_usuario_creacion, --usuario_ejecutor,
				empresa_id, --emp_id,
				sucursal_id--suc_id
			)VALUES(prefactura_fila.cliente_id, prefactura_fila.empleado_id, serie_folio_fac, prefactura_fila.fac_total, prefactura_fila.fac_total, prefactura_fila.moneda_id, tipo_cam, espacio_tiempo_ejecucion, fecha_de_vencimiento, prefactura_fila.fac_subtotal, prefactura_fila.fac_monto_ieps, prefactura_fila.fac_impuesto, prefactura_fila.fac_monto_retencion, prefactura_fila.orden_compra, usuario_ejecutor, emp_id, suc_id);
			
			--select translate('2012-12-05T13:47:12','T',' ')::timestamp with time zone
			
			if trim(str_data[30])='' then 
				str_data[30]:='0';
			end if;
			
			--Crea registros en la tabla fac_docs
			INSERT INTO fac_docs(
				serie_folio,--serie_folio_fac,
				folio_pedido,--prefactura_fila.folio_pedido,
				cxc_clie_id,--prefactura_fila.cliente_id,
				moneda_id,--prefactura_fila.moneda_id,
				subtotal,--prefactura_fila.fac_subtotal,
				monto_ieps,--prefactura_fila.fac_monto_ieps,
				impuesto,--prefactura_fila.fac_impuesto,
				monto_retencion,--prefactura_fila.fac_monto_retencion,
				total,--prefactura_fila.fac_total,
				tasa_retencion_immex,--prefactura_fila.tasa_retencion_immex,
				tipo_cambio,--tipo_cam,
				proceso_id,--prefactura_fila.proceso_id,
				cxc_agen_id,--prefactura_fila.empleado_id,
				terminos_id,--prefactura_fila.terminos_id,
				fecha_vencimiento,--fecha_de_vencimiento
				orden_compra,--prefactura_fila.orden_compra,
				observaciones, --prefactura_fila.observaciones,
				fac_metodos_pago_id, --prefactura_fila.fac_metodos_pago_id,
				no_cuenta, --prefactura_fila.no_cuenta,
				enviar_ruta,--prefactura_fila.enviar_ruta,
				inv_alm_id,--prefactura_fila.inv_alm_id
				cxc_clie_df_id,--prefactura_fila.cxc_clie_df_id,
				momento_creacion,--translate(str_data[13],'T',' ')::timestamp with time zone,,
				gral_usr_id_creacion, --usuario_ejecutor,
				ref_id, --str_data[28] 
				monto_descto, --prefactura_fila.fac_monto_descto
				motivo_descto, --prefactura_fila.motivo_descto,
				subtotal_sin_descto, --str_data[30]::double precision 
				ctb_tmov_id --prefactura_fila.ctb_tmov_id 
			)VALUES(serie_folio_fac, prefactura_fila.folio_pedido, prefactura_fila.cliente_id, prefactura_fila.moneda_id, prefactura_fila.fac_subtotal, prefactura_fila.fac_monto_ieps, prefactura_fila.fac_impuesto, prefactura_fila.fac_monto_retencion, prefactura_fila.fac_total, prefactura_fila.tasa_retencion_immex, tipo_cam, prefactura_fila.proceso_id, prefactura_fila.empleado_id, prefactura_fila.terminos_id, fecha_de_vencimiento, prefactura_fila.orden_compra, prefactura_fila.observaciones, prefactura_fila.fac_metodos_pago_id, prefactura_fila.no_cuenta, prefactura_fila.enviar_ruta, prefactura_fila.inv_alm_id, prefactura_fila.cxc_clie_df_id, translate(str_data[13],'T',' ')::timestamp with time zone, usuario_ejecutor, str_data[28], prefactura_fila.fac_monto_descto, prefactura_fila.motivo_descto, str_data[30]::double precision,prefactura_fila.ctb_tmov_id) 
			RETURNING id INTO ultimo_id;
			
			
			--Guarda la cadena del xml timbrado
			INSERT INTO fac_cfdis(tipo, ref_id, doc, gral_emp_id, gral_suc_id, fecha_crea, gral_usr_id_crea) 
			VALUES (1,str_data[28],str_data[29]::text,emp_id,suc_id,translate(str_data[13],'T',' ')::timestamp with time zone, usuario_ejecutor);
			
			
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			--Inicia gaurdar datos para la Adenda
			--Primero se verifica si en los parametros indica que se debe incluir la Adenda
			IF facpar.incluye_adenda THEN 
				
				--Verificar que exista un id de cliente valido
				IF prefactura_fila.cliente_id > 1 THEN 
					--Buscar el numero de Adenda asignado al cliente.
					SELECT cxc_clie_tipo_adenda_id FROM cxc_clie WHERE id=prefactura_fila.cliente_id INTO idAdenda;
					
					--Varificar si tiene adenda asignada
					IF idAdenda > 0 THEN 
						--Verificar el numero de adenda
						IF idAdenda=1 THEN 
							--Si el numero de Adenda es 1, entonces solo debe se debe validar datos cuando el tipo de documento es igual a 3.
							--Tipo Documento 3=Factura de Remision
							IF prefactura_fila.tipo_documento::integer=3 THEN 
								--Verificar si ya hay un registro de la Adenda y que no este ligado a una factura, es decir no ha sido facturado
								IF (SELECT count(id) FROM fac_docs_adenda WHERE prefactura_id=prefactura_fila.id AND fac_docs_id=0)>0 THEN 
									--Actualizar datos de la adenda porque ya existe un registro
									UPDATE fac_docs_adenda SET fac_docs_id=ultimo_id
									WHERE prefactura_id=prefactura_fila.id AND fac_docs_id=0;
								END IF;
							END IF;
						END IF;
						
						--Addenda SUN CHEMICAL
						IF idAdenda=2 THEN 
							--Tipo Documento 1:Factura, 3=Factura de Remision
							IF prefactura_fila.tipo_documento::integer=1 OR prefactura_fila.tipo_documento::integer=3 THEN 
								--Verificar si ya hay un registro de la Adenda y que no este ligado a una factura, es decir no ha sido facturado
								IF (SELECT count(id) FROM fac_docs_adenda WHERE prefactura_id=prefactura_fila.id AND fac_docs_id=0)>0 THEN 
									--Actualizar datos de la adenda porque ya existe un registro
									UPDATE fac_docs_adenda SET fac_docs_id=ultimo_id
									WHERE prefactura_id=prefactura_fila.id AND fac_docs_id=0;
								END IF;
							END IF;
						END IF;
						--Termina Addenda SUN CHEMICAL
						
					END IF;
				END IF;
			END IF;
			--Termina Guardar datos Adenda
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			



			
			--bandera que identifica si el producto es tipo 4
			--si es tipo 4 no debe existir movimientos en inventario
			bandera_tipo_4=TRUE;
			tipo_movimiento_id:=5;--Salida por Venta
			id_tipo_consecutivo:=21; --Folio Orden de Salida
			id_almacen := prefactura_fila.inv_alm_id;--almacen de donde se hara la salida
			
			--Bandera que indica si se debe actualizar el flujo del proceso.
			--El proceso solo debe actualizarse cuando no quede ni una sola partida viva
			actualizar_proceso:=true;
			
			--refact=false:No es refacturacion
			--tipo_documento=1:Factura
			IF refact='false' AND prefactura_fila.tipo_documento=1 THEN
				
				--aqui entra para tomar el consecutivo del folio  la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				--suc_id_consecutivo
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
				
				--genera registro en tabla inv_osal(Orden de Salida)
				INSERT INTO inv_osal(folio,estatus,erp_proceso_id,inv_mov_tipo_id,tipo_documento,folio_documento,fecha_exp,gral_app_id,cxc_clie_id,inv_alm_id,subtotal,monto_iva,monto_retencion,monto_total,folio_pedido,orden_compra,moneda_id,tipo_cambio,momento_creacion,gral_usr_id_creacion, gral_emp_id, gral_suc_id, monto_ieps)
				VALUES(nuevo_folio,0,prefactura_fila.proceso_id,tipo_movimiento_id,tipo_de_documento,serie_folio_fac,espacio_tiempo_ejecucion,app_selected,prefactura_fila.cliente_id,id_almacen, prefactura_fila.fac_subtotal, prefactura_fila.fac_impuesto, prefactura_fila.fac_monto_retencion, prefactura_fila.fac_total, prefactura_fila.folio_pedido,prefactura_fila.orden_compra,prefactura_fila.moneda_id,tipo_cam,espacio_tiempo_ejecucion,usuario_ejecutor, emp_id, suc_id, prefactura_fila.fac_monto_ieps)
				RETURNING id INTO id_osal;
				
				--genera registro del movimiento
				INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id, gral_app_id,inv_mov_tipo_id, referencia, fecha_mov ) 
				VALUES(prefactura_fila.observaciones,espacio_tiempo_ejecucion,usuario_ejecutor,app_selected, tipo_movimiento_id, serie_folio_fac, translate(str_data[13],'T',' ')::timestamp with time zone) 
				RETURNING id INTO identificador_nuevo_movimiento;
				
			END IF;
			
			/*
			--tipo_documento 3=Factura de remision
			IF prefactura_fila.tipo_documento=3 THEN 
				--buscar numero de remision que se incluyeron en esta factura
				sql_select:='SELECT DISTINCT fac_rem_id FROM fac_rems_docs WHERE erp_proceso_id = '||prefactura_fila.proceso_id;
				
				FOR fila_fac_rem_doc IN EXECUTE(sql_select) LOOP
					--asignar facturado a cada remision
					UPDATE fac_rems SET facturado=TRUE WHERE id=fila_fac_rem_doc.fac_rem_id;
				END LOOP;
			END IF;
			*/
			
			--obtiene lista de productos de la prefactura
			sql_select:='';
			sql_select:='
			SELECT  erp_prefacturas_detalles.id AS id_det,
				erp_prefacturas_detalles.producto_id,
				erp_prefacturas_detalles.presentacion_id,
				erp_prefacturas_detalles.cantidad AS cant_pedido,
				erp_prefacturas_detalles.cant_facturado,
				erp_prefacturas_detalles.cant_facturar AS cantidad,
				erp_prefacturas_detalles.tipo_impuesto_id,
				erp_prefacturas_detalles.valor_imp,
				erp_prefacturas_detalles.precio_unitario,
				inv_prod.tipo_de_producto_id as tipo_producto,
				erp_prefacturas_detalles.costo_promedio,
				erp_prefacturas_detalles.costo_referencia, 
				erp_prefacturas_detalles.reservado,
				erp_prefacturas_detalles.reservado AS nuevo_reservado,
				(CASE WHEN inv_prod_presentaciones.id IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
				(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec,
				inv_prod.unidad_id AS id_uni_prod,
				inv_prod.densidad AS densidad_prod,
				inv_prod_unidades.titulo AS nombre_unidad,
				erp_prefacturas_detalles.inv_prod_unidad_id,
				erp_prefacturas_detalles.gral_ieps_id,
				erp_prefacturas_detalles.valor_ieps,
				(CASE WHEN erp_prefacturas_detalles.descto IS NULL THEN 0 ELSE erp_prefacturas_detalles.descto END) AS descto,
				(CASE WHEN erp_prefacturas_detalles.fac_rem_det_id IS NULL THEN 0 ELSE erp_prefacturas_detalles.fac_rem_det_id END) AS fac_rem_det_id,
				erp_prefacturas_detalles.gral_imptos_ret_id,
				erp_prefacturas_detalles.tasa_ret  
			FROM erp_prefacturas_detalles 
			JOIN inv_prod ON inv_prod.id=erp_prefacturas_detalles.producto_id
			LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
			LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=erp_prefacturas_detalles.presentacion_id 
			WHERE erp_prefacturas_detalles.cant_facturar>0 
			AND erp_prefacturas_detalles.prefacturas_id='||str_data[4]::integer||';';
			--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
			
			FOR prefactura_detalle IN EXECUTE(sql_select) LOOP
				--Inicializar valores
				cantPresReservAnterior:=0;
				cantPresAsignado:=0;
				partida_facturada:=false;
				
				--tipo_documento 3=Factura de remision
				IF prefactura_fila.tipo_documento::integer = 3 THEN 
					--toma el costo promedio que viene de la prefactura
					costo_promedio_actual := prefactura_detalle.costo_promedio;
					costo_referencia_actual := prefactura_detalle.costo_referencia;
				ELSE
					--Obtener costo promedio actual del producto. El costo promedio es en MN.
					SELECT * FROM inv_obtiene_costo_promedio_actual(prefactura_detalle.producto_id, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
					
					--Obtener el costo ultimo actual del producto. Este costo es convertido a pesos
					sql_select2 := 'SELECT (CASE WHEN gral_mon_id_'||mes_actual||'=1 THEN costo_ultimo_'||mes_actual||'  ELSE costo_ultimo_'||mes_actual||' * (CASE WHEN gral_mon_id_'||mes_actual||'=1 THEN 1 ELSE tipo_cambio_'||mes_actual||' END) END) AS costo_ultimo FROM inv_prod_cost_prom WHERE inv_prod_id='||prefactura_detalle.producto_id||' AND ano='||ano_actual||';';
					EXECUTE sql_select2 INTO costo_referencia_actual;
				END IF;
				
				--Verificar que no tenga valor null
				IF costo_promedio_actual IS NULL OR costo_promedio_actual<=0 THEN costo_promedio_actual:=0; END IF;
				IF costo_referencia_actual IS NULL OR costo_referencia_actual<=0 THEN costo_referencia_actual:=0; END IF;
				
				cantUnidadProd:=0;
				
				idUnidadMedida:=prefactura_detalle.id_uni_prod;
				densidadProd:=prefactura_detalle.densidad_prod;
				nombreUnidadMedida:=prefactura_detalle.nombre_unidad;
				IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
				
				cantUnidadProd := prefactura_detalle.cantidad::double precision;
				
				IF facpar.cambiar_unidad_medida THEN
					IF idUnidadMedida::integer<>prefactura_detalle.inv_prod_unidad_id THEN
						EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
						IF match_cadena=true THEN
							--Convertir a kilos
							cantUnidadProd := cantUnidadProd::double precision * densidadProd;
						ELSE
							EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
							IF match_cadena=true THEN 
								--Convertir a Litros
								cantUnidadProd := cantUnidadProd::double precision / densidadProd;
							END IF;
						END IF;
					END IF;
				END IF;
				
				
				--Redondear cantidades
				prefactura_detalle.cant_pedido := round(prefactura_detalle.cant_pedido::numeric,prefactura_detalle.no_dec)::double precision;
				prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
				prefactura_detalle.cantidad := round(prefactura_detalle.cantidad::numeric,prefactura_detalle.no_dec)::double precision;
				prefactura_detalle.reservado := round(prefactura_detalle.reservado::numeric,prefactura_detalle.no_dec)::double precision;
				prefactura_detalle.nuevo_reservado := round(prefactura_detalle.nuevo_reservado::numeric,prefactura_detalle.no_dec)::double precision;
				
				IF (cantUnidadProd::double precision <= prefactura_detalle.reservado::double precision) THEN 
					--Asignar la cantidad para descontar de reservado
					prefactura_detalle.reservado := cantUnidadProd::double precision;
				END IF;
				
				--Calcular la nueva cantidad reservada
				prefactura_detalle.nuevo_reservado := prefactura_detalle.nuevo_reservado::double precision - prefactura_detalle.reservado::double precision;
				
				--Redondaer la nueva cantidad reservada
				prefactura_detalle.nuevo_reservado := round(prefactura_detalle.nuevo_reservado::numeric,prefactura_detalle.no_dec)::double precision;
				
				--crea registro en fac_docs_detalles
				INSERT INTO fac_docs_detalles(fac_doc_id,inv_prod_id,inv_prod_presentacion_id,gral_imptos_id,valor_imp,cantidad,precio_unitario,costo_promedio, costo_referencia, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, gral_imptos_ret_id, tasa_ret)
				VALUES(ultimo_id,prefactura_detalle.producto_id,prefactura_detalle.presentacion_id,prefactura_detalle.tipo_impuesto_id,prefactura_detalle.valor_imp,prefactura_detalle.cantidad,prefactura_detalle.precio_unitario, costo_promedio_actual, costo_referencia_actual, prefactura_detalle.inv_prod_unidad_id, prefactura_detalle.gral_ieps_id, prefactura_detalle.valor_ieps, prefactura_detalle.descto, prefactura_detalle.gral_imptos_ret_id, prefactura_detalle.tasa_ret)
				RETURNING id INTO ultimo_id_det;
				
				IF refact='false'  AND prefactura_fila.tipo_documento::integer=1 THEN
					--Si el tipo de producto es diferente de 4 el hay que descontar existencias y generar Movimientos
					--tipo=4 Servicios
					--para el tipo servicios NO debe generar movimientos NI descontar existencias
					IF prefactura_detalle.tipo_producto::integer<>4 THEN
						
						bandera_tipo_4=FALSE;--indica que por lo menos un producto es diferente de tipo4, por lo tanto debe generarse movimientos
						
						--tipo=1 Normal o Terminado
						--tipo=2 Subensable o Formulacion o Intermedio
						--tipo=5 Refacciones
						--tipo=6 Accesorios
						--tipo=7 Materia Prima
						--tipo=8 Prod. en Desarrollo
						
						--tipo=3 Kit
						--tipo=4 Servicios
						--IF prefactura_detalle.tipo_producto=1 OR prefactura_detalle.tipo_producto=2 OR prefactura_detalle.tipo_producto=5 OR prefactura_detalle.tipo_producto=6 OR prefactura_detalle.tipo_producto=7 OR prefactura_detalle.tipo_producto=8 THEN
						IF prefactura_detalle.tipo_producto::integer<>3 AND  prefactura_detalle.tipo_producto::integer<>4 THEN
							--Genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id, costo, inv_prod_presentacion_id)
							VALUES(prefactura_detalle.producto_id, id_almacen,0, cantUnidadProd, identificador_nuevo_movimiento, costo_promedio_actual, prefactura_detalle.presentacion_id);
							
							--Query para descontar producto de existencias y descontar existencia reservada porque ya se Factur√≥
							sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||cantUnidadProd||'::double precision), 
							reservado=(reservado::double precision - '||prefactura_detalle.reservado||'::double precision), momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
							WHERE inv_alm_id='||id_almacen||'::integer AND inv_prod_id='||prefactura_detalle.producto_id||'::integer AND ano='||ano_actual||'::integer;';
							EXECUTE sql_update;
							IF FOUND THEN
								--RAISE EXCEPTION '%','FOUND'||FOUND;
							ELSE
								RAISE EXCEPTION '%','NOT FOUND:'||FOUND||'  No se pudo actualizar inv_exi';
							END IF;
							
							--Crear registro en orden salida detalle
							--La cantidad se almacena en la unidad de venta
							INSERT INTO inv_osal_detalle(inv_osal_id,inv_prod_id,inv_prod_presentacion_id,cantidad,precio_unitario, inv_prod_unidad_id, gral_ieps_id, valor_ieps)
							VALUES(id_osal,prefactura_detalle.producto_id,prefactura_detalle.presentacion_id,prefactura_detalle.cantidad,prefactura_detalle.precio_unitario, prefactura_detalle.inv_prod_unidad_id, prefactura_detalle.gral_ieps_id, prefactura_detalle.valor_ieps);
							
							
							--Verificar si se est√° llevando el control de existencias por Presentaciones
							IF controlExisPres=true THEN 
								--Si la configuracion indica que se validan Presentaciones desde el Pedido,entonces significa que hay reservados, por lo tanto hay que descontarlos
								IF facpar.validar_pres_pedido=true THEN 
									--Convertir la cantidad reservada a su equivalente en presentaciones
									cantPresReservAnterior := prefactura_detalle.reservado::double precision / prefactura_detalle.cant_equiv::double precision;
									
									--redondear la Cantidad de la Presentacion reservada Anteriormente
									cantPresReservAnterior := round(cantPresReservAnterior::numeric,prefactura_detalle.no_dec)::double precision; 
								END IF;
								
								--Convertir la cantidad de la partida a su equivalente a presentaciones
								cantPresAsignado := cantUnidadProd::double precision / prefactura_detalle.cant_equiv::double precision;
								
								--Redondear la cantidad de Presentaciones asignado en la partida
								cantPresAsignado := round(cantPresAsignado::numeric,prefactura_detalle.no_dec)::double precision;
								
								--Sumar salidas de inv_exi_pres
								UPDATE inv_exi_pres SET 
									salidas=(salidas::double precision + cantPresAsignado::double precision), reservado=(reservado::double precision - cantPresReservAnterior::double precision), 
									momento_actualizacion=translate(str_data[13],'T',' ')::timestamp with time zone, gral_usr_id_actualizacion=usuario_ejecutor 
								WHERE inv_alm_id=id_almacen AND inv_prod_id=prefactura_detalle.producto_id AND inv_prod_presentacion_id=prefactura_detalle.presentacion_id;
								--Termina sumar salidas
							END IF;
							
							
							
							--::Aqui inica calculos para el control de facturacion por partida::::::::
							--Calcular la cantidad facturada
							prefactura_detalle.cant_facturado:=prefactura_detalle.cant_facturado::double precision + prefactura_detalle.cantidad::double precision;
							
							--Redondear la cantidad facturada
							prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
							
							IF prefactura_detalle.cant_pedido <= prefactura_detalle.cant_facturado THEN 
								partida_facturada:=true;
							ELSE
								--Si entro aqui quiere decir que por lo menos una partida esta quedando pendiente de facturar por completo.
								actualizar_proceso:=false;
							END IF;
							
							--RAISE EXCEPTION '%','cant_pedido:'||prefactura_detalle.cant_pedido||'    cant_facturado:'||prefactura_detalle.cant_facturado;
							--RAISE EXCEPTION '%','partida_facturada'||partida_facturada;
							
							--Actualizar el registro de la partida
							UPDATE erp_prefacturas_detalles SET cant_facturado=prefactura_detalle.cant_facturado, facturado=partida_facturada, cant_facturar=0, reservado=prefactura_detalle.nuevo_reservado 
							WHERE id=prefactura_detalle.id_det;
							
							
							--Obtener el id del pedido que se esta facturando
							SELECT id FROM poc_pedidos WHERE folio=prefactura_fila.folio_pedido ORDER BY id DESC LIMIT 1 INTO id_pedido;
							
							IF id_pedido IS NULL THEN id_pedido:=0; END IF;
							
							IF id_pedido<>0 THEN 
								--Actualizar el registro detalle del Pedido
								UPDATE poc_pedidos_detalle SET reservado=prefactura_detalle.nuevo_reservado 
								WHERE poc_pedido_id=id_pedido AND inv_prod_id=prefactura_detalle.producto_id AND presentacion_id=prefactura_detalle.presentacion_id;
							END IF;
							
						END IF;--termina tipo producto 1, 2, 7
					ELSE
						IF prefactura_detalle.tipo_producto::integer=4 THEN
							--::Aqui inica calculos para el control de facturacion por partida::::::::
							--Calcular la cantidad facturada
							prefactura_detalle.cant_facturado:=prefactura_detalle.cant_facturado::double precision + prefactura_detalle.cantidad::double precision;
							
							--Redondear la cantidad facturada
							prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
							
							IF prefactura_detalle.cant_pedido <= prefactura_detalle.cant_facturado THEN 
								partida_facturada:=true;
							END IF;
							--Actualizar el registro de la partida
							UPDATE erp_prefacturas_detalles SET 
								cant_facturado=prefactura_detalle.cant_facturado, 
								facturado=partida_facturada, 
								cant_facturar=0 
							WHERE id=prefactura_detalle.id_det;
						END IF;
					END IF;
					--Termina verificacion diferente de tipo 4
				ELSE
					--tipo_documento 3=Factura de remision
					IF prefactura_fila.tipo_documento::integer = 3 THEN 
						--::Aqui inica calculos para el control de facturacion por partida::::::::
						--Calcular la cantidad facturada
						prefactura_detalle.cant_facturado:=prefactura_detalle.cant_facturado::double precision + prefactura_detalle.cantidad::double precision;
						
						--Redondear la cantidad facturada
						prefactura_detalle.cant_facturado := round(prefactura_detalle.cant_facturado::numeric,prefactura_detalle.no_dec)::double precision;
						
						IF prefactura_detalle.cant_pedido <= prefactura_detalle.cant_facturado THEN 
							partida_facturada:=true;
						ELSE
							--Si entro aqui quiere decir que por lo menos una partida esta quedando pendiente de facturar por completo.
							actualizar_proceso:=false;
						END IF;
						
						--RAISE EXCEPTION '%','cant_pedido:'||prefactura_detalle.cant_pedido||'    cant_facturado:'||prefactura_detalle.cant_facturado;
						--RAISE EXCEPTION '%','partida_facturada'||partida_facturada;
						
						--Actualizar el registro de la partida
						UPDATE erp_prefacturas_detalles SET cant_facturado=prefactura_detalle.cant_facturado, facturado=partida_facturada, cant_facturar=0, reservado=0 
						WHERE id=prefactura_detalle.id_det;

						--Crear registros para relacionar las partidas de la Remision con las partidas de las facturas.
						INSERT INTO fac_rem_doc_det(fac_doc_id, fac_doc_det_id,fac_rem_det_id)
						VALUES(ultimo_id, ultimo_id_det, prefactura_detalle.fac_rem_det_id);
						
					END IF;
				END IF; 
				--termina if que verifica si es refacturacion

				/*
				--tipo_documento 3=Factura de remision
				IF prefactura_fila.tipo_documento::integer = 3 THEN 
					--Actualizar el registro de la partida, cuando es Factura de remision se factura toda la partida
					UPDATE erp_prefacturas_detalles SET cant_facturado=cantidad, facturado=true, cant_facturar=0, reservado=0 
					WHERE id=prefactura_detalle.id_det;
				END IF;
				*/
			END LOOP;
			
			--si bandera tipo 4=true, significa el producto que se esta facturando son servicios;
			--por lo tanto hay que eliminar el movimiento de inventario
			IF bandera_tipo_4=TRUE THEN 
				--refact=false:No es refacturacion
				--tipo_documento=1:Factura
				IF refact='false' AND prefactura_fila.tipo_documento=1 THEN
					DELETE FROM inv_mov WHERE id=identificador_nuevo_movimiento;
				END IF;
			END IF;
			
			IF (SELECT count(prefact_det.id) FROM erp_prefacturas_detalles AS prefact_det JOIN inv_prod ON inv_prod.id=prefact_det.producto_id WHERE prefact_det.prefacturas_id=str_data[4]::integer AND inv_prod.tipo_de_producto_id<>4 AND prefact_det.facturado=false )>=1 THEN
				actualizar_proceso:=false;
			END IF;
			
			--Verificar si hay que actualizar el flujo del proceso
			IF actualizar_proceso THEN 
				--Actualiza el flujo del proceso a 3=Facturado
				UPDATE erp_proceso SET proceso_flujo_id=3 WHERE id=prefactura_fila.proceso_id;
			ELSE
				--Actualiza el flujo del proceso a 7=FACTURA PARCIAL
				UPDATE erp_proceso SET proceso_flujo_id=7 WHERE id=prefactura_fila.proceso_id;
			END IF;

			

			--tipo_documento 3=Factura de remision
			IF prefactura_fila.tipo_documento=3 THEN 
				--buscar numero de remision que se incluyeron en esta factura
				sql_select:='SELECT DISTINCT fac_rem_id FROM fac_rems_docs WHERE erp_proceso_id = '||prefactura_fila.proceso_id;
				
				FOR fila_fac_rem_doc IN EXECUTE(sql_select) LOOP
					IF (SELECT count(fac_rems_docs.id) as exis FROM fac_rems_docs JOIN erp_prefacturas ON erp_prefacturas.proceso_id = fac_rems_docs.erp_proceso_id JOIN erp_prefacturas_detalles ON erp_prefacturas_detalles.prefacturas_id = erp_prefacturas.id WHERE (erp_prefacturas_detalles.cantidad::double precision - erp_prefacturas_detalles.cant_facturado::double precision)>0 AND fac_rems_docs.fac_rem_id = fila_fac_rem_doc.fac_rem_id)<=0 THEN 
						--Asignar facturado a cada remision
						UPDATE fac_rems SET facturado=TRUE WHERE id=fila_fac_rem_doc.fac_rem_id;
					END IF; 
					
				END LOOP;
				
			END IF;
			
			--Una vez terminado el Proceso se asignan ceros a estos campos
			UPDATE erp_prefacturas SET fac_subtotal=0, fac_impuesto=0, fac_monto_retencion=0, fac_total=0, fac_monto_ieps=0, fac_monto_descto=0 
			WHERE id=str_data[4]::integer;
			
			--Actualiza el consecutivo del folio de la factura en la tabla fac_cfds_conf_folios. La actualizaci√≥n es por Empresa-sucursal
			UPDATE fac_cfds_conf_folios SET folio_actual=(folio_actual+1) WHERE id=(SELECT fac_cfds_conf_folios.id FROM fac_cfds_conf JOIN fac_cfds_conf_folios ON fac_cfds_conf_folios.fac_cfds_conf_id=fac_cfds_conf.id WHERE fac_cfds_conf_folios.proposito='FAC' AND fac_cfds_conf.empresa_id=emp_id AND fac_cfds_conf.gral_suc_id=suc_id);
			
			valor_retorno := '1:'||ultimo_id;--retorna el id de fac_docs
			
		END IF;
		--:::::: TERMINA GENERACION DE FACTURA VERSION CFDI TIMBRE FISCAL ::::::::::::::::::::::::::::::::::::::::::::::
		--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		
		
	END IF;--termina prefacturas(FACTURACION)
	
	
	
	
	
	
	
	
	
	
	
	
	
	-- Aplicativo Cancelacion de Facturas
	IF app_selected = 36 THEN 
		--Cancelacion de una factura
		IF command_selected = 'cancelacion' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_fac_docs
			--str_data[5]	tipo_cancelacion
			--str_data[6]	motivo_cancelacion
			--str_data[7]	tmov
			
			if str_data[7] is null then 
				str_data[7]='0';
			end if;
			
			--Obtiene todos los datos de la factura
			SELECT fac_docs.*  FROM fac_docs WHERE fac_docs.id=str_data[4]::integer LIMIT 1 INTO factura_fila;
			
			--Cancela registro en fac_docs
			UPDATE fac_docs SET cancelado=TRUE, fac_docs_tipo_cancelacion_id=str_data[5]::integer,motivo_cancelacion=str_data[6], ctb_tmov_id_cancelacion=str_data[7]::integer, momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancelacion=usuario_ejecutor 
			WHERE id=factura_fila.id
			RETURNING inv_alm_id INTO id_almacen;
			
			UPDATE fac_cfdis SET cancelado=TRUE, fecha_cancela=espacio_tiempo_ejecucion, gral_usr_id_cancela=usuario_ejecutor 
			WHERE ref_id=factura_fila.ref_id AND gral_emp_id=emp_id;
			
  
			-- Cambia estado del comprobante a 0
			UPDATE fac_cfds SET estado_del_comprobante='0', fac_docs_tipo_cancelacion_id=str_data[5]::integer, momento_cancelacion=espacio_tiempo_ejecucion, motivo_cancelacion=str_data[6], id_user_cancela=usuario_ejecutor
			WHERE fac_cfds.proceso_id = factura_fila.proceso_id AND fac_cfds.serie_folio=factura_fila.serie_folio;
			
			--Cancela registro en h_facturas
			UPDATE erp_h_facturas SET cancelacion=TRUE, fac_docs_tipo_cancelacion_id=str_data[5]::integer, momento_cancelacion=espacio_tiempo_ejecucion, id_usuario_cancelacion=usuario_ejecutor
			WHERE serie_folio ILIKE factura_fila.serie_folio; 
			
			--Bandera que identifica si el producto es tipo 4
			--Si es tipo 4 no debe existir movimientos en inventario
			bandera_tipo_4=TRUE;
			
			--Verifica tipo de cancelacion
			IF str_data[5]::integer=1 THEN
				--Aqui entra cuando es cancelacion total
				
				--AQUI INICIA DEVOLUCION DE PRODUCTOS AL INVENTARIO
				--genera registro del movimiento de cancelacion
				tipo_movimiento_id:=2;--DEVOLUCION POR CANCELACION DE FACTURA
				INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id,gral_app_id, inv_mov_tipo_id, referencia, fecha_mov) 
				VALUES(str_data[6],espacio_tiempo_ejecucion,usuario_ejecutor,app_selected,tipo_movimiento_id, factura_fila.serie_folio, espacio_tiempo_ejecucion) 
				RETURNING id INTO identificador_nuevo_movimiento;
				
				--Obtiene lista de productos de la factura
				sql_select:='
				SELECT fac_docs_detalles.inv_prod_id,
					(fac_docs_detalles.cantidad::double precision - cantidad_devolucion::double precision) AS cantidad,
					inv_prod.tipo_de_producto_id as tipo_producto,
					fac_docs_detalles.inv_prod_presentacion_id AS presentacion_id,
					(CASE WHEN inv_prod_presentaciones.id IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
					(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec,
					inv_prod.unidad_id AS id_uni_prod,
					inv_prod.densidad AS densidad_prod,
					inv_prod_unidades.titulo AS nombre_unidad,
					fac_docs_detalles.inv_prod_unidad_id 
				FROM fac_docs_detalles 
				JOIN inv_prod ON inv_prod.id=fac_docs_detalles.inv_prod_id
				LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=fac_docs_detalles.inv_prod_presentacion_id 
				WHERE fac_docs_detalles.fac_doc_id='||str_data[4]::integer;
				
				--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
				FOR factura_detalle IN EXECUTE(sql_select) LOOP
					cantUnidadProd:=0;
					cantUnidadProd:=0;
					
					idUnidadMedida:=factura_detalle.id_uni_prod;
					densidadProd:=factura_detalle.densidad_prod;
					nombreUnidadMedida:=factura_detalle.nombre_unidad;
					IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
					
					--Tomar la cantidad en la Unidad de Venta
					cantUnidadVenta := factura_detalle.cantidad::double precision;
					
					IF facpar.cambiar_unidad_medida THEN
						IF idUnidadMedida::integer<>factura_detalle.inv_prod_unidad_id THEN
							EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
							IF match_cadena=true THEN
								--Convertir a kilos
								factura_detalle.cantidad := factura_detalle.cantidad::double precision * densidadProd;
							ELSE
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
								IF match_cadena=true THEN 
									--Convertir a Litros
									factura_detalle.cantidad := factura_detalle.cantidad::double precision / densidadProd;
								END IF;
							END IF;
						END IF;
					END IF;
					
					--Si el tipo de producto es diferente de 4, hay que devolver existencias y generar Movimientos
					--tipo=4 Servicios
					--para el tipo servicios debe generar movimientos ni devolver existencias
					IF factura_detalle.tipo_producto<>4 THEN
						bandera_tipo_4=FALSE;--indica que por lo menos un producto es diferente de tipo4, por lo tanto debe generarse movimientos
						
						--tipo=1 Normal o Terminado
						--tipo=2 Subensable o Formulacion o Intermedio
						--tipo=5 Refacciones
						--tipo=6 Accesorios
						--tipo=7 Materia Prima
						--tipo=8 Prod. en Desarrollo
						IF factura_detalle.tipo_producto=1 OR factura_detalle.tipo_producto=2 OR factura_detalle.tipo_producto=5 OR factura_detalle.tipo_producto=6 OR factura_detalle.tipo_producto=7 OR factura_detalle.tipo_producto=8 THEN
							--Redondear la cantidad
							factura_detalle.cantidad := round(factura_detalle.cantidad::numeric,factura_detalle.no_dec)::double precision;
							
							--genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id, inv_prod_presentacion_id)
							VALUES(factura_detalle.inv_prod_id, 0,id_almacen, factura_detalle.cantidad, identificador_nuevo_movimiento, factura_detalle.presentacion_id);
							
							--reiniciamos las variables
							exis:=0;
							sql_select:='';
							
							--query para verificar existencia del producto en el almacen y en el a√±o actual
							sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id='||factura_detalle.inv_prod_id||' AND inv_alm_id='||id_almacen||' AND ano = '||ano_actual||';';
							--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
							EXECUTE sql_select INTO exis;
							
							IF exis >0 THEN
								sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||factura_detalle.cantidad||'::double precision),momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
								WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||factura_detalle.inv_prod_id||' AND ano='||ano_actual||';';
								EXECUTE sql_update;
							ELSE
								sql_insert:='INSERT INTO inv_exi (inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial) '||
								'VALUES('||factura_detalle.inv_prod_id||','||id_almacen||','||ano_actual||','||factura_detalle.cantidad||','''|| espacio_tiempo_ejecucion ||''',0)';
								EXECUTE sql_insert;
							END IF;
							
							--Verificar si se est√° llevando el control de existencias por Presentaciones
							IF controlExisPres=true THEN 							
								--Convertir la cantidad de la partida a su equivalente a presentaciones
								cantPresAsignado := factura_detalle.cantidad::double precision / factura_detalle.cant_equiv::double precision;
								
								--Redondear la cantidad de Presentaciones asignado en la partida
								cantPresAsignado := round(cantPresAsignado::numeric,factura_detalle.no_dec)::double precision;
								
								exis:=0;
								sql_select:='';
								
								--query para verificar existencia del producto en el almacen y en el a√±o actual
								sql_select := 'SELECT count(id) FROM inv_exi_pres WHERE inv_prod_id='||factura_detalle.inv_prod_id||' AND inv_alm_id='||id_almacen||' AND inv_prod_presentacion_id = '||factura_detalle.presentacion_id||';';
								--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
								EXECUTE sql_select INTO exis;
								
								--Sumar entradas de inv_exi_pres
								IF exis>0 THEN 
									UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantPresAsignado::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
									WHERE inv_alm_id=id_almacen AND inv_prod_id=factura_detalle.inv_prod_id AND inv_prod_presentacion_id=factura_detalle.presentacion_id;
								ELSE
									INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, inicial, momento_creacion, gral_usr_id_creacion, entradas )
									VALUES(id_almacen,factura_detalle.inv_prod_id,factura_detalle.presentacion_id,0, espacio_tiempo_ejecucion,usuario_ejecutor,cantPresAsignado::double precision);
								END IF;
								--Termina sumar entradas
								
								exis:=0;
							END IF;
						END IF;--termina tipo producto normal y subensamble
					END IF;--termina validacion tipo 4
				END LOOP;
				
				IF bandera_tipo_4=TRUE THEN 
					--la factura es de un producto tipo 4, por lo tanto se elimina el movimiento generado anteriormente
					DELETE FROM inv_mov WHERE id=identificador_nuevo_movimiento;
				END IF;
				
				--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
				--INICIA CANCELACION DE ORDEN DE SALIDA
				--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
				--Obtener datos de la orden de salida que genero esta factura
				SELECT * FROM inv_osal WHERE inv_osal.folio_documento=factura_fila.serie_folio AND  inv_osal.cxc_clie_id=factura_fila.cxc_clie_id AND inv_osal.tipo_documento=1 
				INTO fila;
				--RAISE EXCEPTION '%','fila.id: '||fila.id;
				
				UPDATE inv_osal SET cancelacion=true, momento_cancelacion=espacio_tiempo_ejecucion, motivo_cancelacion=str_data[6], gral_usr_id_actualizacion=usuario_ejecutor 
				WHERE id=fila.id;
				--TERMINA CANCELACION DE ORDEN DE SALIDA
				--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
				
				
				
				
				--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
				--INICIA GENERACION DE ORDERN DE DEVOLUCION
				--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
				
				--Obtener datos de la orden de salida que genero esta factura
				SELECT * FROM inv_osal WHERE inv_osal.folio_documento=factura_fila.serie_folio AND inv_osal.cxc_clie_id=factura_fila.cxc_clie_id AND inv_osal.tipo_documento IN (1)
				INTO fila;
				
				--Estatus 0=No se ha tocado por el personal de Almacen, 
				--Estatus 1=Ya se ha ingresado cantidaddes, lotes, pedimentos y fechas de caducidad pero aun no se ha descontado del lote
				--Estatus 2=Confirmado(ya se le dio salida)
				
				--Solo se puede generar orden de devolucion cuando el estatus es mayor a Uno
				IF fila.estatus::integer >= 1 THEN
					--Folio Orden de Devolucion
					id_tipo_consecutivo:=26;
					--Este dato se va vacio porque es cancelacion de factura, esto no genera nota de credito.
					serie_folio_nota_credito:='';
					
					--Aqui entra para tomar el consecutivo del folio  la sucursal actual
					UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
					WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
					
					--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
					nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
					
					INSERT INTO inv_odev(
						folio,--nuevo_folio,
						inv_mov_tipo_id,--tipo_movimiento_id,
						tipo_documento,--fila.tipo_documento,
						folio_documento,--fila.folio_documento,
						folio_ncto,--serie_folio_nota_credito,
						fecha_exp,--fila.fecha_exp,
						cxc_clie_id,--factura_fila.cxc_clie_id
						inv_alm_id,--fila.inv_alm_id,
						moneda_id,--factura_fila.moneda_id,
						erp_proceso_id,--factura_fila.proceso_id,
						momento_creacion,--espacio_tiempo_ejecucion,
						gral_usr_id_creacion,--usuario_ejecutor,
						gral_emp_id,--emp_id,
						gral_suc_id,--suc_id,
						cancelacion--false
					)VALUES(nuevo_folio, tipo_movimiento_id, fila.tipo_documento, fila.folio_documento, serie_folio_nota_credito, fila.fecha_exp, factura_fila.cxc_clie_id, fila.inv_alm_id, factura_fila.moneda_id, factura_fila.proceso_id, espacio_tiempo_ejecucion, usuario_ejecutor, emp_id, suc_id, false) 
					RETURNING id INTO ultimo_id;
					
					
					--Obtiene los productos de la Orden de Salida
					sql_select:='
					SELECT 
						inv_osal_detalle.id,
						inv_osal_detalle.inv_prod_id,
						inv_osal_detalle.inv_prod_presentacion_id,
						(inv_osal_detalle.cantidad::double precision - cant_dev::double precision) AS cantidad_devolucion
					FROM inv_osal_detalle 
					WHERE inv_osal_detalle.inv_osal_id='||fila.id||';';
					
					--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
					FOR factura_detalle IN EXECUTE(sql_select) LOOP
						--Registrar cantidades que se devolvieron a inv_osal_detalle
						UPDATE inv_osal_detalle SET cant_dev=(cant_dev + factura_detalle.cantidad_devolucion::double precision) 
						WHERE id=factura_detalle.id; 
						
						--Obtiene lista de lotes de la Salida
						sql_select:='
						SELECT 
							inv_lote_detalle.inv_lote_id AS id_lote,
							inv_lote_detalle.inv_osal_detalle_id,
							inv_lote_detalle.cantidad_sal AS cant_fac,
							(inv_lote_detalle.cantidad_sal::double precision - cantidad_dev::double precision) AS devolucion,
							inv_osal_detalle.inv_prod_unidad_id AS id_uni_prod_venta 
						FROM inv_osal_detalle 
						JOIN inv_lote_detalle ON inv_lote_detalle.inv_osal_detalle_id=inv_osal_detalle.id 
						JOIN inv_lote ON inv_lote.id=inv_lote_detalle.inv_lote_id
						WHERE inv_osal_detalle.id='||factura_detalle.id||' AND inv_lote.inv_prod_id='||factura_detalle.inv_prod_id||';';
						
						--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
						FOR fila_detalle IN EXECUTE(sql_select) LOOP
							fila_detalle.devolucion:=factura_detalle.cantidad_devolucion::double precision;
							
							--Crear registro en inv_odev_detalle
							INSERT INTO inv_odev_detalle(inv_odev_id,inv_osal_detalle_id,inv_lote_id,cant_fac_lote,cant_dev_lote,inv_prod_unidad_id)
							VALUES(ultimo_id,fila_detalle.inv_osal_detalle_id,fila_detalle.id_lote,fila_detalle.cant_fac,fila_detalle.devolucion,fila_detalle.id_uni_prod_venta);
						END LOOP;
						
					END LOOP;
					
				END IF;
				--TERMINA GENERACION DE ORDEN DE DEVOLUCION
				--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
				
			END IF;--Termina tipo de cancelacion 1=Cancelacion total
			
			
			
			--tipo 2=Cancelacion Para refacturacion
			IF str_data[5]::integer = 2 THEN
				--Aqui entra cuando se refactura
				--actualiza campo refacturacion y regresa el id del proceso 
				UPDATE erp_prefacturas SET refacturar=TRUE WHERE proceso_id=factura_fila.proceso_id
				RETURNING proceso_id, id INTO id_proceso, ultimo_id;
				
				--Esta variable indicara si hay que Regresar toda la Prefactura a Facturacion o Factura Parcial
				--TRUE  2=FACTURACION
				--FALSE 7=FACTURA PARCIAL
				actualizar_proceso:=true;
				
				--obtiene lista de productos de la factura
				sql_select:='SELECT  fac_docs_detalles.inv_prod_id,
						fac_docs_detalles.inv_prod_presentacion_id AS presentacion_id,
						fac_docs_detalles.cantidad,
						0::double precision AS nueva_cant_fac,
						inv_prod.tipo_de_producto_id AS tipo_producto,
						(CASE WHEN inv_prod_presentaciones.id IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
						(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec 
					FROM fac_docs_detalles 
					JOIN inv_prod ON inv_prod.id=fac_docs_detalles.inv_prod_id
					LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=fac_docs_detalles.inv_prod_presentacion_id 
					WHERE fac_docs_detalles.fac_doc_id='||str_data[4]::integer;
					
				--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
				FOR factura_detalle IN EXECUTE(sql_select) LOOP
					/*
					factura_detalle.inv_prod_id
					factura_detalle.presentacion_id
					factura_detalle.cantidad
					factura_detalle.tipo_producto
					factura_detalle.cant_equiv
					factura_detalle.no_dec
					factura_detalle.nueva_cant_fac
					*/
					--Si el tipo de producto es diferente de 4, hay que devolver la cantidad a la prefactura
					--tipo=4 Servicios
					--para el tipo servicios debe generar movimientos ni devolver existencias
					IF factura_detalle.tipo_producto::integer<>4 THEN
						--tipo=1 Normal o Terminado
						--tipo=2 Subensable o Formulacion o Intermedio
						--tipo=5 Refacciones
						--tipo=6 Accesorios
						--tipo=7 Materia Prima
						--tipo=8 Prod. en Desarrollo
						IF factura_detalle.tipo_producto::integer=1 OR factura_detalle.tipo_producto::integer=2 OR factura_detalle.tipo_producto::integer=5 OR factura_detalle.tipo_producto::integer=6  OR factura_detalle.tipo_producto::integer=7 OR factura_detalle.tipo_producto::integer=8 THEN
							--Redondear la cantidad
							factura_detalle.cantidad := round(factura_detalle.cantidad::numeric,factura_detalle.no_dec)::double precision;
							
							SELECT cant_facturado FROM erp_prefacturas_detalles 
							WHERE prefacturas_id=ultimo_id AND producto_id=factura_detalle.inv_prod_id AND presentacion_id=factura_detalle.presentacion_id
							INTO factura_detalle.nueva_cant_fac;
							
							--Redondear valor
							factura_detalle.nueva_cant_fac := round(factura_detalle.nueva_cant_fac::numeric,factura_detalle.no_dec)::double precision;

							--Calcular nueva cantidad facturada
							factura_detalle.nueva_cant_fac := factura_detalle.nueva_cant_fac::double precision - factura_detalle.cantidad::double precision;
							
							--Redondear nueva cantidad facturada
							factura_detalle.nueva_cant_fac := round(factura_detalle.nueva_cant_fac::numeric,factura_detalle.no_dec)::double precision;
							
							--Actualizar partida de Prefacturas detalles
							UPDATE erp_prefacturas_detalles SET cant_facturado=factura_detalle.nueva_cant_fac, facturado=false
							WHERE prefacturas_id=ultimo_id AND producto_id=factura_detalle.inv_prod_id AND presentacion_id=factura_detalle.presentacion_id;
							
							IF factura_detalle.nueva_cant_fac>0 THEN 
								--Si la nueva cantidad facturada es mayor que cero,
								--quiere decir que solo se revive una parte de la partida
								actualizar_proceso:=false;
							END IF;
						END IF;--termina tipo producto normal y subensamble
					END IF;--termina validacion tipo 4
				END LOOP;
				
				IF actualizar_proceso THEN 
					--Regresa el proceso 2=Facturacion para permitir la refacturacion
					UPDATE erp_proceso SET proceso_flujo_id=2 WHERE id=factura_fila.proceso_id;
				ELSE 
					--Regresa el proceso 7=Factura parcial para permitir la refacturacion
					UPDATE erp_proceso SET proceso_flujo_id=7 WHERE id=factura_fila.proceso_id;
				END IF;
			END IF;
			
			valor_retorno := 'true';
		END IF;--termina cancelacion de factura
		
	END IF;--Termina facturas de Clientes
	
	
	
	
	-- aplicativo Notas de Credito para Clientes
	IF app_selected = 70 THEN
		--str_data[4]	identificador
		--str_data[5]	id_cliente
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones
		--str_data[9]	select_moneda
		--str_data[10]	select_vendedor
		--str_data[11]	concepto
		--str_data[12]	tipo_cambio
		--str_data[13]	importe
		--str_data[14]	impuesto
		--str_data[15]	retencion
		--str_data[16]	total
		--str_data[17]	factura
		--str_data[18]	tmov_id
		
		--Nueva Nota de Credito
		IF command_selected = 'new' THEN
			
			monto_subtotal:=str_data[13]::double precision;
			monto_impuesto:= str_data[14]::double precision;
			total_retencion:= str_data[15]::double precision;
			suma_total:= str_data[16]::double precision;
			
			--verificar si hay que retener iva para este cliente
			SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex/100 end FROM cxc_clie WHERE id=str_data[5]::integer INTO retener_iva, tasa_retencion;
			
			--Obtener el id de la direccion fiscal de la factura
			SELECT cxc_clie_df_id FROM fac_docs WHERE serie_folio=str_data[17] INTO id_df;
			
			INSERT INTO fac_nota_credito
			(
				cxc_clie_id, --str_data[5]::integer,
				valor_impuesto,--str_data[7]::double precision,
				observaciones, --str_data[8],
				moneda_id, --str_data[9]::integer,
				cxc_agen_id, --str_data[10]::integer,
				concepto, --str_data[11],
				tipo_cambio,--str_data[12]::double precision,
				subtotal, --monto_subtotal,
				impuesto, --monto_impuesto,
				monto_retencion,--total_retencion,
				total, --suma_total,
				serie_folio_factura,--str_data[17],
				ctb_tmov_id,--str_data[18]::integer,
				cxc_clie_df_id,--id_df,
				tasa_retencion_immex, --tasa_retencion,
				momento_creacion, --espacio_tiempo_ejecucion,
				gral_usr_id_creacion, --usuario_ejecutor
				gral_emp_id,--emp_id,
				gral_suc_id,--suc_id
				gral_app_id_creacion
			)
			VALUES(str_data[5]::integer, str_data[7]::double precision, str_data[8], str_data[9]::integer, str_data[10]::integer, str_data[11], str_data[12]::double precision, monto_subtotal, monto_impuesto, total_retencion, suma_total, str_data[17], str_data[18]::integer, id_df, tasa_retencion, espacio_tiempo_ejecucion, usuario_ejecutor, emp_id, suc_id, app_selected)
			RETURNING id INTO ultimo_id;

			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			--Inicia gaurdar datos para la Adenda
			--Primero se verifica si en los parametros indica que se debe incluir la Adenda
			IF facpar.incluye_adenda THEN 
				--Verificar que exista un id de cliente valido
				IF str_data[5]::integer > 1 THEN 
					--Buscar el numero de Adenda asignado al cliente.
					SELECT cxc_clie_tipo_adenda_id FROM cxc_clie WHERE id=str_data[5]::integer INTO idAdenda;
					
					--Varificar si tiene adenda asignada
					IF idAdenda > 0 THEN 
						--Verificar el numero de adenda
						--Addenda SUN CHEMICAL
						IF idAdenda=2 THEN 
							--Buscar si la factura tiene adenda 
							SELECT count(fac_docs_adenda.id) FROM fac_docs_adenda JOIN fac_docs ON fac_docs.id=fac_docs_adenda.fac_docs_id 
							WHERE fac_docs.serie_folio=str_data[17] AND fac_docs.cxc_clie_id=str_data[5]::integer 
							INTO exis;
							
							IF exis <=0 THEN 
								--Inicializar
								exis:=0;
								
								--Si no tiene, buscar si la factura trae OC
								SELECT count(fac_docs.id) FROM fac_docs 
								WHERE fac_docs.serie_folio=str_data[17] AND fac_docs.cxc_clie_id=str_data[5]::integer AND fac_docs.orden_compra<>'' 
								INTO exis;
								
								IF exis>0 THEN 
									--Obtener id y Orden de Compra
									SELECT id, orden_compra FROM fac_docs 
									WHERE fac_docs.serie_folio=str_data[17] AND fac_docs.cxc_clie_id=str_data[5]::integer AND fac_docs.orden_compra<>'' 
									INTO ultimo_id, valor_campo1;
									
									--Insertar valores en la tabla
									INSERT INTO fac_docs_adenda(prefactura_id, fac_docs_id, cxc_clie_adenda_tipo_id, valor1)
									VALUES(0, ultimo_id, idAdenda, valor_campo1);
								END IF;
							END IF;
						END IF;
						--Termina Addenda SUN CHEMICAL
					END IF;
				END IF;
			END IF;
			--Termina Guardar datos Adenda
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


			valor_retorno := '1';
		END IF;--termina Nueva Nota de Credito
		
		
		
		--EDIT Nota de Credito
		IF command_selected = 'edit' THEN
			monto_subtotal:=str_data[13]::double precision;
			monto_impuesto:= str_data[14]::double precision;
			total_retencion:= str_data[15]::double precision;
			suma_total:= str_data[16]::double precision;
			
			--verificar si hay que retener iva para este cliente
			SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex/100 end FROM cxc_clie WHERE id=str_data[5]::integer INTO retener_iva, tasa_retencion;
			
			UPDATE fac_nota_credito SET cxc_clie_id=str_data[5]::integer, valor_impuesto=str_data[7]::double precision, observaciones=str_data[8], moneda_id=str_data[9]::integer, cxc_agen_id=str_data[10]::integer, concepto=str_data[11], tipo_cambio=str_data[12]::double precision, subtotal=monto_subtotal, impuesto=monto_impuesto, monto_retencion=total_retencion, total=suma_total, serie_folio_factura=str_data[17], ctb_tmov_id=str_data[18]::integer, tasa_retencion_immex=tasa_retencion, momento_creacion=espacio_tiempo_ejecucion, gral_usr_id_creacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer;
			
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			--Inicia gaurdar datos para la Adenda
			--Primero se verifica si en los parametros indica que se debe incluir la Adenda
			IF facpar.incluye_adenda THEN 
				--Verificar que exista un id de cliente valido
				IF str_data[5]::integer > 1 THEN 
					--Buscar el numero de Adenda asignado al cliente.
					SELECT cxc_clie_tipo_adenda_id FROM cxc_clie WHERE id=str_data[5]::integer INTO idAdenda;
					
					--Varificar si tiene adenda asignada
					IF idAdenda > 0 THEN 
						--Verificar el numero de adenda
						--Addenda SUN CHEMICAL
						IF idAdenda=2 THEN 
							--Buscar si la factura tiene adenda 
							SELECT count(fac_docs_adenda.id) FROM fac_docs_adenda JOIN fac_docs ON fac_docs.id=fac_docs_adenda.fac_docs_id 
							WHERE fac_docs.serie_folio=str_data[17] AND fac_docs.cxc_clie_id=str_data[5]::integer 
							INTO exis;
							
							IF exis <=0 THEN 
								--Inicializar
								exis:=0;
								
								--Si no tiene, buscar si la factura trae OC
								SELECT count(fac_docs.id) FROM fac_docs 
								WHERE fac_docs.serie_folio=str_data[17] AND fac_docs.cxc_clie_id=str_data[5]::integer AND fac_docs.orden_compra<>'' 
								INTO exis;
								
								IF exis>0 THEN 
									--Obtener id y Orden de Compra
									SELECT id, orden_compra FROM fac_docs 
									WHERE fac_docs.serie_folio=str_data[17] AND fac_docs.cxc_clie_id=str_data[5]::integer AND fac_docs.orden_compra<>'' 
									INTO ultimo_id, valor_campo1;
									
									--Insertar valores en la tabla
									INSERT INTO fac_docs_adenda(prefactura_id, fac_docs_id, cxc_clie_adenda_tipo_id, valor1)
									VALUES(0, ultimo_id, idAdenda, valor_campo1);
								END IF;
							ELSE
								--Buscar si la factura tiene adenda 
								SELECT fac_docs_adenda.id FROM fac_docs_adenda JOIN fac_docs ON fac_docs.id=fac_docs_adenda.fac_docs_id 
								WHERE fac_docs.serie_folio=str_data[17] AND fac_docs.cxc_clie_id=str_data[5]::integer limit 1
								INTO id2;

								--Obtener id y Orden de Compra
								SELECT id, orden_compra FROM fac_docs 
								WHERE fac_docs.serie_folio=str_data[17] AND fac_docs.cxc_clie_id=str_data[5]::integer AND fac_docs.orden_compra<>'' 
								INTO ultimo_id, valor_campo1;
								
								UPDATE fac_docs_adenda SET valor1=valor_campo1, fac_docs_id=ultimo_id 
								WHERE id=id2;
								
							END IF;
						END IF;
						--Termina Addenda SUN CHEMICAL
					END IF;
				END IF;
			END IF;
			--Termina Guardar datos Adenda
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

			valor_retorno := '1';
		END IF;--termina EDIT Nota de Credito
		
		
		--:::::::::::::GENERAR NOTA CREDITO CFD:::::::::::::::::::::::::::::
		IF command_selected='genera_nota_credito_cfd' THEN
			INSERT INTO fac_cfds(
				rfc_cliente,--str_data[5],
				serie,--str_data[6],
				folio_del_comprobante_fiscal,--str_data[7],
				numero_de_aprobacion,--str_data[8],
				monto_de_la_operacion,--str_data[9]::double precision,
				monto_del_impuesto,--str_data[10]::double precision,
				estado_del_comprobante,--str_data[11],
				nombre_archivo,--str_data[12],
				momento_expedicion,--str_data[13],
				razon_social,--str_data[14],
				tipo_comprobante,--str_data[15],
				proposito,--str_data[16],
				anoaprovacion,--str_data[17],
				serie_folio,--str_data[6]||str_data[7],
				conceptos,--str_data[18],
				impuestos_trasladados,--str_data[19],
				impuestos_retenidos,--str_data[20],
				regimen_fiscal,--str_data[22],
				metodo_pago,--str_data[23],
				numero_cuenta,--str_data[24],
				lugar_expedicion,--str_data[25],
				id_user_crea,--usuario_ejecutor,
				empresa_id,--emp_id,
				sucursal_id,--suc_id,
				proceso_id--0
			    ) 
			VALUES(str_data[5], str_data[6], str_data[7], str_data[8], str_data[9]::double precision, str_data[10]::double precision, str_data[11], str_data[12], str_data[13], str_data[14], str_data[15], str_data[16], str_data[17], str_data[6]||str_data[7], str_data[18], str_data[19], str_data[20], str_data[22], str_data[23], str_data[24], str_data[25], usuario_ejecutor, emp_id, suc_id, 0) 
			RETURNING id,serie_folio,momento_expedicion INTO ultimo_id,serie_folio_nota_credito,fecha_nota_credito;
			
			UPDATE fac_nota_credito SET serie_folio=serie_folio_nota_credito, momento_expedicion=fecha_nota_credito, gral_usr_id_expedicion=usuario_ejecutor 
			WHERE id=str_data[4]::integer
			RETURNING serie_folio_factura INTO serie_folio_fac;
			
			--actualizar erp_h_facturas
			SELECT monto_total,moneda_id from  erp_h_facturas where serie_folio=serie_folio_fac INTO total_factura,id_moneda_factura ;
			
			--sacar suma total de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=serie_folio_fac AND cancelacion=FALSE) AS sbt  INTO suma_pagos;
			
			--sacar suma total de notas de credito para esta factura
			--cuando la moneda de la factura es USD hay que convertir todas las Notas de Credito a Dolar
			IF id_moneda_factura=2 THEN
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total_nota) FROM (
						SELECT 	round(( (CASE WHEN moneda_id=1 THEN total/tipo_cambio ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='' AND serie_folio_factura=serie_folio_fac 
					) AS sbt
				) AS subtabla INTO suma_notas_credito;
			ELSE
				--cuando la Factura es en pesos NO HAY necesidad de convertir, porque a las facturas en USD no se le aplica notas de credito de Otra MONEDA, solo pesos
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total) FROM fac_nota_credito WHERE serie_folio_factura=serie_folio_fac AND cancelado=FALSE
				) AS subtabla INTO suma_notas_credito;
			END IF;
			
			nuevacantidad_monto_pago:=round((suma_pagos)::numeric,4)::double precision;
			
			--SI saldado=true, entonces se asigna un cero al saldo de la factura
			IF str_data[26]::boolean=TRUE THEN 
				nuevo_saldo_factura:=0;
				UPDATE fac_cfds SET pagado=true WHERE serie_folio=serie_folio_fac;
			ELSE
				nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,4)::double precision;
			END IF;
			
			--actualiza cantidades cada vez que se realice un pago
			UPDATE erp_h_facturas SET total_pagos=nuevacantidad_monto_pago, total_notas_creditos=suma_notas_credito, saldo_factura=nuevo_saldo_factura,  pagado=str_data[26]::boolean, momento_actualizacion=now() 
			WHERE serie_folio=serie_folio_fac;
			
			valor_retorno := '1';
		END IF;--termina GENERAR NOTA CREDITO CFD::::::::::::::::::
		
		
		
		--:::::GENERA NOTA DE CREDITO CFDI:::::::::::::::::::::::::::::
		IF command_selected='genera_nota_credito_cfdi' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_nota_credito
			--str_data[5]	SerieFolio
			--str_data[6]	fac_saldado
			
			UPDATE fac_nota_credito SET serie_folio=str_data[5], momento_expedicion=espacio_tiempo_ejecucion, gral_usr_id_expedicion=usuario_ejecutor 
			WHERE id=str_data[4]::integer
			RETURNING serie_folio_factura INTO serie_folio_fac;
			
			--actualizar erp_h_facturas
			SELECT monto_total,moneda_id from  erp_h_facturas where serie_folio=serie_folio_fac INTO total_factura,id_moneda_factura ;
			
			--sacar suma total de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=serie_folio_fac AND cancelacion=FALSE) AS sbt  INTO suma_pagos;
			
			--sacar suma total de notas de credito para esta factura
			--cuando la moneda de la factura es USD hay que convertir todas las Notas de Credito a Dolar
			IF id_moneda_factura=2 THEN
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total_nota) FROM (
						SELECT 	round(( (CASE WHEN moneda_id=1 THEN total/tipo_cambio ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='' AND serie_folio_factura=serie_folio_fac
					) AS sbt
				) AS subtabla INTO suma_notas_credito;
			ELSE
				--cuando la Factura es en pesos NO HAY necesidad de convertir, porque a las facturas en USD no se le aplica notas de credito de Otra MONEDA, solo pesos
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total) FROM fac_nota_credito WHERE serie_folio_factura=serie_folio_fac AND cancelado=FALSE
				) AS subtabla INTO suma_notas_credito;
			END IF;
			
			nuevacantidad_monto_pago:=round((suma_pagos)::numeric,4)::double precision;
			
			--SI saldado=true, entonces se asigna un cero al saldo de la factura
			IF str_data[6]::boolean=TRUE THEN 
				nuevo_saldo_factura:=0;
			ELSE
				nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,2)::double precision;
			END IF;
			
			--actualiza cantidades cada vez que se realice un pago
			UPDATE erp_h_facturas SET total_pagos=nuevacantidad_monto_pago, total_notas_creditos=suma_notas_credito, saldo_factura=nuevo_saldo_factura, pagado=str_data[6]::boolean, momento_actualizacion=espacio_tiempo_ejecucion 
			WHERE serie_folio=serie_folio_fac;
			
			valor_retorno := '1';
		END IF;--termina GENERAR NOTA CREDITO CFDI
		
		
		
		--:::::GENERA NOTA DE CREDITO CFDITF:::::::::::::::::::::::::::::
		IF command_selected='genera_nota_credito_cfditf' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_nota_credito
			--str_data[5]	SerieFolio
			--str_data[6]	fac_saldado
			--str_data[7]	ref_id
			--str_data[8]	xml_timbrado
			
			serie_folio_fac := str_data[5];
			
			UPDATE fac_nota_credito SET serie_folio=serie_folio_fac, momento_expedicion=espacio_tiempo_ejecucion, gral_usr_id_expedicion=usuario_ejecutor, ref_id=str_data[7] 
			WHERE id=str_data[4]::integer
			RETURNING serie_folio_factura,momento_expedicion,concepto, serie_folio INTO serie_folio_fac,fecha_nota_credito, concepto_nota_credito, serie_folio_nota_credito;

			--Guarda la cadena del xml timbrado
			INSERT INTO fac_cfdis(tipo, ref_id, doc, gral_emp_id, gral_suc_id, fecha_crea, gral_usr_id_crea) 
			VALUES (2,str_data[7],str_data[8]::text,emp_id,suc_id,espacio_tiempo_ejecucion, usuario_ejecutor);

			
			--actualizar erp_h_facturas
			SELECT monto_total,moneda_id from  erp_h_facturas where serie_folio=serie_folio_fac INTO total_factura,id_moneda_factura ;
			
			--sacar suma total de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=serie_folio_fac AND cancelacion=FALSE) AS sbt  INTO suma_pagos;
			
			--sacar suma total de notas de credito para esta factura
			--cuando la moneda de la factura es USD hay que convertir todas las Notas de Credito a Dolar
			IF id_moneda_factura=2 THEN
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total_nota) FROM (
						SELECT 	round(( (CASE WHEN moneda_id=1 THEN total/tipo_cambio ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='' AND serie_folio_factura=serie_folio_fac
					) AS sbt
				) AS subtabla INTO suma_notas_credito;
			ELSE
				--cuando la Factura es en pesos NO HAY necesidad de convertir, porque a las facturas en USD no se le aplica notas de credito de Otra MONEDA, solo pesos
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total) FROM fac_nota_credito WHERE serie_folio_factura=serie_folio_fac AND cancelado=FALSE
				) AS subtabla INTO suma_notas_credito;
			END IF;
			
			nuevacantidad_monto_pago:=round((suma_pagos)::numeric,4)::double precision;
			
			--SI saldado=true, entonces se asigna un cero al saldo de la factura
			IF str_data[6]::boolean=TRUE THEN 
				nuevo_saldo_factura:=0;
			ELSE
				nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,2)::double precision;
			END IF;
			
			--actualiza cantidades cada vez que se realice un pago
			UPDATE erp_h_facturas SET total_pagos=nuevacantidad_monto_pago,  total_notas_creditos=suma_notas_credito, saldo_factura=nuevo_saldo_factura,  pagado=str_data[6]::boolean, momento_actualizacion=espacio_tiempo_ejecucion 
			WHERE serie_folio=serie_folio_fac;
			
			valor_retorno := '1';
		END IF;--termina GENERAR NOTA CREDITO CFDITF
		
		
		
		--::::::::::::CANCELAR Nota de Credito:::::::::::::::::::::::::::
		IF command_selected = 'cancelacion' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_nota
			--str_data[5]	motivo_cancelacion
			--str_data[6]	tipo_facturacion
			--str_data[7]	tmov
			
			UPDATE fac_nota_credito SET cancelado=true, motivo_cancelacion=str_data[5], ctb_tmov_id_cancelacion=str_data[7]::integer,momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancelacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer 
			RETURNING serie_folio,serie_folio_factura, gral_app_id_creacion, ref_id INTO serie_folio_nota_credito, serie_folio_fac, aplicativo_id, refId;
			
			UPDATE fac_cfdis SET cancelado=TRUE, fecha_cancela=espacio_tiempo_ejecucion, gral_usr_id_cancela=usuario_ejecutor 
			WHERE ref_id=refId AND gral_emp_id=emp_id;
			
			IF str_data[6]='cfd' THEN
				UPDATE fac_cfds SET estado_del_comprobante='0', motivo_cancelacion=str_data[5],momento_cancelacion=espacio_tiempo_ejecucion
				WHERE serie_folio=serie_folio_nota_credito;
			END IF;
			
			--actualizar erp_h_facturas
			SELECT monto_total,moneda_id from  erp_h_facturas where serie_folio=serie_folio_fac INTO total_factura,id_moneda_factura ;
			
			--sacar suma total de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=serie_folio_fac AND cancelacion=FALSE) AS sbt  INTO suma_pagos;
			
			--sacar suma total de notas de credito para esta factura
			--cuando la moneda de la factura es USD hay que convertir todas las Notas de Credito a Dolar
			IF id_moneda_factura=2 THEN
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total_nota) FROM (
						SELECT 	round(( (CASE WHEN moneda_id=1 THEN total/tipo_cambio ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='' AND serie_folio_factura=serie_folio_fac AND cancelado=FALSE
					) AS sbt
				) AS subtabla INTO suma_notas_credito;
			ELSE
				--cuando la Factura es en pesos NO HAY necesidad de convertir, porque a las facturas en USD no se le aplica notas de credito de Otra MONEDA, solo pesos
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total) FROM fac_nota_credito WHERE serie_folio_factura=serie_folio_fac AND cancelado=FALSE
				) AS subtabla INTO suma_notas_credito;
			END IF;
			
			nuevacantidad_monto_pago:=round((suma_pagos)::numeric,4)::double precision;
			
			nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,2)::double precision;
			
			--actualiza cantidades cada vez que se realice un pago
			UPDATE erp_h_facturas SET total_pagos=nuevacantidad_monto_pago, total_notas_creditos=suma_notas_credito, saldo_factura=nuevo_saldo_factura, pagado=false, momento_actualizacion=espacio_tiempo_ejecucion 
			WHERE serie_folio=serie_folio_fac;
			
			--****AQUI FALTA AGREGAR DEVOLUCION DE MERCANCIA AL CANCELAR NOTA DE CREDITO*************
			--SI el aplicativo es 76, la nota de credito fue generada por una Devolucion,
			--en este caso hay que realizar una salida de mercacia por la cancelacion de la Nota de Credito
			IF aplicativo_id=76 THEN 
				
			END IF;
			
			valor_retorno := serie_folio_nota_credito||':true';
		END IF;--termina CANCELAR Nota de Credito
		
	END IF;--Termina aplicativo Notas de Credito para Clientes




	
	--Aplicativo Devolucion de Mercancia
	IF app_selected = 76 THEN 
		--str_data[4]	id_factura
		--str_data[5]	id_cliente
		--str_data[6]	id_impuesto
		--str_data[7]	valor_impuesto
		--str_data[8]	observaciones
		--str_data[9]	select_moneda
		--str_data[10]	select_vendedor
		--str_data[11]	concepto
		--str_data[12]	tipo_cambio
		--str_data[13]	importe
		--str_data[14]	impuesto
		--str_data[15]	retencion
		--str_data[16]	total
		--str_data[17]	factura
		--str_data[18]	monto_ieps
		--str_data[19]	tmov
		
		--Nueva Nota de Credito
		IF command_selected = 'new' THEN
			monto_subtotal:=str_data[13]::double precision;
			monto_impuesto:= str_data[14]::double precision;
			total_retencion:= str_data[15]::double precision;
			suma_total:= str_data[16]::double precision;
			suma_ieps:= str_data[18]::double precision;
			
			--Verificar si hay que retener iva para este cliente
			SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex/100 end FROM cxc_clie WHERE id=str_data[5]::integer INTO retener_iva, tasa_retencion;
			
			--Obtener el id de la direccion fiscal de la factura
			SELECT cxc_clie_df_id FROM fac_docs WHERE id=str_data[4]::integer INTO id_df;
			
			INSERT INTO fac_nota_credito(
				cxc_clie_id, --str_data[5]::integer,
				valor_impuesto,--str_data[7]::double precision,
				observaciones, --str_data[8],
				moneda_id, --str_data[9]::integer,
				cxc_agen_id, --str_data[10]::integer,
				concepto, --str_data[11],
				tipo_cambio,--str_data[12]::double precision,
				subtotal, --monto_subtotal,
				impuesto, --monto_impuesto,
				monto_retencion,--total_retencion,
				total, --suma_total,
				monto_ieps,--suma_ieps, 
				serie_folio_factura,--str_data[17],
				ctb_tmov_id,--str_data[19]::integer,
				cxc_clie_df_id,--id_df,
				tasa_retencion_immex, --tasa_retencion,
				momento_creacion, --espacio_tiempo_ejecucion,
				gral_usr_id_creacion, --usuario_ejecutor
				gral_emp_id,--emp_id,
				gral_suc_id,--suc_id
				gral_app_id_creacion
			)VALUES(str_data[5]::integer,str_data[7]::double precision,str_data[8],str_data[9]::integer,str_data[10]::integer,str_data[11],str_data[12]::double precision,monto_subtotal,monto_impuesto,total_retencion,suma_total,suma_ieps,str_data[17],str_data[19]::integer,id_df,tasa_retencion,espacio_tiempo_ejecucion,usuario_ejecutor,emp_id,suc_id, app_selected)
			RETURNING id INTO ultimo_id;
			
			total_filas:= array_length(extra_data,1);
			cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					
					--str_filas[1] seleccionado
					IF str_filas[1]::integer != 0 THEN--1: no esta esta seleccionado, 0:No esta seleccionado
						--str_filas[2]	producto_id 
						--str_filas[3]	cantidad
						--str_filas[4]	cantidad_dev
						--str_filas[5]	id_impuesto
						--str_filas[6]	valor_iva
						--str_filas[7]	idpres
						--str_filas[8]	precio unitario
						--str_filas[9]	idIeps
						--str_filas[10]	tasaIeps
						
						--Registrar cantidades a devolver
						UPDATE fac_docs_detalles SET cantidad_devolucion=(cantidad_devolucion::double precision + str_filas[4]::double precision) 
						WHERE fac_doc_id=str_data[4]::integer 
						AND inv_prod_id=str_filas[2]::integer 
						AND inv_prod_presentacion_id=str_filas[7]::integer 
						RETURNING inv_prod_unidad_id INTO idUnidadMedidaVenta;
						--RAISE EXCEPTION '%','str_data[5] '||str_data[4];
						
						--Crear registro para el detalle de la Nota de Credito
						INSERT INTO fac_nota_credito_det(fac_nota_credito_id,inv_prod_id,inv_prod_presentacion_id,cantidad,precio_unitario,gral_imptos_id,valor_imp, cant_fac, inv_prod_unidad_id, gral_ieps_id, valor_ieps)
						VALUES(ultimo_id,str_filas[2]::integer,str_filas[7]::integer,str_filas[4]::double precision,str_filas[8]::double precision,str_filas[5]::integer,str_filas[6]::double precision, str_filas[3]::double precision,idUnidadMedidaVenta, str_filas[9]::integer, str_filas[10]::double precision);
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1:'||ultimo_id::character varying;
		END IF;--termina Nueva Nota de Credito
		
		
		
		--:::::::::::::GENERAR NOTA CREDITO CFD:::::::::::::::::::::::::::::
		IF command_selected='genera_nota_credito_cfd' THEN
			serie_folio_fac := str_data[6]||str_data[7];
			
			INSERT INTO fac_cfds(
				rfc_cliente,--str_data[5],
				serie,--str_data[6],
				folio_del_comprobante_fiscal,--str_data[7],
				numero_de_aprobacion,--str_data[8],
				monto_de_la_operacion,--str_data[9]::double precision,
				monto_del_impuesto,--str_data[10]::double precision,
				estado_del_comprobante,--str_data[11],
				nombre_archivo,--str_data[12],
				momento_expedicion,--str_data[13],
				razon_social,--str_data[14],
				tipo_comprobante,--str_data[15],
				proposito,--str_data[16],
				anoaprovacion,--str_data[17],
				serie_folio,--serie_folio_fac,
				conceptos,--str_data[18],
				impuestos_trasladados,--str_data[19],
				impuestos_retenidos,--str_data[20],
				regimen_fiscal,--str_data[22],
				metodo_pago,--str_data[23],
				numero_cuenta,--str_data[24],
				lugar_expedicion,--str_data[25],
				id_user_crea,--usuario_ejecutor,
				empresa_id,--emp_id,
				sucursal_id,--suc_id,
				proceso_id--0
			    ) VALUES(str_data[5],str_data[6],str_data[7],str_data[8],str_data[9]::double precision,str_data[10]::double precision,str_data[11],str_data[12],str_data[13],str_data[14],str_data[15],str_data[16],str_data[17],serie_folio_fac,str_data[18],str_data[19],str_data[20],str_data[22],str_data[23],str_data[24],str_data[25],usuario_ejecutor,emp_id,suc_id,0) 
			RETURNING id,serie_folio,momento_expedicion INTO ultimo_id,serie_folio_nota_credito,fecha_nota_credito;
			
			UPDATE fac_nota_credito SET serie_folio=serie_folio_nota_credito, momento_expedicion=fecha_nota_credito, gral_usr_id_expedicion=usuario_ejecutor
			WHERE id=str_data[4]::integer
			RETURNING serie_folio_factura,concepto INTO serie_folio_fac,concepto_nota_credito;
			
			--Actualizar erp_h_facturas
			SELECT monto_total,moneda_id from  erp_h_facturas where serie_folio=serie_folio_fac INTO total_factura,id_moneda_factura ;
			
			--sacar suma total de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=serie_folio_fac AND cancelacion=FALSE) AS sbt  INTO suma_pagos;
			
			--sacar suma total de notas de credito para esta factura
			--cuando la moneda de la factura es USD hay que convertir todas las Notas de Credito a Dolar
			IF id_moneda_factura=2 THEN
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total_nota) FROM (
						SELECT 	round(( (CASE WHEN moneda_id=1 THEN total/tipo_cambio ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='' AND serie_folio_factura=serie_folio_fac 
					) AS sbt
				) AS subtabla INTO suma_notas_credito;
			ELSE
				--cuando la Factura es en pesos NO HAY necesidad de convertir, porque a las facturas en USD no se le aplica notas de credito de Otra MONEDA, solo pesos
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total) FROM fac_nota_credito WHERE serie_folio_factura=serie_folio_fac AND cancelado=FALSE
				) AS subtabla INTO suma_notas_credito;
			END IF;
			
			nuevacantidad_monto_pago:=round((suma_pagos)::numeric,4)::double precision;
			
			--SI saldado=true, entonces se asigna un cero al saldo de la factura
			IF str_data[26]::boolean=TRUE THEN 
				nuevo_saldo_factura:=0;
				UPDATE fac_cfds SET pagado=true WHERE serie_folio=serie_folio_fac;
			ELSE
				nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,4)::double precision;
			END IF;
			
			--Actualiza cantidades cada vez que se realice un pago
			UPDATE erp_h_facturas SET total_pagos=nuevacantidad_monto_pago, total_notas_creditos=suma_notas_credito, saldo_factura=nuevo_saldo_factura,  pagado=str_data[26]::boolean, momento_actualizacion=espacio_tiempo_ejecucion
			WHERE serie_folio=serie_folio_fac AND empresa_id=emp_id;
			
			valor_retorno := '1';
		END IF;--termina GENERAR NOTA CREDITO CFD::::::::::::::::::
		
		
		
		--:::::GENERA NOTA DE CREDITO CFDI:::::::::::::::::::::::::::::
		IF command_selected='genera_nota_credito_cfdi' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_nota_credito
			--str_data[5]	SerieFolio
			--str_data[6]	fac_saldado
			
			serie_folio_fac := str_data[5];
			
			UPDATE fac_nota_credito SET serie_folio=serie_folio_fac,momento_expedicion=espacio_tiempo_ejecucion,gral_usr_id_expedicion=usuario_ejecutor
			WHERE id=str_data[4]::integer
			RETURNING serie_folio_factura,momento_expedicion,concepto, serie_folio INTO serie_folio_fac,fecha_nota_credito, concepto_nota_credito, serie_folio_nota_credito;
			
			--actualizar erp_h_facturas
			SELECT monto_total,moneda_id from  erp_h_facturas where serie_folio=serie_folio_fac INTO total_factura,id_moneda_factura ;
			
			--sacar suma total de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=serie_folio_fac AND cancelacion=FALSE) AS sbt  INTO suma_pagos;
			
			--sacar suma total de notas de credito para esta factura
			--cuando la moneda de la factura es USD hay que convertir todas las Notas de Credito a Dolar
			IF id_moneda_factura=2 THEN
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total_nota) FROM (
						SELECT 	round(( (CASE WHEN moneda_id=1 THEN total/tipo_cambio ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='' AND serie_folio_factura=serie_folio_fac
					) AS sbt
				) AS subtabla INTO suma_notas_credito;
			ELSE
				--cuando la Factura es en pesos NO HAY necesidad de convertir, porque a las facturas en USD no se le aplica notas de credito de Otra MONEDA, solo pesos
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (
					SELECT sum(total) FROM fac_nota_credito WHERE serie_folio_factura=serie_folio_fac AND cancelado=FALSE
				) AS subtabla INTO suma_notas_credito;
			END IF;
			
			nuevacantidad_monto_pago:=round((suma_pagos)::numeric,4)::double precision;
			
			--SI saldado=true, entonces se asigna un cero al saldo de la factura
			IF str_data[6]::boolean=TRUE THEN 
				nuevo_saldo_factura:=0;
			ELSE
				nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,2)::double precision;
			END IF;
			
			--actualiza cantidades cada vez que se realice un pago
			UPDATE erp_h_facturas SET total_pagos=nuevacantidad_monto_pago, total_notas_creditos=suma_notas_credito,saldo_factura=nuevo_saldo_factura, pagado=str_data[6]::boolean,momento_actualizacion=espacio_tiempo_ejecucion
			WHERE serie_folio=serie_folio_fac AND empresa_id=emp_id;
			
			valor_retorno := '1';
		END IF;--termina GENERAR NOTA CREDITO CFDI
		
		
		
		
		--:::::GENERA NOTA DE CREDITO CFDITF:::::::::::::::::::::::::::::
		IF command_selected='genera_nota_credito_cfditf' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_nota_credito
			--str_data[5]	SerieFolio
			--str_data[6]	fac_saldado
			--str_data[7]	id_cliente
			--str_data[8]	ref_id
			--str_data[9]	xml
			
			serie_folio_fac := str_data[5];
			
			UPDATE fac_nota_credito SET serie_folio=serie_folio_fac, momento_expedicion=espacio_tiempo_ejecucion, gral_usr_id_expedicion=usuario_ejecutor, ref_id=str_data[8] 
			WHERE id=str_data[4]::integer
			RETURNING serie_folio_factura,momento_expedicion,concepto, serie_folio INTO serie_folio_fac,fecha_nota_credito, concepto_nota_credito, serie_folio_nota_credito;
			
			--Guarda la cadena del xml timbrado
			INSERT INTO fac_cfdis(tipo, ref_id, doc, gral_emp_id, gral_suc_id, fecha_crea, gral_usr_id_crea) 
			VALUES (2,str_data[8],str_data[9]::text,emp_id,suc_id,espacio_tiempo_ejecucion, usuario_ejecutor);
			
				
			--actualizar erp_h_facturas
			SELECT monto_total,moneda_id from  erp_h_facturas where serie_folio=serie_folio_fac INTO total_factura,id_moneda_factura ;
			
			--sacar suma total de pagos para esta factura
			SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=serie_folio_fac AND cancelacion=FALSE) AS sbt  INTO suma_pagos;
			
			--Sacar suma total de notas de credito para esta factura
			--Cuando la moneda de la factura es USD hay que convertir todas las Notas de Credito a Dolar
			IF id_moneda_factura=2 THEN
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (SELECT sum(total_nota) FROM (SELECT round(( (CASE WHEN moneda_id=1 THEN total/tipo_cambio ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='' AND serie_folio_factura=serie_folio_fac ) AS sbt ) AS subtabla INTO suma_notas_credito;
			ELSE
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (SELECT sum(total_nota) FROM (SELECT 	round(( (CASE WHEN moneda_id<>1 THEN total*tipo_cambio ELSE total END))::numeric,2)::double precision AS total_nota FROM fac_nota_credito WHERE serie_folio!='' AND serie_folio_factura=serie_folio_fac) AS sbt) AS subtabla INTO suma_notas_credito;
			END IF;
			
			nuevacantidad_monto_pago:=round((suma_pagos)::numeric,4)::double precision;
			
			--SI saldado=true, entonces se asigna un cero al saldo de la factura
			IF str_data[6]::boolean=TRUE THEN 
				nuevo_saldo_factura:=0;
			ELSE
				nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,2)::double precision;
			END IF;
			
			--actualiza cantidades cada vez que se realice un pago
			UPDATE erp_h_facturas SET total_pagos=nuevacantidad_monto_pago, total_notas_creditos=suma_notas_credito,saldo_factura=nuevo_saldo_factura, pagado=str_data[6]::boolean,momento_actualizacion=espacio_tiempo_ejecucion
			WHERE serie_folio=serie_folio_fac AND empresa_id=emp_id;
			
			valor_retorno := '1';
		END IF;--termina GENERAR NOTA CREDITO CFDITF
		
		
		
		
		--Si es diferente de Nuevo; inicia devolucion existencias
		IF command_selected != 'new' THEN
			--RAISE EXCEPTION '%','command_selected: '||command_selected;
			
			--Obtener datos de la factura
			SELECT * FROM fac_docs WHERE serie_folio=serie_folio_fac AND cxc_clie_id=str_data[7]::integer LIMIT 1 INTO factura_fila;
			
			id_almacen := factura_fila.inv_alm_id;
			
			--bandera que identifica si el producto es tipo 4
			--si es tipo 4 no debe existir movimientos en inventario
			bandera_tipo_4=TRUE;
			
			--AQUI INICIA DEVOLUCION DE PRODUCTOS AL INVENTARIO
			--Genera registro del movimiento de cancelacion
			tipo_movimiento_id:=21;--DEVOLUCION DE MERCANCIA CON NOTA DE CREDITO
			INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id,gral_app_id, inv_mov_tipo_id, referencia, fecha_mov) 
			VALUES(concepto_nota_credito,espacio_tiempo_ejecucion,usuario_ejecutor,app_selected,tipo_movimiento_id, str_data[5], fecha_nota_credito) 
			RETURNING id INTO identificador_nuevo_movimiento;
			
			--Obtiene lista de productos de la Nota de Credito por Devolucion
			sql_select:='
			SELECT 
				fac_nota_credito_det.inv_prod_id,
				fac_nota_credito_det.cantidad,
				inv_prod.tipo_de_producto_id AS tipo_producto,
				fac_nota_credito_det.inv_prod_presentacion_id AS presentacion_id,
				(CASE WHEN inv_prod.densidad IS NULL OR inv_prod.densidad=0 THEN 1 ELSE inv_prod.densidad END) AS densidad_prod,
				(CASE WHEN inv_prod_presentaciones.id IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
				(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.id END) AS unidad_id,
				(CASE WHEN inv_prod_unidades.id IS NULL THEN '''' ELSE inv_prod_unidades.titulo END) AS unidad_titulo,
				(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec,
				fac_nota_credito_det.inv_prod_unidad_id AS id_uni_venta 
			FROM fac_nota_credito_det 
			JOIN inv_prod ON inv_prod.id=fac_nota_credito_det.inv_prod_id
			LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
			LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=fac_nota_credito_det.inv_prod_presentacion_id 
			WHERE fac_nota_credito_det.fac_nota_credito_id='||str_data[4]::integer||'';
			
			--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
			FOR factura_detalle IN EXECUTE(sql_select) LOOP
				--Inicializar valores
				cantPresAsignado:=0;
				
				/*
				factura_detalle.inv_prod_id
				factura_detalle.cantidad
				factura_detalle.tipo_producto
				*/
				--Si el tipo de producto es diferente de 4, hay que devolver existencias y generar Movimientos
				--tipo=4 Servicios
				--para el tipo servicios debe generar movimientos ni devolver existencias
				IF factura_detalle.tipo_producto<>4 THEN
					bandera_tipo_4=FALSE;--indica que por lo menos un producto es diferente de tipo4, por lo tanto debe generarse movimientos
					
					--tipo=1 Normal o Terminado
					--tipo=2 Subensable o Formulacion o Intermedio
					--tipo=5 Refacciones
					--tipo=6 Accesorios
					--tipo=7 Materia Prima
					--tipo=8 Prod. en Desarrollo
					IF factura_detalle.tipo_producto::integer=1 OR factura_detalle.tipo_producto::integer=2 OR factura_detalle.tipo_producto::integer=5 OR factura_detalle.tipo_producto::integer=6 OR factura_detalle.tipo_producto::integer=7 OR factura_detalle.tipo_producto::integer=8 THEN

						cantUnidadProd:=0;
						densidadProd:=0;
						
						idUnidadMedida:=factura_detalle.unidad_id;
						densidadProd:=factura_detalle.densidad_prod;
						nombreUnidadMedida:=factura_detalle.unidad_titulo;
						idUnidadMedidaVenta:=factura_detalle.id_uni_venta;
						
						--Tomar la cantidad en la Unidad de Venta
						cantUnidadVenta := factura_detalle.cantidad::double precision;
						
						IF facpar.cambiar_unidad_medida THEN
							IF idUnidadMedida<>idUnidadMedidaVenta THEN
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
								IF match_cadena=true THEN
									--Convertir a kilos
									factura_detalle.cantidad := factura_detalle.cantidad::double precision * densidadProd;
								ELSE
									EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
									IF match_cadena=true THEN 
										--Convertir a Litros
										factura_detalle.cantidad := factura_detalle.cantidad::double precision / densidadProd;
									END IF;
								END IF;
							END IF;
						END IF;
						
						
						--Redondear cantidad
						factura_detalle.cantidad := round(factura_detalle.cantidad::numeric,factura_detalle.no_dec)::double precision;
						
						--genera registro en detalles del movimiento
						INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id, inv_prod_presentacion_id)
						VALUES(factura_detalle.inv_prod_id, 0,id_almacen, factura_detalle.cantidad, identificador_nuevo_movimiento, factura_detalle.presentacion_id);
						
						--Reiniciamos las variables
						exis:=0;
						sql_select:='';
						
						--Query para verificar existencia del producto en el almacen y en el a√±o actual
						sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||factura_detalle.inv_prod_id||' AND inv_alm_id='||id_almacen||' AND ano = '||ano_actual;
						--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
						EXECUTE sql_select INTO exis;
						
						IF exis >0 THEN
							sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||factura_detalle.cantidad||'::double precision),momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
							WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||factura_detalle.inv_prod_id||' AND ano='||ano_actual;
							EXECUTE sql_update;
						ELSE
							sql_insert:='INSERT INTO inv_exi (inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial) '||
							'VALUES('||factura_detalle.inv_prod_id||','||id_almacen||','||ano_actual||','||factura_detalle.cantidad||','''|| espacio_tiempo_ejecucion ||''',0)';
							EXECUTE sql_insert;
						END IF;
						
						--Verificar si se est√° llevando el control de existencias por Presentaciones
						IF controlExisPres=true THEN 
							--Convertir la cantidad de la partida a su equivalente a presentaciones
							cantPresAsignado := factura_detalle.cantidad::double precision / factura_detalle.cant_equiv::double precision;
							
							--Redondear la cantidad de Presentaciones asignado en la partida
							cantPresAsignado := round(cantPresAsignado::numeric,factura_detalle.no_dec)::double precision;
							
							--Sumar entradas de inv_exi_pres
							UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantPresAsignado::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
							WHERE inv_alm_id=id_almacen AND inv_prod_id=factura_detalle.inv_prod_id AND inv_prod_presentacion_id=factura_detalle.presentacion_id;
							--Termina sumar entradas
						END IF;
						
					END IF;--termina tipo producto normal y subensamble
				END IF;--termina validacion tipo 4
				
			END LOOP;
			
			IF bandera_tipo_4=TRUE THEN 
				--la factura es de un producto tipo 4, por lo tanto se elimina el movimiento generado anteriormente
				DELETE FROM inv_mov WHERE id=identificador_nuevo_movimiento;
			END IF;
			
			
			--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			--INICIA GENERACION DE ORDERN DE DEVOLUCION
			--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			
			--Buscar si la factura es de una Remision
			SELECT count(id) FROM fac_rems_docs WHERE erp_proceso_id=factura_fila.proceso_id INTO exis;
			
			IF exis > 0 THEN 
				--ORDEN DE SALIDA DE UNA REMISION FACTURADA
				SELECT DISTINCT fac_rems.folio FROM fac_rems_docs JOIN fac_rems ON fac_rems.id=fac_rems_docs.fac_rem_id 
				WHERE erp_proceso_id=factura_fila.proceso_id LIMIT 1
				INTO serie_folio_fac;
				
				--Obtener datos de la orden de salida que genero esta Remision
				SELECT * FROM inv_osal WHERE inv_osal.folio_documento=serie_folio_fac AND inv_osal.cxc_clie_id=factura_fila.cxc_clie_id AND inv_osal.tipo_documento IN (2)
				INTO fila;

				--Aqui seteamos este valor porque la Orden de Dev es de una Factura(Factura de remsion)
				fila.tipo_documento:=1;
				fila.folio_documento:=serie_folio_fac;
			ELSE
				--ORDEN DE SALIDA DE UNA FACTURA
				--Obtener datos de la orden de salida que genero esta factura
				SELECT * FROM inv_osal WHERE inv_osal.folio_documento=factura_fila.serie_folio AND inv_osal.cxc_clie_id=factura_fila.cxc_clie_id AND inv_osal.tipo_documento IN (1)
				INTO fila;
			END IF;
			
			
			--RAISE EXCEPTION '%' ,'fila.estatus: '||fila.estatus;
			
			--estatus 0=No se ha tocado por el personal de Almacen, 
			--estatus 1=Ya se ha ingresado cantidaddes, lotes, pedimentos y fechas de caducidad pero aun no se ha descontado del lote
			--estatus 2=Confirmado(ya se le dio salida)
			
			--Solo se puede generar orden de devolucion cuando el estatus es mayor a Uno
			IF fila.estatus::integer >= 1 THEN
				id_tipo_consecutivo:=26; --Folio Orden de Devolucion
				
				--aqui entra para tomar el consecutivo del folio  la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

				ultimo_id:=0;
				INSERT INTO inv_odev(
					folio,--nuevo_folio,
					inv_mov_tipo_id,--tipo_movimiento_id,
					tipo_documento,--fila.tipo_documento,
					folio_documento,--fila.folio_documento,
					folio_ncto,--serie_folio_nota_credito,
					fecha_exp,--fila.fecha_exp,
					cxc_clie_id,--factura_fila.cxc_clie_id
					inv_alm_id,--fila.inv_alm_id,
					moneda_id,--factura_fila.moneda_id,
					erp_proceso_id,--factura_fila.proceso_id,
					momento_creacion,--espacio_tiempo_ejecucion,
					gral_usr_id_creacion,--usuario_ejecutor,
					gral_emp_id,--emp_id,
					gral_suc_id,--suc_id,
					cancelacion--false
				)VALUES(nuevo_folio, tipo_movimiento_id, fila.tipo_documento, fila.folio_documento, serie_folio_nota_credito, fila.fecha_exp, factura_fila.cxc_clie_id, fila.inv_alm_id, factura_fila.moneda_id, factura_fila.proceso_id, espacio_tiempo_ejecucion, usuario_ejecutor, emp_id, suc_id, false) 
				RETURNING id INTO ultimo_id;
				
				--Obtiene lista de la Nota de Credito por Devolucion
				sql_select:='
				SELECT 
					fac_nota_credito_det.inv_prod_id,
					fac_nota_credito_det.inv_prod_presentacion_id,
					fac_nota_credito_det.cantidad AS cantidad_devolucion
				FROM fac_nota_credito_det
				WHERE fac_nota_credito_id='||str_data[4]::integer||';';
				
				--RAISE EXCEPTION '%','sql_select '||sql_select;
				FOR factura_detalle IN EXECUTE(sql_select) LOOP
					--Registrar cantidades que se devolvieron a inv_osal_detalle
					UPDATE inv_osal_detalle SET cant_dev=(cant_dev + factura_detalle.cantidad_devolucion::double precision) 
					WHERE inv_prod_id=factura_detalle.inv_prod_id 
					AND inv_prod_presentacion_id=factura_detalle.inv_prod_presentacion_id 
					AND inv_osal_id=fila.id;
					
					
					--Obtiene lista de lotes de la Salida
					sql_select:='
					SELECT 
						inv_lote_detalle.inv_lote_id AS id_lote,
						inv_lote_detalle.inv_osal_detalle_id,
						inv_lote_detalle.cantidad_sal AS cant_fac,
						0::double precision AS devolucion,
						inv_osal_detalle.inv_prod_unidad_id AS id_uni_venta 
					FROM inv_osal_detalle 
					JOIN inv_lote_detalle ON inv_lote_detalle.inv_osal_detalle_id=inv_osal_detalle.id 
					JOIN inv_lote ON inv_lote.id=inv_lote_detalle.inv_lote_id
					WHERE inv_osal_detalle.inv_osal_id='||fila.id||' AND inv_lote.inv_prod_id='||factura_detalle.inv_prod_id||';';
					
					--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
					FOR fila_detalle IN EXECUTE(sql_select) LOOP
						fila_detalle.devolucion:=factura_detalle.cantidad_devolucion::double precision;
						
						--Crear registro en inv_odev_detalle
						INSERT INTO inv_odev_detalle(inv_odev_id,inv_osal_detalle_id,inv_lote_id,cant_fac_lote,cant_dev_lote, inv_prod_unidad_id)
						VALUES(ultimo_id,fila_detalle.inv_osal_detalle_id,fila_detalle.id_lote,fila_detalle.cant_fac,fila_detalle.devolucion,fila_detalle.id_uni_venta);
					END LOOP;
					
				END LOOP;
				
			END IF;
			--TERMINA GENERACION DE ORDEN DE DEVOLUCION
			--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			
			valor_retorno := '1';
		END IF;--termina proceso de devolucion
		
	END IF;--Termina aplicativo Devolucion de Mercancia




	--Aplicativo consulta de Facturas
	--Aqui se guardan los datos de la addenda
	IF app_selected = 142 THEN
		--Aqui entra para crear el nuevo registro del Header de la Nomina
		IF command_selected = 'guardar_addenda' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_fac_doc
			--str_data[5]	tipo_addenda_id
			--str_data[6]	adenda_campo1
			--str_data[7]	adenda_campo2
			--str_data[8]	adenda_campo3
			--str_data[9]	adenda_campo4
			--str_data[10]	adenda_campo5
			--str_data[11]	adenda_campo6
			--str_data[12]	adenda_campo7
			--str_data[13]	adenda_campo8
			
			IF str_data[5]::integer = 3 THEN 
				--Buscar si los datos de la addenda ya esta guardada
				select count(id) from fac_docs_adenda where fac_docs_id=str_data[4]::integer and cxc_clie_adenda_tipo_id=str_data[5]::integer into exis;
				
				if exis>0 then 
					--Si ya existe, solo hay que actualizar datos
					update fac_docs_adenda set valor1=str_data[6],valor2=str_data[7],valor3=str_data[8],valor4=str_data[9],valor5=str_data[10],valor6=str_data[11]
					where fac_docs_id=str_data[4]::integer and cxc_clie_adenda_tipo_id=str_data[5]::integer;
				else

					select erp_prefacturas.id from fac_docs join erp_prefacturas on erp_prefacturas.proceso_id=fac_docs.proceso_id where fac_docs.id=str_data[4]::integer limit 1
					into ultimo_id;

					if ultimo_id is null then ultimo_id:=0; end if;
					
					--Si no existe, hay que crear registro
					insert into fac_docs_adenda(prefactura_id, fac_docs_id,cxc_clie_adenda_tipo_id,valor1,valor2,valor3,valor4,valor5,valor6)
					values(ultimo_id, str_data[4]::integer,str_data[5]::integer,str_data[6],str_data[7],str_data[8],str_data[9],str_data[10],str_data[11]);
				end if;
			END IF;

			valor_retorno := '1';
			--Termina validacion addeda=3
		END IF;

		--Aqui entra para crear el nuevo registro del Header de la Nomina
		IF command_selected = 'actualizar_addenda' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_fac_doc
			--str_data[5]	tipo_addenda_id
			
			--Actualizar estatus a generado
			update fac_docs_adenda set generado=true where fac_docs_id=str_data[4]::integer and cxc_clie_adenda_tipo_id=str_data[5]::integer;

			valor_retorno := '1';
		END IF;


	END IF;







	
	-- Factura de NOMINA
	IF app_selected = 173 THEN
		--Aqui entra para crear el nuevo registro del Header de la Nomina
		IF command_selected = 'new' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5]	comp_tipo
			--str_data[6]	comp_forma_pago
			--str_data[7]	comp_tc
			--str_data[8]	comp_no_cuenta
			--str_data[9]	fecha_pago
			--str_data[10]	select_comp_metodo_pago
			--str_data[11]	select_comp_moneda
			--str_data[12]	select_comp_periodicidad
			--str_data[13]	select_no_periodo
			
			IF trim(str_data[7])='' THEN str_data[7]:='0'; END IF;
			
			INSERT INTO fac_nomina(
				id, --str_data[4]::integer,
				tipo_comprobante, --str_data[5],
				forma_pago, --str_data[6],
				tipo_cambio, --str_data[7]::double precision,
				no_cuenta, --str_data[8],
				fecha_pago, --str_data[9]::date,
				fac_metodos_pago_id, --str_data[10]::integer,
				gral_mon_id, --str_data[11]::integer,
				nom_periodicidad_pago_id, --str_data[12]::integer,
				nom_periodos_conf_det_id, --str_data[13]::integer,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion,--usuario_ejecutor,
				gral_emp_id, --emp_id,
				gral_suc_id --suc_id
			)VALUES(str_data[4]::integer, str_data[5], str_data[6], str_data[7]::double precision, str_data[8], str_data[9]::date, str_data[10]::integer, str_data[11]::integer, str_data[12]::integer, str_data[13]::integer, espacio_tiempo_ejecucion, usuario_ejecutor, emp_id, suc_id)
			RETURNING id INTO ultimo_id;
			
			total_filas:= array_length(extra_data,1);
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	elim 
					--str_filas[2]	noTr 
					--str_filas[3]	id_reg 
					--str_filas[4]	id_empleado
					--str_filas[5]	total_percep
					--str_filas[6]	total_deduc
					--str_filas[7]	pago_neto
					
					IF str_filas[1]::integer<>0 THEN --1: no esta esta Eliminado, 0:Si esta Eliminado
						--Crear registro en fac_nomina_det
						INSERT INTO fac_nomina_det(fac_nomina_id, gral_empleado_id )
						VALUES(ultimo_id,str_filas[4]::integer);
					END IF;
				END LOOP;
			END IF;
			
			--valor_actualizado||id_registro||codigo_error||mensaje
			valor_retorno := '1:'||ultimo_id||':'||'0'||':Los datos se guardaron con exito.';
		END IF;
		--Termina new Nomina
		
		
		IF command_selected = 'edit' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5]	comp_tipo
			--str_data[6]	comp_forma_pago
			--str_data[7]	comp_tc
			--str_data[8]	comp_no_cuenta
			--str_data[9]	fecha_pago
			--str_data[10]	select_comp_metodo_pago
			--str_data[11]	select_comp_moneda
			--str_data[12]	select_comp_periodicidad
			--str_data[13]	select_no_periodo
			
			IF trim(str_data[7])='' THEN str_data[7]:='0'; END IF;
			
			UPDATE fac_nomina SET tipo_comprobante=str_data[5], forma_pago=str_data[6], tipo_cambio=str_data[7]::double precision, no_cuenta=str_data[8], fecha_pago=str_data[9]::date, fac_metodos_pago_id=str_data[10]::integer, gral_mon_id=str_data[11]::integer, nom_periodicidad_pago_id=str_data[12]::integer, nom_periodos_conf_det_id=str_data[13]::integer, momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer
			RETURNING id INTO ultimo_id;
			
			IF extra_data[1]<>'sin datos' THEN
				total_filas:= array_length(extra_data,1);
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	elim 
					--str_filas[2]	noTr 
					--str_filas[3]	id_reg 
					--str_filas[4]	id_empleado
					--str_filas[5]	total_percep
					--str_filas[6]	total_deduc
					--str_filas[7]	pago_neto

					IF str_filas[3]::integer > 0 THEN 
						IF str_filas[1]::integer=0 THEN --1: no esta esta Eliminado, 0:Si esta Eliminado
							DELETE FROM fac_nomina_det WHERE id=str_filas[3]::integer;
							DELETE FROM fac_nomina_det_deduc WHERE fac_nomina_det_id=str_filas[3]::integer;
							DELETE FROM fac_nomina_det_percep WHERE fac_nomina_det_id=str_filas[3]::integer;
							DELETE FROM fac_nomina_det_hrs_extra WHERE fac_nomina_det_id=str_filas[3]::integer;
							DELETE FROM fac_nomina_det_incapa WHERE fac_nomina_det_id=str_filas[3]::integer;
						END IF;
					ELSE
						IF str_filas[3]::integer=0 THEN 
							--Aqui se verifica si el id del registro viene en cero
							SELECT id::character varying FROM fac_nomina_det WHERE fac_nomina_id=str_data[4]::integer AND gral_empleado_id=str_filas[4]::integer 
							INTO str_filas[3];
							
							IF str_filas[3] IS NULL THEN str_filas[3]:='0'; END IF;
						END IF;
						IF str_filas[3]::integer<=0 THEN 
							--Crear registro en fac_nomina_det
							INSERT INTO fac_nomina_det(fac_nomina_id, gral_empleado_id )VALUES(str_data[4]::integer,str_filas[4]::integer);
						END IF;
					END IF;
				END LOOP;
			END IF;
			
			--valor_actualizado||id_registro||codigo_error||mensaje
			valor_retorno := '1:'||ultimo_id||':'||'0'||':Los datos se guardaron con exito.';
		END IF;
		--Termina EDIT Nomina





		--FACTURAR Nomina por Empleado(Actualizar registros para indicar que ya fue facturado)
		IF command_selected = 'facturar_nomina' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	nom_det_id
			--str_data[5]	empleado_id
			--str_data[6]	ref_id
			--str_data[7]	Serie
			--str_data[8]	Folio
			--str_data[9]	cadena_xml

			--Actualiza el registro para indicar que se ha generado CFDi de Nomina
			UPDATE fac_nomina_det SET facturado=true, serie=str_data[7],folio=str_data[8],ref_id=str_data[6], momento_facturacion=espacio_tiempo_ejecucion, gral_usr_id_facturacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer AND gral_empleado_id=str_data[5]::integer RETURNING fac_nomina_id INTO ultimo_id;
			
			--Guarda la cadena del xml timbrado
			INSERT INTO fac_cfdis(tipo, ref_id, doc, gral_emp_id, gral_suc_id, fecha_crea, gral_usr_id_crea) VALUES (3,str_data[6],str_data[9]::text,emp_id,suc_id,espacio_tiempo_ejecucion, usuario_ejecutor);
			
			--Obtener el ID del numero de periodo
			SELECT nom_periodos_conf_det_id FROM fac_nomina WHERE id=ultimo_id LIMIT 1 INTO id2;
			IF id2 IS NULL THEN id2:=0; END IF;
			
			IF (SELECT count(id) FROM fac_nomina_det WHERE fac_nomina_id=ultimo_id AND facturado=false)<=0 THEN 
				--Actualiza para indicar se ha generado CFDI de todos los registros de NOMINA
				UPDATE fac_nomina SET status=2 WHERE id=ultimo_id;
			ELSE
				--Actualiza para indicar se ha generado CFDI de por lo menos un registro de NOMINA
				UPDATE fac_nomina SET status=1 WHERE id=ultimo_id;
			END IF;
			
			--Actualizar el periodo actual para indicar que ya fue generado la nomina correspondiente
			UPDATE nom_periodos_conf_det SET estatus=true WHERE id=id2;
			
			--Actualiza el consecutivo del folio de Nominas en la tabla fac_cfds_conf_folios. La actualizaci√≥n es por Empresa-sucursal
			UPDATE fac_cfds_conf_folios SET folio_actual=(folio_actual+1) WHERE id=(SELECT fac_cfds_conf_folios.id FROM fac_cfds_conf JOIN fac_cfds_conf_folios ON fac_cfds_conf_folios.fac_cfds_conf_id=fac_cfds_conf.id WHERE lower(trim(fac_cfds_conf_folios.proposito))='nom' AND fac_cfds_conf.empresa_id=emp_id AND fac_cfds_conf.gral_suc_id=suc_id);
			
			--valor_actualizado||id_registro||codigo_error||mensaje
			valor_retorno := '1:'||ultimo_id||':'||'0'||':Se ha creado el CFDI de Nomina'||str_data[7]||str_data[8]||'.';
		END IF;
		--Termina FACTURAR Nomina



		--CANCELAR CFDI DE NOMINA
		IF command_selected = 'cancelacion_cfdi_nomina' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_reg
			--str_data[5]	id_empleado
			
			--Actualiza el registro para indicar que se ha generado CFDi de Nomina
			UPDATE fac_nomina_det SET cancelado=true, momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancela=usuario_ejecutor 
			WHERE id=str_data[4]::integer AND gral_empleado_id=str_data[5]::integer RETURNING ref_id INTO refId;
			
			--Actualiza el registro de xmls
			UPDATE fac_cfdis SET cancelado=true, fecha_cancela=espacio_tiempo_ejecucion, gral_usr_id_cancela=usuario_ejecutor 
			WHERE tipo=3 AND ref_id=refId AND gral_emp_id=emp_id;
			
			--valor_actualizado||id_registro||codigo_error||mensaje
			valor_retorno := '1:Se ha CANCELADO el CFDI de Nomina '||refId;
		END IF;
		--Termina FACTURAR Nomina



		
		
		--Guarda datos de la nomina de un empleado en especifico
		IF command_selected = 'new_nomina' THEN 
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5]	id_reg
			--str_data[6]	id_empleado
			--str_data[7]	no_empleado
			--str_data[8]	rfc_empleado
			--str_data[9]	nombre_empleado
			--str_data[10]	select_departamento
			--str_data[11]	select_puesto
			--str_data[12]	fecha_contrato
			--str_data[13]	antiguedad
			--str_data[14]	curp
			--str_data[15]	select_reg_contratacion
			--str_data[16]	select_tipo_contrato
			--str_data[17]	select_tipo_jornada
			--str_data[18]	select_preriodo_pago
			--str_data[19]	clabe
			--str_data[20]	select_banco
			--str_data[21]	select_riesgo_puesto
			--str_data[22]	imss
			--str_data[23]	reg_patronal
			--str_data[24]	salario_base
			--str_data[25]	fecha_ini_pago
			--str_data[26]	fecha_fin_pago
			--str_data[27]	salario_integrado
			--str_data[28]	no_dias_pago
			--str_data[29]	concepto_descripcion
			--str_data[30]	concepto_unidad
			--str_data[31]	concepto_cantidad
			--str_data[32]	concepto_valor_unitario
			--str_data[33]	concepto_importe
			--str_data[34]	descuento
			--str_data[35]	motivo_descuento
			--str_data[36]	select_impuesto_retencion
			--str_data[37]	importe_retencion
			--str_data[38]	comp_subtotal
			--str_data[39]	comp_descuento
			--str_data[40]	comp_retencion
			--str_data[41]	comp_total
			--str_data[42]	percep_total_gravado
			--str_data[43]	percep_total_excento
			--str_data[44]	deduc_total_gravado
			--str_data[45]	deduc_total_excento
			--str_data[46]	percepciones
			--str_data[47]	deducciones
			--str_data[48]	hrs_extras
			--str_data[49]	incapacidades
			
			IF str_data[5]::integer=0 THEN 
				--Aqui se verifica si el id del registro viene en cero
				SELECT id::character varying FROM fac_nomina_det WHERE fac_nomina_id=str_data[4]::integer AND gral_empleado_id=str_data[6]::integer 
				INTO str_data[5];
				
				IF str_data[5] IS NULL THEN str_data[5]:='0'; END IF;
			END IF;
			
			IF str_data[5]::integer>0 THEN
				--Se actualiza porque el registro ya existe
				UPDATE fac_nomina_det SET gral_empleado_id = str_data[6]::integer, no_empleado = str_data[7], rfc = str_data[8], nombre = str_data[9], curp = str_data[14], gral_depto_id = str_data[10]::integer, gral_puesto_id = str_data[11]::integer, fecha_contrato = str_data[12]::date, antiguedad = str_data[13]::integer, nom_regimen_contratacion_id = str_data[15]::integer, nom_tipo_contrato_id = str_data[16]::integer, nom_tipo_jornada_id = str_data[17]::integer, nom_periodicidad_pago_id = str_data[18]::integer, clabe = str_data[19], tes_ban_id = str_data[20]::integer, nom_riesgo_puesto_id = str_data[21]::integer, imss = str_data[22], reg_patronal = str_data[23], salario_base = str_data[24]::double precision, salario_integrado = str_data[27]::double precision, fecha_ini_pago = str_data[25]::date, fecha_fin_pago = str_data[26]::date, no_dias_pago = str_data[28]::integer, concepto_descripcion = str_data[29], concepto_unidad = str_data[30], concepto_cantidad = str_data[31]::double precision, concepto_valor_unitario = str_data[32]::double precision, concepto_importe = str_data[33]::double precision, descuento = str_data[34]::double precision, motivo_descuento = str_data[35], gral_isr_id = str_data[36]::integer, importe_retencion = str_data[37]::double precision, comp_subtotal = str_data[38]::double precision, comp_descuento = str_data[39]::double precision, comp_retencion = str_data[40]::double precision, comp_total = str_data[41]::double precision, percep_total_gravado = str_data[42]::double precision, percep_total_excento = str_data[43]::double precision, deduc_total_gravado = str_data[44]::double precision, deduc_total_excento = str_data[45]::double precision, validado=true 
				WHERE id=str_data[5]::integer 
				RETURNING id INTO ultimo_id;
				
				--Se eliminan estos registros porque mas adelante se vuelven a crear
				DELETE FROM fac_nomina_det_percep WHERE fac_nomina_det_id = ultimo_id;
				DELETE FROM fac_nomina_det_deduc WHERE fac_nomina_det_id = ultimo_id;
				DELETE FROM fac_nomina_det_hrs_extra WHERE fac_nomina_det_id = ultimo_id;
				DELETE FROM fac_nomina_det_incapa WHERE fac_nomina_det_id = ultimo_id;
			ELSE
				--Se crea nuevo registro
				INSERT INTO fac_nomina_det(fac_nomina_id, gral_empleado_id, no_empleado, rfc, nombre, curp, gral_depto_id, gral_puesto_id, fecha_contrato, antiguedad, nom_regimen_contratacion_id, nom_tipo_contrato_id, nom_tipo_jornada_id, nom_periodicidad_pago_id, clabe, tes_ban_id, nom_riesgo_puesto_id, imss, reg_patronal, salario_base, salario_integrado, fecha_ini_pago, fecha_fin_pago, no_dias_pago, concepto_descripcion, concepto_unidad, concepto_cantidad, concepto_valor_unitario, concepto_importe, descuento, motivo_descuento, gral_isr_id, importe_retencion, comp_subtotal, comp_descuento, comp_retencion, comp_total, percep_total_gravado, percep_total_excento, deduc_total_gravado, deduc_total_excento, validado)
				values(str_data[4]::integer, str_data[6]::integer, str_data[7], str_data[8], str_data[9], str_data[14], str_data[10]::integer, str_data[11]::integer, str_data[12]::date, str_data[13]::integer, str_data[15]::integer, str_data[16]::integer, str_data[17]::integer, str_data[18]::integer, str_data[19], str_data[20]::integer, str_data[21]::integer, str_data[22], str_data[23], str_data[24]::double precision, str_data[27]::double precision, str_data[25]::date, str_data[26]::date, str_data[28]::integer, str_data[29], str_data[30], str_data[31]::double precision, str_data[32]::double precision, str_data[33]::double precision, str_data[34]::double precision, str_data[35], str_data[36]::integer, str_data[37]::double precision, str_data[38]::double precision, str_data[39]::double precision, str_data[40]::double precision, str_data[41]::double precision, str_data[42]::double precision, str_data[43]::double precision, str_data[44]::double precision, str_data[45]::double precision, true)
				RETURNING id INTO ultimo_id;
			END IF;
			
			--str_data[46]	percepciones
			IF str_data[46] is not null AND str_data[46]<>'' THEN
				--Convertir en arreglo la cadena de Percepciones
				SELECT INTO str_percep string_to_array(str_data[46],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_percep,1) .. array_upper(str_percep,1) LOOP
					SELECT INTO str_filas string_to_array(str_percep[cont_fila],'|');
					--str_filas[1]	id_percep
					--str_filas[2]	noTrPercep
					--str_filas[3]	percep_monto_gravado
					--str_filas[4]	percep_monto_excento
					INSERT INTO fac_nomina_det_percep(fac_nomina_det_id,nom_percep_id,gravado,excento) 
					VALUES (ultimo_id,str_filas[1]::integer,str_filas[3]::double precision,str_filas[4]::double precision);
				END LOOP;
			END IF;
			
			--str_data[47]	deducciones
			IF str_data[47] is not null AND str_data[47]<>'' THEN
				--Convertir en arreglo la cadena de Deducciones
				SELECT INTO str_deduc string_to_array(str_data[47],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_deduc,1) .. array_upper(str_deduc,1) LOOP
					SELECT INTO str_filas string_to_array(str_deduc[cont_fila],'|');
					--str_filas[1]	id_deduc
					--str_filas[2]	noTrDeduc
					--str_filas[3]	deduc_monto_gravado
					--str_filas[4]	deduc_monto_excento
					INSERT INTO fac_nomina_det_deduc(fac_nomina_det_id,nom_deduc_id,gravado,excento) 
					VALUES (ultimo_id,str_filas[1]::integer,str_filas[3]::double precision,str_filas[4]::double precision);
				END LOOP;
			END IF;
			
			--str_data[48]	hrs_extras
			IF str_data[48] is not null AND str_data[48]<>'' THEN
				--Convertir en arreglo la cadena de Horas Extras
				SELECT INTO str_hrs_extras string_to_array(str_data[48],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_hrs_extras,1) .. array_upper(str_hrs_extras,1) LOOP
					SELECT INTO str_filas string_to_array(str_hrs_extras[cont_fila],'|');
					--str_filas[1]	id_he
					--str_filas[2]	noTrhe
					--str_filas[3]	select_tipo_he
					--str_filas[4]	he_no_dias
					--str_filas[5]	he_no_horas
					--str_filas[6]	he_importe
					INSERT INTO fac_nomina_det_hrs_extra(fac_nomina_det_id, nom_tipo_hrs_extra_id ,no_dias, no_hrs, importe) 
					VALUES (ultimo_id,str_filas[3]::integer,str_filas[4]::double precision,str_filas[5]::double precision, str_filas[6]::double precision);
				END LOOP;
			END IF;

			
			--str_data[49]	incapacidades
			IF str_data[49] is not null AND str_data[49]<>'' THEN
				--Convertir en arreglo la cadena de Horas Extras
				SELECT INTO str_incapa string_to_array(str_data[49],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_incapa,1) .. array_upper(str_incapa,1) LOOP
					SELECT INTO str_filas string_to_array(str_incapa[cont_fila],'|');
					--str_filas[1]	id_incapacidad
					--str_filas[2]	noTrIncapacidad
					--str_filas[3]	select_tipo_incapacidad
					--str_filas[4]	incapacidad_no_dias
					--str_filas[5]	incapacidad_importe
					INSERT INTO fac_nomina_det_incapa(fac_nomina_det_id, nom_tipo_incapacidad_id, no_dias, importe) 
					VALUES (ultimo_id, str_filas[3]::integer, str_filas[4]::double precision, str_filas[5]::double precision);
				END LOOP;
			END IF;
			
			IF ultimo_id IS NULL THEN ultimo_id=0; END IF;
			
			--valor_actualizado||id_registro||codigo_error||mensaje
			valor_retorno := '1:'||ultimo_id||':'||'0'||':Los datos se guardaron con exito.';
		END IF;
		--Termina NEW Nomina Empleado
		
		
		
		--Editar el registro de Nomina de un empleado
		IF command_selected = 'edit_nomina' THEN 
			IF str_data[5]::integer=0 THEN 
				--Aqui se verifica si el id del registro viene en cero
				SELECT id::character varying FROM fac_nomina_det WHERE fac_nomina_id=str_data[4]::integer AND gral_empleado_id=str_data[6]::integer 
				INTO str_data[5];
				
				IF str_data[5] IS NULL THEN str_data[5]:='0'; END IF;
			END IF;
			
			IF trim(str_data[13])='' THEN str_data[13]:='0'; END IF;
			
			UPDATE fac_nomina_det SET gral_empleado_id = str_data[6]::integer, no_empleado = str_data[7], rfc = str_data[8], nombre = str_data[9], curp = str_data[14], gral_depto_id = str_data[10]::integer, gral_puesto_id = str_data[11]::integer, fecha_contrato = str_data[12]::date, antiguedad = str_data[13]::integer, nom_regimen_contratacion_id = str_data[15]::integer, nom_tipo_contrato_id = str_data[16]::integer, nom_tipo_jornada_id = str_data[17]::integer, nom_periodicidad_pago_id = str_data[18]::integer, clabe = str_data[19], tes_ban_id = str_data[20]::integer, nom_riesgo_puesto_id = str_data[21]::integer, imss = str_data[22], reg_patronal = str_data[23], salario_base = str_data[24]::double precision, salario_integrado = str_data[27]::double precision, fecha_ini_pago = str_data[25]::date, fecha_fin_pago = str_data[26]::date, no_dias_pago = str_data[28]::integer, concepto_descripcion = str_data[29], concepto_unidad = str_data[30], concepto_cantidad = str_data[31]::double precision, concepto_valor_unitario = str_data[32]::double precision, concepto_importe = str_data[33]::double precision, descuento = str_data[34]::double precision, motivo_descuento = str_data[35], gral_isr_id = str_data[36]::integer, importe_retencion = str_data[37]::double precision, comp_subtotal = str_data[38]::double precision, comp_descuento = str_data[39]::double precision, comp_retencion = str_data[40]::double precision, comp_total = str_data[41]::double precision, percep_total_gravado = str_data[42]::double precision, percep_total_excento = str_data[43]::double precision, deduc_total_gravado = str_data[44]::double precision, deduc_total_excento = str_data[45]::double precision, validado=true 
			WHERE id=str_data[5]::integer 
			RETURNING id INTO ultimo_id;
			
			--Eliminar los registros de percepciones de nomina
			DELETE FROM fac_nomina_det_percep WHERE fac_nomina_det_id = ultimo_id;
			
			--str_data[46]	percepciones
			IF str_data[46] is not null AND str_data[46]<>'' THEN 
				--Convertir en arreglo la cadena de Percepciones
				SELECT INTO str_percep string_to_array(str_data[46],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_percep,1) .. array_upper(str_percep,1) LOOP
					SELECT INTO str_filas string_to_array(str_percep[cont_fila],'|');
					
					--Volver a crear los registros de las percepciones de nomina
					INSERT INTO fac_nomina_det_percep(fac_nomina_det_id,nom_percep_id,gravado,excento) VALUES (ultimo_id,str_filas[1]::integer,str_filas[3]::double precision,str_filas[4]::double precision);
				END LOOP;
			END IF;


			--Eliminar los registros de Deducciones de nomina
			DELETE FROM fac_nomina_det_deduc WHERE fac_nomina_det_id = ultimo_id;
			
			--str_data[47]	deducciones
			IF str_data[47] is not null AND str_data[47]<>'' THEN
				--Convertir en arreglo la cadena de Deducciones
				SELECT INTO str_deduc string_to_array(str_data[47],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_deduc,1) .. array_upper(str_deduc,1) LOOP
					SELECT INTO str_filas string_to_array(str_deduc[cont_fila],'|');
					
					--Volver a crear los registros de las deducciones de nomina
					INSERT INTO fac_nomina_det_deduc(fac_nomina_det_id,nom_deduc_id,gravado,excento) VALUES (ultimo_id,str_filas[1]::integer,str_filas[3]::double precision,str_filas[4]::double precision);
				END LOOP;
			END IF;


			--Eliminar los registros de Horas Extras de nomina
			DELETE FROM fac_nomina_det_hrs_extra WHERE fac_nomina_det_id = ultimo_id;
			
			--str_data[48]	hrs_extras
			IF str_data[48] is not null AND str_data[48]<>'' THEN
				--Convertir en arreglo la cadena de Horas Extras
				SELECT INTO str_hrs_extras string_to_array(str_data[48],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_hrs_extras,1) .. array_upper(str_hrs_extras,1) LOOP
					SELECT INTO str_filas string_to_array(str_hrs_extras[cont_fila],'|');
					--Volver a crear los registros de las horas extras de nomina
					INSERT INTO fac_nomina_det_hrs_extra(fac_nomina_det_id, nom_tipo_hrs_extra_id ,no_dias, no_hrs, importe) 
					VALUES (ultimo_id,str_filas[3]::integer,str_filas[4]::double precision,str_filas[5]::double precision, str_filas[6]::double precision);
				END LOOP;
			END IF;
			
			--Eliminar los registros de Incapacidades de nomina
			DELETE FROM fac_nomina_det_incapa WHERE fac_nomina_det_id = ultimo_id;
			
			--str_data[49]	incapacidades
			IF str_data[49] is not null AND str_data[49]<>'' THEN
				--Convertir en arreglo la cadena de Horas Extras
				SELECT INTO str_incapa string_to_array(str_data[49],'&&&');
				cont_fila=1;
				FOR cont_fila IN array_lower(str_incapa,1) .. array_upper(str_incapa,1) LOOP
					SELECT INTO str_filas string_to_array(str_incapa[cont_fila],'|');
					--Volver a crear los registros de Incapacidades de nomina
					INSERT INTO fac_nomina_det_incapa(fac_nomina_det_id, nom_tipo_incapacidad_id, no_dias, importe) VALUES (ultimo_id, str_filas[3]::integer, str_filas[4]::double precision, str_filas[5]::double precision);
				END LOOP;
			END IF;
			
			IF ultimo_id IS NULL THEN ultimo_id=0; END IF;
			
			--valor_actualizado||id_registro||codigo_error||mensaje
			valor_retorno := '1:'||ultimo_id||':'||'0'||':Los datos se guardaron con exito.';
		END IF;
		--Termina EDIT Nomina Empleado
		
	END IF;
	--Termina Factura de NOMINA
	
	
	
	
	--Configuracion de parametros de Facturacion
	IF app_selected = 175 THEN
		IF command_selected = 'edit' THEN 
			--str_data[1]  app_selected
			--str_data[2]  command_selected
			--str_data[3]  id_usuario 
			--str_data[4]  identificador
			--str_data[5]  identificador_suc
			--str_data[6]  correo_envio
			--str_data[7]  passwd_correo_envio
			--str_data[8]  passwd2_correo_envio
			--str_data[9]  servidor_correo_envio
			--str_data[10]  puerto_correo_envio
			--str_data[11]  correo_cco
			--str_data[12]  select_almacen_ventas
			--str_data[13]  select_formato_pedido
			--str_data[14]  correo_id
			--str_data[15]  cco_id

			IF str_data[14]::integer=0 THEN 
				INSERT INTO gral_emails(gral_emp_id, gral_suc_id, email, passwd, port, host, borrado_logico) VALUES(emp_id, str_data[5]::integer, str_data[6], str_data[7], str_data[10], str_data[9], false) 
				RETURNING id INTO ultimo_id;

				str_data[14]:=ultimo_id::character varying;
			ELSE
				UPDATE gral_emails SET email=str_data[6], passwd=str_data[7], port=str_data[10], host=str_data[9] WHERE id=str_data[14]::integer;
			END IF;
			
			IF str_data[15]::integer=0 THEN 
				INSERT INTO gral_emails(gral_emp_id, gral_suc_id, email, passwd, port, host, borrado_logico) VALUES(emp_id, str_data[5]::integer, str_data[11], '', '', '', false) 
				RETURNING id INTO id2;
				
				str_data[15]:=id2::character varying;
			ELSE
				UPDATE gral_emails SET email=str_data[11] WHERE id=str_data[15]::integer;
			END IF;
			
			UPDATE fac_par SET inv_alm_id=str_data[12]::integer, formato_pedido=str_data[13]::integer, gral_emails_id_envio=str_data[14]::integer, gral_emails_id_cco=str_data[15]::integer, momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer AND gral_suc_id=str_data[5]::integer;
			
		END IF;
	END IF;






	--quitar y reasignar reservados
	--select * from quitar_y_reasignar_reservados(emp_id) into result;




	
	

	
	RETURN valor_retorno; 

END;$$;


--
-- Name: genera_folio_proveedor(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.genera_folio_proveedor() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	fila record;
	nombre_consecutivo character varying = '';
	cadena_extra character varying = '';
	ultimo_cosecutivo_proveedor character varying;
	folio_proveedor character varying;
	cadena_sql character varying;
BEGIN

	
	
	
	--obtiene lista de todos los proveedores
	cadena_sql:='SELECT id, empresa_id from cxp_prov order by id';
	
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
			IF fila.empresa_id = 4 THEN
				nombre_consecutivo:='folio_proveedor_kathion';
				cadena_extra:='KAPROV';
			END IF;
			IF fila.empresa_id = 7 THEN
				nombre_consecutivo:='folio_proveedor_kemikal';
				cadena_extra:='KEPROV';
			END IF;
			
			--obtener el ultimo consecutivo del folio_proveedor
			SELECT consecutivo FROM erp_consecutivos INTO ultimo_cosecutivo_proveedor WHERE secuencia ILIKE nombre_consecutivo;
			
			--actualiza secuencia consecutiva del folio_proveedor
			UPDATE erp_consecutivos
			SET consecutivo = (ultimo_cosecutivo_proveedor::integer + 1)::character varying,momento_actualizacion = now()
			WHERE secuencia ILIKE nombre_consecutivo;
			
			--nuevo folio del proveedor
			folio_proveedor := cadena_extra||erp_fn_agregar_ceros((ultimo_cosecutivo_proveedor::integer + 1)::character varying,4);
			
			UPDATE cxp_prov SET folio=folio_proveedor WHERE id=fila.id;
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: genera_movimientos_de_facturas_canceladas_y_devolucion_producto(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.genera_movimientos_de_facturas_canceladas_y_devolucion_producto(id_prefactura integer, id_user integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	
	--variables para movimientos en existencias
	cadena_sql text;
	cadena_sql_formula text;
	id_almacen integer=0;
	
	prefactura_detalle record;
	formulacion record;
	fecha_facturacion timestamp with time zone;
	id_user_creacion integer; 
	ano_actual integer;
	mes_actual integer;
	observaciones_prefactura text = '';
	identificador_nuevo_movimiento integer = 0;
	cantidad_porcentaje double precision;
	exis integer=0;
	sql_insert character varying;
	sql_update character varying;
	sql_select character varying;
BEGIN

	--obtener id de almacen de la sucursal
  	SELECT inv_suc_alm.almacen_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id = id_user
	INTO id_almacen;
	
	SELECT erp_prefacturas.observaciones, 
		erp_prefacturas.id_usuario_creacion,
		(split_part(fac_cfds.momento_expedicion,'T',1)||' '||split_part(fac_cfds.momento_expedicion,'T',2)):: timestamp with time zone fecha_movimiento
	FROM erp_prefacturas
	JOIN fac_cfds ON fac_cfds.id=erp_prefacturas.factura_id
	WHERE erp_prefacturas.id = id_prefactura
	INTO observaciones_prefactura, id_user_creacion, fecha_facturacion;
	
	
	SELECT EXTRACT(YEAR FROM fecha_facturacion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM fecha_facturacion) INTO mes_actual;
	
	-- el aplicativo de prefacturas es el numero 13
	--genera registro del movimiento de cancelacion
	INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id,gral_app_id) 
	VALUES(observaciones_prefactura,fecha_facturacion,id_user_creacion,13) 
	RETURNING id INTO identificador_nuevo_movimiento;
	
	
	--obtiene lista de productos de la factura
	cadena_sql:='SELECT  erp_prefacturas_detalles.producto_id,
				erp_prefacturas_detalles.cantidad,
				inv_prod.tipo_de_producto_id as tipo_producto
			FROM erp_prefacturas_detalles 
			JOIN inv_prod ON inv_prod.id=erp_prefacturas_detalles.producto_id
			WHERE prefacturas_id='||id_prefactura;
	
	--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
	
	FOR prefactura_detalle IN EXECUTE(cadena_sql) LOOP
		
		/*
		prefactura_detalle.producto_id
		prefactura_detalle.cantidad
		prefactura_detalle.tipo_producto
		*/
		
		
		IF prefactura_detalle.tipo_producto = 1 THEN
			--genera registro en detalles del movimiento
			INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id)
			VALUES(prefactura_detalle.producto_id, 0,id_almacen, prefactura_detalle.cantidad, identificador_nuevo_movimiento);
			
			--reiniciamos el valor de la variable exis a cero
			exis:=0;
			
			--query para verificar existencia del producto en el almacen y en el a√±o actual
			sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||prefactura_detalle.producto_id||' AND inv_alm_id ='||id_almacen||' AND ano = '||ano_actual;
			--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
			EXECUTE sql_select INTO exis;
			
			IF exis >0 THEN
				sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||prefactura_detalle.cantidad||'::double precision),momento_entrada_'||mes_actual||'='''||fecha_facturacion||'''
				WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||prefactura_detalle.producto_id||' AND ano='||ano_actual;
				EXECUTE sql_update;
			ELSE
				sql_insert:='INSERT INTO inv_exi (inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial) '||
				'VALUES('||prefactura_detalle.producto_id||','||id_almacen||','||ano_actual||','||prefactura_detalle.cantidad||','''|| fecha_facturacion ||''',0)';
				EXECUTE sql_insert;
			END IF;
			
		ELSE
			--obtiene los productos ingredientes del producto formulado
			
			cadena_sql_formula:='SELECT producto_formulacion_id,
					producto_ingrediente_id, 
					(porcentaje / 100) as porcentaje
				FROM inv_prod_formulaciones 
				WHERE producto_formulacion_id='||prefactura_detalle.producto_id;
				
				
			FOR formulacion IN EXECUTE(cadena_sql_formula) LOOP
				
				cantidad_porcentaje := prefactura_detalle.cantidad * formulacion.porcentaje;
				
				--genera registro en detalles del movimiento
				INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id)
				VALUES(formulacion.producto_ingrediente_id, 0,id_almacen, cantidad_porcentaje, identificador_nuevo_movimiento);

				--query para sumar producto de existencias
				sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||cantidad_porcentaje||'::double precision),momento_entrada_'||mes_actual||'='''||fecha_facturacion||'''
				WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||formulacion.producto_ingrediente_id||' AND ano='||ano_actual;
				EXECUTE sql_update;
				
			END LOOP;
			
			
		END IF;
		
		
		
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: genera_movimientos_de_facturas_y_descuenta_existencias(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.genera_movimientos_de_facturas_y_descuenta_existencias(id_prefactura integer, id_user integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';


	--variables para movimientos en existencias
	cadena_sql text;
	sql_update text;
	cadena_sql_formula text;
	id_almacen integer=0;
	
	prefactura_detalle record;
	formulacion record;
	fecha_facturacion timestamp with time zone;
	id_user_creacion integer; 
	ano_actual integer;
	mes_actual integer;
	observaciones_prefactura text = '';
	identificador_nuevo_movimiento integer = 0;
	cantidad_porcentaje double precision;
BEGIN
	--obtener id de almacen de la sucursal
  	SELECT inv_suc_alm.almacen_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id = id_user
	INTO id_almacen;

	
	SELECT erp_prefacturas.observaciones, 
		erp_prefacturas.id_usuario_creacion,
		(split_part(fac_cfds.momento_expedicion,'T',1)||' '||split_part(fac_cfds.momento_expedicion,'T',2)):: timestamp with time zone fecha_movimiento
	FROM erp_prefacturas
	JOIN fac_cfds ON fac_cfds.id=erp_prefacturas.factura_id
	WHERE erp_prefacturas.id=id_prefactura
	INTO observaciones_prefactura, id_user_creacion, fecha_facturacion;
	

	SELECT EXTRACT(YEAR FROM fecha_facturacion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM fecha_facturacion) INTO mes_actual;
	
	-- el aplicativo de prefacturas es el numero 13
	--genera registro del movimiento
	INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id, gral_app_id) 
	VALUES(observaciones_prefactura,fecha_facturacion,id_user,13) 
	RETURNING id INTO identificador_nuevo_movimiento;
	
	--obtiene lista de productos de la factura
	cadena_sql:='SELECT  erp_prefacturas_detalles.producto_id,
				erp_prefacturas_detalles.cantidad,
				inv_prod.tipo_de_producto_id as tipo_producto
			FROM erp_prefacturas_detalles 
			JOIN inv_prod ON inv_prod.id=erp_prefacturas_detalles.producto_id
			WHERE prefacturas_id='||id_prefactura;
	
	--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
	
	FOR prefactura_detalle IN EXECUTE(cadena_sql) LOOP
		
		/*
		prefactura_detalle.producto_id
		prefactura_detalle.cantidad
		prefactura_detalle.tipo_producto
		*/
		
		
		IF prefactura_detalle.tipo_producto = 1 THEN
			--genera registro en detalles del movimiento
			INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id)
			VALUES(prefactura_detalle.producto_id, id_almacen,0, prefactura_detalle.cantidad, identificador_nuevo_movimiento);
			
			--query para descontar producto de existencias
			sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||prefactura_detalle.cantidad||'),momento_salida_'||mes_actual||'='''||fecha_facturacion||'''
			WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||prefactura_detalle.producto_id||' AND ano='||ano_actual;
			EXECUTE sql_update;
		ELSE
			--obtiene los productos ingredientes del producto formulado
			cadena_sql_formula:='SELECT producto_formulacion_id,
					producto_ingrediente_id, 
					(porcentaje / 100) as porcentaje
				FROM inv_prod_formulaciones 
				WHERE producto_formulacion_id='||prefactura_detalle.producto_id;
				
				
			FOR formulacion IN EXECUTE(cadena_sql_formula) LOOP
				
				cantidad_porcentaje := prefactura_detalle.cantidad * formulacion.porcentaje;
				
				--genera registro en detalles del movimiento
				INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id)
				VALUES(formulacion.producto_ingrediente_id, id_almacen,0, cantidad_porcentaje, identificador_nuevo_movimiento);
				
				--query para descontar producto de existencias
				sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||cantidad_porcentaje||'),momento_salida_'||mes_actual||'='''||fecha_facturacion||'''
				WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||formulacion.producto_ingrediente_id||' AND ano='||ano_actual;

				EXECUTE sql_update;
			END LOOP;

			
		END IF;
		
		
		
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: get_clave_cfdi_claveprodserv(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_clave_cfdi_claveprodserv(in_id_cfdi_claveprodserv integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

DECLARE
	sql_select character varying = '';
	out_clave_cfdi_claveprodserv character varying='';
	
BEGIN	
	
	sql_select := 'SELECT clave FROM cfdi_claveprodserv WHERE id='||in_id_cfdi_claveprodserv||'::integer;';
	EXECUTE sql_select INTO out_clave_cfdi_claveprodserv;
	
	--RAISE EXCEPTION '%',cadena_sql;
	
	IF out_clave_cfdi_claveprodserv IS NULL THEN 
		out_clave_cfdi_claveprodserv:='';
	END IF;
	
	RETURN out_clave_cfdi_claveprodserv;
	
END;

$$;


--
-- Name: get_id_cfdi_claveprodserv(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_id_cfdi_claveprodserv(in_clave_cfdi_claveprodserv character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

DECLARE
	sql_select character varying = '';
	out_id_cfdi_claveprodserv character varying='';
	
BEGIN	
	
	sql_select := 'SELECT id FROM cfdi_claveprodserv WHERE clave='||in_clave_cfdi_claveprodserv||'::character varying;';
	EXECUTE sql_select INTO out_id_cfdi_claveprodserv;
	
	--RAISE EXCEPTION '%',cadena_sql;
	
	IF out_id_cfdi_claveprodserv IS NULL THEN 
		out_id_cfdi_claveprodserv:='';
	END IF;
	
	RETURN out_id_cfdi_claveprodserv;
	
END;

$$;


--
-- Name: gral_adm_catalogos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gral_adm_catalogos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

DECLARE
	

	--estas  variables se utilizan en la mayoria de los catalogos
	str_data text[];
	str_percep text[];
	str_deduc text[];
	
	app_selected integer;
	command_selected text;
	valor_retorno character varying;
	usuario_id integer;
	emp_id integer;
	suc_id integer;
	ultimo_id integer;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	id_almacen integer=0;
	exis integer=0;
	
	id_tipo_consecutivo integer=0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
	incluye_modulo_produccion boolean;
	incluye_modulo_contabilidad boolean;
	incluye_modulo_envasado boolean;
	controlExisPres boolean = false;--Variable que indica si se debe controlar las existencias por presentaciones
	incluye_nomina boolean:=false;
	
	--seran eliminadas
	nombre_consecutivo character varying = '';
	cadena_extra character varying = '';
	ultimo_cosecutivo_proveedor character varying;
	folio_proveedor character varying;
	
	--variables para catalogo de clientes
	str_filas text[];
	total_filas integer;--total de elementos de arreglo
	cont_fila integer;--contador de filas o posiciones del arreglo
	factura_en boolean;
	descarga_xml boolean;
	numero_control_client character varying;
	ultimo_cosecutivo_cliente character varying;
	
	--variables para catalogo de productos
	ultimo_cosecutivo_producto character varying;
	nuevo_sku character varying;
	tipo_producto integer;
	id_producto integer;
	str_pres text[];
	tot_filas integer;--total de elementos de arreglo de id de presentaciones
	meta_imp character varying='';
	
	--variable para prefacturas
	ultimo_id_proceso integer;
	
	--variable para pagos
	folio_transaccion bigint;
	ultimo_cosecutivo_transaccion character varying;
	id_forma_pago integer;
	id_anticipo integer;
	monto_anticipo_actual double precision;
	saldo_anticipo double precision;
	rowCount integer;
	item text[];
	iterar text[];
	veces int:=0;
	incrementa int:=1;
	sql_pagos text; 
	fila record;
	fila2 record;
	suma_pagos double precision=0;
	suma_notas_credito double precision=0;
	folio_transaccion_pago bigint;
	
	total_factura double precision;
	monto_pagos double precision;
	nuevacantidad_monto_pago double precision;
	nuevo_saldo_factura double precision;
	suma_pagos_efectuados  double precision;
	
	id_pago integer:=0;
	monto_cancelado double precision:=0;
	id_pagos_detalles integer;
	nuevacantidad_monto_cancelados double precision:=0;
	total_monto_cancelados double precision;
	serie_folio_cancel character varying:='';
	id_moneda_factura integer:=0;
	id_moneda_anticipo integer:=0; 
	tipo_cambio_pago double precision:=0;
	
	ultimo_id_usr integer=0;
	eliminar_registro boolean=true;
	valor1 double precision:=0;
BEGIN
	--convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	--aplicativo seleccionado
	app_selected := str_data[1]::integer;
	
	command_selected := str_data[2];--new, edit, delete. Para aplicativo 14 pagos: pago, anticipo, cancelacion
	
	-- usuario que utiliza el aplicativo
	usuario_id := str_data[3]::integer;
	
	/*
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id;
	*/
	
	--obtiene empresa_id, sucursal_id y sucursal_id
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id,inv_suc_alm.almacen_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id=usuario_id
	INTO emp_id, suc_id, id_almacen;
	
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	valor_retorno:='0';
	
	--Query para verificar si la empresa actual incluye Control de Existencias por Presentacion
	SELECT control_exis_pres,nomina,incluye_contabilidad FROM gral_emp WHERE id=emp_id 
	INTO controlExisPres, incluye_nomina,incluye_modulo_contabilidad;
	
	-- Catalogo de Almacenes
	IF app_selected = 1 THEN
		IF command_selected = 'new' THEN
			INSERT INTO inv_alm(
				titulo,--str_data[5]
				calle,--str_data[6]
				numero,--str_data[7]
				colonia,--str_data[8]
				codigo_postal,--str_data[9]
				gral_pais_id,--str_data[10]::integer
				gral_edo_id,--str_data[11]::integer
				gral_mun_id,--str_data[12]::integer
				tel_1,--str_data[13]
				tel_2,--str_data[14]
				tel_1_ext,--str_data[15]
				tel_2_ext,--str_data[16]
				responsable,--str_data[17]
				responsable_puesto,--str_data[18]
				responsable_email,--str_data[19]
				almacen_tipo_id,--str_data[20]::integer
				compras,--str_data[21]::boolean
				consignacion,--str_data[22]::boolean
				explosion_mat,--str_data[23]::boolean
				garantias,--str_data[24]::boolean
				reabastecimiento,--str_data[25]::boolean
				recepcion_mat,--str_data[26]::boolean
				reporteo,--str_data[27]::boolean
				traspaso,--str_data[28]::boolean
				ventas,--str_data[29]::boolean
				borrado_logico,--false
				momento_creacion--now()
			) VALUES(str_data[5],str_data[6],str_data[7],str_data[8],str_data[9],str_data[10]::integer,str_data[11]::integer,str_data[12]::integer,str_data[13],str_data[14],str_data[15],str_data[16],str_data[17],str_data[18],str_data[19],str_data[20]::integer,str_data[21]::boolean,str_data[22]::boolean,str_data[23]::boolean,str_data[24]::boolean,str_data[25]::boolean,str_data[26]::boolean,str_data[27]::boolean,str_data[28]::boolean,str_data[29]::boolean,false,now()) 
			RETURNING id INTO ultimo_id;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN
				--RAISE EXCEPTION '%' ,extra_data[cont_fila]::integer;
				FOR cont_fila IN 1 .. total_filas LOOP
					INSERT INTO inv_suc_alm(almacen_id,sucursal_id) VALUES(ultimo_id, extra_data[cont_fila]::integer);
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_alm SET 
				titulo=str_data[5],
				calle=str_data[6],
				numero=str_data[7],
				colonia=str_data[8],
				codigo_postal=str_data[9],
				gral_pais_id=str_data[10]::integer,
				gral_edo_id=str_data[11]::integer,
				gral_mun_id=str_data[12]::integer,
				tel_1=str_data[13],
				tel_2=str_data[14],
				tel_1_ext=str_data[15],
				tel_2_ext=str_data[16],
				responsable=str_data[17],
				responsable_puesto=str_data[18],
				responsable_email=str_data[19],
				almacen_tipo_id=str_data[20]::integer,
				compras=str_data[21]::boolean,
				consignacion=str_data[22]::boolean,
				explosion_mat=str_data[23]::boolean,
				garantias=str_data[24]::boolean,
				reabastecimiento=str_data[25]::boolean,
				recepcion_mat=str_data[26]::boolean,
				reporteo=str_data[27]::boolean,
				traspaso=str_data[28]::boolean,
				ventas=str_data[29]::boolean,
				momento_actualizacion=now()
			WHERE id = str_data[4]::integer;

			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			IF extra_data[1] != 'sin datos' THEN
				DELETE FROM inv_suc_alm WHERE almacen_id=str_data[4]::integer;
				FOR cont_fila IN 1 .. total_filas LOOP
					INSERT INTO inv_suc_alm(almacen_id,sucursal_id) VALUES(str_data[4]::integer, extra_data[cont_fila]::integer);
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_alm SET borrado_logico=true, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de Almacenes




	
	-- Catalogo de Proveedores
	IF app_selected = 2 THEN
		IF command_selected = 'new' THEN

			id_tipo_consecutivo:=2;--Folio de proveedor
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

			INSERT INTO cxp_prov(
				folio,--nuevo_folio
				rfc,--str_data[6]
				curp,--str_data[7]
				razon_social,--str_data[8]
				clave_comercial,--str_data[9]
				calle,--str_data[10]
				numero,--str_data[11]
				colonia,--str_data[12]
				cp,--str_data[13]
				entre_calles,--str_data[14]
				pais_id,--str_data[15]::integer
				estado_id,--str_data[16]::integer
				municipio_id,--str_data[17]::integer
				localidad_alternativa,--str_data[18]
				telefono1,--str_data[19]
				extension1,--str_data[20]
				fax,--str_data[21]
				telefono2,--str_data[22]
				extension2,--str_data[23]
				correo_electronico,--str_data[24]
				web_site,--str_data[25]
				impuesto,--str_data[26]::integer
				cxp_prov_zona_id,--str_data[27]::integer
				grupo_id,--str_data[28]::integer
				proveedortipo_id,--str_data[29]::integer
				clasif_1,--str_data[30]::integer
				clasif_2,--str_data[31]::integer
				clasif_3,--str/controllers/facturas/startup.agnux_data[32]::integer
				moneda_id,--str_data[33]::integer
				tiempo_entrega_id,--str_data[34]::integer
				estatus,--str_data[35]::boolean
				limite_credito,--str_data[36]::double precision
				dias_credito_id,--str_data[37]::integer
				descuento,--str_data[38]::double precision
				credito_a_partir,--str_data[39]::integer
				cxp_prov_tipo_embarque_id,--str_data[40]::integer
				flete_pagado,--str_data[41]::boolean
				condiciones,--str_data[42]
				observaciones,--str_data[43]
				vent_contacto,--str_data[44]
				vent_puesto,--str_data[45]
				vent_calle,--str_data[46]
				vent_numero,--/controllers/facturas/startup.agnuxstr_data[47]
				vent_colonia,--str_data[48]
				vent_cp,--str_data[49]
				vent_entre_calles,--str_data[50]
				vent_pais_id,--str_data[51]::integer
				vent_estado_id,--str_data[52]::integer
				vent_municipio_id,--str_data[53]::integer
				vent_telefono1,--str_data[54]
				vent_extension1,--str_data[55]
				vent_fax,--str_data[56]
				vent_telefono2,--str_data[57]
				vent_extension2,--str_data[58]
				vent_email,--str_data[59]
				cob_contacto,--str_data[60]
				cob_puesto,--str_data[61]
				cob_calle,--str_data[62]
				cob_numero,--str_data[63]
				cob_colonia,--str_data[64]
				cob_cp,--str_data[65]
				cob_entre_calles,--str_data[66]
				cob_pais_id,--str_data[67]::integer
				cob_estado_id,--str_data[68]::integer
				cob_municipio_id,--str_data[69]::integer
				cob_telefono1,--str_data[70]
				cob_extension1,--str_data[71]
				cob_fax,--str_data[72]
				cob_telefono2,--str_data[73]
				cob_extension2,--str_data[74]
				cob_email,--str_data[75]
				comentarios,--str_data[76]
				ctb_cta_id_pasivo,--str_data[77]::integer,
				ctb_cta_id_egreso,--str_data[78]::integer,
				ctb_cta_id_ietu,--str_data[79]::integer,
				ctb_cta_id_comple,--str_data[80]::integer,
				ctb_cta_id_pasivo_comple,--str_data[81]::integer,
				transportista,--str_data[82]::boolean,
				empresa_id,--emp_id
				sucursal_id,--suc_id
				borrado_logico,--false,
				momento_creacion,--now()
				id_usuario_creacion--usuario_id
			)
			VALUES(nuevo_folio,str_data[6],str_data[7],str_data[8],str_data[9],str_data[10],str_data[11],str_data[12],str_data[13],str_data[14],str_data[15]::integer,str_data[16]::integer,str_data[17]::integer,str_data[18],str_data[19],str_data[20],str_data[21],str_data[22],str_data[23],str_data[24],str_data[25],str_data[26]::integer,str_data[27]::integer,str_data[28]::integer,str_data[29]::integer,str_data[30]::integer,str_data[31]::integer,str_data[32]::integer,str_data[33]::integer,str_data[34]::integer,str_data[35]::boolean,str_data[36]::double precision,str_data[37]::integer,str_data[38]::double precision,str_data[39]::integer,str_data[40]::integer,str_data[41]::boolean,str_data[42],str_data[43],str_data[44],str_data[45],str_data[46],str_data[47],str_data[48],str_data[49],str_data[50],str_data[51]::integer,str_data[52]::integer,str_data[53]::integer,str_data[54],str_data[55],str_data[56],str_data[57],str_data[58],str_data[59],str_data[60],str_data[61],str_data[62],str_data[63],str_data[64],str_data[65],str_data[66],str_data[67]::integer,str_data[68]::integer,str_data[69]::integer,str_data[70],str_data[71],str_data[72],str_data[73],str_data[74],str_data[75],str_data[76], str_data[77]::integer, str_data[78]::integer, str_data[79]::integer, str_data[80]::integer, str_data[81]::integer, str_data[82]::boolean, emp_id, suc_id, false, now(), usuario_id);
			
			/*
			INSERT INTO cxp_prov(
				folio,--nuevo_folio
				rfc,--str_data[6]
				curp,--str_data[7]
				razon_social,--str_data[8]
				clave_comercial,--str_data[9]
				calle,--str_data[10]
				numero,--str_data[11]
				colonia,--str_data[12]
				cp,--str_data[13]
				entre_calles,--str_data[14]
				pais_id,--str_data[15]::integer
				estado_id,--str_data[16]::integer
				municipio_id,--str_data[17]::integer
				localidad_alternativa,--str_data[18]
				telefono1,--str_data[19]
				extension1,--str_data[20]
				fax,--str_data[21]
				telefono2,--str_data[22]
				extension2,--str_data[23]
				correo_electronico,--str_data[24]
				web_site,--str_data[25]
				impuesto,--str_data[26]::integer
				cxp_prov_zona_id,--str_data[27]::integer
				grupo_id,--str_data[28]::integer
				proveedortipo_id,--str_data[29]::integer
				clasif_1,--str_data[30]::integer
				clasif_2,--str_data[31]::integer
				clasif_3,--str/controllers/facturas/startup.agnux_data[32]::integer
				moneda_id,--str_data[33]::integer
				tiempo_entrega_id,--str_data[34]::integer
				estatus,--str_data[35]::boolean
				limite_credito,--str_data[36]::double precision
				dias_credito_id,--str_data[37]::integer
				descuento,--str_data[38]::double precision
				credito_a_partir,--str_data[39]::integer
				cxp_prov_tipo_embarque_id,--str_data[40]::integer
				flete_pagado,--str_data[41]::boolean
				condiciones,--str_data[42]
				observaciones,--str_data[43]
				vent_contacto,--str_data[44]
				vent_puesto,--str_data[45]
				vent_calle,--str_data[46]
				vent_numero,--/controllers/facturas/startup.agnuxstr_data[47]
				vent_colonia,--str_data[48]
				vent_cp,--str_data[49]
				vent_entre_calles,--str_data[50]
				vent_pais_id,--str_data[51]::integer
				vent_estado_id,--str_data[52]::integer
				vent_municipio_id,--str_data[53]::integer
				vent_telefono1,--str_data[54]
				vent_extension1,--str_data[55]
				vent_fax,--str_data[56]
				vent_telefono2,--str_data[57]
				vent_extension2,--str_data[58]
				vent_email,--str_data[59]
				cob_contacto,--str_data[60]
				cob_puesto,--str_data[61]
				cob_calle,--str_data[62]
				cob_numero,--str_data[63]
				cob_colonia,--str_data[64]
				cob_cp,--str_data[65]
				cob_entre_calles,--str_data[66]
				cob_pais_id,--str_data[67]::integer
				cob_estado_id,--str_data[68]::integer
				cob_municipio_id,--str_data[69]::integer
				cob_telefono1,--str_data[70]
				cob_extension1,--str_data[71]
				cob_fax,--str_data[72]
				cob_telefono2,--str_data[73]
				cob_extension2,--str_data[74]
				cob_email,--str_data[75]
				comentarios,--str_data[76]
				ctb_cta_id_pasivo,--str_data[77]::integer,
				transportista,--str_data[78]::boolean,
				empresa_id,--emp_id
				sucursal_id,--suc_id
				borrado_logico,--false,
				momento_creacion,--now()
				id_usuario_creacion--usuario_id
			)
			VALUES(nuevo_folio,str_data[6],str_data[7],str_data[8],str_data[9],str_data[10],str_data[11],str_data[12],str_data[13],str_data[14],str_data[15]::integer,str_data[16]::integer,str_data[17]::integer,str_data[18],str_data[19],str_data[20],str_data[21],str_data[22],str_data[23],str_data[24],str_data[25],str_data[26]::integer,str_data[27]::integer,str_data[28]::integer,str_data[29]::integer,str_data[30]::integer,str_data[31]::integer,str_data[32]::integer,str_data[33]::integer,str_data[34]::integer,str_data[35]::boolean,str_data[36]::double precision,str_data[37]::integer,str_data[38]::double precision,str_data[39]::integer,str_data[40]::integer,str_data[41]::boolean,str_data[42],str_data[43],str_data[44],str_data[45],str_data[46],str_data[47],str_data[48],str_data[49],str_data[50],str_data[51]::integer,str_data[52]::integer,str_data[53]::integer,str_data[54],str_data[55],str_data[56],str_data[57],str_data[58],str_data[59],str_data[60],str_data[61],str_data[62],str_data[63],str_data[64],str_data[65],str_data[66],str_data[67]::integer,str_data[68]::integer,str_data[69]::integer,str_data[70],str_data[71],str_data[72],str_data[73],str_data[74],str_data[75],str_data[76], str_data[77]::integer,str_data[78]::boolean, emp_id, suc_id, false, now(), usuario_id);
			*/
			valor_retorno := '1';
		END IF;

		
		IF command_selected = 'edit' THEN 
			/*
			UPDATE cxp_prov SET rfc=str_data[6],curp=str_data[7],razon_social=str_data[8],clave_comercial=str_data[9],calle=str_data[10],numero=str_data[11],colonia=str_data[12],cp=str_data[13],entre_calles=str_data[14],pais_id=str_data[15]::integer,estado_id=str_data[16]::integer,municipio_id=str_data[17]::integer,localidad_alternativa=str_data[18],telefono1=str_data[19],extension1=str_data[20],fax=str_data[21],telefono2=str_data[22],extension2=str_data[23],correo_electronico=str_data[24],web_site=str_data[25],impuesto=str_data[26]::integer,cxp_prov_zona_id=str_data[27]::integer,grupo_id=str_data[28]::integer,proveedortipo_id=str_data[29]::integer,clasif_1=str_data[30]::integer,clasif_2=str_data[31]::integer,clasif_3=str_data[32]::integer,moneda_id=str_data[33]::integer,tiempo_entrega_id=str_data[34]::integer,estatus=str_data[35]::boolean,limite_credito=str_data[36]::double precision,dias_credito_id=str_data[37]::integer,
				descuento=str_data[38]::double precision,credito_a_partir=str_data[39]::integer,cxp_prov_tipo_embarque_id=str_data[40]::integer,flete_pagado=str_data[41]::boolean,condiciones=str_data[42],observaciones=str_data[43],vent_contacto=str_data[44],vent_puesto=str_data[45],vent_calle=str_data[46],vent_numero=str_data[47],vent_colonia=str_data[48],vent_cp=str_data[49],vent_entre_calles=str_data[50],vent_pais_id=str_data[51]::integer,vent_estado_id=str_data[52]::integer,vent_municipio_id=str_data[53]::integer,vent_telefono1=str_data[54],vent_extension1=str_data[55],vent_fax=str_data[56],vent_telefono2=str_data[57],vent_extension2=str_data[58],vent_email=str_data[59],cob_contacto=str_data[60],cob_puesto=str_data[61],cob_calle=str_data[62],cob_numero=str_data[63],cob_colonia=str_data[64],cob_cp=str_data[65],cob_entre_calles=str_data[66],cob_pais_id=str_data[67]::integer,cob_estado_id=str_data[68]::integer,cob_municipio_id=str_data[69]::integer,
				cob_telefono1=str_data[70],cob_extension1=str_data[71],cob_fax=str_data[72],cob_telefono2=str_data[73],cob_extension2=str_data[74],cob_email=str_data[75],comentarios=str_data[76], ctb_cta_id_pasivo=str_data[77]::integer,transportista=str_data[78]::boolean, momento_actualizacion=now(),id_usuario_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;
			*/
			UPDATE cxp_prov SET rfc=str_data[6],curp=str_data[7],razon_social=str_data[8],clave_comercial=str_data[9],calle=str_data[10],numero=str_data[11],colonia=str_data[12],cp=str_data[13],entre_calles=str_data[14],pais_id=str_data[15]::integer,estado_id=str_data[16]::integer,municipio_id=str_data[17]::integer,localidad_alternativa=str_data[18],telefono1=str_data[19],extension1=str_data[20],fax=str_data[21],telefono2=str_data[22],extension2=str_data[23],correo_electronico=str_data[24],web_site=str_data[25],impuesto=str_data[26]::integer,cxp_prov_zona_id=str_data[27]::integer,grupo_id=str_data[28]::integer,proveedortipo_id=str_data[29]::integer,clasif_1=str_data[30]::integer,clasif_2=str_data[31]::integer,clasif_3=str_data[32]::integer,moneda_id=str_data[33]::integer,tiempo_entrega_id=str_data[34]::integer,estatus=str_data[35]::boolean,limite_credito=str_data[36]::double precision,dias_credito_id=str_data[37]::integer,
				descuento=str_data[38]::double precision,credito_a_partir=str_data[39]::integer,cxp_prov_tipo_embarque_id=str_data[40]::integer,flete_pagado=str_data[41]::boolean,condiciones=str_data[42],observaciones=str_data[43],vent_contacto=str_data[44],vent_puesto=str_data[45],vent_calle=str_data[46],vent_numero=str_data[47],vent_colonia=str_data[48],vent_cp=str_data[49],vent_entre_calles=str_data[50],vent_pais_id=str_data[51]::integer,vent_estado_id=str_data[52]::integer,vent_municipio_id=str_data[53]::integer,vent_telefono1=str_data[54],vent_extension1=str_data[55],vent_fax=str_data[56],vent_telefono2=str_data[57],vent_extension2=str_data[58],vent_email=str_data[59],cob_contacto=str_data[60],cob_puesto=str_data[61],cob_calle=str_data[62],cob_numero=str_data[63],cob_colonia=str_data[64],cob_cp=str_data[65],cob_entre_calles=str_data[66],cob_pais_id=str_data[67]::integer,cob_estado_id=str_data[68]::integer,cob_municipio_id=str_data[69]::integer,
				cob_telefono1=str_data[70],cob_extension1=str_data[71],cob_fax=str_data[72],cob_telefono2=str_data[73],cob_extension2=str_data[74],cob_email=str_data[75],comentarios=str_data[76], ctb_cta_id_pasivo=str_data[77]::integer, ctb_cta_id_egreso=str_data[78]::integer, ctb_cta_id_ietu=str_data[79]::integer, ctb_cta_id_comple=str_data[80]::integer, ctb_cta_id_pasivo_comple=str_data[81]::integer, transportista=str_data[82]::boolean, momento_actualizacion=now(),id_usuario_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxp_prov SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina catalogo de proveedores
	


	--Catalogo de Empleados
	IF app_selected = 4 THEN
		IF command_selected = 'new' THEN

			id_tipo_consecutivo:=15;--Consecutivo de clave empleado
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--RAISE EXCEPTION '%','datos: '||extra_data;
			--RAISE EXCEPTION '%','nombre_consecutivo: '||nombre_consecutivo;
			--RAISE EXCEPTION '%','cadena_extra: '||cadena_extra;
			--RAISE EXCEPTION '%','numero_control_client: '||numero_control_client;

			IF trim(str_data[13])='' THEN
				str_data[13]:='2014-01-01';
			END IF;

			IF trim(str_data[61])='' THEN
				str_data[61]:='0';
			END IF;

			IF trim(str_data[62])='' THEN
				str_data[62]:='0';
			END IF;
			
			INSERT INTO gral_empleados(
				clave,--nuevo_folio,                       
				nombre_pila,--=str_data[5],
				apellido_paterno,--=str_data[6],
				apellido_materno,--=str_data[7],
				imss,--=str_data[8],
				infonavit,--=str_data[9],
				curp,--=str_data[10],
				rfc,--=str_data[11],
				fecha_nacimiento,--=str_data[12]::date,
				fecha_ingreso,--=str_data[13]::date,
				gral_escolaridad_id,--=str_data[14]::integer,
				gral_sexo_id,--=str_data[15]::integer,
				gral_civil_id,--=str_data[16]::integer,
				gral_religion_id,--=str_data[17]::integer,
				gral_sangretipo_id,--=str_data[30]::integer,
				gral_puesto_id,--=str_data[33]::integer,
				gral_categ_id,--=str_data[35]::integer,
				gral_suc_id_empleado,--=str_data[34]::integer,
				telefono,--=str_data[18],
				telefono_movil,--=str_data[19],
				correo_personal,--=str_data[20],
				gral_pais_id,--=str_data[21]::integer,
				gral_edo_id,--=str_data[22]::integer,
				gral_mun_id,--=str_data[23]::integer,
				calle,--=str_data[24],
				numero,--=str_data[25],
				colonia,--=str_data[26],
				cp,--=str_data[27],
				contacto_emergencia,--=str_data[28],
				telefono_emergencia,--=str_data[29],
				enfermedades,--=str_data[31],
				alergias,--=str_data[32],
				comentarios,--=str_data[36],
				comision_agen,--=str_data[41],
				region_id_agen,--=str_data[48],
				comision2_agen,--=str_data[42],
				comision3_agen,--=str_data[43],
				comision4_agen,--=str_data[44],
				dias_tope_comision,--=str_data[45],
				dias_tope_comision2,--=str_data[46],
				dias_tope_comision3,--=str_data[47],
				tipo_comision,--str_data[49]::integer,
				monto_tope_comision,--=str_data[50],
				monto_tope_comision2,--=str_data[51],
				monto_tope_comision3,--=str_data[52],
				correo_empresa,--str_data[53],
				no_int,--str_data[54],
				nom_regimen_contratacion_id,--str_data[55]::integer,
				nom_tipo_contrato_id,--str_data[56]::integer,
				nom_tipo_jornada_id,--str_data[57]::integer,
				nom_periodicidad_pago_id,--str_data[58]::integer,
				tes_ban_id,--str_data[59]::integer,
				nom_riesgo_puesto_id,--str_data[60]::integer,
				salario_base,--str_data[61]::double precision,
				salario_integrado,--str_data[62]::double precision,
				registro_patronal,--str_data[63],
				clabe, --str_data[64],
				genera_nomina, --str_data[67]::boolean,
				gral_depto_id, --str_data[68]::integer,
				momento_creacion,--now()
				gral_usr_id_creacion,
				gral_emp_id,
				gralsuc_id
				)VALUES (
				--Informaci√≥n: data_string: 4___new___1___0___[3]ADMIN___[4]SANTOS___[5]CAMPOS___[6]12345678901___[7]12345678901___[8]MASN831210MK7___[9]MASN831210MK7___[10]2012-08-09___[11]2012-08-15___3___2___2___7___1234567891_________2___19___986___AV.JUAREZ___12___MARIA LUISA___64988___EZEQUIEL CARDENAS___1234567891___2_________4
					nuevo_folio,                       
					str_data[5],
					str_data[6],
					str_data[7],
					str_data[8],
					str_data[9],
					str_data[10],
					str_data[11],
					str_data[12]::date,
					str_data[13]::date,
					str_data[14]::integer,
					str_data[15]::integer,
					str_data[16]::integer,
					str_data[17]::integer,
					str_data[30]::integer,
					str_data[33]::integer,
					str_data[35]::integer,
					str_data[34]::integer,
					str_data[18],
					str_data[19],
					str_data[20],
					str_data[21]::integer,
					str_data[22]::integer,
					str_data[23]::integer,
					str_data[24],
					str_data[25],
					str_data[26],
					str_data[27],
					str_data[28],
					str_data[29],
					str_data[31],
					str_data[32],
					str_data[36],
					str_data[41]::double precision,
					str_data[48]::integer,
					str_data[42]::double precision,
					str_data[43]::double precision,
					str_data[44]::double precision,
					str_data[45]::double precision,
					str_data[46]::double precision,
					str_data[47]::double precision,
					str_data[49]::integer,
					str_data[50]::double precision,
					str_data[51]::double precision,
					str_data[52]::double precision,
					str_data[53],
					str_data[54],
					str_data[55]::integer,
					str_data[56]::integer,
					str_data[57]::integer,
					str_data[58]::integer,
					str_data[59]::integer,
					str_data[60]::integer,
					str_data[61]::double precision,
					str_data[62]::double precision,
					str_data[63],
					str_data[64],
					str_data[67]::boolean,
					str_data[68]::integer,
					now(),
					usuario_id::integer,
					emp_id::integer, 
					suc_id::integer 
				)RETURNING id INTO ultimo_id;
				


			IF trim(str_data[37])<>'' THEN 
				--Si existe el nombre del usuario hay que crear el registro.
				
				--Crea el usuario
				INSERT INTO gral_usr(username,password,enabled,gral_empleados_id)VALUES(str_data[37],str_data[38],str_data[40]::boolean,ultimo_id::integer)
				RETURNING id INTO ultimo_id_usr;
				
				--Asigna sucursal al usuario
				INSERT INTO gral_usr_suc(gral_usr_id,gral_suc_id) VALUES(ultimo_id_usr,str_data[34]::integer);
				
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				
				IF extra_data[1]<>'sin datos' THEN
					FOR cont_fila IN 1 .. total_filas LOOP
						SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
						--Aqui se vuelven a crear los registros para asignar roles al usuario
						INSERT INTO gral_usr_rol(gral_usr_id,gral_rol_id) VALUES(ultimo_id_usr,extra_data[cont_fila]::integer);
					END LOOP;
				END IF;
			END IF;

			
			--Verificar si incluye NOMINA
			IF incluye_nomina THEN 
				--str_data[65] Percepciones
				IF str_data[65] is not null AND str_data[65]!='' THEN
					--Convertir en arreglo la cadena de Percepciones
					SELECT INTO str_percep string_to_array(str_data[65],',');
					
					FOR iter_y IN array_lower(str_percep,1) .. array_upper(str_percep,1) LOOP
						INSERT INTO gral_empleado_percep(gral_empleado_id,nom_percep_id) VALUES (ultimo_id,str_percep[iter_y]::integer);
					END LOOP;
				END IF;

				--str_data[66] deducciones
				IF str_data[66] is not null AND str_data[66]!='' THEN
					--Convertir en arreglo la cadena de Percepciones
					SELECT INTO str_deduc string_to_array(str_data[66],',');
					
					FOR iter_y IN array_lower(str_deduc,1) .. array_upper(str_deduc,1) LOOP
						INSERT INTO gral_empleado_deduc(gral_empleado_id,nom_deduc_id) VALUES (ultimo_id,str_deduc[iter_y]::integer);
					END LOOP;
				END IF;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			--SELECT INTO str_data string_to_array(''||campos_data||'','___');
			--RAISE EXCEPTION '%',str_data[1];
			--RAISE EXCEPTION '%',identificador;
			UPDATE gral_empleados SET 
				nombre_pila=str_data[5],
				apellido_paterno=str_data[6],
				apellido_materno=str_data[7],
				imss=str_data[8],
				infonavit=str_data[9],
				curp=str_data[10],
				rfc=str_data[11],
				fecha_nacimiento=str_data[12]::date,
				fecha_ingreso=str_data[13]::date,
				gral_escolaridad_id=str_data[14]::integer,
				gral_sexo_id=str_data[15]::integer,
				gral_civil_id=str_data[16]::integer,
				gral_religion_id=str_data[17]::integer,
				gral_sangretipo_id=str_data[30]::integer,
				gral_puesto_id=str_data[33]::integer,
				gral_categ_id=str_data[35]::integer,
				gral_suc_id_empleado=str_data[34]::integer,
				telefono=str_data[18],
				telefono_movil=str_data[19],
				correo_personal=str_data[20],
				gral_pais_id=str_data[21]::integer,
				gral_edo_id=str_data[22]::integer,
				gral_mun_id=str_data[23]::integer,
				calle=str_data[24],
				numero=str_data[25],
				colonia=str_data[26],
				cp=str_data[27],
				contacto_emergencia=str_data[28],
				telefono_emergencia=str_data[29],
				enfermedades=str_data[31],
				alergias=str_data[32],
				comentarios=str_data[36],
				comision_agen=str_data[41]::double precision,
				region_id_agen=str_data[48]::integer,
				comision2_agen=str_data[42]::double precision,
				comision3_agen=str_data[43]::double precision,
				comision4_agen=str_data[44]::double precision,
				dias_tope_comision=str_data[45]::double precision,
				dias_tope_comision2=str_data[46]::double precision,
				dias_tope_comision3=str_data[47]::double precision,
				tipo_comision=str_data[49]::integer,
				monto_tope_comision=str_data[50]::double precision,
				monto_tope_comision2=str_data[51]::double precision,
				monto_tope_comision3=str_data[52]::double precision,
				correo_empresa=str_data[53],
				no_int=str_data[54],
				nom_regimen_contratacion_id=str_data[55]::integer,
				nom_tipo_contrato_id=str_data[56]::integer,
				nom_tipo_jornada_id=str_data[57]::integer,
				nom_periodicidad_pago_id=str_data[58]::integer,
				tes_ban_id=str_data[59]::integer,
				nom_riesgo_puesto_id=str_data[60]::integer,
				salario_base=str_data[61]::double precision,
				salario_integrado=str_data[62]::double precision,
				registro_patronal=str_data[63],
				clabe=str_data[64],
				genera_nomina=str_data[67]::boolean,
				gral_depto_id=str_data[68]::integer,
				momento_actualizacion=now()::timestamp with time zone,
				gral_usr_id_actualizacion=usuario_id
			WHERE id=str_data[4]::integer;
			
			
			IF trim(str_data[37])<>'' THEN 
				IF (SELECT count(id) FROM gral_usr WHERE gral_empleados_id=str_data[4]::integer)<=0 THEN 
					--Crea el usuario
					INSERT INTO gral_usr(username,password,enabled,gral_empleados_id)VALUES(str_data[37],str_data[38],str_data[40]::boolean,str_data[4]::integer)
					RETURNING id INTO ultimo_id_usr;
				ELSE
					UPDATE gral_usr SET username=str_data[37], password=str_data[38], enabled=str_data[40]::boolean
					WHERE gral_empleados_id=str_data[4]::integer RETURNING id INTO ultimo_id_usr;
				END IF;
				
				--Buscar el registro en gral_usr_suc
				SELECT count(id) FROM gral_usr_suc WHERE gral_usr_id=ultimo_id_usr INTO exis;
				
				IF exis > 0 THEN
					--Actualizar la sucursal del usuario
					UPDATE gral_usr_suc SET gral_suc_id=str_data[34]::integer WHERE gral_usr_id=ultimo_id_usr;
				ELSE 
					--Crear registro
					INSERT INTO gral_usr_suc(gral_usr_id, gral_suc_id)VALUES(ultimo_id_usr, str_data[34]::integer);
				END IF;
			ELSE
				IF (SELECT count(id) FROM gral_usr WHERE gral_empleados_id=str_data[4]::integer AND enabled=true)>=0 THEN 
					UPDATE gral_usr SET enabled=false WHERE gral_empleados_id=str_data[4]::integer AND enabled=true;
				END IF;
			END IF;
			
			
			--Elimina todos los roles asignados actualmente
			delete from gral_usr_rol where gral_usr_id=ultimo_id_usr;


			IF trim(str_data[37])<>'' THEN 
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;

				--RAISE EXCEPTION '%','extra_data[1]: '||extra_data[1];
				
				IF extra_data[1]<>'sin_datos' THEN
					FOR cont_fila IN 1 .. total_filas LOOP
						SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
						--Aqui se vuelven a crear los registros
						INSERT INTO gral_usr_rol(gral_usr_id,gral_rol_id  )
						VALUES(ultimo_id_usr,extra_data[cont_fila]::integer);
					END LOOP;
				END IF;
			END IF;



			--Verificar si incluye NOMINA
			IF incluye_nomina THEN 
				--Elimina las Percepciones asignadas actualmente
				delete from gral_empleado_percep where gral_empleado_id=str_data[4]::integer;
				
				--str_data[65] Percepciones
				IF str_data[65] is not null AND str_data[65]!='' THEN
					--Convertir en arreglo la cadena de Percepciones
					SELECT INTO str_percep string_to_array(str_data[65],',');
					--Aqui se vuelven a crear registros de las percepciones asignadas
					FOR iter_y IN array_lower(str_percep,1) .. array_upper(str_percep,1) LOOP
						INSERT INTO gral_empleado_percep(gral_empleado_id,nom_percep_id) VALUES (str_data[4]::integer,str_percep[iter_y]::integer);
					END LOOP;
				END IF;


				--Elimina las Deducciones asignadas actualmente
				delete from gral_empleado_deduc where gral_empleado_id=str_data[4]::integer;
				
				--str_data[66] deducciones
				IF str_data[66] is not null AND str_data[66]!='' THEN
					--Convertir en arreglo la cadena de Percepciones
					SELECT INTO str_deduc string_to_array(str_data[66],',');

					--Aqui se vuelven a crear registros de las Deducciones asignadas
					FOR iter_y IN array_lower(str_deduc,1) .. array_upper(str_deduc,1) LOOP
						INSERT INTO gral_empleado_deduc(gral_empleado_id,nom_deduc_id) VALUES (str_data[4]::integer,str_deduc[iter_y]::integer);
					END LOOP;
				END IF;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_empleados SET borrado_logico=true,  momento_baja=now(), gral_usr_id_baja=usuario_id::integer 
			WHERE id=str_data[4]::integer;
			
			--Deshabilitar usuario y cambiar el nombre del username, esto para evitar conservar el nombre del usuario.
			--No es posible eliminar el registro porque se utliza como llave foranea en varias tablas
			UPDATE gral_usr SET username='01010101010101010101010101010101010101010101010101', enabled=false WHERE gral_empleados_id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;

	END IF;--termina catalogo de empleados
	
	
	
	
	-- Catalogo de Clientes
	IF app_selected = 5 THEN
		IF command_selected = 'new' THEN

			id_tipo_consecutivo:=1;--Folio de proveedor
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--RAISE EXCEPTION '%','emp_id: '||emp_id;
			--RAISE EXCEPTION '%','nombre_consecutivo: '||nombre_consecutivo;
			--RAISE EXCEPTION '%','cadena_extra: '||cadena_extra;
			--RAISE EXCEPTION '%','numero_control_client: '||numero_control_client;
			
			INSERT INTO cxc_clie(
					numero_control,--nuevo_folio
					rfc,--str_data[6]
					curp,--str_data[7]
					razon_social,--str_data[8]
					clave_comercial,--str_data[9]
					calle,--str_data[10]
					numero,--str_data[11]
					entre_calles,--str_data[12]
					numero_exterior,--str_data[13]
					colonia,--str_data[14]
					cp,--str_data[15]
					pais_id,--str_data[16]::integer
					estado_id,--str_data[17]::integer
					municipio_id,--str_data[18]::integer
					localidad_alternativa,--str_data[19]
					telefono1,--str_data[20]
					extension1,--str_data[21]
					fax,--str_data[22]
					telefono2,--str_data[23]
					extension2,--str_data[24]
					email,--str_data[25]
					cxc_agen_id,--str_data[26]::integer
					contacto,--str_data[27]
					zona_id,--str_data[28]::integer
					cxc_clie_grupo_id,--str_data[29]::integer
					clienttipo_id,--str_data[30]::integer
					clasif_1,--str_data[31]::integer
					clasif_2,--str_data[32]::integer
					clasif_3,--str_data[33]::integer
					moneda,--str_data[34]::integer
					filial,--str_data[35]::boolean
					estatus,--str_data[36]::boolean
					gral_imp_id,--str_data[37]::integer
					limite_credito,--str_data[38]::double precision
					dias_credito_id,--str_data[39]::integer
					credito_suspendido,--str_data[40]::boolean
					credito_a_partir,--str_data[41]::integer
					cxp_prov_tipo_embarque_id,--str_data[42]::integer
					dias_caducidad_cotizacion,--str_data[43]::integer
					condiciones,--str_data[44]
					observaciones,--str_data[45]
					contacto_compras_nombre,--str_data[46]
					contacto_compras_puesto,--str_data[47]
					contacto_compras_calle,--str_data[48]
					contacto_compras_numero,--str_data[49]
					contacto_compras_colonia,--str_data[50]
					contacto_compras_cp,--str_data[51]
					contacto_compras_entre_calles,--str_data[52]
					contacto_compras_pais_id,--str_data[53]::integer
					contacto_compras_estado_id,--str_data[54]::integer
					contacto_compras_municipio_id,--str_data[55]::integer
					contacto_compras_telefono1,--str_data[56]
					contacto_compras_extension1,--str_data[57]
					contacto_compras_fax,--str_data[58]
					contacto_compras_telefono2,--str_data[59]
					contacto_compras_extension2,--str_data[60]
					contacto_compras_email,--str_data[61]
					contacto_pagos_nombre,--str_data[62]
					contacto_pagos_puesto,--str_data[63]
					contacto_pagos_calle,--str_data[64]
					contacto_pagos_numero,--str_data[65]
					contacto_pagos_colonia,--str_data[66]
					contacto_pagos_cp,--str_data[67]
					contacto_pagos_entre_calles,--str_data[68]
					contacto_pagos_pais_id,--str_data[69]::integer
					contacto_pagos_estado_id,--str_data[70]::integer
					contacto_pagos_municipio_id,--str_data[71]::integer
					contacto_pagos_telefono1,--str_data[72]
					contacto_pagos_extension1,--str_data[73]
					contacto_pagos_fax,--str_data[74]
					contacto_pagos_telefono2,--str_data[75]
					contacto_pagos_extension2,--str_data[76]
					contacto_pagos_email,--str_data[77]
					empresa_immex,--str_data[78]::boolean,
					tasa_ret_immex,--str_data[79]::double precision,
					dia_revision,--str_data[80]::smallint,
					dia_pago,--str_data[81]::smallint,
					cta_pago_mn,--str_data[82],
					cta_pago_usd,--str_data[83],
					ctb_cta_id_activo,--str_data[84]::integer,
					ctb_cta_id_ingreso,--str_data[85]::integer,
					ctb_cta_id_ietu,--str_data[86]::integer,
					ctb_cta_id_comple,--str_data[87]::integer,
					ctb_cta_id_activo_comple,--str_data[88]::integer,
					lista_precio,--str_data[89]::integer,
					fac_metodos_pago_id,--str_data[90]::integer,
					empresa_id,--emp_id
					sucursal_id,--suc_id
					borrado_logico,--false
					momento_creacion,--now()
					id_usuario_creacion--usuario_id
				)VALUES (
					nuevo_folio,
					str_data[6],
					str_data[7],
					str_data[8],
					str_data[9],
					str_data[10],
					str_data[11],
					str_data[12],
					str_data[13],
					str_data[14],
					str_data[15],
					str_data[16]::integer,
					str_data[17]::integer,
					str_data[18]::integer,
					str_data[19],
					str_data[20],
					str_data[21],
					str_data[22],
					str_data[23],
					str_data[24],
					str_data[25],
					str_data[26]::integer,
					str_data[27],
					str_data[28]::integer,
					str_data[29]::integer,
					str_data[30]::integer,
					str_data[31]::integer,
					str_data[32]::integer,
					str_data[33]::integer,
					str_data[34]::integer,
					str_data[35]::boolean,
					str_data[36]::boolean,
					str_data[37]::integer,
					str_data[38]::double precision,
					str_data[39]::integer,
					str_data[40]::boolean,
					str_data[41]::integer,
					str_data[42]::integer,
					str_data[43]::integer,
					str_data[44],
					str_data[45],
					str_data[46],
					str_data[47],
					str_data[48],
					str_data[49],
					str_data[50],
					str_data[51],
					str_data[52],
					str_data[53]::integer,
					str_data[54]::integer,
					str_data[55]::integer,
					str_data[56],
					str_data[57],
					str_data[58],
					str_data[59],
					str_data[60],
					str_data[61],
					str_data[62],
					str_data[63],
					str_data[64],
					str_data[65],
					str_data[66],
					str_data[67],
					str_data[68],
					str_data[69]::integer,
					str_data[70]::integer,
					str_data[71]::integer,
					str_data[72],
					str_data[73],
					str_data[74],
					str_data[75],
					str_data[76],
					str_data[77],
					str_data[78]::boolean,
					str_data[79]::double precision,
					str_data[80]::smallint,
					str_data[81]::smallint,
					str_data[82],
					str_data[83],
					str_data[84]::integer,
					str_data[85]::integer,
					str_data[86]::integer,
					str_data[87]::integer,
					str_data[88]::integer,
					str_data[89]::integer,
					str_data[90]::integer,
					emp_id,
					suc_id,
					false,
					now(),
					usuario_id
				)RETURNING id INTO ultimo_id;
			
				
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1] calle
					--str_filas[2] numero
					--str_filas[3] colonia
					--str_filas[4] idpais
					--str_filas[5] identidad
					--str_filas[6] idlocalidad
					--str_filas[7] codigop
					--str_filas[8] localternativa
					--str_filas[9] telefono
					--str_filas[10] numfax
					
					INSERT INTO erp_clients_consignacions(cliente_id, calle, numero, colonia, pais_id, estado_id, municipio_id, cp, localidad_alternativa, telefono, fax, momento_creacion)
					VALUES(ultimo_id, str_filas[1], str_filas[2], str_filas[3], str_filas[4]::integer, str_filas[5]::integer, str_filas[6]::integer, str_filas[7], str_filas[8], str_filas[9], str_filas[10], now());
					
				END LOOP;
				
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			--SELECT INTO str_data string_to_array(''||campos_data||'','___');
			--RAISE EXCEPTION '%',str_data[1];
			--RAISE EXCEPTION '%',identificador;
			UPDATE cxc_clie SET 
					rfc=str_data[6],
					curp=str_data[7],
					razon_social=str_data[8],
					clave_comercial=str_data[9],
					calle=str_data[10],
					numero=str_data[11],
					entre_calles=str_data[12],
					numero_exterior=str_data[13],
					colonia=str_data[14],
					cp=str_data[15],
					pais_id=str_data[16]::integer,
					estado_id=str_data[17]::integer,
					municipio_id=str_data[18]::integer,
					localidad_alternativa=str_data[19],
					telefono1=str_data[20],
					extension1=str_data[21],
					fax=str_data[22],
					telefono2=str_data[23],
					extension2=str_data[24],
					email=str_data[25],
					cxc_agen_id=str_data[26]::integer,
					contacto=str_data[27],
					zona_id=str_data[28]::integer,
					cxc_clie_grupo_id=str_data[29]::integer,
					clienttipo_id=str_data[30]::integer,
					clasif_1=str_data[31]::integer,
					clasif_2=str_data[32]::integer,
					clasif_3=str_data[33]::integer,
					moneda=str_data[34]::integer,
					filial=str_data[35]::boolean,
					estatus=str_data[36]::boolean,
					gral_imp_id=str_data[37]::integer,
					limite_credito=str_data[38]::double precision,
					dias_credito_id=str_data[39]::integer,
					credito_suspendido=str_data[40]::boolean,
					credito_a_partir=str_data[41]::integer,
					cxp_prov_tipo_embarque_id=str_data[42]::integer,
					dias_caducidad_cotizacion=str_data[43]::integer,
					condiciones=str_data[44],
					observaciones=str_data[45],
					contacto_compras_nombre=str_data[46],
					contacto_compras_puesto=str_data[47],
					contacto_compras_calle=str_data[48],
					contacto_compras_numero=str_data[49],
					contacto_compras_colonia=str_data[50],
					contacto_compras_cp=str_data[51],
					contacto_compras_entre_calles=str_data[52],
					contacto_compras_pais_id=str_data[53]::integer,
					contacto_compras_estado_id=str_data[54]::integer,
					contacto_compras_municipio_id=str_data[55]::integer,
					contacto_compras_telefono1=str_data[56],
					contacto_compras_extension1=str_data[57],
					contacto_compras_fax=str_data[58],
					contacto_compras_telefono2=str_data[59],
					contacto_compras_extension2=str_data[60],
					contacto_compras_email=str_data[61],
					contacto_pagos_nombre=str_data[62],
					contacto_pagos_puesto=str_data[63],
					contacto_pagos_calle=str_data[64],
					contacto_pagos_numero=str_data[65],
					contacto_pagos_colonia=str_data[66],
					contacto_pagos_cp=str_data[67],
					contacto_pagos_entre_calles=str_data[68],
					contacto_pagos_pais_id=str_data[69]::integer,
					contacto_pagos_estado_id=str_data[70]::integer,
					contacto_pagos_municipio_id=str_data[71]::integer,
					contacto_pagos_telefono1=str_data[72],
					contacto_pagos_extension1=str_data[73],
					contacto_pagos_fax=str_data[74],
					contacto_pagos_telefono2=str_data[75],
					contacto_pagos_extension2=str_data[76],
					contacto_pagos_email=str_data[77],
					empresa_immex=str_data[78]::boolean,
					tasa_ret_immex=str_data[79]::double precision,
					dia_revision=str_data[80]::smallint,
					dia_pago=str_data[81]::smallint,
					cta_pago_mn=str_data[82],
					cta_pago_usd=str_data[83],
					ctb_cta_id_activo=str_data[84]::integer,
					ctb_cta_id_ingreso=str_data[85]::integer,
					ctb_cta_id_ietu=str_data[86]::integer,
					ctb_cta_id_comple=str_data[87]::integer,
					ctb_cta_id_activo_comple=str_data[88]::integer,
					lista_precio=str_data[89]::integer,
					fac_metodos_pago_id=str_data[90]::integer,
					momento_actualizacion = now(),
					id_usuario_actualizacion = usuario_id,
					empresa_id=emp_id,
					sucursal_id=suc_id
			WHERE id=str_data[4]::integer;
			
			--eliminar direcciones de este cliente en la tabla clients_consignacions
			DELETE FROM erp_clients_consignacions WHERE cliente_id = str_data[4]::integer;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--aqui se vuelven a crear los registros
					INSERT INTO erp_clients_consignacions(cliente_id,calle,numero,colonia,pais_id,estado_id,municipio_id,cp,localidad_alternativa,telefono,fax,momento_creacion)
					VALUES(str_data[3]::integer,str_filas[1],str_filas[2],str_filas[3],str_filas[4]::integer,str_filas[5]::integer,str_filas[6]::integer,str_filas[7],str_filas[8],str_filas[9],str_filas[10],now());
					
				END LOOP;
				
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxc_clie SET borrado_logico=true, momento_baja=now(),id_usuario_baja = str_data[3]::integer WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;

	END IF;--termina catalogo de clientes
	
	
	
	-- Catalogo de Productos
	IF app_selected = 8 THEN
		
		IF str_data[15]::integer=0 THEN
			meta_imp:='exento';
		END IF;
		IF str_data[15]::integer=1 THEN
			meta_imp:='iva_1';
		END IF;
		IF str_data[15]::integer=2 THEN
			meta_imp:='tasa_cero';
		END IF;
		
		--query para verificar si la Empresa actual incluye Modulo de Produccion, Modulo de Contabilidad y Modulo de Envasado
		SELECT incluye_produccion, incluye_contabilidad, encluye_envasado FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, incluye_modulo_contabilidad, incluye_modulo_envasado;
		
		IF command_selected = 'new' THEN
			id_tipo_consecutivo:=3;--Folio de pproducto

			--alter para catalogo productos
			--ALTER TABLE inv_prod ADD COLUMN archivo_pdf character varying DEFAULT '';
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			--UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			--WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			--nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			nuevo_folio := str_data[31];
			tipo_producto:=str_data[18]::integer;
			INSERT INTO inv_prod(	
				sku,--nuevo_folio
				descripcion,--str_data[5]
				codigo_barras,--str_data[6]
				tentrega,--str_data[7]::integer,
				inv_clas_id,--str_data[8]::integer
				inv_stock_clasif_id,--str_data[9]::integer
				estatus,--str_data[10]::boolean
				inv_prod_familia_id,--str_data[11]::integer
				subfamilia_id,--str_data[12]::integer
				inv_prod_grupo_id,--str_data[13]::integer
				ieps,--str_data[14]::integer
				--meta_impuesto,--meta_imp
				gral_impto_id,--str_data[15]::integer,
				inv_prod_linea_id,--str_data[16]::integer
				inv_mar_id,--str_data[17]::integer
				tipo_de_producto_id,--str_data[18]::integer
				inv_seccion_id,--str_data[19]::integer
				unidad_id,--str_data[20]::integer
				requiere_numero_lote,--str_data[21]::boolean
				requiere_nom,--str_data[22]::boolean
				requiere_numero_serie,--str_data[23]::boolean
				requiere_pedimento,--str_data[24]::boolean
				permitir_stock,--str_data[25]::boolean
				venta_moneda_extranjera,--str_data[26]::boolean
				compra_moneda_extranjera,--str_data[27]::boolean
				cxp_prov_id,--str_data[29]::integer
				densidad,--str_data[30]::double precision
				valor_maximo,--str_data[32]::double precision
				valor_minimo,--str_data[33]::double precision
				punto_reorden,--str_data[34]::double precision
				ctb_cta_id_gasto, --str_data[35]::integer,
				ctb_cta_id_costo_venta, --str_data[36]::integer,
				ctb_cta_id_venta, --str_data[37]::integer,
				borrado_logico,--false
				momento_creacion,--now()
				id_usuario_creacion,--usuario_id
				empresa_id,--emp_id
				sucursal_id,--suc_id
				descripcion_corta,--str_data[40]
				descripcion_larga,--str_data[41]
				archivo_img,--str_data[38]
				archivo_pdf,--str_data[39]
				inv_prod_presentacion_id,--str_data[42]::integer
				flete,--str_data[43]::boolean,
				no_clie,--str_data[44]
				gral_mon_id,--str_data[45]::integer
				gral_imptos_ret_id, --str_data[46]::integer
                cfdi_prodserv_id --str_data[47]::integer
			) values(
				nuevo_folio,
				str_data[5],
				str_data[6],
				str_data[7]::integer,
				str_data[8]::integer,
				str_data[9]::integer,
				str_data[10]::boolean,
				str_data[11]::integer,
				str_data[12]::integer,
				str_data[13]::integer,
				str_data[14]::integer,
				--meta_imp,
				str_data[15]::integer,
				str_data[16]::integer,
				str_data[17]::integer,
				str_data[18]::integer,
				str_data[19]::integer,
				str_data[20]::integer,
				str_data[21]::boolean,
				str_data[22]::boolean,
				str_data[23]::boolean,
				str_data[24]::boolean,
				str_data[25]::boolean,
				str_data[26]::boolean,
				str_data[27]::boolean,
				str_data[29]::integer,
				str_data[30]::double precision,
				str_data[32]::double precision,
				str_data[33]::double precision,
				str_data[34]::double precision,
				str_data[35]::integer,
				str_data[36]::integer,
				str_data[37]::integer,
				false,
				now(),
				usuario_id,
				emp_id,
				suc_id,
				str_data[40],
				str_data[41],
				str_data[38],
				str_data[39],
				str_data[42]::integer,
				str_data[43]::boolean,
				str_data[44],
				str_data[45]::integer,
				str_data[46]::integer,
                get_id_cfdi_claveprodserv(str_data[47])::integer
			)RETURNING id INTO id_producto;
			
			--convertir en arreglo los id de presentaciones de producto
			SELECT INTO str_pres string_to_array(str_data[28],',');
			
			--obtiene numero de elementos del arreglo str_pres
			tot_filas:= array_length(str_pres,1);
			
			
			--Si el tiopo de producto es diferente de 3 y 4, hay que guardar presentaciones
			--tipo=3 Kit
			--tipo=4 Servicios
			--IF str_data[18]::integer!=3 AND str_data[18]::integer!=4 THEN
				
				FOR cont_fila_pres IN 1 .. tot_filas LOOP
					--Crea registros de presentaciones  en tabla inv_prod_pres_x_prod
					INSERT INTO inv_prod_pres_x_prod(producto_id,presentacion_id) VALUES (id_producto,str_pres[cont_fila_pres]::integer);
					
					--Crea registro por cada presentacion en la tabla de precios 
					INSERT INTO inv_pre (gral_emp_id, inv_prod_id, inv_prod_presentacion_id, momento_creacion,borrado_logico,precio_1, precio_2, precio_3, precio_4, precio_5, precio_6, precio_7, precio_8, precio_9, precio_10, gral_mon_id_pre1, gral_mon_id_pre2, gral_mon_id_pre3, gral_mon_id_pre4, gral_mon_id_pre5, gral_mon_id_pre6, gral_mon_id_pre7, gral_mon_id_pre8, gral_mon_id_pre9, gral_mon_id_pre10, descuento_1,descuento_2,descuento_3,descuento_4,descuento_5,descuento_6,descuento_7,descuento_8,descuento_9,descuento_10,default_precio_1,default_precio_2,default_precio_3,default_precio_4,default_precio_5,default_precio_6,default_precio_7,default_precio_8,default_precio_9,default_precio_10,operacion_precio_1,operacion_precio_2,operacion_precio_3,operacion_precio_4,operacion_precio_5,operacion_precio_6,operacion_precio_7,operacion_precio_8,operacion_precio_9,operacion_precio_10,calculo_precio_1,calculo_precio_2,calculo_precio_3,calculo_precio_4,calculo_precio_5,calculo_precio_6,calculo_precio_7,calculo_precio_8,calculo_precio_9,calculo_precio_10,redondeo_precio_1,redondeo_precio_2,redondeo_precio_3,redondeo_precio_4,redondeo_precio_5,redondeo_precio_6,redondeo_precio_7,redondeo_precio_8,redondeo_precio_9,redondeo_precio_10) 
					VALUES(emp_id, id_producto,str_pres[cont_fila_pres]::integer, now(), false, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,0,0,0,0,0,0,0,0,0 ,0,0,0,0,0,0,0,0,0,0,  1,1,1,1,1,1,1,1,1,1 ,1,1,1,1,1,1,1,1,1,1,  0,0,0,0,0,0,0,0,0,0);
				END LOOP;
			--END IF;
			
			IF incluye_modulo_produccion=TRUE THEN 
				--para Producto 3=Kit
				IF tipo_producto=3 THEN
					total_filas:= array_length(extra_data,1);
					cont_fila:=1;
					IF extra_data[1]<>'sin datos' THEN
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							--str_filas[1] eliminado
							IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--ya no se valida nada
								--str_filas[1]	producto_ingrediente_id
								--str_filas[2] 	porcentaje
								--INSERT INTO inv_prod_formulaciones(producto_formulacion_id,producto_ingrediente_id,porcentaje) VALUES (id_producto,str_filas[1]::integer,str_filas[2]::double precision);
								INSERT INTO inv_kit(producto_kit_id,producto_elemento_id,cantidad) 
								VALUES (id_producto,str_filas[1]::integer,str_filas[2]::double precision);
							END IF;
						END LOOP;
					END IF;
				END IF;	
			ELSE
				--para Producto 1=TERMINADO, 2=INTERMEDIO, 3=KIT, 8=DESARROLLO
				IF tipo_producto=1 OR tipo_producto=2 OR tipo_producto=3 OR tipo_producto=8 THEN 
					total_filas:= array_length(extra_data,1);
					cont_fila:=1;
					IF extra_data[1]<>'sin datos' THEN
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							--str_filas[1] eliminado
							IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--ya no se valida nada
								--str_filas[1]	producto_ingrediente_id
								--str_filas[2] 	porcentaje
								--INSERT INTO inv_prod_formulaciones(producto_formulacion_id,producto_ingrediente_id,porcentaje) VALUES (id_producto,str_filas[1]::integer,str_filas[2]::double precision);
								INSERT INTO inv_kit(producto_kit_id,producto_elemento_id,cantidad) VALUES(id_producto,str_filas[1]::integer,str_filas[2]::double precision);
							END IF;
						END LOOP;
					END IF;
				END IF;
			END IF;
			
			
			--Si el tipo de producto es DIFERENTE DE 3=Kit Y 4=Servicios
			IF str_data[18]::integer<>3 AND str_data[18]::integer<>4 THEN
				--Genera registro en la tabla inv_exi
				FOR fila2 IN EXECUTE('SELECT distinct inv_suc_alm.almacen_id FROM gral_suc JOIN inv_suc_alm ON inv_suc_alm.sucursal_id=gral_suc.id WHERE gral_suc.empresa_id='||emp_id||' ORDER BY inv_suc_alm.almacen_id') LOOP
					INSERT INTO inv_exi(inv_prod_id, inv_alm_id, ano, exi_inicial, transito) VALUES(id_producto, fila2.almacen_id, ano_actual, 0, 0);
				END LOOP;
				
				if str_data[45]::integer=1 then 
					--Si es MN, el tipo de cambio es 1
					valor1:=1;
				else
					--Buscar el tipo de cambio del d√≠a
					SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=str_data[45]::integer ORDER BY momento_creacion DESC LIMIT 1 into valor1;
					if valor1 is null then valor1:=1; end if;
				end if;
				
				--Genera registro en la tabla 
				INSERT INTO inv_prod_cost_prom(inv_prod_id, ano,gral_mon_id_1,gral_mon_id_2,gral_mon_id_3,gral_mon_id_4,gral_mon_id_5,gral_mon_id_6,gral_mon_id_7,gral_mon_id_8,gral_mon_id_9,gral_mon_id_10,gral_mon_id_11,gral_mon_id_12,tipo_cambio_1,tipo_cambio_2,tipo_cambio_3,tipo_cambio_4,tipo_cambio_5,tipo_cambio_6,tipo_cambio_7,tipo_cambio_8,tipo_cambio_9,tipo_cambio_10,tipo_cambio_11,tipo_cambio_12) 
				VALUES(id_producto, ano_actual,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1);
			END IF;
			
			valor_retorno := '1';
		END IF;--termina nuevo producto
		
		
		IF command_selected = 'edit' THEN
			nuevo_folio := str_data[31];
			tipo_producto:=str_data[18]::integer;
			UPDATE inv_prod SET 
				sku=nuevo_folio,--nuevo_folio, 
				descripcion=str_data[5],
				codigo_barras=str_data[6],
				tentrega=str_data[7]::integer,
				inv_clas_id=str_data[8]::integer,
				inv_stock_clasif_id=str_data[9]::integer,
				estatus=str_data[10]::boolean,
				inv_prod_familia_id=str_data[11]::integer,
				subfamilia_id=str_data[12]::integer,
				inv_prod_grupo_id=str_data[13]::integer,
				ieps=str_data[14]::integer,
				--meta_impuesto=meta_imp,
				gral_impto_id=str_data[15]::integer,
				inv_prod_linea_id=str_data[16]::integer,
				inv_mar_id=str_data[17]::integer,
				tipo_de_producto_id=str_data[18]::integer,
				inv_seccion_id=str_data[19]::integer,
				unidad_id=str_data[20]::integer,
				requiere_numero_lote=str_data[21]::boolean,
				requiere_nom=str_data[22]::boolean,
				requiere_numero_serie=str_data[23]::boolean,
				requiere_pedimento=str_data[24]::boolean,
				permitir_stock=str_data[25]::boolean,
				venta_moneda_extranjera=str_data[26]::boolean,
				compra_moneda_extranjera=str_data[27]::boolean,
				cxp_prov_id=str_data[29]::integer,
				densidad=str_data[30]::double precision,
				valor_maximo=str_data[32]::double precision,
				valor_minimo=str_data[33]::double precision,
				punto_reorden=str_data[34]::double precision,
				ctb_cta_id_gasto=str_data[35]::integer,
				ctb_cta_id_costo_venta=str_data[36]::integer,
				ctb_cta_id_venta=str_data[37]::integer,
				momento_actualizacion=now(),
				id_usuario_actualizacion=usuario_id,
				descripcion_corta=str_data[40],
				descripcion_larga=str_data[41],
				archivo_img=str_data[38],
				archivo_pdf=str_data[39],
				inv_prod_presentacion_id=str_data[42]::integer,
				flete=str_data[43]::boolean,
				no_clie=str_data[44],
				gral_mon_id=str_data[45]::integer,
				gral_imptos_ret_id=str_data[46]::integer,
                cfdi_prodserv_id=get_id_cfdi_claveprodserv(str_data[47])::integer
			WHERE id=str_data[4]::integer;
			
			--convertir en arreglo los id de presentaciones de producto
			SELECT INTO str_pres string_to_array(str_data[28],',');
			
			--obtiene numero de elementos del arreglo str_pres
			tot_filas:= array_length(str_pres,1);
			
			--elimina los registros de las presentaciones del producto
			DELETE FROM inv_prod_pres_x_prod WHERE producto_id=str_data[4]::integer;
			
			--Si el tiopo de producto es diferente de 3 y 4, hay que guardar presentaciones
			--tipo=3 Kit
			--tipo=4 Servicios
			--IF str_data[18]::integer!=3 AND str_data[18]::integer!=4 THEN
				--aqui se vuelven a crear los registros de las presentaciones del producto
				FOR cont_fila_pres IN 1 .. tot_filas LOOP
					INSERT INTO inv_prod_pres_x_prod(producto_id,presentacion_id) VALUES (str_data[4]::integer,str_pres[cont_fila_pres]::integer);
				END LOOP;
			--END IF;
			
			FOR fila IN EXECUTE('SELECT id, inv_prod_id, inv_prod_presentacion_id FROM inv_prod_costos WHERE inv_prod_id='||str_data[4]::integer||' AND ano=EXTRACT(YEAR FROM now())') LOOP
				exis:=0;
				SELECT count(id) FROM inv_prod_pres_x_prod WHERE producto_id=fila.inv_prod_id AND presentacion_id=fila.inv_prod_presentacion_id INTO exis;
				IF exis<=0 THEN 
					DELETE FROM inv_prod_costos WHERE id=fila.id;
				END IF;
			END LOOP;
			
			FOR fila IN EXECUTE('SELECT id, inv_prod_id, inv_prod_presentacion_id FROM inv_pre WHERE inv_prod_id='||str_data[4]::integer||' AND gral_emp_id='||emp_id) LOOP
				exis:=0;
				SELECT count(id) FROM inv_prod_pres_x_prod WHERE producto_id=fila.inv_prod_id AND presentacion_id=fila.inv_prod_presentacion_id INTO exis;
				IF exis<=0 THEN 
					DELETE FROM inv_pre WHERE id=fila.id;
				END IF;
			END LOOP;
			
			IF controlExisPres THEN 
				FOR fila IN EXECUTE('SELECT id, inv_prod_id, inv_prod_presentacion_id FROM inv_exi_pres WHERE inv_prod_id='||str_data[4]::integer) LOOP
					exis:=0;
					SELECT count(id) FROM inv_prod_pres_x_prod WHERE producto_id=fila.inv_prod_id AND presentacion_id=fila.inv_prod_presentacion_id INTO exis;
					IF exis<=0 THEN 
						DELETE FROM inv_exi_pres WHERE id=fila.id;
					END IF;
				END LOOP;

				FOR fila IN EXECUTE('select id, inv_prod_id, inv_prod_presentacion_id from env_conf where inv_prod_id='||str_data[4]::integer) LOOP
					exis:=0;
					SELECT count(id) FROM inv_prod_pres_x_prod WHERE producto_id=fila.inv_prod_id AND presentacion_id=fila.inv_prod_presentacion_id INTO exis;
					IF exis<=0 THEN 
						DELETE FROM env_conf WHERE id=fila.id;
						DELETE FROM env_conf_det WHERE env_conf_id=fila.id;
					END IF;
				END LOOP;
			END IF;
			
				
			IF incluye_modulo_produccion=TRUE THEN 
				--para Producto 3=Kit
				IF tipo_producto=3 THEN
					--elimina los prod ingredientes de la tabla inv_kit
					DELETE FROM inv_kit  WHERE producto_kit_id = str_data[4]::integer;
					
					total_filas:= array_length(extra_data,1);
					cont_fila:=1;
					IF extra_data[1] != 'sin datos' THEN
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							--str_filas[1] eliminado
							IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--ya no se valida nada
								--str_filas[1]	producto_elemento_id
								--str_filas[2] 	cantidad
								INSERT INTO inv_kit(producto_kit_id,producto_elemento_id,cantidad) VALUES (str_data[4]::integer,str_filas[1]::integer,str_filas[2]::double precision);
							END IF;
						END LOOP;
					END IF;
				END IF;	
			ELSE
				
				--Para Producto 1=TERMINADO, 2=INTERMEDIO, 3=KIT, 8=DESARROLLO
				IF tipo_producto=1 OR tipo_producto=2 OR tipo_producto=3 OR tipo_producto=8 THEN 
					--elimina los prod ingredientes de la tabla inv_kit
					DELETE FROM inv_kit  WHERE producto_kit_id=str_data[4]::integer;

					--RAISE EXCEPTION '%','extra_data: '||extra_data;
					
					total_filas:= array_length(extra_data,1);
					cont_fila:=1;
					IF extra_data[1] != 'sin datos' THEN
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							--str_filas[1] eliminado
							IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
								--str_filas[1]	producto_elemento_id
								--str_filas[2] 	cantidad
								INSERT INTO inv_kit(producto_kit_id,producto_elemento_id,cantidad) VALUES (str_data[4]::integer,str_filas[1]::integer,str_filas[2]::double precision);
							END IF;
						END LOOP;
					END IF;
				END IF;	
			END IF;
			
			valor_retorno := '1';
		END IF;--termina edit producto
		
		
		
		IF command_selected = 'delete' THEN
			valor_retorno := '1';
			
			IF incluye_modulo_produccion=TRUE THEN
				--aqui buscamos si el producto es formulado
				SELECT count(inv_prod_id) FROM pro_estruc  WHERE inv_prod_id=str_data[4]::integer AND borrado_logico=FALSE INTO exis;
				IF exis > 0 THEN
					valor_retorno := '01';
				ELSE
					exis:=0; --inicializar variable
					--aqui buscamos si el producto forma parte de una formula
					SELECT count(pro_estruc_det.inv_prod_id) FROM pro_estruc_det JOIN pro_estruc ON pro_estruc.id=pro_estruc_det.pro_estruc_id WHERE pro_estruc_det.inv_prod_id=str_data[4]::integer  AND pro_estruc.borrado_logico=FALSE 
					INTO exis;
					
					IF exis > 0 THEN
						valor_retorno := '02';
					END IF;
				END IF;
				
				IF valor_retorno='1' THEN 
					--si el valor retorno sigue igual a 1, entonces tambien buscamos en la tabla de kits
					SELECT count(producto_elemento_id) FROM inv_kit WHERE producto_elemento_id=str_data[4]::integer INTO exis;
					IF exis > 0 THEN
						valor_retorno := '03';
					END IF;
				END IF;
			ELSE
				SELECT count(producto_elemento_id) FROM inv_kit WHERE producto_elemento_id=str_data[4]::integer INTO exis;
				IF exis > 0 THEN
					valor_retorno := '04';
				END IF;
			END IF;
			
			
			IF incluye_modulo_envasado=TRUE THEN 
				--verificamos que el producto no forme parte de una configuracion de envase
				exis:=0;
				SELECT count(env_conf_det.inv_prod_id) FROM env_conf JOIN  env_conf_det ON env_conf_det.env_conf_id=env_conf.id WHERE env_conf_det.inv_prod_id=str_data[4]::integer AND env_conf.borrado_logico=FALSE 
				INTO exis;
				IF exis > 0 THEN
					valor_retorno := '05';
				END IF;
			END IF;


			IF (select sum((inv_exi.exi_inicial - inv_exi.transito - inv_exi.reservado  + inv_exi.entradas_1 - inv_exi.salidas_1 + inv_exi.entradas_2 - inv_exi.salidas_2 + inv_exi.entradas_3 - inv_exi.salidas_3 + inv_exi.entradas_4 - inv_exi.salidas_4 + inv_exi.entradas_5 - inv_exi.salidas_5 + inv_exi.entradas_6 - inv_exi.salidas_6 + inv_exi.entradas_7 - inv_exi.salidas_7 + inv_exi.entradas_8 - inv_exi.salidas_8 + inv_exi.entradas_9 - inv_exi.salidas_9 + inv_exi.entradas_10 - inv_exi.salidas_10 + inv_exi.entradas_11 - inv_exi.salidas_11 + inv_exi.entradas_12 - inv_exi.salidas_12)) AS existencia FROM inv_exi WHERE inv_prod_id=str_data[4]::integer)>0.0001 THEN 
				--No se puede eliminar porque hay existencia en uno o mas almacenes
				valor_retorno := '06';
			END IF;
			
			
			--Si valor retorno es igual a 1, entonces procedemos a eliminar el producto
			IF valor_retorno='1' THEN 
				UPDATE inv_prod SET borrado_logico=true, momento_baja=now(), id_usuario_baja = usuario_id
				WHERE id = str_data[4]::integer;
				
				--elimina los registros de las formulacion del producto
				DELETE FROM inv_kit  WHERE producto_kit_id = str_data[4]::integer;
				
				--elimina los registros de las presentaciones del producto
				DELETE FROM inv_prod_pres_x_prod WHERE producto_id=str_data[4]::integer;
				
				DELETE FROM inv_prod_costos WHERE inv_prod_id=str_data[4]::integer AND ano=EXTRACT(YEAR FROM now());

				DELETE FROM inv_pre WHERE inv_prod_id=str_data[4]::integer AND gral_emp_id=emp_id;

				DELETE FROM inv_exi_pres WHERE inv_prod_id=str_data[4]::integer;
			END IF;
			
			--valor_retorno := '1';
		END IF;
	END IF;
	--termina catalogo de productos
	
	
	
	
	-- prefacturas
	IF app_selected = 13 THEN
		IF command_selected = 'new' THEN
			
			--str_data[3]	id_usuario
			--str_data[4]	id_prefactura
			--str_data[5] 	id_cliente
			--str_data[6]	moneda
			--str_data[7]	observaciones
			--str_data[8]	subtotal
			--str_data[9]	impuesto
			--str_data[10]	total
			--str_data[11]	tipo_cambio
			--str_data[12]	id_vendedor
			--str_data[13]	id_condiciones
			--str_data[14]	orden_compra
			--str_data[15]	refacturar
			--str_data[16]	id_metodo_pago
			--str_data[17]	no_cuenta
			--str_data[19]	tipo_documento
			
			
			--crea registro en tabla erp_proceso y retorna el id del registro creado
			INSERT INTO  erp_proceso(proceso_flujo_id,empresa_id,sucursal_id)VALUES(2, emp_id, suc_id) RETURNING id into ultimo_id_proceso;
			
			--crear registro en la tabla cotizacions y retorna el id del registro creado
			 INSERT INTO  erp_prefacturas(
				  cliente_id,
				  moneda_id,
				  observaciones,
				  subtotal,
				  impuesto,
				  total,
				  proceso_id,
				  tipo_cambio,
				  empleado_id,
				  terminos_id,
				  orden_compra,
				  refacturar,
				  fac_metodos_pago_id,
				  no_tarjeta,
				  id_usuario_creacion,
				  momento_creacion
			)
			VALUES(
				  str_data[5]::integer,
				  str_data[6]::integer,
				  str_data[7],
				  str_data[8]::double precision,
				  str_data[9]::double precision,
				  str_data[10]::double precision,
				  ultimo_id_proceso,
				  str_data[11]::double precision,
				  str_data[12]::integer,
				  str_data[13]::integer,
				  str_data[14],
				  str_data[15]::boolean,
				  str_data[16]::integer,
				  str_data[17],
				  str_data[3]::integer,
				  now()
			) RETURNING id into ultimo_id;
			
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					
					--crea registros para tabla invfisico-detalles
					INSERT INTO erp_prefacturas_detalles(
						  producto_id,
						  presentacion_id,
						  tipo_impuesto_id,
						  cantidad,
						  precio_unitario,
						  prefacturas_id,
						  momento_creacion
					)VALUES(
						  str_filas[3]::integer,
						  str_filas[4]::integer,
						  str_filas[5]::integer,
						  str_filas[6]::double precision,
						  str_filas[7]::double precision,
						  ultimo_id,
						  now()
					);
					
					IF str_data[16]='true' THEN
						
						
					END IF;
					
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;--termina nueva prefactura
		
		
		
		IF command_selected = 'edit' THEN
			--str_data[3]	id_usuario
			--str_data[4]	id_prefactura
			--str_data[5] 	id_cliente
			--str_data[6]	moneda
			--str_data[7]	observaciones
			--str_data[8]	subtotal
			--str_data[9]	impuesto
			--str_data[10]	total
			--str_data[11]	tipo_cambio
			--str_data[12]	id_vendedor
			--str_data[13]	id_condiciones
			--str_data[14]	orden_compra
			--str_data[15]	refacturar
			--str_data[16]	id_metodo_pago
			--str_data[17]	no_cuenta
			--str_data[19]	tipo_documento
			UPDATE erp_prefacturas SET 
				cliente_id = str_data[5]::integer, 
				moneda_id = str_data[6]::integer, 
				observaciones = str_data[7], 
				subtotal = str_data[8]::double precision, 
				impuesto = str_data[9]::double precision, 
				total = str_data[10]::double precision, 
				tipo_cambio = str_data[11]::double precision,
				empleado_id=str_data[12]::integer,
				terminos_id=str_data[13]::integer,
				orden_compra=str_data[14],
				refacturar=str_data[15]::boolean, 
				fac_metodos_pago_id=str_data[16]::integer,
				no_tarjeta=str_data[17],
				id_usuario_actualizacion = str_data[3]::integer,
				momento_actualizacion = now()
			WHERE id = str_data[4]::integer;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				--str_filas[1] 0:eliminado, 1:no eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					
					--verifica si trae un id. Este id es el id del registro en la tabla cotizacions_detalles
					IF str_filas[2] !='0' THEN
						--RAISE EXCEPTION '%','No es nuevo';
						--actualiza registros en la tabla invfisico-detalles
						UPDATE erp_prefacturas_detalles SET cantidad = str_filas[6]::double precision,precio_unitario = str_filas[7]::double precision,tipo_impuesto_id = str_filas[5]::integer
						WHERE  id = str_filas[2]::integer  AND prefacturas_id = str_data[4]::integer;
					ELSE
						--RAISE EXCEPTION '%','Este si es nuevo es nuevo: '||str_filas[2];
						--crea nuevos registros
						INSERT INTO erp_prefacturas_detalles(prefacturas_id,producto_id,presentacion_id,tipo_impuesto_id,cantidad,precio_unitario,momento_creacion)
						VALUES(str_data[4]::integer,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::integer,str_filas[6]::double precision,str_filas[7]::double precision,now());
					END IF;
				ELSE
					--elimina registro que se elimino en el grid
					DELETE FROM erp_prefacturas_detalles where id = str_filas[2]::integer  AND prefacturas_id = str_data[4]::integer;
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;--termina edit prefactura
		
		IF command_selected = 'delete' THEN
			UPDATE erp_prefacturas SET borrado_logico = true, momento_baja = now(),id_usuario_baja = str_data[3]::integer
			where id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
	END IF;--termina prefacturas
	
	
	-- pagos
	IF app_selected = 14 THEN

		id_tipo_consecutivo:=11;--Numero de transaccion pago CXC
		
		--aqui entra para tomar el consecutivo del folio  la sucursal actual
		UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
		WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
		
		--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
		--nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

		
		--nuevo folio transaccion
		folio_transaccion := nuevo_consecutivo::bigint;
		folio_transaccion_pago := nuevo_consecutivo::bigint;
		
		
		IF command_selected = 'pago' THEN
			--obtiene id de la forma de pago
			SELECT id FROM erp_pagos_formas WHERE titulo ILIKE str_data[11] LIMIT 1 into id_forma_pago;
			
			id_anticipo := 0;
			monto_anticipo_actual:=0;
			--obtener id del anticipo
			SELECT COUNT(id) FROM cxc_ant WHERE numero_transaccion = str_data[23]::bigint AND cliente_id=str_data[4]::integer and borrado_logico=false INTO rowCount;
			IF rowCount > 0 THEN
				SELECT id, anticipo_actual FROM cxc_ant WHERE numero_transaccion = str_data[23]::bigint AND cliente_id = str_data[4]::integer   LIMIT 1 
				INTO id_anticipo, monto_anticipo_actual;
			END IF;
			
			INSERT INTO erp_pagos (
					numero_transaccion,
					momento_creacion,
					forma_pago_id,
					numero_cheque,
					referencia,
					numero_tarjeta,
					observaciones,
					id_usuario_pago,
					banco_id,
					moneda_id,
					monto_pago,
					cliente_id,
					fecha_deposito,
					numerocuenta_id,
					movimiento,
					bancokemikal_id,
					tipo_cambio,
					anticipo_id,
					empresa_id,
					sucursal_id
				)
			VALUES (folio_transaccion,
					now(),
					id_forma_pago,
					str_data[12],
					str_data[13],
					str_data[14],
					str_data[10],
					str_data[3]::integer,
					str_data[9]::integer,
					str_data[7]::integer,
					str_data[16]::double precision,
					str_data[4]::integer,
					str_data[17]::timestamp with time zone,
					str_data[19]::integer,
					str_data[18],
					str_data[20]::integer,
					str_data[21]::double precision,
					id_anticipo,
					emp_id, 
					suc_id
				) RETURNING id into ultimo_id;
				
			--str_data[3]	id_usuario
			--str_data[4]	cliente_id
			--str_data[5]	deuda_pesos
			--str_data[6]	deuda_usd
			--str_data[7]	moneda
			--str_data[8]	fecha+" "+hora+":"+minutos+":"+segundos
			--str_data[9]	banco
			--str_data[10]	observaciones
			--str_data[11]	forma_pago
			--str_data[12]	cheque
			--str_data[13]	referencia
			--str_data[14]	tarjeta
			--str_data[15]	antipo
			--str_data[16]	monto_pago
			--str_data[17]	fecha_deposito
			--str_data[18]	ficha_movimiento_deposito
			--str_data[19]	ficha_cuenta_deposito
			--str_data[20]	ficha_banco_kemikal
			--str_data[21]	tipo_cambio
			--str_data[22]	anticipo_gastado
			--str_data[23]	no_transaccion_anticipo
			--str_data[24]	saldo_a_favor
			
			--RAISE EXCEPTION '%','Si llega aqui: id_pago: '||ultimo_id_pago;
			--------------------saldando facturas--------------------------------
			--SELECT INTO item string_to_array(''||valores||'','&');
			
			SELECT INTO veces array_upper(extra_data,1);
			WHILE incrementa <= veces LOOP
				SELECT INTO iterar string_to_array(extra_data[incrementa],'___');
				--RAISE EXCEPTION '%', iterar[1];
				--iterar[1]	factura_vista
				--iterar[2]	saldado
				--iterar[3]	saldo
				--iterar[4]	tipocambio(este tipo de cambio no se utiliza, el tipo de cambio esta en pagos)
				
				SELECT moneda_id FROM fac_docs WHERE serie_folio=iterar[1] INTO id_moneda_factura;
				
				INSERT INTO erp_pagos_detalles (pago_id,serie_folio,cantidad,momento_pago,fac_moneda_id) 
				VALUES (ultimo_id,iterar[1],iterar[3]::double precision,str_data[8]::timestamp with time zone, id_moneda_factura);
				
				IF iterar[2]::boolean = true THEN
					UPDATE erp_h_facturas SET pagado=true WHERE serie_folio = iterar[1]::character varying;
					UPDATE fac_cfds SET pagado=true WHERE serie_folio ilike iterar[1]::character varying;
					--UPDATE erp_notacargos SET pagado=true WHERE serie_folio ilike iterar[1]::character varying;
				END IF;
				incrementa:= 1 + incrementa;
			END LOOP;

			sql_pagos:='SELECT serie_folio,cantidad FROM erp_pagos_detalles WHERE pago_id = '||ultimo_id;
			--RAISE EXCEPTION '%','Si llega aqui: sql-pagos: '||string_pagos;
			
			FOR fila IN EXECUTE(sql_pagos) LOOP
				EXECUTE 'SELECT monto_total,total_pagos	from  erp_h_facturas where serie_folio ilike '''||fila.serie_folio||'''' 
				INTO total_factura,monto_pagos;

				--sacar suma total de pagos para esta factura
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=fila.serie_folio AND cancelacion=FALSE) AS sbt  INTO suma_pagos;

				--sacar suma total de notas de credito para esta factura
				--SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (SELECT sum(total) FROM fac_nota_credito WHERE serie_folio_factura=fila.serie_folio AND cancelado=FALSE) AS subtabla INTO suma_notas_credito;
				SELECT total_notas_creditos FROM erp_h_facturas WHERE serie_folio=fila.serie_folio INTO suma_notas_credito;
				
				nuevacantidad_monto_pago:=round((suma_pagos)::numeric,4)::double precision;
				nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,4)::double precision;
				
				--actualiza cantidades cada vez que se realice un pago
				UPDATE erp_h_facturas SET 
					total_pagos=nuevacantidad_monto_pago, 
					total_notas_creditos=suma_notas_credito,
					saldo_factura=nuevo_saldo_factura, 
					momento_actualizacion=now(),
					fecha_ultimo_pago=str_data[17]::date
				WHERE serie_folio=fila.serie_folio;
			END LOOP;
			
			--Inicia guardar saldos a favor y actualizar anticipos
			IF id_anticipo !=0 THEN
				--aqui entra porque el pago es de un anticipo y actualiza cantidades del anticipo
				IF monto_anticipo_actual >= str_data[22]::double precision THEN
					saldo_anticipo := monto_anticipo_actual - str_data[22]::double precision;
					IF saldo_anticipo <=0 THEN
					    UPDATE cxc_ant SET anticipo_actual=0, borrado_logico = true, id_usuario_actualizacion = str_data[3]::integer, momento_baja = now()
					    WHERE cliente_id = str_data[4]::integer AND id = id_anticipo;
					ELSE
					    UPDATE cxc_ant SET anticipo_actual = saldo_anticipo, id_usuario_baja = str_data[3]::integer, momento_actualizacion = now()
					    WHERE cliente_id = str_data[4]::integer AND id = id_anticipo;
					END IF;
				END IF;
			ELSE
				--Aqui entra porque el pago no es de un anticipo
				IF str_data[24]::double precision > 0 THEN
					/*
					INSERT INTO erp_pagosxaplicar( 
						cliente_id,
						moneda_id,
						monto_inicial,
						monto_actual,
						momento_creacion,
						id_usuario_creacion,
						empresa_id,
						sucursal_id)
					VALUES(
						str_data[4]::integer,
						str_data[7]::integer,
						str_data[24]::double precision,
						str_data[24]::double precision,
						now(),str_data[3]::integer,
						emp_id,
						suc_id	
					);
					*/
					--Aqu√≠ se genera una nuevo numero de transaccion para el anticipo des saldo a favor
					--aqui entra para tomar el consecutivo del folio  la sucursal actual

					UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
					WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
										--nuevo folio transaccion
					folio_transaccion := nuevo_consecutivo::bigint;

					INSERT INTO cxc_ant(
						numero_transaccion,--folio_transaccion,
						cliente_id,--str_data[4]::integer,
						moneda_id,--str_data[7]::integer,
						anticipo_inicial,--str_data[24]::double precision,
						anticipo_actual,--str_data[24]::double precision,
						fecha_anticipo_usuario,--now(),
						observaciones,--'ANTICIPO GENERADO DESDE UN PAGO COMO SALDO A FAVOR DEL CLIENTE'
						momento_creacion,--now(),
						id_usuario_creacion,--str_data[3]::integer,
						empresa_id,--emp_id,
						sucursal_id--suc_id
					)
					VALUES(
						folio_transaccion,
						str_data[4]::integer,
						str_data[7]::integer,
						str_data[24]::double precision,
						str_data[24]::double precision,
						now(),
						'ANTICIPO GENERADO DESDE UN PAGO COMO SALDO A FAVOR DEL CLIENTE',
						now(),
						str_data[3]::integer,
						emp_id,
						suc_id					
					);

				END IF;
			
			END IF;
			
	--GAS		valor_retorno = folio_transaccion::character varying||'___'||ultimo_id::character varying;
			valor_retorno = folio_transaccion_pago::character varying||'___'||ultimo_id::character varying;
			
		END IF;--termina registro de pago
		
		
		
		--registro de anticipo
		IF command_selected = 'anticipo' THEN
			
			SELECT INTO str_data string_to_array(''||campos_data||'','___');	
			--str_data[3] 	id_usuario
			--str_data[4] 	fecha_anticipo
			--str_data[5] 	monto_anticipo
			--str_data[6] 	id_moneda
                        --str_data[7]   id_cliente
                        --str_data[8]   observaciones
                                
			INSERT INTO cxc_ant(
				numero_transaccion,
				cliente_id,
				moneda_id,
				anticipo_inicial,
				anticipo_actual,
				fecha_anticipo_usuario,
				observaciones,
				momento_creacion,
				id_usuario_creacion,
				empresa_id,
				sucursal_id
			)
			VALUES(
				folio_transaccion,
				str_data[7]::integer,
				str_data[6]::integer,
				str_data[5]::double precision,
				str_data[5]::double precision,
				str_data[4]::timestamp with time zone,
				str_data[8],
				now(),
				str_data[3]::integer,
				emp_id,
				suc_id
			);
			valor_retorno := folio_transaccion::character varying;			
		END IF;--termina registro de anticipo
		
		
		
		--cancelacion de pagos
		IF command_selected = 'cancelacion' THEN
			--str_data[3]	id_usuario
			--str_data[4]	cancelar_por
			--str_data[5]	observaciones_canc
			--str_data[6]	numero_trans
			--str_data[7]	fecha_cancelacion

			--folio_transaccion:=str_data[6]::bigint;
			
			--TIPO CANCELACION POR FACTURAS
			IF str_data[4]='1' THEN
				id_anticipo:=0;
				--obtiene id del pago y id de anticipo
				SELECT id,anticipo_id,tipo_cambio FROM erp_pagos WHERE numero_transaccion=str_data[6]::bigint ORDER BY id DESC LIMIT 1 INTO id_pago,id_anticipo, tipo_cambio_pago;
				--RAISE EXCEPTION '%','monto cancelado: SELECT id,anticipo_id FROM erp_pagos WHERE numero_transaccion ILIKE '||str_data[3];
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					--arreglo[cont_fila] serie_folio
					--RAISE EXCEPTION '%','SERIE_FOLIO: '||extra_data[cont_fila]||'   id_pago:'||id_pago;
					
					--actualiza tabla erp_pagos_detalles
					UPDATE erp_pagos_detalles SET cancelacion = true, momento_cancelacion = str_data[7]::timestamp with time zone 
					WHERE pago_id = id_pago AND serie_folio ilike extra_data[cont_fila] RETURNING id,cantidad into id_pagos_detalles,monto_cancelado;
					
					--verificar monto_cancelado
					--RAISE EXCEPTION '%','monto cancelado: '||monto_cancelado;
					
					SELECT monto_total,total_pagos_cancelados,moneda_id from  erp_h_facturas where serie_folio=extra_data[cont_fila]
					INTO total_factura,total_monto_cancelados,id_moneda_factura;
					
					SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=extra_data[cont_fila] AND cancelacion=FALSE ) AS sbt  INTO suma_pagos;

					--sacar total de notas de credito
					SELECT total_notas_creditos FROM erp_h_facturas WHERE serie_folio=extra_data[cont_fila] INTO suma_notas_credito;
					
					nuevacantidad_monto_cancelados:=round((total_monto_cancelados + monto_cancelado)::numeric,4)::double precision;
					--nuevo_saldo_factura:=round((total_factura - suma_pagos)::numeric,4)::double precision;
					nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,4)::double precision;

					
					--RAISE EXCEPTION '%','TotFact='||total_factura||' SaldoFact='||saldo_factura||' TotalCan='||total_monto_cancelados||' NuevoTotCan='||nuevacantidad_monto_cancelados;
					
					--actualiza cantidades cada vez que se realice una cancelacion
					UPDATE erp_h_facturas SET 
						total_pagos = suma_pagos,
						total_notas_creditos=suma_notas_credito,
						total_pagos_cancelados = nuevacantidad_monto_cancelados, 
						saldo_factura=nuevo_saldo_factura,
						pagado = false
					where serie_folio ilike extra_data[cont_fila]
					RETURNING moneda_id into id_moneda_factura;
					
					UPDATE fac_cfds SET pagado=false WHERE serie_folio=extra_data[cont_fila];
					
					INSERT INTO  erp_pagos_cancelacion_detalles(pagos_detalles_id,numero_transaccion,momento_creacion_usuario,id_usuario_creacion,observaciones,momento_creacion)
					VALUES( id_pagos_detalles,folio_transaccion, str_data[7]::timestamp with time zone, str_data[3]::integer, str_data[5], now());
					
					
					--actualiza anticipos al cancelar un pago que fue originado de un anticipo
					IF id_anticipo !=0 THEN
						SELECT anticipo_actual,moneda_id FROM cxc_ant WHERE id = id_anticipo INTO monto_anticipo_actual, id_moneda_anticipo;
						
						IF id_moneda_factura = 1 THEN 
							IF id_moneda_anticipo = 2 THEN 
								saldo_anticipo:=monto_anticipo_actual + (monto_cancelado / tipo_cambio_pago);
							END IF;
							IF id_moneda_anticipo = 1 THEN 
								saldo_anticipo:=monto_anticipo_actual + monto_cancelado;
							END IF;
						END IF;
						IF id_moneda_factura = 2 THEN 
							IF id_moneda_anticipo = 2 THEN 
								saldo_anticipo:=monto_anticipo_actual + monto_cancelado;
							END IF;
							IF id_moneda_anticipo = 1 THEN 
								saldo_anticipo:=monto_anticipo_actual + (monto_cancelado * tipo_cambio_pago);
							END IF;
						END IF;
						
						--RAISE EXCEPTION '%','saldo_anticipo: '||saldo_anticipo;
						UPDATE cxc_ant SET anticipo_actual = saldo_anticipo,
									id_usuario_actualizacion = str_data[3]::integer, 
									momento_actualizacion = now(),
									borrado_logico = false,
									momento_baja = null
						WHERE id = id_anticipo;
					END IF;
					
				END LOOP;
				valor_retorno:=folio_transaccion::character varying;
				--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
			END IF;--TERMINA TIPO CANCELACION POR FACTURAS
			
			
			
			
			--TIPO CANCELACION POR NUMERO DE TRANSACCION
			IF str_data[4]='2' THEN
				--obtiene id del pago
				
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					id_anticipo:=0;
					--extra_data[cont_fila] numero de transaccion
					SELECT id,anticipo_id,tipo_cambio FROM erp_pagos WHERE numero_transaccion = extra_data[cont_fila]::bigint LIMIT 1 INTO id_pago,id_anticipo,tipo_cambio_pago;
					--RAISE EXCEPTION '%','id_pago: '||id_pago;
					
					--cancela todas las facturas pagadas con esta transaccion
					UPDATE erp_pagos_detalles SET cancelacion = true, momento_cancelacion = str_data[7]::timestamp with time zone 
					WHERE pago_id = id_pago;
					
					
					sql_pagos:='SELECT id,serie_folio, cantidad FROM erp_pagos_detalles WHERE  erp_pagos_detalles.pago_id = '||id_pago;
					
					FOR fila IN EXECUTE (sql_pagos) LOOP
						SELECT monto_total,total_pagos_cancelados,moneda_id from  erp_h_facturas where serie_folio=fila.serie_folio
						INTO total_factura,total_monto_cancelados,id_moneda_factura;
						
						--RAISE EXCEPTION '%','total_factura '||total_factura;
						--RAISE EXCEPTION '%','total_monto_cancelados: '||total_monto_cancelados;
						
						SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio = fila.serie_folio AND cancelacion=FALSE ) AS sbt  INTO suma_pagos;
						--RAISE EXCEPTION '%','suma_pagos '||suma_pagos;

						SELECT total_notas_creditos FROM erp_h_facturas WHERE serie_folio=fila.serie_folio INTO suma_notas_credito;
						
						nuevacantidad_monto_cancelados:=round((total_monto_cancelados + fila.cantidad)::numeric,4)::double precision;
						--nuevo_saldo_factura:=round((total_factura - suma_pagos)::numeric,4)::double precision;
						nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,4)::double precision;
						
						
						--actualiza cantidades cada vez que se realice una cancelacion
						UPDATE erp_h_facturas SET 
							total_pagos = suma_pagos,
							total_notas_creditos=suma_notas_credito,
							total_pagos_cancelados = nuevacantidad_monto_cancelados, 
							saldo_factura=nuevo_saldo_factura,
							pagado = false
						where serie_folio ilike fila.serie_folio
						RETURNING moneda_id into id_moneda_factura;
						
						UPDATE fac_cfds SET pagado=false WHERE serie_folio ilike fila.serie_folio;
						
						
						INSERT INTO  erp_pagos_cancelacion_detalles(pagos_detalles_id,numero_transaccion,momento_creacion_usuario,id_usuario_creacion,observaciones,momento_creacion)
						VALUES( fila.id, folio_transaccion, str_data[7]::timestamp with time zone, str_data[3]::integer, str_data[5], now());
						
						--actualiza anticipos al cancelar un pago que fue originado de un anticipo
						IF id_anticipo !=0 THEN
							--SELECT anticipo_actual FROM cxc_ant WHERE id = id_anticipo INTO monto_anticipo_actual;
							SELECT anticipo_actual,moneda_id FROM cxc_ant WHERE id = id_anticipo INTO monto_anticipo_actual, id_moneda_anticipo;
							
							IF id_moneda_factura = 1 THEN 
								IF id_moneda_anticipo = 2 THEN 
									saldo_anticipo:=monto_anticipo_actual + (fila.cantidad / tipo_cambio_pago);
								END IF;
								IF id_moneda_anticipo = 1 THEN 
									saldo_anticipo:=monto_anticipo_actual + fila.cantidad;
								END IF;
							END IF;
							IF id_moneda_factura = 2 THEN 
								IF id_moneda_anticipo = 2 THEN 
									saldo_anticipo:=monto_anticipo_actual + fila.cantidad;
								END IF;
								IF id_moneda_anticipo = 1 THEN 
									saldo_anticipo:=monto_anticipo_actual + (fila.cantidad * tipo_cambio_pago);
								END IF;
							END IF;
							
							--RAISE EXCEPTION '%','moneda_factura:'||id_moneda_factura||'  moneda_anticipo:'||id_moneda_anticipo||'  monto_anticipo_actual:'||monto_anticipo_actual||'  monto_cancelado:'||fila.cantidad||'  saldo_anticipo:'||saldo_anticipo; 
							
							UPDATE cxc_ant SET anticipo_actual = saldo_anticipo,
										id_usuario_actualizacion = str_data[3]::integer, 
										momento_actualizacion = now(),
										borrado_logico = false,
										momento_baja = null
							WHERE id = id_anticipo;
						END IF;
						
					END LOOP;
					--RAISE EXCEPTION '%','TotFact='||total_factura||' SaldoFact='||saldo_factura||' TotalCan='||total_monto_cancelados||' NuevoTotCan='||nuevacantidad_monto_cancelados;
					
					--valor_retorno:= valor_retorno||extra_data[cont_fila]||',';
					
					--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
					
				END LOOP;
				valor_retorno:= folio_transaccion::character varying;
				
			END IF;--TERMINA TIPO CANCELACION POR NUMERO DE TRANSACCION
			
		END IF;--termina termina cancelacion de pagos
		
	END IF;--termina pagos
	
	
	
	
	-- Catalogo de centros de costo
	IF app_selected = 15 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			--str_data[6] 	descripcion
			INSERT INTO ctb_cc (titulo,descripcion, momento_creacion, id_usuario_creacion,empresa_id,borrado_logico)
			VALUES (str_data[5],str_data[6], now(),usuario_id, emp_id,false);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE ctb_cc SET titulo=str_data[5],descripcion=str_data[6],id_usuario_actualizacion=usuario_id,momento_actualizacion=now(),borrado_logico=false
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_cc SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de centros de costo
	
	
	-- Catalogo de centros de Tipos de Poliza
	IF app_selected = 16 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	tipo
			--str_data[6] 	descripcion
			--str_data[7] 	grupo
			INSERT INTO ctb_tpol (titulo, ctb_tpol_grupo_id, tipo, empresa_id, borrado_logico, momento_creacion, id_usuario_creacion)
			VALUES (str_data[6], str_data[7]::integer, str_data[5]::integer, emp_id, false,now(),usuario_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE ctb_tpol SET titulo=str_data[6],ctb_tpol_grupo_id=str_data[7]::integer, tipo=str_data[5]::integer,id_usuario_actualizacion=usuario_id,momento_actualizacion=now()
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_tpol SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Tipos de poliza
	
	
	
	-- Catalogo de conceptos contables
	IF app_selected = 17 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			--str_data[6] 	descripcion
			INSERT INTO ctb_con (titulo,descripcion, momento_creacion, id_usuario_creacion,empresa_id,borrado_logico)
			VALUES (str_data[5],str_data[6], now(),usuario_id, emp_id,false);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE ctb_con SET titulo=str_data[5],descripcion=str_data[6],id_usuario_actualizacion=usuario_id,momento_actualizacion=now(),borrado_logico=false
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_con SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de conceptos contables
	
	
	-- Catalogo de Clasificacion de Cuentas(Cuentas de Mayor)
	IF app_selected = 18 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	ctamayor
			--str_data[6]	clasificacion
			--str_data[7]	des_espanol
			--str_data[8]	des_ingles
			--str_data[9]	des_otro
			INSERT INTO ctb_may (ctb_may_clase_id,clasificacion,descripcion,descripcion_ing,descripcion_otr,borrado_logico,	empresa_id,momento_creacion,id_usuario_creacion)
			VALUES (str_data[5]::integer,str_data[6]::smallint, str_data[7], str_data[8], str_data[9], false,emp_id,now(),usuario_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE ctb_may SET ctb_may_clase_id=str_data[5]::integer,clasificacion=str_data[6]::smallint, descripcion=str_data[7],descripcion_ing=str_data[8],descripcion_otr=str_data[9],id_usuario_actualizacion=usuario_id,momento_actualizacion=now(),borrado_logico=false
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_may SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Clasificacion de Cuentas(Cuentas de Mayor)
	
	
	
	-- Catalogo de Catalogo de Agentes
	IF app_selected = 19 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	nombre_agente
			--str_data[6]	usuario_agente
			--str_data[7]	comision
			--str_data[8]	region

			INSERT INTO cxc_agen(nombre, comision, gral_reg_id,gral_usr_id,borrado_logico,momento_creacion,gral_usr_id_creacion)
			VALUES(str_data[5],str_data[7]::double precision,str_data[8]::integer,str_data[6]::integer,false,now(),usuario_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_agen SET nombre=str_data[5],
						comision=str_data[7]::double precision,
						gral_reg_id=str_data[8]::integer,
						gral_usr_id=str_data[6]::integer,
						gral_usr_id_actualizacion=usuario_id,
						momento_actualizacion=now()
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxc_agen SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de Agentes
	
	
	-- Catalogo de Catalogo Clientes Clasificacion 1
	IF app_selected = 20 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			INSERT INTO cxc_clie_clas1 (titulo) VALUES (str_data[5]);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_clie_clas1 SET titulo=str_data[5] WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			DELETE FROM cxc_clie_clas1 WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Clientes Clasificacion 1
	

	-- Catalogo de Catalogo Clientes Clasificacion 2
	IF app_selected = 21 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			INSERT INTO cxc_clie_clas2 (titulo) VALUES (str_data[5]);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_clie_clas2 SET titulo=str_data[5] WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			DELETE FROM cxc_clie_clas2 WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Clientes Clasificacion 2
	
	
	-- Catalogo de Catalogo Clientes Clasificacion 3
	IF app_selected = 22 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			INSERT INTO cxc_clie_clas3 (titulo) VALUES (str_data[5]);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_clie_clas3 SET titulo=str_data[5] WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			DELETE FROM cxc_clie_clas3 WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Clientes Clasificacion 3

	
	
	-- Catalogo de Zonas de  Clientes
        IF app_selected = 23 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxc_clie_zonas (titulo,borrado_logico) VALUES (str_data[5],false);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_clie_zonas SET titulo=str_data[5] WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        --DELETE FROM cxc_clie_zonas WHERE id=str_data[4]::integer;
                        UPDATE cxc_clie_zonas
                        SET borrado_logico = true
                        WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo zonas de  Clientes
        


        -- Catalogo de  Grupos de  Clientes
        IF app_selected = 24 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxc_clie_grupos (titulo,borrado_logico) VALUES (str_data[5],false);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_clie_grupos SET titulo=str_data[5] WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        --DELETE FROM cxc_clie_grupos WHERE id=str_data[4]::integer;
                        UPDATE cxc_clie_grupos
                        SET borrado_logico = true
                        WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Grupos de  Clientes

	
	
	-- Catalogo de Catalogo Proveedores Clasificacion 1
        IF app_selected = 25 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_clas1 (titulo, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
                        VALUES (str_data[5], false, now(),usuario_id, emp_id, suc_id );
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_clas1 SET titulo=str_data[5], momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
			UPDATE cxp_prov_clas1 SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja=usuario_id 
			WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Proveedores Clasificacion 1
	
	
        -- Catalogo de Catalogo Proveedores Clasificacion 2
        IF app_selected = 26 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_clas2 (titulo, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
                        VALUES (str_data[5], false, now(),usuario_id, emp_id, suc_id);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_clas1 SET titulo=str_data[5], momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
			UPDATE cxp_prov_clas1 SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja=usuario_id 
			WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Proveedores Clasificacion 2
	
	
	
        -- Catalogo de Catalogo Proveedores Clasificacion 3
        IF app_selected = 27 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_clas3 (titulo, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
                        VALUES (str_data[5], false, now(), usuario_id, emp_id, suc_id);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_clas1 SET titulo=str_data[5], momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
			UPDATE cxp_prov_clas1 SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja=usuario_id 
			WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Proveedores Clasificacion 3

	-- Catalogo de Zonas de  Proveedores
        IF app_selected = 28 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_zonas (titulo) VALUES (str_data[5]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_zonas SET titulo=str_data[5] WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxp_prov_zonas WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo zonas de  proveedores
        
	
	
        -- Catalogo de  Grupos de  Proveedores
        IF app_selected = 29 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_grupos (titulo) VALUES (str_data[5]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_grupos SET titulo=str_data[5] WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxp_prov_grupos WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Grupos de  proveedores
	
	
	
	
	
	-- Catalogo de tipos de movimientos  de  Proveedores
        IF app_selected = 31 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        --str_data[6]         descripcion
                        --str_data[7]         moneda_id
                        INSERT INTO cxp_mov_tipos (titulo,moneda_id,descripcion) VALUES (str_data[5],str_data[7]::integer,str_data[6]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_mov_tipos SET titulo=str_data[5],descripcion=str_data[6],moneda_id=str_data[7]::integer
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxp_mov_tipos WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo tipos de  movimientos de proveedores
        
        -- Catalogo de tipos de movimientos  de  clientes
	IF app_selected = 32 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        --str_data[6]         descripcion
                        --str_data[7]         moneda_id
                        INSERT INTO cxc_mov_tipos (titulo,moneda_id,descripcion) VALUES (str_data[5],str_data[7]::integer,str_data[6]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_mov_tipos SET titulo=str_data[5],descripcion=str_data[6],moneda_id=str_data[7]::integer 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxc_mov_tipos WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo tipos de movimientos  de  clientes
	
	
        -- Catalogo de tipos de mensajes  de  clientes
        IF app_selected = 33 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        --str_data[6]         descripcion
                        --str_data[7]         moneda_id
                        INSERT INTO cxc_clie_mensajes (cxc_mov_tipo_id,cxc_clie_id,msg_1) VALUES (str_data[4]::integer,str_data[5]::integer,str_data[6]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_clie_mensajes SET cxc_mov_tipo_id=str_data[4],cxc_clie_id=str_data[5] ,msg_1=str_data[6] 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxc_mov_tipos WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo tipos de  mensajes de clientes
	
	
	
	
	
	-- Catalogo de Catalogo de tipos de movimientos de inventarios
	IF app_selected = 35 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	tipo
			--str_data[6]	descripcion
			--str_data[7]	mov_de_ajuste

			INSERT INTO inv_mov_tipos(titulo, descripcion, ajuste,momento_creacion, borrado_logico, grupo, afecta_compras, 
			afecta_ventas, considera_consumo, tipo_costo)
			VALUES(str_data[5],str_data[6],str_data[7]::boolean,now(), false, str_data[8]::smallint,str_data[9]::boolean,
			str_data[10]::boolean,str_data[11]::boolean,str_data[12]::smallint);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE inv_mov_tipos SET titulo=str_data[5],
						descripcion=str_data[6],
						ajuste=str_data[7]::boolean,
						momento_actualizacion=now(), 
						grupo=str_data[8]::smallint, 
						afecta_compras=str_data[9]::boolean, 
						afecta_ventas=str_data[10]::boolean, 
						considera_consumo=str_data[11]::boolean, 
						tipo_costo=str_data[12]::smallint
						
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_mov_tipos SET borrado_logico=true, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de tipos de movimientos de inventarios




	-- Catalogo de Catalogo de invsecciones
	IF app_selected = 37 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	estatus

			INSERT INTO inv_secciones(titulo, descripcion, activa,momento_creacion, borrado_logico,gral_usr_id_creacion,gral_emp_id,gral_suc_id)
			VALUES(str_data[5],str_data[6],str_data[7]::boolean,now(), false, usuario_id, emp_id, suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE inv_secciones SET titulo=str_data[5],
						descripcion=str_data[6],
						activa=str_data[7]::boolean,
						momento_actualizacion=now(),
						gral_usr_id_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_secciones SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja=usuario_id
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de invsecciones


	-- Catalogo de inventario de  Marcas
	IF app_selected = 38 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			--str_data[6]     estatus
			--strd_data[7]    url
			INSERT INTO inv_mar (titulo,borrado_logico,url,momento_creacion,estatus, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
			VALUES (str_data[5],false,str_data[7],now(),str_data[6]::boolean,  usuario_id, emp_id, suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE inv_mar SET titulo=str_data[5],
					    estatus=str_data[6]::boolean,
					    momento_actualizacion=now(),
					    gral_usr_id_actualizacion=usuario_id
			WHERE inv_mar.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_mar SET momento_baja=now(),
					    borrado_logico=true,
					    gral_usr_id_baja=usuario_id
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Marcas

	-- Catalogo de inv_prod_lineas
	IF app_selected = 39 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	seccion
			--str_data[8]	marcas
			
			INSERT INTO inv_prod_lineas(titulo, descripcion, inv_seccion_id,momento_creacion, borrado_logico,gral_usr_id_creacion, gral_emp_id, gral_suc_id)
			VALUES(str_data[5],str_data[6],str_data[7]::integer,now(), false, usuario_id, emp_id, suc_id) 
			RETURNING id INTO ultimo_id;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN
				--RAISE EXCEPTION '%' ,extra_data[cont_fila]::integer;
				FOR cont_fila IN 1 .. total_filas LOOP
					insert into inv_lm(inv_prod_linea_id,inv_mar_id) 
					values(ultimo_id, extra_data[cont_fila]::integer);
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_prod_lineas SET titulo=str_data[5],
						descripcion=str_data[6],
						inv_seccion_id=str_data[7]::integer,
						momento_actualizacion=now(),
						gral_usr_id_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;

			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			IF extra_data[1] != 'sin datos' THEN
				delete from inv_lm where inv_prod_linea_id=str_data[4]::integer;
				FOR cont_fila IN 1 .. total_filas LOOP
					insert into inv_lm(inv_prod_linea_id,inv_mar_id) values(str_data[4]::integer, extra_data[cont_fila]::integer);
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_prod_lineas SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;----termina Catalogo de inv_prod_lineas



	-- Catalogo de  Zonas de invetarios
	IF app_selected = 40 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         descripcion
			--str_data[6]     estatus
			--strd_data[7]    zona
			INSERT INTO inv_zonas (titulo,descripcion,borrado_logico,momento_creacion,estatus) VALUES (str_data[7],str_data[5],false,now(),str_data[6]::boolean);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
		
			UPDATE inv_zonas SET titulo=str_data[7],						
						estatus=str_data[6]::boolean,
						descripcion=str_data[5],
						momento_actualizacion=now()
						WHERE inv_zonas.id = str_data[4]::integer;
						valor_retorno := '1';
		END IF;
			
		IF command_selected = 'delete' THEN
			 UPDATE inv_zonas SET momento_baja=now(),
					    borrado_logico=true
					    WHERE id = str_data[4]::integer;
					    valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Zonas de invetarios
	
	
	
	
	
	-- Catalogo de tes_mov_tipos
	IF app_selected = 41 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	grupo--int
			--str_data[8]	tipo
			--str_data[9]	conconsecutivo
			--str_data[10]	conciliacionautomatica
			
			INSERT INTO tes_mov_tipos(titulo, descripcion, tipo,consecutivo,grupo,conciliacion, borrado_logico, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion) 
			VALUES(str_data[5],str_data[6],str_data[8]::boolean,str_data[9]::boolean, str_data[7]::integer, str_data[10]::boolean, false, now(), emp_id, suc_id, usuario_id ) RETURNING id INTO ultimo_id;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE tes_mov_tipos SET titulo=str_data[5],
						descripcion=str_data[6],
						tipo=str_data[8]::boolean,
						consecutivo=str_data[9]::boolean,
						grupo=str_data[7]::integer,
						conciliacion=str_data[10]::boolean, 
						borrado_logico=false,
						momento_actualizacion=now(),
						gral_usr_id_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE tes_mov_tipos SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de tes_mov_tipos
	
	
	
	
	-- Catalogo de tes_ban
	IF app_selected = 42 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	clave
			
			INSERT INTO tes_ban(titulo, descripcion, borrado_logico, momento_creacion,gral_usr_id_creacion,gral_emp_id, gral_suc_id, clave) 
			VALUES(str_data[5],str_data[6],false, now(), usuario_id, emp_id, suc_id, str_data[7]) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN			
			UPDATE tes_ban SET titulo=str_data[5],descripcion=str_data[6],clave=str_data[7],borrado_logico=false,momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id 
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE tes_ban SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de tes_ban




	
	-- Catalogo de Familias
        IF app_selected = 43 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         familia
                        --str_data[6]         descripcion
                        INSERT INTO inv_prod_familias (titulo,descripcion,momento_creacion, borrado_logico, gral_usr_id_creacion, gral_emp_id, gral_suc_id, inv_prod_tipo_id)
                        VALUES (str_data[5],str_data[6],now(),false,  usuario_id, emp_id, suc_id, str_data[7]::integer)
                        RETURNING id INTO ultimo_id;
                        
                        UPDATE inv_prod_familias SET identificador_familia_padre=ultimo_id WHERE id=ultimo_id;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE inv_prod_familias SET titulo=str_data[5],descripcion=str_data[6],momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_id, inv_prod_tipo_id=str_data[7]::integer 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        UPDATE inv_prod_familias SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina catalogo de Familias

	-- Catalogo de Conceptos Bancarios(tes_con)
	IF app_selected = 44 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			
			INSERT INTO tes_con(titulo, descripcion, tipo, borrado_logico,gral_usr_id_creacion,gral_emp_id,gral_suc_id, momento_creacion) 
			VALUES(str_data[5],str_data[6],str_data[7]::boolean,false,usuario_id, emp_id, suc_id, now()) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE tes_con SET 
				titulo=str_data[5],
				descripcion=str_data[6],
				tipo=str_data[7]::boolean,
				borrado_logico=false,
				gral_usr_id_actualizacion=usuario_id,
				momento_actualizacion=now() 
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE tes_con SET borrado_logico=true,gral_usr_id_baja=usuario_id, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de tes_con
	
	
	
	-- Catalogo de  producto grupos
        IF app_selected = 45 THEN
                IF command_selected = 'new' THEN
                       --id [4]                 id
                        --str_data[5]         grupo
                        --str_data[6]     descripcion
                        
                        INSERT INTO inv_prod_grupos (titulo,descripcion,borrado_logico, gral_usr_id_creacion, gral_emp_id, gral_suc_id, momento_creacion) 
                        VALUES (str_data[5],str_data[6],false, usuario_id, emp_id, suc_id, now());
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
			UPDATE inv_prod_grupos SET 
				titulo=str_data[5],						
				descripcion=str_data[6],
				momento_actualizacion=now(),
				gral_usr_id_actualizacion=usuario_id
			WHERE inv_prod_grupos.id = str_data[4]::integer;
			valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE inv_prod_grupos SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id
                         WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo producto grupos	
	
	
	
	-- Catalogo de  Plazas
        IF app_selected = 46 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         plaza
                        --str_data[6]     nombre
                        --str_data[7]     id_zona
                        INSERT INTO gral_plazas (titulo,descripcion,momento_creacion,borrado_logico,empresa_id,estatus,inv_zonas_id) VALUES (str_data[5],str_data[6],now(),false,emp_id,str_data[8]::boolean,str_data[7]::integer);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE gral_plazas SET titulo=str_data[5], descripcion=str_data[6], inv_zonas_id =str_data[7]::integer, momento_actualizacion=now(), estatus=str_data[8]::boolean 
                        WHERE gral_plazas.id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE gral_plazas SET momento_baja=now(), borrado_logico=true WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Plazas



	-- Catalogo de inv_pre
	IF app_selected = 47 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[76]	select_presentacion
			
			INSERT INTO inv_pre(
				inv_prod_id, 
				precio_1,
				precio_2,
				precio_3,
				precio_4,
				precio_5,
				precio_6,
				precio_7,
				precio_8,
				precio_9,
				precio_10,
				descuento_1,
				descuento_2,
				descuento_3,
				descuento_4,
				descuento_5,
				descuento_6,
				descuento_7,
				descuento_8,
				descuento_9,
				descuento_10, 
				default_precio_1, --str_data[26]::double precision
				default_precio_2, --str_data[27]::double precision
				default_precio_3, --str_data[28]::double precision
				default_precio_4, --str_data[29]::double precision
				default_precio_5, --str_data[30]::double precision
				default_precio_6, --str_data[31]::double precision
				default_precio_7, --str_data[32]::double precision
				default_precio_8, --str_data[33]::double precision
				default_precio_9, --str_data[34]::double precision
				default_precio_10, --str_data[35]::double precision
				base_precio_1, --str_data[36]::integer
				base_precio_2, --str_data[37]::integer
				base_precio_3, --str_data[38]::integer
				base_precio_4, --str_data[39]::integer
				base_precio_5, --str_data[40]::integer
				base_precio_6, --str_data[41]::integer
				base_precio_7, --str_data[42]::integer
				base_precio_8, --str_data[43]::integer
				base_precio_9, --str_data[44]::integer
				base_precio_10, --str_data[45]::integer
				calculo_precio_1, --str_data[46]::integer
				calculo_precio_2, --str_data[47]::integer
				calculo_precio_3, --str_data[48]::integer
				calculo_precio_4, --str_data[49]::integer
				calculo_precio_5, --str_data[50]::integer
				calculo_precio_6, --str_data[51]::integer
				calculo_precio_7, --str_data[52]::integer
				calculo_precio_8, --str_data[53]::integer
				calculo_precio_9, --str_data[54]::integer
				calculo_precio_10, --str_data[55]::integer
				operacion_precio_1, --str_data[56]::integer
				operacion_precio_2, --str_data[57]::integer
				operacion_precio_3, --str_data[58]::integer
				operacion_precio_4, --str_data[59]::integer
				operacion_precio_5, --str_data[60]::integer
				operacion_precio_6, --str_data[61]::integer
				operacion_precio_7, --str_data[62]::integer
				operacion_precio_8, --str_data[63]::integer
				operacion_precio_9, --str_data[64]::integer
				operacion_precio_10, --str_data[65]::integer
				redondeo_precio_1, --str_data[66]::integer
				redondeo_precio_2, --str_data[67]::integer
				redondeo_precio_3, --str_data[68]::integer
				redondeo_precio_4, --str_data[69]::integer
				redondeo_precio_5, --str_data[70]::integer
				redondeo_precio_6, --str_data[71]::integer
				redondeo_precio_7, --str_data[72]::integer
				redondeo_precio_8, --str_data[73]::integer
				redondeo_precio_9, --str_data[74]::integer
				redondeo_precio_10, --str_data[75]::integer
				inv_prod_presentacion_id, --str_data[76]::integer
				gral_mon_id_pre1, --str_data[77]::integer
				gral_mon_id_pre2, --str_data[78]::integer
				gral_mon_id_pre3, --str_data[79]::integer
				gral_mon_id_pre4, --str_data[80]::integer
				gral_mon_id_pre5, --str_data[81]::integer
				gral_mon_id_pre6, --str_data[82]::integer
				gral_mon_id_pre7, --str_data[83]::integer
				gral_mon_id_pre8, --str_data[84]::integer
				gral_mon_id_pre9, --str_data[85]::integer
				gral_mon_id_pre10, --str_data[86]::integer
				gral_emp_id, --emp_id
				gral_usr_id_creacion, --usuario_id, 
				borrado_logico,--FALSE
				momento_creacion --now()
			) 
			VALUES(str_data[5]::integer,
				str_data[6]::double precision,str_data[7]::double precision,str_data[8]::double precision,str_data[9]::double precision,str_data[10]::double precision,str_data[11]::double precision,str_data[12]::double precision,str_data[13]::double precision,str_data[14]::double precision,str_data[15]::double precision,
				str_data[16]::double precision,str_data[17]::double precision,str_data[18]::double precision,str_data[19]::double precision,str_data[20]::double precision,str_data[21]::double precision,str_data[22]::double precision,str_data[23]::double precision,str_data[24]::double precision,str_data[25]::double precision,
				str_data[26]::double precision,str_data[27]::double precision,str_data[28]::double precision,str_data[29]::double precision,str_data[30]::double precision,str_data[31]::double precision,str_data[32]::double precision,str_data[33]::double precision,str_data[34]::double precision,str_data[35]::double precision,
				str_data[36]::integer,str_data[37]::integer,str_data[38]::integer,str_data[39]::integer,str_data[40]::integer,str_data[41]::integer,str_data[42]::integer,str_data[43]::integer,str_data[44]::integer,str_data[45]::integer,
				str_data[46]::integer,str_data[47]::integer,str_data[48]::integer,str_data[49]::integer,str_data[50]::integer,str_data[51]::integer,str_data[52]::integer,str_data[53]::integer,str_data[54]::integer,str_data[55]::integer,
				str_data[56]::integer,str_data[57]::integer,str_data[58]::integer,str_data[59]::integer,str_data[60]::integer,str_data[61]::integer,str_data[62]::integer,str_data[63]::integer,str_data[64]::integer,str_data[65]::integer,
				str_data[66]::integer,str_data[67]::integer,str_data[68]::integer,str_data[69]::integer,str_data[70]::integer,str_data[71]::integer,str_data[72]::integer,str_data[73]::integer,str_data[74]::integer,str_data[75]::integer,
				str_data[76]::integer, str_data[77]::integer, str_data[78]::integer, str_data[79]::integer, str_data[80]::integer, str_data[81]::integer, str_data[82]::integer, str_data[83]::integer, str_data[84]::integer, str_data[85]::integer, str_data[86]::integer,
				emp_id,usuario_id,false,now()
			) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_pre SET precio_1=str_data[6]::double precision,
				precio_2=str_data[7]::double precision,
				precio_3=str_data[8]::double precision,
				precio_4=str_data[9]::double precision,
				precio_5=str_data[10]::double precision,
				precio_6=str_data[11]::double precision,
				precio_7=str_data[12]::double precision,
				precio_8=str_data[13]::double precision,
				precio_9=str_data[14]::double precision,
				precio_10=str_data[15]::double precision,
				descuento_1=str_data[16]::double precision,
				descuento_2=str_data[17]::double precision,
				descuento_3=str_data[18]::double precision,
				descuento_4=str_data[19]::double precision,
				descuento_5=str_data[20]::double precision,
				descuento_6=str_data[21]::double precision,
				descuento_7=str_data[22]::double precision,
				descuento_8=str_data[23]::double precision,
				descuento_9=str_data[24]::double precision,
				descuento_10=str_data[25]::double precision,
				default_precio_1 = str_data[26]::double precision,
				default_precio_2 = str_data[27]::double precision,
				default_precio_3 = str_data[28]::double precision,
				default_precio_4 = str_data[29]::double precision,
				default_precio_5 = str_data[30]::double precision,
				default_precio_6 = str_data[31]::double precision,
				default_precio_7 = str_data[32]::double precision,
				default_precio_8 = str_data[33]::double precision,
				default_precio_9 = str_data[34]::double precision,
				default_precio_10 = str_data[35]::double precision,
				base_precio_1 = str_data[36]::integer,
				base_precio_2 = str_data[37]::integer,
				base_precio_3 = str_data[38]::integer,
				base_precio_4 = str_data[39]::integer,
				base_precio_5 = str_data[40]::integer,
				base_precio_6 = str_data[41]::integer,
				base_precio_7 = str_data[42]::integer,
				base_precio_8 = str_data[43]::integer,
				base_precio_9 = str_data[44]::integer,
				base_precio_10 = str_data[45]::integer,
				calculo_precio_1 = str_data[46]::integer,
				calculo_precio_2 = str_data[47]::integer,
				calculo_precio_3 = str_data[48]::integer,
				calculo_precio_4 = str_data[49]::integer,
				calculo_precio_5 = str_data[50]::integer,
				calculo_precio_6 = str_data[51]::integer,
				calculo_precio_7 = str_data[52]::integer,
				calculo_precio_8 = str_data[53]::integer,
				calculo_precio_9 = str_data[54]::integer,
				calculo_precio_10 = str_data[55]::integer,
				operacion_precio_1 = str_data[56]::integer,
				operacion_precio_2 = str_data[57]::integer,
				operacion_precio_3 = str_data[58]::integer,
				operacion_precio_4 = str_data[59]::integer,
				operacion_precio_5 = str_data[60]::integer,
				operacion_precio_6 = str_data[61]::integer,
				operacion_precio_7 = str_data[62]::integer,
				operacion_precio_8 = str_data[63]::integer,
				operacion_precio_9 = str_data[64]::integer,
				operacion_precio_10 = str_data[65]::integer,
				redondeo_precio_1 = str_data[66]::integer,
				redondeo_precio_2 = str_data[67]::integer,
				redondeo_precio_3 = str_data[68]::integer,
				redondeo_precio_4 = str_data[69]::integer,
				redondeo_precio_5 = str_data[70]::integer,
				redondeo_precio_6 = str_data[71]::integer,
				redondeo_precio_7 = str_data[72]::integer,
				redondeo_precio_8 = str_data[73]::integer,
				redondeo_precio_9 = str_data[74]::integer,
				redondeo_precio_10 = str_data[75]::integer,
				inv_prod_presentacion_id=str_data[76]::integer,
				gral_mon_id_pre1 = str_data[77]::integer,
				gral_mon_id_pre2 = str_data[78]::integer,
				gral_mon_id_pre3 = str_data[79]::integer,
				gral_mon_id_pre4 = str_data[80]::integer,
				gral_mon_id_pre5 = str_data[81]::integer,
				gral_mon_id_pre6 = str_data[82]::integer,
				gral_mon_id_pre7 = str_data[83]::integer,
				gral_mon_id_pre8 = str_data[84]::integer,
				gral_mon_id_pre9 = str_data[85]::integer,
				gral_mon_id_pre10 = str_data[86]::integer,
				gral_usr_id_actualizacion = usuario_id,
				borrado_logico=false,
				momento_actualizacion=now() 
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_pre SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de inv_pre
	



	-- Catalogo de SubFamilias
        IF app_selected = 48 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         familia
                        --str_data[6]         descripcion
                        --str_data[7]         select_familia
                        INSERT INTO inv_prod_familias (titulo,descripcion,identificador_familia_padre,momento_creacion, borrado_logico, gral_usr_id_creacion, gral_emp_id, gral_suc_id,inv_prod_tipo_id)
                        VALUES (str_data[5],str_data[6],str_data[7]::integer,now(),false, usuario_id, emp_id, suc_id, str_data[8]::integer);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE inv_prod_familias SET titulo=str_data[5],descripcion=str_data[6],identificador_familia_padre=str_data[7]::integer,momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_id, inv_prod_tipo_id=str_data[8]::integer 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        UPDATE inv_prod_familias SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina catalogo de SubFamilias

        	

	-- Catalogo de unidades
	IF app_selected = 49 THEN
		IF command_selected = 'new' THEN
			INSERT INTO inv_prod_unidades (titulo,borrado_logico,titulo_abr,decimales)
				VALUES (str_data[6],false, str_data[5],str_data[7]::integer);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE inv_prod_unidades SET titulo=str_data[6],
						     titulo_abr=str_data[5],
						     decimales=str_data[7]::integer
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			eliminar_registro=true;


			IF eliminar_registro=TRUE THEN
				exis:=0;
				SELECT count(id) FROM inv_prod WHERE empresa_id=emp_id AND borrado_logico=false AND unidad_id=str_data[4]::integer 
				INTO exis;
				IF exis>0 THEN 
					valor_retorno := 'La Unidad de Medida no pudo ser eliminada porque est&aacute; asignado uno o m&aacute;s productos.';
					eliminar_registro=FALSE;
				END IF;
			END IF;

			IF eliminar_registro=TRUE THEN
				UPDATE inv_prod_unidades SET borrado_logico=true  WHERE inv_prod_unidades.id=str_data[4]::integer;
				valor_retorno := 'La Unidadde Medida fue eliminada con exito.';
			END IF;
		END IF;
	END IF;--termina catalogo de unidades
	
	
	
	-- Catalogo de  inventario de Clasicacion de   stock
        IF app_selected = 50 THEN
                IF command_selected = 'new' THEN
			--str_data[4]         id
                        --str_data[5]        titulo
                        --str_data[6]     descripcion
                        INSERT INTO inv_stock_clasificaciones (titulo,descripcion,borrado_logico,momento_creacion,gral_emp_id,gral_suc_id,gral_usr_id_creacion) 
                        VALUES (str_data[5],str_data[6],false,now(),emp_id,suc_id,usuario_id);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE inv_stock_clasificaciones SET  
				titulo=str_data[5],   						
				      descripcion=str_data[6],
				      momento_actualizacion= now(),
				      gral_usr_id_actualizacion=usuario_id
				WHERE inv_stock_clasificaciones.id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE inv_stock_clasificaciones SET borrado_logico=true,
                                                 gral_usr_id_baja= usuario_id
			 WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo inventario Clasificacion stock
	
	


	-- Catalogo de Comisiones
	IF app_selected = 51 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			
			INSERT INTO inv_com(  inv_prod_id,
			  limite_inferior,--smallint
			  limite_superior,
			  comision,
			  comision_valor,
			  nivel,
			  escala ,
			 borrado_logico, momento_creacion ) 
			VALUES(str_data[5]::integer,
			str_data[8]::double precision,
			str_data[9]::double precision,
			str_data[10]::double precision,
			str_data[11]::double precision,
			str_data[7]::smallint,
			str_data[6]::smallint,
			false, now()) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_com SET 
			  limite_inferior=str_data[8]::double precision,
			  limite_superior=str_data[9]::double precision,
			  comision=str_data[10]::double precision,
			  comision_valor=str_data[11]::double precision,
			  nivel=str_data[7]::smallint,
			  escala=str_data[6]::smallint ,
			borrado_logico=false,
			momento_actualizacion=now() 
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_com SET borrado_logico=true, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de Comisiones


	
	
	
	-- Catalogo de  inventario de Clasicaciones
        IF app_selected = 52 THEN
                IF command_selected = 'new' THEN
			--str_data[4]         id
                        --str_data[5]         titulo
                        --str_data[6]         descripcion
                        --str_data[7]         factorseguridad
                        --str_data[8]         stockseguridad
                        INSERT INTO inv_clas (titulo,descripcion,borrado_logico,stock_seguridad,factor_maximo,momento_creacion,gral_emp_id,gral_suc_id,gral_usr_id_creacion) 
                        VALUES (str_data[5],str_data[6],false,str_data[7]::double precision,str_data[8]::double precision,now(),emp_id,suc_id,usuario_id);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                
                        UPDATE inv_clas SET  titulo=str_data[5],   						
					      descripcion=str_data[6],
					      momento_actualizacion= now(),
					      stock_seguridad=str_data[7]::double precision,
					      factor_maximo=str_data[8]::double precision,
					      gral_usr_id_actualizacion=usuario_id
			WHERE inv_clas.id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE inv_clas SET borrado_logico=true,
				             momento_baja=now(),
                                             gral_usr_id_baja= usuario_id
			 WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo inventario Clasificaciones



	-- Catalogo de inv_pre_ofe
	IF app_selected = 53 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			
			INSERT INTO inv_pre_ofe(  inv_prod_id,
			  precio_oferta,
			  descto_max,
			  criterio_oferta,
			  precio_lista_1,precio_lista_2,
			  precio_lista_3,precio_lista_4,
			  precio_lista_5,precio_lista_6,
			  precio_lista_7,precio_lista_8,
			  precio_lista_9,precio_lista_10,
			  fecha_inicial,fecha_final,
			  tipo_descto_precio,
			 borrado_logico, momento_creacion ) 
			VALUES(str_data[5]::integer,
			str_data[8]::double precision,
			0,
			str_data[10]::boolean,
			str_data[11]::boolean,
			str_data[12]::boolean,
			str_data[13]::boolean,
			str_data[14]::boolean,
			str_data[15]::boolean,
			str_data[16]::boolean,
			str_data[17]::boolean,
			str_data[18]::boolean,
			str_data[19]::boolean,
			str_data[20]::boolean,
			str_data[6]::date,
			str_data[7]::date,
			str_data[21]::boolean,
			false, now()) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_pre_ofe SET 
			  precio_oferta=str_data[8]::double precision,
			  descto_max=0,
			  criterio_oferta=str_data[10]::boolean,
			  precio_lista_1=str_data[11]::boolean,precio_lista_2=str_data[12]::boolean,
			  precio_lista_3=str_data[13]::boolean,precio_lista_4=str_data[14]::boolean,
			  precio_lista_5=str_data[15]::boolean,precio_lista_6=str_data[16]::boolean,
			  precio_lista_7=str_data[17]::boolean,precio_lista_8=str_data[18]::boolean,
			  precio_lista_9=str_data[19]::boolean,precio_lista_10=str_data[20]::boolean,
			  fecha_inicial=str_data[6]::date,fecha_final=str_data[7]::date,
			  tipo_descto_precio=str_data[21]::boolean,
			borrado_logico=false,
			momento_actualizacion=now() 
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_pre_ofe SET borrado_logico=true, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de inv_pre_ofe




	-- Catalogo de  inventario plazas-sucursales
	IF app_selected = 54 THEN
		--str_data[1]         app_selected
		--str_data[2]         command_selected
		--str_data[3]         id_sucursal
		--str_data[4]         plazasAgregadas
			
		IF str_data[4] = '' THEN
			 DELETE FROM gral_suc_pza WHERE sucursal_id=str_data[3]::integer; 
			valor_retorno := '1';
		END IF;
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		
		IF str_data[4] != '' THEN
			DELETE FROM gral_suc_pza WHERE sucursal_id=str_data[3]::integer;  
			
			--convertir en arreglo las plazasAgregadas
			SELECT INTO str_filas string_to_array(str_data[4],',');
			
			--obtiene numero de elementos del arreglo str_fila
			tot_filas:= array_length(str_fila,1);
			
			--crea registros gral_suc_pza
			FOR cont_fila_pres IN 1 .. tot_filas LOOP
				INSERT INTO gral_suc_pza(plaza_id,sucursal_id) VALUES (str_fila[cont_fila_pres]::integer,str_data[3]::integer);
			END LOOP;
			
			valor_retorno := '1';
		END IF;
                
        END IF;--termina Catalogo inventario plazas-sucursales
	
	
	
	-- Catalogo Direcciones de proveedores
       IF app_selected = 56 THEN
             IF command_selected = 'new' THEN
		--str_data[4]        id                --str_data[5]        calle
                --str_data[6]	     codigoPostal      --str_data[7]        colonia
                --str_data[8]        entreCalles       --str_data[9]	     extDos
                --str_data[10]       extUno            --str_data[11]       numExterior
                --str_data[12]	     numInterior       --str_data[13]       proveedor
                --str_data[14]       id_estado         --str_data[15]	     id_municipio
                --str_data[16]       id_pais           --str_data[17]       telDos
                --str_data[18]	     telUno
                
		INSERT INTO cxp_prov_dir(proveedor_id,calle,entre_calles,numero_interior,numero_exterior,colonia,cp,pais_id,estado_id,municipio_id,telefono1,extension1,telefono2,borrado_logico,momento_creacion,id_usuario_creacion,gral_emp_id,gral_suc_id ) 
		VALUES (str_data[13]::integer,str_data[5],str_data[8],str_data[12],str_data[11],str_data[7]::character varying,str_data[6]::integer,str_data[16]::integer,str_data[14]::integer,str_data[15]::integer,str_data[18],str_data[10],str_data[17],false,now(),usuario_id,emp_id,suc_id );
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_dir SET 
				proveedor_id=str_data[13]::INTEGER,
				calle        	=str_data[5],  --calle
				entre_calles 	=str_data[8], --entre calles
				numero_interior =str_data[12], --numero interior
				numero_exterior =str_data[11], --numeroexterior
				colonia 	=str_data[7], --colonia
				cp 		=str_data[6], --cp
				pais_id 	=str_data[16]::INTEGER,--pais
				estado_id 	=str_data[14]::INTEGER, --edo
				municipio_id 	=str_data[15]::INTEGER, --mpio
				telefono1 	=str_data[18],--567
				extension1 	=str_data[10],--5678
				telefono2 	=str_data[17],--56789	
				extension2 	=str_data[9],--567890				
				momento_actualizacion =now(),
				id_usuario_actualizacion= usuario_id						
                        WHERE cxp_prov_dir.id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE cxp_prov_dir SET momento_baja=now(),
                                            borrado_logico=true,
                                            id_usuario_baja=usuario_id
                         WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Direcciones de proveedores
	
	
	

	--Catalogo de Chequera
	IF app_selected = 59 THEN
		--str_data[1]  app_selected                     str_data[11]  id_estado                         
		--str_data[2]  command_selected			str_data[12]  id_moneda				str_data[21]  telefono1
		--str_data[3]  id_usuario			str_data[13]  id_banco			        str_data[22]  extencion1
		--str_data[4]  id				str_data[14]  chk_imprimir_chequeningles	str_data[23]  telefono2	
		--str_data[5]  chequera				str_data[15]  calle				str_data[24]  extencion2		
		--str_data[6]  chk_modificar_consecutivo 	str_data[16]  numero				str_data[25]  fax
		--str_data[7]  chk_modificar_fecha		str_data[17]  colonia				str_data[26]  gerente
		--str_data[8]  chk_modificar_cheque		str_data[18]  cp				str_data[27]  ejecutivo
		--str_data[9]  id_pais				str_data[19]  numero_sucursal		        str_data[28]  email;
		--str_data[10]  id_municipio			str_data[20]  nombre_sucursal        		str_data[29]  id_cta_activo
		
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  inventario de Clasicaciones
                IF command_selected = 'new' THEN
			INSERT INTO tes_che (titulo ,aut_modif_consecutivo,   aut_modif_fecha ,    aut_modif_cheque ,       gral_pais_id ,  gral_mun_id ,                gral_edo_id ,            moneda_id ,          tes_ban_id ,  imp_cheque_ingles,  calle  ,  numero  ,  colonia ,  codigo_postal ,num_sucursal ,  nombre_sucursal  ,  telefono1  ,  extencion1  ,  telefono2  ,  extencion2  ,  fax  ,  gerente  ,  ejecutivo  ,  email  ,  momento_creacion , borrado_logico ,  gral_usr_id_creacion ,    gral_emp_id ,  gral_suc_id, ctb_cta_id_activo) 
			VALUES (str_data[5],str_data[6]::boolean, str_data[7]::boolean,str_data[8]::boolean,str_data[9]::integer,str_data[10]::integer, str_data[11]::integer, str_data[12]::integer,str_data[13]::integer,str_data[14]::boolean, str_data[15], str_data[16], str_data[17], str_data[18]::integer, str_data[19]::integer,str_data[20],str_data[21],str_data[22],str_data[23],str_data[24],str_data[25],str_data[26],str_data[27], str_data[28], now(), false,usuario_id, emp_id, suc_id, str_data[29]::integer);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE tes_che SET  titulo=str_data[5],
                        aut_modif_consecutivo =  str_data[6]::boolean,
                        aut_modif_fecha =str_data[7]::boolean,
                        aut_modif_cheque=str_data[8]::boolean,
                        gral_pais_id=str_data[9]::integer,
                        gral_mun_id =str_data[10]::integer, 
                        gral_edo_id = str_data[11]::integer,
                        moneda_id= str_data[12]::integer,
                        tes_ban_id =str_data[13]::integer,
                        imp_cheque_ingles=str_data[14]::boolean  ,
                        calle   =str_data[15],
                        numero = str_data[16] ,
                        colonia= str_data[17],
                        codigo_postal =str_data[18]::integer,
                        num_sucursal =str_data[19]::integer , 
                        nombre_sucursal =str_data[20],
                        telefono1 =str_data[21],
                        extencion1  =str_data[22],
                        telefono2 =str_data[23],
                        extencion2  =str_data[24],
                        fax  =str_data[25],
                        gerente =str_data[26] ,
                        ejecutivo =str_data[27],
                        email =str_data[28],
                        ctb_cta_id_activo=str_data[29]::integer,
			momento_actualizacion=now(),
			gral_usr_id_actualizacion=usuario_id
			WHERE tes_che.id = str_data[4]::integer;
			
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE tes_che SET borrado_logico=true,momento_baja=now(),gral_usr_id_baja= usuario_id
			 WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
	END IF;--termina Catalogo Chequeras


	




	-- Catalogo de inventario de  Presentaciones
	IF app_selected = 68 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			--str_data[6]         cantidad-equivalencia
			INSERT INTO inv_prod_presentaciones (titulo,borrado_logico,momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id, cantidad) 
			VALUES (str_data[5],false,now(), usuario_id, emp_id, suc_id,str_data[6]::double precision );
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE inv_prod_presentaciones SET titulo=str_data[5], cantidad = str_data[6]::double precision, momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_id
			WHERE inv_prod_presentaciones.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			eliminar_registro=true;
			
			IF eliminar_registro=TRUE THEN 
				exis:=0;
				SELECT count(id) FROM inv_prod_pres_x_prod WHERE presentacion_id=str_data[4]::integer
				INTO exis;
				IF exis>0 THEN 
					valor_retorno := 'La presentaci&oacute;n no pudo ser eliminada porque est&aacute; asignado como presentaci&oacute;n de uno o m&aacute;s productos.';
					eliminar_registro=FALSE;
				END IF;
			END IF;
			
			IF eliminar_registro=TRUE THEN
				exis:=0;
				SELECT count(id) FROM inv_prod WHERE empresa_id=emp_id AND borrado_logico=FALSE AND inv_prod_presentacion_id=str_data[4]::integer 
				INTO exis;
				IF exis>0 THEN 
					valor_retorno := 'La presentaci&oacute;n no pudo ser eliminada porque est&aacute; asignado como presentaci&oacute;n default de uno o m&aacute;s productos.';
					eliminar_registro=FALSE;
				END IF;
			END IF;
			
			--Verificar si hay que validar existencias de Presentaciones
			IF controlExisPres=true THEN 
				IF eliminar_registro=TRUE THEN
					exis:=0;
					SELECT count(id) FROM env_conf WHERE gral_emp_id=emp_id AND borrado_logico=FALSE AND inv_prod_presentacion_id=str_data[4]::integer 
					INTO exis;
					IF exis > 0 THEN 
						valor_retorno := 'La presentaci&oacute;n no pudo ser eliminada porque est&aacute; asociado a un registro en el cat&aacute;logo de configuraci&oacute;n de envases.';
						eliminar_registro=FALSE;
					ELSE
						--Eliminar registro de existencias por presentaciones si es que existe
						DELETE FROM inv_exi_pres WHERE inv_prod_presentacion_id=str_data[4]::integer;
					END IF;
				END IF;
			END IF;
			
			
			IF eliminar_registro=TRUE THEN
				UPDATE inv_prod_presentaciones SET momento_baja=now(), borrado_logico=true, gral_usr_id_baja=usuario_id WHERE id = str_data[4]::integer;
				
				--Eliminar de la tabla de costos
				DELETE FROM inv_prod_costos WHERE ano=EXTRACT(YEAR  FROM now()) AND inv_prod_presentacion_id=str_data[4]::integer;
				
				--Eliminar de la Lista de Precios
				DELETE FROM inv_pre WHERE gral_emp_id=emp_id AND inv_prod_presentacion_id=str_data[4]::integer;
				
				valor_retorno := 'La presentacion fue eliminada.';
			END IF;
			
		END IF;
	END IF;--termina Catalogo Presentaciones




	--Catalogo de formulas
	IF app_selected = 69 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  id_prod_master
		--str_data[6]  inv_prod_id
		--str_data[7]  nivel
		--str_data[8]  producto_elemento_id
		--str_data[9]  cantidad
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas


                IF command_selected = 'new' THEN
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
		
			IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
				
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--aqui se vuelven a crear los registros
					INSERT INTO inv_formulas ( inv_prod_id_master ,  inv_prod_id ,          producto_elemento_id ,     cantidad ,                         nivel ) 
					VALUES (                  str_data[5]::integer,  str_data[6]::integer,  str_filas[1]::integer,      str_filas[2]::Double precision,   str_data[7]::integer);
					valor_retorno := '1';
					
				END LOOP;
			END IF;
		END IF;
                
                IF command_selected = 'edit' THEN
                        total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;

			DELETE FROM  inv_formulas WHERE inv_formulas.inv_prod_id_master = str_data[5]::integer AND inv_formulas.inv_prod_id=str_data[6]::integer AND inv_formulas.nivel=str_data[7]::integer;
			--RAISE EXCEPTION '%','update:'||'DELETE FROM  inv_formulas WHERE inv_formulas.inv_prod_id_master = '||str_data[5]::integer||' AND inv_formulas.inv_prod_id='||str_data[6]::integer||' AND inv_formulas.nivel='||str_data[7]::integer||' ';
			--IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					INSERT INTO inv_formulas ( inv_prod_id_master ,  inv_prod_id ,          producto_elemento_id ,     cantidad ,                         nivel ) 
					VALUES (                  str_data[5]::integer,  str_data[6]::integer,  str_filas[1]::integer,      str_filas[2]::Double precision,   str_data[7]::integer);
				END LOOP;
			--END IF;
			valor_retorno := '1';
                END IF;

                IF command_selected = 'delete' THEN
                         DELETE  FROM inv_formulas 
			 WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
	END IF;--termina Catalogo de formulas
	
	
	
	
	-- Catalogo de inventario de  Vehiculos
	IF app_selected = 73 THEN
		IF command_selected = 'new' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id
			--str_data[5]	select_tipo_unidad
			--str_data[6]	select_clase
			--str_data[7]	select_marca
			--str_data[8]	select_anio
			--str_data[9]	color
			--str_data[10]	no_economico
			--str_data[11]	select_tipo_placa
			--str_data[12]	placas
			--str_data[13]	no_serie
			--str_data[14]	select_tipo_rodada
			--str_data[15]	select_tipo_caja
			--str_data[16]	cap_volumen
			--str_data[17]	cap_peso
			--str_data[18]	select_clasif2
			--str_data[19]	id_prov
			--str_data[20]	id_operador
			--str_data[21]	comentarios
			

			--Folio Catalogo de Unidades(LOG)
			id_tipo_consecutivo:=53;
			
			--Aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

			
			INSERT INTO log_vehiculos (
				folio, --nuevo_folio,
				log_vehiculo_tipo_id, --str_data[5]::integer,
				log_vehiculo_clase_id, --str_data[6]::integer,
				log_vehiculo_marca_id, --str_data[7]::integer,
				anio, --str_data[8]::integer,
				color, --str_data[9],
				numero_economico, --str_data[10],
				log_vehiculo_tipo_placa_id, --str_data[11]::integer,
				placa, --str_data[12],
				numero_serie, --str_data[13],
				log_vehiculo_tipo_rodada_id, --str_data[14]::integer,
				log_vehiculo_tipo_caja_id, --str_data[15]::integer,
				cap_volumen, --str_data[16]::double precision,
				cap_peso, --str_data[17]::double precision,
				clasificacion2, --str_data[18]::integer,
				cxp_prov_id, --str_data[19]::integer,
				log_chofer_id, --str_data[20]::integer,
				comentarios, --str_data[21],
				gral_emp_id, --emp_id,
				gral_suc_id, --suc_id,
				borrado_logico, --false,
				momento_crea, --espacio_tiempo_ejecucion,
				gral_usr_id_crea --usuario_id
			) 
			VALUES (nuevo_folio, str_data[5]::integer, str_data[6]::integer, str_data[7]::integer, str_data[8]::integer, str_data[9], str_data[10], str_data[11]::integer, str_data[12], str_data[13], str_data[14]::integer, str_data[15]::integer, str_data[16]::double precision, str_data[17]::double precision, str_data[18]::integer, str_data[19]::integer, str_data[20]::integer, str_data[21], emp_id, suc_id, false, espacio_tiempo_ejecucion, usuario_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE log_vehiculos SET log_vehiculo_tipo_id=str_data[5]::integer, log_vehiculo_clase_id=str_data[6]::integer, log_vehiculo_marca_id=str_data[7]::integer, anio=str_data[8]::integer, color=str_data[9], numero_economico=str_data[10], log_vehiculo_tipo_placa_id=str_data[11]::integer, placa=str_data[12], numero_serie=str_data[13], log_vehiculo_tipo_rodada_id=str_data[14]::integer, log_vehiculo_tipo_caja_id=str_data[15]::integer, cap_volumen=str_data[16]::double precision, cap_peso=str_data[17]::double precision, clasificacion2=str_data[18]::integer, cxp_prov_id=str_data[19]::integer, log_chofer_id=str_data[20]::integer, comentarios=str_data[21], momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
			WHERE log_vehiculos.id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE log_vehiculos SET momento_baja=espacio_tiempo_ejecucion, gral_usr_id_baja=usuario_id, borrado_logico=true 
			WHERE log_vehiculos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Vehiculo
	
	
	
	
	-- Catalogo de inventario de  Puestos
	IF app_selected = 75 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			INSERT INTO gral_puestos (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE gral_puestos SET titulo=str_data[5],
					    momento_actualizacion=now(),
					    gral_usr_id_actualizacion=usuario_id
			WHERE gral_puestos.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_puestos SET momento_baja=now(),borrado_logico=true 
			WHERE gral_puestos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Puestos
	
	
	-- Catalogo de inventario de  escolaridades
	IF app_selected = 77 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO gral_escolaridads (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_escolaridads SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id
			WHERE gral_escolaridads.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			UPDATE gral_escolaridads SET momento_baja=now(),borrado_logico=true 
			WHERE gral_escolaridads.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Escolaridades



	-- Catalogo de inventario de  Religiones
	IF app_selected = 78 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO gral_religions (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE gral_religions SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id
			WHERE gral_religions.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			UPDATE gral_religions SET momento_baja=now(),borrado_logico=true 
			WHERE gral_religions.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Religiones
	
	
	
	-- Catalogo de inventario de  tipos de sangre
	IF app_selected = 79 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO gral_sangretipos (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_sangretipos SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id
			WHERE gral_sangretipos.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			UPDATE gral_sangretipos SET momento_baja=now(),borrado_logico=true 
			WHERE gral_sangretipos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Tipo de sangre




	
	-- Catalogo de inventario de  departamentos
	IF app_selected = 82 THEN
		IF command_selected = 'new' THEN
		--RAISE EXCEPTION '%','titulo'||str_data[5];
			--str_data[4]         id select * from gral_deptos
			--str_data[5]         titulo
			INSERT INTO gral_deptos (titulo,costo_prorrateo,vigente, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id,    gral_suc_id) 
			VALUES (str_data[5], str_data[6]::double precision, true,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
			
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_deptos SET titulo=str_data[5],
					      costo_prorrateo=str_data[6]::double precision,
					      momento_actualizacion=now(),
					      gral_usr_id_actualizacion=usuario_id
		        WHERE gral_deptos.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update gral_deptos SET momento_baja=now(),
					      borrado_logico=true 
			WHERE gral_deptos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  departamentos
	
	
	-- Catalogo de inventario de  tipo de equipos
	IF app_selected = 83 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO pro_tipo_equipo (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE pro_tipo_equipo SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id
		        WHERE pro_tipo_equipo.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update pro_tipo_equipo SET momento_baja=now(),borrado_logico=true 
			WHERE pro_tipo_equipo.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  tipo de equipos




	-- Catalogo de inventario de  dias no laborables
	IF app_selected = 84 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        fecha_no_laborable
			--str_data[6]        descripcion
			INSERT INTO gral_dias_no_laborables (fecha_no_laborable, descripcion, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
			VALUES (str_data[5]::date,str_data[6],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN		
			UPDATE gral_dias_no_laborables SET fecha_no_laborable=str_data[5]::date,
					      descripcion = str_data[6],
					      momento_actualizacion=now(),
					      gral_usr_id_actualizacion=usuario_id
		        WHERE gral_dias_no_laborables.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update gral_dias_no_laborables SET momento_baja=now(),
					      borrado_logico=true 
			WHERE gral_dias_no_laborables.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  dias no laborables




	-- Catalogo de inventario de  categorias
	IF app_selected = 85 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        titulo(categ)
			--str_data[6]        sueldo_por_hora 	
			--str_data[7]        sueldo_por_horas_ext 
			--str_data[8]        gral_puesto_id (puesto)select * from gral_categ
			INSERT INTO gral_categ (titulo,      sueldo_por_hora,               sueldo_por_horas_ext,          gral_puesto_id,          borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
			VALUES (                str_data[5], str_data[6]::double precision, str_data[7]::double precision, str_data[8]::integer,    false,          now(),            usuario_id,           emp_id,      suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_categ SET titulo=str_data[5],
			                      sueldo_por_hora=str_data[6]::double precision,
			                      sueldo_por_horas_ext=str_data[7]::double precision,
			                      gral_puesto_id=str_data[8]::integer,
					      momento_actualizacion=now(),
					      gral_usr_id_actualizacion=usuario_id
		        WHERE gral_categ.id = str_data[4]::integer;
			valor_retorno := '0';


		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update gral_categ SET momento_baja=now(),
					      borrado_logico=true 
			WHERE gral_categ.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  tipo de categorias



	
	-- Catalogo de inventario de  turnos
	IF app_selected = 92 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        turno
			--str_data[6]        hora_ini 	
			--str_data[7]        hora_fin 
			--str_data[8]        gral_deptos_id (depto) select * from gral_deptos_turnos
			INSERT INTO gral_deptos_turnos (turno,       hora_ini,                         hora_fin,                         gral_deptos_id,          borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
			VALUES (                        str_data[5]::integer, str_data[6]::time with time zone, str_data[7]::time with time zone, str_data[8]::integer,    false,          now(),            usuario_id,           emp_id,      suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_deptos_turnos SET turno=str_data[5]::integer,
			                      hora_ini=str_data[6]::time with time zone,
			                      hora_fin=str_data[7]::time with time zone,
			                      gral_deptos_id=str_data[8]::integer,
					      momento_actualizacion=now(),
					      gral_usr_id_actualizacion=usuario_id
		        WHERE gral_deptos_turnos.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;

		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update gral_deptos_turnos SET momento_baja=now(),
					      borrado_logico=true 
			WHERE gral_deptos_turnos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  tipo de turnos
	


	--Catalogo de productos equivalentes 
	IF app_selected = 96 THEN 
		--str_data[1]  app_selected 
		--str_data[2]  command_selected     
		--str_data[3]  id_usuario 
		--str_data[4]  id 
		--str_data[5]  inv_prod_id 
		--str_data[6]  inv_prod_id_equiv
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];


		IF command_selected = 'new' THEN 
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo 
			cont_fila:=1; 

			IF extra_data[1] != 'sin datos' THEN 
				FOR cont_fila IN 1 .. total_filas LOOP 
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___'); 
					--aqui se vuelven a crear los registros 
					INSERT INTO inv_prod_equiv ( inv_prod_id ,          inv_prod_id_equiv ,    observaciones )  
					VALUES (                     str_data[5]::integer,  str_filas[2]::integer,  str_filas[3]); 
					valor_retorno := '1'; 
				END LOOP; 
			END IF; 
		END IF; 

		IF command_selected = 'edit' THEN 
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo 
			cont_fila:=1; 
			--DELETE FROM  inv_prod_equiv WHERE inv_prod_equiv.id = '||str_data[4]::integer||' AND inv_formulas.inv_prod_id='||str_data[6]::integer||' AND inv_formulas.nivel='||str_data[7]::integer||' ';
			DELETE  FROM inv_prod_equiv WHERE inv_prod_id = str_data[5]::integer;
			--IF extra_data[1] = 'sin datos' THEN 
				FOR cont_fila IN 1 .. total_filas LOOP 
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___'); 
					--aqui se vuelven a crear los registros 
					INSERT INTO inv_prod_equiv ( inv_prod_id ,          inv_prod_id_equiv ,    observaciones )  
					VALUES (                     str_data[5]::integer,  str_filas[2]::integer,  str_filas[3]); 
				END LOOP; 
				valor_retorno := '1';
			--END IF;
		END IF; 

		IF command_selected = 'delete' THEN 
			DELETE  FROM inv_prod_equiv  
			WHERE inv_prod_id = str_data[4]::integer; 
			valor_retorno := '1'; 
		END IF; 

	END IF;--termina Catalogo de productos equivalentes 

	
	
	-- Aplicativo de edicion de codigo ISO
	IF app_selected = 99 THEN
		IF command_selected = 'edit' THEN
			UPDATE gral_docs_conf SET valor=str_data[5] WHERE gral_docs_conf.gral_doc_id = str_data[4]::integer and campo='CODIGO1';
			
			UPDATE gral_docs_conf SET valor=str_data[6] WHERE gral_docs_conf.gral_doc_id = str_data[4]::integer and campo='CODIGO2';

			UPDATE gral_docs SET momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_id
			WHERE gral_docs.id = str_data[4]::integer;
			
			valor_retorno := '0';
		END IF;
	END IF;--termina Catalogo Puestos

	
	
	-- Catalogo de Motivos de Visitas
	IF app_selected = 109 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        descripcion
			
			id_tipo_consecutivo:=33;--Folio de motivo de visita
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO crm_motivos_visita (folio_mv,
						descripcion,
						borrado_logico, 
						momento_creacion, 
						gral_usr_id_creacion, 
						gral_emp_id, 
						gral_suc_id) 
						
					VALUES ( nuevo_folio,
						str_data[5],
						false,          
						now(),            
						usuario_id,           
						emp_id,      
						suc_id);
			valor_retorno := '1';
		END IF;	
		IF command_selected = 'edit' THEN
			UPDATE crm_motivos_visita SET descripcion=str_data[5],
						      momento_actualizacion=now(),
						      gral_usr_id_actualizacion=usuario_id	      
		        WHERE crm_motivos_visita.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_motivos_visita SET momento_baja=now(),borrado_logico=true 
			WHERE crm_motivos_visita.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de Motivos de Visita


	
	-- Catalogo de Formas de Contacto
	IF app_selected = 110 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        descripcion
			
			id_tipo_consecutivo:=34;--Folio de forma de contacto
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO crm_formas_contacto (folio_fc,
						descripcion,
						borrado_logico, 
						momento_creacion, 
						gral_usr_id_creacion, 
						gral_emp_id, 
						gral_suc_id) 
						
					VALUES ( nuevo_folio,
						str_data[5],
						false,          
						now(),            
						usuario_id,           
						emp_id,      
						suc_id);
			valor_retorno := '1';
		END IF;	
		IF command_selected = 'edit' THEN
			UPDATE crm_formas_contacto SET descripcion=str_data[5],
						      momento_actualizacion=now(),
						      gral_usr_id_actualizacion=usuario_id	      
		        WHERE crm_formas_contacto.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_formas_contacto SET momento_baja=now(),borrado_logico=true 
			WHERE crm_formas_contacto.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Formas de Contacto
	
	-- Catalogo de Motivos de Llamada
	IF app_selected = 111 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        descripcion
			
			id_tipo_consecutivo:=35;--Folio de motivo de llamada
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO crm_motivos_llamada (folio_mll,
						descripcion,
						borrado_logico, 
						momento_creacion, 
						gral_usr_id_creacion, 
						gral_emp_id, 
						gral_suc_id) 
						
					VALUES ( nuevo_folio,
						str_data[5],
						false,          
						now(),            
						usuario_id,           
						emp_id,      
						suc_id);
			valor_retorno := '1';
		END IF;	
		IF command_selected = 'edit' THEN
			UPDATE crm_motivos_llamada SET descripcion=str_data[5],
						      momento_actualizacion=now(),
						      gral_usr_id_actualizacion=usuario_id	      
		        WHERE crm_motivos_llamada.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_motivos_llamada SET momento_baja=now(),borrado_logico=true 
			WHERE crm_motivos_llamada.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Motivos de Llamada
	

	--Catalogo de Prospectos(CRM)
	IF app_selected = 113 THEN
		IF command_selected = 'new' THEN
			id_tipo_consecutivo:=38;--Folio Catalogo de Prospectos
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--RAISE EXCEPTION '%','emp_id: '||emp_id;
			--RAISE EXCEPTION '%','nombre_consecutivo: '||nombre_consecutivo;
			--RAISE EXCEPTION '%','cadena_extra: '||cadena_extra;
			--RAISE EXCEPTION '%','numero_control_client: '||numero_control_client;
			
			INSERT INTO crm_prospectos(
					numero_control,--nuevo_folio
					
					estatus ,--str_data[5]
					crm_etapas_prospecto_id ,--str_data[6]
					tipo_prospecto_id,--str_data[7]

					rfc,--str_data[8]
					razon_social,--str_data[9]
					calle,--str_data[10]
					numero,--str_data[11]
					entre_calles,--str_data[12]
					numero_exterior,--str_data[13]
					colonia,--str_data[14]
					cp,--str_data[15]
					pais_id,--str_data[16]::integer
					estado_id,--str_data[17]::integer
					municipio_id,--str_data[18]::integer
					localidad_alternativa,--str_data[19]
					telefono1,--str_data[20]
					extension1,--str_data[21]
					fax,--str_data[22]
					telefono2,--str_data[23]
					extension2,--str_data[24]
					email,--str_data[25]
					contacto,--str_data[26]
					clasificacion_id, --str_data[27] ,
					tipo_industria_id,--str_data[28],
					observaciones,--str_data[29]
					
					momento_creacion,--now()
					gral_usr_id_creacion,--usuario_id
					gral_emp_id,--emp_id
					gral_suc_id--suc_id
				)VALUES (
					nuevo_folio,
					str_data[5]::integer,
					str_data[6]::integer,
					str_data[7]::integer,

					str_data[8],
					str_data[9],
					str_data[10],
					str_data[11],
					str_data[12],
					str_data[13],
					str_data[14],
					str_data[15],
					str_data[16]::integer,
					str_data[17]::integer,
					str_data[18]::integer,
					str_data[19],
					str_data[20],
					str_data[21],
					str_data[22],
					str_data[23],
					str_data[24],
					str_data[25],
					str_data[26],
					str_data[27]::integer,
					str_data[28]::integer,
					str_data[29],
				
					now(),
					usuario_id,
					emp_id,
					suc_id
				)RETURNING id INTO ultimo_id;
			
				
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			--SELECT INTO str_data string_to_array(''||campos_data||'','___');
			--RAISE EXCEPTION '%',str_data[1];
			--RAISE EXCEPTION '%',identificador;
			--RAISE EXCEPTION '%','total  de filas???'||str_data[5]||'___'||str_data[6]||'___'||str_data[7]||'___'||str_data[8]||'___'||str_data[9]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10];
			UPDATE crm_prospectos SET 
					--numero_control,--nuevo_folio
					estatus=str_data[5]::integer,
					crm_etapas_prospecto_id=str_data[6]::integer,
					tipo_prospecto_id=str_data[7]::integer,

					rfc=str_data[8],
					razon_social=str_data[9],
					calle=str_data[10],
					numero=str_data[11],
					entre_calles=str_data[12],
					numero_exterior=str_data[13],
					colonia=str_data[14],
					cp=str_data[15],
					pais_id=str_data[16]::integer,
					estado_id=str_data[17]::integer,
					municipio_id=str_data[18]::integer,
					localidad_alternativa=str_data[19],
					telefono1=str_data[20],
					extension1=str_data[21],
					fax=str_data[22],
					telefono2=str_data[23],
					extension2=str_data[24],
					email=str_data[25],
					contacto=str_data[26],
					clasificacion_id=str_data[27]::integer ,
					tipo_industria_id=str_data[28]::integer,
					observaciones=str_data[29],
					borrado_logico=false,
					momento_creacion=now(),
					gral_usr_id_actualizacion=usuario_id
					--gral_emp_id,--emp_id
					--gral_suc_id--suc_id
			WHERE id=str_data[4]::integer;
			
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE crm_prospectos SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja = str_data[3]::integer WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Prospectos(CRM)

	
	
	-- Catalogo de Direcciones Fiscales de Clientes
	IF app_selected = 118 THEN
		IF command_selected = 'new' THEN
			--str_data[1] app_selected
			--str_data[2] command_selected
			--str_data[3] id_usuario
			--str_data[4] identificador
			--str_data[5] id_cliente
			--str_data[6] calle
			--str_data[7] numero_int
			--str_data[8] numero_ext
			--str_data[9] colonia
			--str_data[10] cp
			--str_data[11] select_pais
			--str_data[12] select_estado
			--str_data[13] select_municipio
			--str_data[14] entrecalles
			--str_data[15] tel1
			--str_data[16] ext1
			--str_data[17] fax
			--str_data[18] tel2
			--str_data[19] ext2
			--str_data[20] email
			--str_data[21] contacto
			
			INSERT INTO cxc_clie_df
			(
				cxc_clie_id,--str_data[5]::integer,
				calle,--str_data[6],
				numero_interior,--str_data[7],
				numero_exterior,--str_data[8],
				colonia,--str_data[9],
				cp,--str_data[10],
				gral_pais_id,--str_data[11]::integer,
				gral_edo_id,--str_data[12]::integer,
				gral_mun_id,--str_data[13]::integer,
				entre_calles,--str_data[14],
				telefono1,--str_data[15],
				extension1,--str_data[16],
				telefono2,--str_data[18],
				extension2,--str_data[19],
				fax,--str_data[17],
				email,--str_data[20],
				contacto,--str_data[21],
				momento_creacion,--now(),
				gra_usr_id_creacion--usuario_id
			)
			VALUES(str_data[5]::integer, str_data[6], str_data[7], str_data[8], str_data[9], str_data[10], str_data[11]::integer, str_data[12]::integer, str_data[13]::integer, str_data[14], str_data[15], str_data[16], str_data[18], str_data[19], str_data[17], str_data[20], str_data[21], now(), usuario_id);
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_clie_df SET cxc_clie_id=str_data[5]::integer, calle=str_data[6], numero_interior=str_data[7], numero_exterior=str_data[8], colonia=str_data[9], cp=str_data[10], gral_pais_id=str_data[11]::integer, gral_edo_id=str_data[12]::integer, gral_mun_id=str_data[13]::integer, entre_calles=str_data[14], telefono1=str_data[15], extension1=str_data[16], telefono2=str_data[18], extension2=str_data[19], fax=str_data[17], email=str_data[20], contacto=str_data[21], momento_actualizacion=now(), gra_usr_id_actualizacion=usuario_id
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxc_clie_df SET momento_baja=now(),borrado_logico=true, gra_usr_id_baja=usuario_id
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Direcciones Fiscales de Clientes








	
	-- Actualizador de Tipos de Cambio
	IF app_selected = 119 THEN
		IF command_selected = 'new'  or command_selected = 'edit' THEN
		--119___edit____1___4____3___2013-01-18___555
		--app_selected+"___"+command_selected+"___"+id_usuario+"___"+id+"___"+moneda_id+"___"+fecha+"___"+tipo_cambio;
		--RAISE EXCEPTION '%','DataString::'||str_data[1]||'___'||str_data[2]||'____'||str_data[3]||'___'||str_data[4]||'____'||str_data[5]||'___'||str_data[6]||'___'||str_data[7]||'___'||str_data[8];
			----str_data[1]    app_selected       119
			----str_data[2]    command_selected   edit
			----str_data[3]    id_usuario         1
		        ----str_data[4]         id            4
			----str_data[5]         moneda_id     3
			----str_data[6]     fecha             2013-01-18
			----strd_data[7]    tipo_cambio       555
			----strd_data[8]     fecha_de_hoy   
/*		         RAISE EXCEPTION '%','id Encontrado::'||'select count(erp_monedavers.id ) as cantidad_registros
			from  erp_monedavers 
			WHERE erp_monedavers.moneda_id='||str_data[5]::integer ||' and to_char(erp_monedavers.momento_creacion,''yyyy-mm-dd'') = '''||str_data[8]||'''';
*/
			
			select count(erp_monedavers.id ) as cantidad_registros
			from  erp_monedavers 
			WHERE erp_monedavers.moneda_id=str_data[5]::integer  and to_char(erp_monedavers.momento_creacion,'yyyy-mm-dd') = str_data[8]
			INTO exis;
			
			--INSERT INTO erp_monedavers (valor ,  momento_creacion )
			--VALUES                (str_data[7],   now())
			--app_selected+"___"+command_selected+"___"+id_usuario+"___"+id+"___"+moneda_id+"___"+fecha+"___"+tipo_cambio;
			IF exis = 0 THEN
				INSERT INTO erp_monedavers (valor ,  momento_creacion,moneda_id ,version) VALUES (str_data[7]::double precision,   now(), str_data[5]::integer,'ERP');  
			ELSE --select * from erp_monedavers where moneda_id=3
				UPDATE erp_monedavers SET momento_creacion=now(),valor=str_data[7]::double precision, version ='ERP'
				WHERE erp_monedavers.moneda_id=str_data[5]::integer and to_char(erp_monedavers.momento_creacion,'yyyy-mm-dd') = str_data[8];
			END IF;
			
			 
			valor_retorno := '1';
			
		END IF;
	END IF;--termina Actualizador de Tipos de cambio
	
	
	
	
	
	--Empieza Job Actualiza Moneda
	IF app_selected = 121 THEN
	/*GAS-SEP
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        valor
			--str_data[5]        tc
			--str_data[6]        moneda_desc
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');

					--RAISE EXCEPTION '%','extra_data[cont_fila]::'||extra_data[cont_fila];
					
					if str_filas[2]::double precision>0 then 
						select id from gral_mon where descripcion ilike '%'||str_filas[1]||'%' and borrado_logico=false limit 1 INTO ultimo_id;

						IF ultimo_id is not null THEN 
							select count(id) as cantidad from erp_monedavers where moneda_id=ultimo_id and momento_creacion > (select (select now())::date) INTO rowCount;
							
							IF rowCount <= 0 THEN 
								INSERT INTO erp_monedavers (moneda_id, valor, momento_creacion, version) 
								VALUES (ultimo_id, str_filas[2]::double precision, now(), str_filas[3]);
							end if;
						end if;
					end if;
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;	
		*/
	END IF;--termina Job Actualiza Moneda
	
	
	
	
	--Aplicativo Actualizador de Contrase√±a del usuario
	IF app_selected = 155 THEN
		IF command_selected = 'edit' THEN
			UPDATE gral_usr SET password=str_data[5] WHERE id=str_data[3]::integer;
			
			valor_retorno := '1';
		END IF;	
		
	END IF;--termina Aplicativo Actualizador de Contrase√±a del usuario
	
	
	
	-- Catalogo de inventario de  IEPS
	IF app_selected = 167 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	tasa
			INSERT INTO gral_ieps (titulo,descripcion,tasa,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],str_data[6],str_data[7]::double precision,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE gral_ieps SET titulo=str_data[5],descripcion=str_data[6],tasa=str_data[7]::double precision,momento_actualizacion=now(),gral_usr_id_actualiza=usuario_id
			WHERE gral_ieps.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_ieps SET momento_baja=now(),borrado_logico=true 
			WHERE gral_ieps.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo IEPS


	-- Catalogo de inventario de  Percepciones
	IF app_selected = 170 THEN
		IF command_selected = 'new' THEN
			id_tipo_consecutivo:=48;--Folio Catalogo de Percepciones
			
			--aqui entra para tomar el consecutivo del folio de la Percepcionesactual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			nuevo_folio:= lpad(nuevo_folio, 3, '0');
			
			--str_data[4]	id
			--str_data clave nuevo_folio
			--str_data[5]	titulo
			--str_data[6]	activo
			--str_data[7]	tipopercepciones
			INSERT INTO nom_percep (clave,titulo,activo,nom_percep_tipo_id,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (nuevo_folio,str_data[5],str_data[6]::boolean,str_data[7]::integer,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE nom_percep SET titulo=str_data[5],activo=str_data[6]::boolean,nom_percep_tipo_id=str_data[7]::integer,momento_actualiza=now(),gral_usr_id_actualiza=usuario_id
			WHERE nom_percep.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE nom_percep SET momento_baja=now(),borrado_logico=true WHERE nom_percep.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Percepciones
	
	
	
	-- Catalogo de inventario de  Deducciones
	IF app_selected = 171 THEN
		IF command_selected = 'new' THEN
			id_tipo_consecutivo:=49;--Folio Catalogo de Deducciones
			
			--aqui entra para tomar el consecutivo del folio  de Deducciones actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			nuevo_folio:= lpad(nuevo_folio, 3, '0');
			
			--str_data[4]	id
			--str_data clave nuevo_folio
			--str_data[5]	titulo
			--str_data[6]	activo
			--str_data[7]	tipopercepciones
			INSERT INTO nom_deduc (clave,titulo,activo,nom_deduc_tipo_id,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (nuevo_folio,str_data[5],str_data[6]::boolean,str_data[7]::integer,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE nom_deduc SET titulo=str_data[5],activo=str_data[6]::boolean,nom_deduc_tipo_id=str_data[7]::integer, momento_actualiza=now(), gral_usr_id_actualiza=usuario_id 
			WHERE nom_deduc.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE nom_deduc SET momento_baja=now(),borrado_logico=true WHERE nom_deduc.id = str_data[4]::integer; 
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo Deducciones


	
	-- Catalogo de inventario de  Periodicidad de Pago
	IF app_selected = 172 THEN
		IF command_selected = 'new' THEN

			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	no_periodos
			--str_data[7]	activo
			INSERT INTO nom_periodicidad_pago (titulo,no_periodos,activo,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],str_data[6]::integer,str_data[7]::boolean,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE nom_periodicidad_pago SET titulo=str_data[5],no_periodos=str_data[6]::integer,activo=str_data[7]::boolean,momento_actualiza=now(), gral_usr_id_actualiza=usuario_id 
			WHERE nom_periodicidad_pago.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE nom_periodicidad_pago SET momento_baja=now(),borrado_logico=true, gral_usr_id_baja=usuario_id  WHERE nom_periodicidad_pago.id = str_data[4]::integer; 
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo Periodicidad de Pago




-- Catalogo de Configuraci√≥n Periodicidad de Pago
	IF app_selected = 174 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data clave nuevo_folio
			--str_data[5]	a√±o
			--str_data[6]	tipoperiodicidad
			--str_data[7]	descripcion
			
			INSERT INTO nom_periodos_conf (ano,nom_periodicidad_pago_id,prefijo,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5]::integer,str_data[6]::integer,str_data[7],false,now(),usuario_id,emp_id,suc_id)
			RETURNING id INTO ultimo_id;
			valor_retorno := '1';
			
			total_filas:= array_length(extra_data,1);
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	id_reg 
					--str_filas[2]	id_periodo 
					--str_filas[3]	folio 
					--str_filas[4]	tituloperiodo
					--str_filas[5]	fecha_inicio 
					--str_filas[6]	fecha_final
					
					--crea registro en nom_periodos_conf_det
					INSERT INTO nom_periodos_conf_det(
						nom_periodos_conf_id,--str_data[4]::integer,
						folio,--str_filas[3]	folio 
						titulo,--str_filas[4]	tituloperiodo 
						fecha_ini,--str_filas[5]	fecha_inicio
						fecha_fin--str_filas[6]	fecha_final
						
					 ) VALUES(ultimo_id, str_filas[3]::integer, str_filas[4], str_filas[5]::date,str_filas[6]::date);
					 --RETURNING id INTO ultimo_id;
					 valor_retorno := '1';
				END LOOP;
			END IF;
			
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE nom_periodos_conf SET ano=str_data[5]::integer,nom_periodicidad_pago_id=str_data[6]::integer,prefijo=str_data[7],momento_actualiza=now(),gral_usr_id_actualiza=usuario_id 
			WHERE nom_periodos_conf.id = str_data[4]::integer;
			valor_retorno := '0';
			
			total_filas:= array_length(extra_data,1);
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP 
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	id_reg 
					--str_filas[2]	id_periodo 
					--str_filas[3]	folio 
					--str_filas[4]	tituloperiodo
					--str_filas[5]	fecha_inicio 
					--str_filas[6]	fecha_final
					
					UPDATE nom_periodos_conf_det SET folio=str_filas[3]::integer,titulo=str_filas[4],fecha_ini=str_filas[5]::date,fecha_fin=str_filas[6]::date
					WHERE nom_periodos_conf_det.id = str_filas[1]::integer;
					valor_retorno := '0';
				END LOOP;
			END IF;
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE nom_periodos_conf SET momento_baja=now(),borrado_logico=true 
			WHERE nom_periodos_conf.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;-- Catalogo de Configuraci√≥n Periodicidad de Pago

	
	-- Catalogo de descuentos  de  clientes
	IF app_selected = 176 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         cliente
                        --str_data[6]         valor
                        INSERT INTO cxc_clie_descto (cxc_clie_id,tipo,valor) VALUES (str_data[5]::integer,1,str_data[6]::double precision);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_clie_descto SET cxc_clie_id=str_data[5]::integer,valor=str_data[6]::double precision 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxc_clie_descto WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo descuentos  de  clientes

        
	--Catalogo de IVA Trasladado
	IF app_selected = 204 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	tasa
			--str_data[7]	cta_id
			
			if str_data[6]::double precision>0 then 
				str_data[6] := str_data[6]::double precision/100;
			end if;
			
			INSERT INTO gral_imptos (descripcion,iva_1,momento_creacion,gral_usr_id_crea,borrado_logico) VALUES (str_data[5],str_data[6]::double precision,espacio_tiempo_ejecucion,usuario_id,false) 
			RETURNING id INTO ultimo_id;

			if incluye_modulo_contabilidad then 
				IF EXISTS (SELECT * FROM information_schema.tables WHERE table_name='gral_impto_cta') THEN
					insert into gral_impto_cta(gral_impto_id,ctb_cta_id,momento_actualiza,gral_usr_id_actualiza,gral_suc_id) 
					values(ultimo_id,str_data[7]::integer,espacio_tiempo_ejecucion,usuario_id,suc_id);
				END IF;
			end if;
						
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN 
			if str_data[6]::double precision>0 then 
				str_data[6] := str_data[6]::double precision/100;
			end if;
			
			UPDATE gral_imptos SET descripcion=str_data[5],iva_1=str_data[6]::double precision,momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualiza=usuario_id 
			WHERE id=str_data[4]::integer;

			if incluye_modulo_contabilidad then 
				IF EXISTS (SELECT * FROM information_schema.tables WHERE table_name='gral_impto_cta') THEN 
					if (select count(id) from gral_impto_cta where gral_impto_id=str_data[4]::integer)>0 then 
						update gral_impto_cta set ctb_cta_id=str_data[7]::integer, momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
						where gral_impto_id=str_data[4]::integer;
					else 
						insert into gral_impto_cta(gral_impto_id,ctb_cta_id,momento_actualiza,gral_usr_id_actualiza,gral_suc_id) 
						values(str_data[4]::integer,str_data[7]::integer,espacio_tiempo_ejecucion,usuario_id,suc_id);
					end if;
				END IF;
			end if;
			
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_imptos SET momento_baja=espacio_tiempo_ejecucion,gral_usr_id_cancela=usuario_id,borrado_logico=true 
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo de IVA Trasladado


	--Catalogo de IVA Retenido
	IF app_selected = 205 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	tasa
			--str_data[7]	cta_id
			
			INSERT INTO gral_imptos_ret(titulo,tasa,momento_creacion,gral_usr_id_crea,borrado_logico) 
			VALUES (str_data[5],str_data[6]::double precision,espacio_tiempo_ejecucion,usuario_id,false) 
			RETURNING id INTO ultimo_id;
			
			if incluye_modulo_contabilidad then 
				IF EXISTS (SELECT * FROM information_schema.tables WHERE table_name='gral_impto_ret_cta') THEN
					insert into gral_impto_ret_cta(gral_impto_ret_id,ctb_cta_id,momento_actualiza,gral_usr_id_actualiza,gral_suc_id) 
					values(ultimo_id,str_data[7]::integer,espacio_tiempo_ejecucion,usuario_id,suc_id);
				END IF;
			end if;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN 
			UPDATE gral_imptos_ret SET titulo=str_data[5],tasa=str_data[6]::double precision,momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualiza=usuario_id 
			WHERE id=str_data[4]::integer;
			
			if incluye_modulo_contabilidad then 
				IF EXISTS (SELECT * FROM information_schema.tables WHERE table_name='gral_impto_ret_cta') THEN 
					if (select count(id) from gral_impto_ret_cta where gral_impto_ret_id=str_data[4]::integer)>0 then 
						update gral_impto_ret_cta set ctb_cta_id=str_data[7]::integer, momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
						where gral_impto_ret_id=str_data[4]::integer;
					else 
						insert into gral_impto_ret_cta(gral_impto_ret_id,ctb_cta_id,momento_actualiza,gral_usr_id_actualiza,gral_suc_id) 
						values(str_data[4]::integer,str_data[7]::integer,espacio_tiempo_ejecucion,usuario_id,suc_id);
					end if;
				END IF;
			end if;
			
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_imptos_ret SET momento_baja=espacio_tiempo_ejecucion,gral_usr_id_cancela=usuario_id,borrado_logico=true 
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo de IVA Retenido



	--Catalogo de Metodos de Pago
	IF app_selected = 209 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	clave
			--str_data[6]	titulo
			
			INSERT INTO fac_metodos_pago(clave_sat,titulo,momento_creacion,gral_usr_id_creacion,borrado_logico) 
			VALUES (str_data[5],str_data[6],espacio_tiempo_ejecucion,usuario_id,false);
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN 
			UPDATE fac_metodos_pago SET clave_sat=str_data[5],titulo=str_data[6],momento_actualiza=espacio_tiempo_ejecucion,gral_usr_id_actualizacion=usuario_id 
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE fac_metodos_pago SET momento_baja=espacio_tiempo_ejecucion,gral_usr_id_baja=usuario_id,borrado_logico=true 
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo de Metodos de Pago














	
	
	
	
	RETURN valor_retorno;
	
END;
$$;


--
-- Name: gral_adm_catalogos_BK(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public."gral_adm_catalogos_BK"(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	

	--estas  variables se utilizan en la mayoria de los catalogos
	str_data text[];
	str_percep text[];
	str_deduc text[];
	
	app_selected integer;
	command_selected text;
	valor_retorno character varying;
	usuario_id integer;
	emp_id integer;
	suc_id integer;
	ultimo_id integer;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	id_almacen integer=0;
	exis integer=0;
	
	id_tipo_consecutivo integer=0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
	incluye_modulo_produccion boolean;
	incluye_modulo_contabilidad boolean;
	incluye_modulo_envasado boolean;
	controlExisPres boolean = false;--Variable que indica si se debe controlar las existencias por presentaciones
	incluye_nomina boolean:=false;
	
	--seran eliminadas
	nombre_consecutivo character varying = '';
	cadena_extra character varying = '';
	ultimo_cosecutivo_proveedor character varying;
	folio_proveedor character varying;
	
	--variables para catalogo de clientes
	str_filas text[];
	total_filas integer;--total de elementos de arreglo
	cont_fila integer;--contador de filas o posiciones del arreglo
	factura_en boolean;
	descarga_xml boolean;
	numero_control_client character varying;
	ultimo_cosecutivo_cliente character varying;
	
	--variables para catalogo de productos
	ultimo_cosecutivo_producto character varying;
	nuevo_sku character varying;
	tipo_producto integer;
	id_producto integer;
	str_pres text[];
	tot_filas integer;--total de elementos de arreglo de id de presentaciones
	meta_imp character varying='';
	
	--variable para prefacturas
	ultimo_id_proceso integer;
	
	--variable para pagos
	folio_transaccion bigint;
	ultimo_cosecutivo_transaccion character varying;
	id_forma_pago integer;
	id_anticipo integer;
	monto_anticipo_actual double precision;
	saldo_anticipo double precision;
	rowCount integer;
	item text[];
	iterar text[];
	veces int:=0;
	incrementa int:=1;
	sql_pagos text; 
	fila record;
	fila2 record;
	suma_pagos double precision=0;
	suma_notas_credito double precision=0;
	
	total_factura double precision;
	monto_pagos double precision;
	nuevacantidad_monto_pago double precision;
	nuevo_saldo_factura double precision;
	suma_pagos_efectuados  double precision;
	
	id_pago integer:=0;
	monto_cancelado double precision:=0;
	id_pagos_detalles integer;
	nuevacantidad_monto_cancelados double precision:=0;
	total_monto_cancelados double precision;
	serie_folio_cancel character varying:='';
	id_moneda_factura integer:=0;
	id_moneda_anticipo integer:=0; 
	tipo_cambio_pago double precision:=0;
	
	ultimo_id_usr integer=0;
	eliminar_registro boolean=true;
	valor1 double precision:=0;
BEGIN
	--convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	--aplicativo seleccionado
	app_selected := str_data[1]::integer;
	
	command_selected := str_data[2];--new, edit, delete. Para aplicativo 14 pagos: pago, anticipo, cancelacion
	
	-- usuario que utiliza el aplicativo
	usuario_id := str_data[3]::integer;
	
	/*
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id;
	*/
	
	--obtiene empresa_id, sucursal_id y sucursal_id
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id,inv_suc_alm.almacen_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id=usuario_id
	INTO emp_id, suc_id, id_almacen;
	
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	valor_retorno:='0';
	
	--Query para verificar si la empresa actual incluye Control de Existencias por Presentacion
	SELECT control_exis_pres,nomina,incluye_contabilidad FROM gral_emp WHERE id=emp_id 
	INTO controlExisPres, incluye_nomina,incluye_modulo_contabilidad;
	
	-- Catalogo de Almacenes
	IF app_selected = 1 THEN
		IF command_selected = 'new' THEN
			INSERT INTO inv_alm(
				titulo,--str_data[5]
				calle,--str_data[6]
				numero,--str_data[7]
				colonia,--str_data[8]
				codigo_postal,--str_data[9]
				gral_pais_id,--str_data[10]::integer
				gral_edo_id,--str_data[11]::integer
				gral_mun_id,--str_data[12]::integer
				tel_1,--str_data[13]
				tel_2,--str_data[14]
				tel_1_ext,--str_data[15]
				tel_2_ext,--str_data[16]
				responsable,--str_data[17]
				responsable_puesto,--str_data[18]
				responsable_email,--str_data[19]
				almacen_tipo_id,--str_data[20]::integer
				compras,--str_data[21]::boolean
				consignacion,--str_data[22]::boolean
				explosion_mat,--str_data[23]::boolean
				garantias,--str_data[24]::boolean
				reabastecimiento,--str_data[25]::boolean
				recepcion_mat,--str_data[26]::boolean
				reporteo,--str_data[27]::boolean
				traspaso,--str_data[28]::boolean
				ventas,--str_data[29]::boolean
				borrado_logico,--false
				momento_creacion--now()
			) VALUES(str_data[5],str_data[6],str_data[7],str_data[8],str_data[9],str_data[10]::integer,str_data[11]::integer,str_data[12]::integer,str_data[13],str_data[14],str_data[15],str_data[16],str_data[17],str_data[18],str_data[19],str_data[20]::integer,str_data[21]::boolean,str_data[22]::boolean,str_data[23]::boolean,str_data[24]::boolean,str_data[25]::boolean,str_data[26]::boolean,str_data[27]::boolean,str_data[28]::boolean,str_data[29]::boolean,false,now()) 
			RETURNING id INTO ultimo_id;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN
				--RAISE EXCEPTION '%' ,extra_data[cont_fila]::integer;
				FOR cont_fila IN 1 .. total_filas LOOP
					INSERT INTO inv_suc_alm(almacen_id,sucursal_id) VALUES(ultimo_id, extra_data[cont_fila]::integer);
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_alm SET 
				titulo=str_data[5],
				calle=str_data[6],
				numero=str_data[7],
				colonia=str_data[8],
				codigo_postal=str_data[9],
				gral_pais_id=str_data[10]::integer,
				gral_edo_id=str_data[11]::integer,
				gral_mun_id=str_data[12]::integer,
				tel_1=str_data[13],
				tel_2=str_data[14],
				tel_1_ext=str_data[15],
				tel_2_ext=str_data[16],
				responsable=str_data[17],
				responsable_puesto=str_data[18],
				responsable_email=str_data[19],
				almacen_tipo_id=str_data[20]::integer,
				compras=str_data[21]::boolean,
				consignacion=str_data[22]::boolean,
				explosion_mat=str_data[23]::boolean,
				garantias=str_data[24]::boolean,
				reabastecimiento=str_data[25]::boolean,
				recepcion_mat=str_data[26]::boolean,
				reporteo=str_data[27]::boolean,
				traspaso=str_data[28]::boolean,
				ventas=str_data[29]::boolean,
				momento_actualizacion=now()
			WHERE id = str_data[4]::integer;

			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			IF extra_data[1] != 'sin datos' THEN
				DELETE FROM inv_suc_alm WHERE almacen_id=str_data[4]::integer;
				FOR cont_fila IN 1 .. total_filas LOOP
					INSERT INTO inv_suc_alm(almacen_id,sucursal_id) VALUES(str_data[4]::integer, extra_data[cont_fila]::integer);
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_alm SET borrado_logico=true, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de Almacenes




	
	-- Catalogo de Proveedores
	IF app_selected = 2 THEN
		IF command_selected = 'new' THEN

			id_tipo_consecutivo:=2;--Folio de proveedor
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

			INSERT INTO cxp_prov(
				folio,--nuevo_folio
				rfc,--str_data[6]
				curp,--str_data[7]
				razon_social,--str_data[8]
				clave_comercial,--str_data[9]
				calle,--str_data[10]
				numero,--str_data[11]
				colonia,--str_data[12]
				cp,--str_data[13]
				entre_calles,--str_data[14]
				pais_id,--str_data[15]::integer
				estado_id,--str_data[16]::integer
				municipio_id,--str_data[17]::integer
				localidad_alternativa,--str_data[18]
				telefono1,--str_data[19]
				extension1,--str_data[20]
				fax,--str_data[21]
				telefono2,--str_data[22]
				extension2,--str_data[23]
				correo_electronico,--str_data[24]
				web_site,--str_data[25]
				impuesto,--str_data[26]::integer
				cxp_prov_zona_id,--str_data[27]::integer
				grupo_id,--str_data[28]::integer
				proveedortipo_id,--str_data[29]::integer
				clasif_1,--str_data[30]::integer
				clasif_2,--str_data[31]::integer
				clasif_3,--str/controllers/facturas/startup.agnux_data[32]::integer
				moneda_id,--str_data[33]::integer
				tiempo_entrega_id,--str_data[34]::integer
				estatus,--str_data[35]::boolean
				limite_credito,--str_data[36]::double precision
				dias_credito_id,--str_data[37]::integer
				descuento,--str_data[38]::double precision
				credito_a_partir,--str_data[39]::integer
				cxp_prov_tipo_embarque_id,--str_data[40]::integer
				flete_pagado,--str_data[41]::boolean
				condiciones,--str_data[42]
				observaciones,--str_data[43]
				vent_contacto,--str_data[44]
				vent_puesto,--str_data[45]
				vent_calle,--str_data[46]
				vent_numero,--/controllers/facturas/startup.agnuxstr_data[47]
				vent_colonia,--str_data[48]
				vent_cp,--str_data[49]
				vent_entre_calles,--str_data[50]
				vent_pais_id,--str_data[51]::integer
				vent_estado_id,--str_data[52]::integer
				vent_municipio_id,--str_data[53]::integer
				vent_telefono1,--str_data[54]
				vent_extension1,--str_data[55]
				vent_fax,--str_data[56]
				vent_telefono2,--str_data[57]
				vent_extension2,--str_data[58]
				vent_email,--str_data[59]
				cob_contacto,--str_data[60]
				cob_puesto,--str_data[61]
				cob_calle,--str_data[62]
				cob_numero,--str_data[63]
				cob_colonia,--str_data[64]
				cob_cp,--str_data[65]
				cob_entre_calles,--str_data[66]
				cob_pais_id,--str_data[67]::integer
				cob_estado_id,--str_data[68]::integer
				cob_municipio_id,--str_data[69]::integer
				cob_telefono1,--str_data[70]
				cob_extension1,--str_data[71]
				cob_fax,--str_data[72]
				cob_telefono2,--str_data[73]
				cob_extension2,--str_data[74]
				cob_email,--str_data[75]
				comentarios,--str_data[76]
				ctb_cta_id_pasivo,--str_data[77]::integer,
				ctb_cta_id_egreso,--str_data[78]::integer,
				ctb_cta_id_ietu,--str_data[79]::integer,
				ctb_cta_id_comple,--str_data[80]::integer,
				ctb_cta_id_pasivo_comple,--str_data[81]::integer,
				transportista,--str_data[82]::boolean,
				empresa_id,--emp_id
				sucursal_id,--suc_id
				borrado_logico,--false,
				momento_creacion,--now()
				id_usuario_creacion--usuario_id
			)
			VALUES(nuevo_folio,str_data[6],str_data[7],str_data[8],str_data[9],str_data[10],str_data[11],str_data[12],str_data[13],str_data[14],str_data[15]::integer,str_data[16]::integer,str_data[17]::integer,str_data[18],str_data[19],str_data[20],str_data[21],str_data[22],str_data[23],str_data[24],str_data[25],str_data[26]::integer,str_data[27]::integer,str_data[28]::integer,str_data[29]::integer,str_data[30]::integer,str_data[31]::integer,str_data[32]::integer,str_data[33]::integer,str_data[34]::integer,str_data[35]::boolean,str_data[36]::double precision,str_data[37]::integer,str_data[38]::double precision,str_data[39]::integer,str_data[40]::integer,str_data[41]::boolean,str_data[42],str_data[43],str_data[44],str_data[45],str_data[46],str_data[47],str_data[48],str_data[49],str_data[50],str_data[51]::integer,str_data[52]::integer,str_data[53]::integer,str_data[54],str_data[55],str_data[56],str_data[57],str_data[58],str_data[59],str_data[60],str_data[61],str_data[62],str_data[63],str_data[64],str_data[65],str_data[66],str_data[67]::integer,str_data[68]::integer,str_data[69]::integer,str_data[70],str_data[71],str_data[72],str_data[73],str_data[74],str_data[75],str_data[76], str_data[77]::integer, str_data[78]::integer, str_data[79]::integer, str_data[80]::integer, str_data[81]::integer, str_data[82]::boolean, emp_id, suc_id, false, now(), usuario_id);
			
			/*
			INSERT INTO cxp_prov(
				folio,--nuevo_folio
				rfc,--str_data[6]
				curp,--str_data[7]
				razon_social,--str_data[8]
				clave_comercial,--str_data[9]
				calle,--str_data[10]
				numero,--str_data[11]
				colonia,--str_data[12]
				cp,--str_data[13]
				entre_calles,--str_data[14]
				pais_id,--str_data[15]::integer
				estado_id,--str_data[16]::integer
				municipio_id,--str_data[17]::integer
				localidad_alternativa,--str_data[18]
				telefono1,--str_data[19]
				extension1,--str_data[20]
				fax,--str_data[21]
				telefono2,--str_data[22]
				extension2,--str_data[23]
				correo_electronico,--str_data[24]
				web_site,--str_data[25]
				impuesto,--str_data[26]::integer
				cxp_prov_zona_id,--str_data[27]::integer
				grupo_id,--str_data[28]::integer
				proveedortipo_id,--str_data[29]::integer
				clasif_1,--str_data[30]::integer
				clasif_2,--str_data[31]::integer
				clasif_3,--str/controllers/facturas/startup.agnux_data[32]::integer
				moneda_id,--str_data[33]::integer
				tiempo_entrega_id,--str_data[34]::integer
				estatus,--str_data[35]::boolean
				limite_credito,--str_data[36]::double precision
				dias_credito_id,--str_data[37]::integer
				descuento,--str_data[38]::double precision
				credito_a_partir,--str_data[39]::integer
				cxp_prov_tipo_embarque_id,--str_data[40]::integer
				flete_pagado,--str_data[41]::boolean
				condiciones,--str_data[42]
				observaciones,--str_data[43]
				vent_contacto,--str_data[44]
				vent_puesto,--str_data[45]
				vent_calle,--str_data[46]
				vent_numero,--/controllers/facturas/startup.agnuxstr_data[47]
				vent_colonia,--str_data[48]
				vent_cp,--str_data[49]
				vent_entre_calles,--str_data[50]
				vent_pais_id,--str_data[51]::integer
				vent_estado_id,--str_data[52]::integer
				vent_municipio_id,--str_data[53]::integer
				vent_telefono1,--str_data[54]
				vent_extension1,--str_data[55]
				vent_fax,--str_data[56]
				vent_telefono2,--str_data[57]
				vent_extension2,--str_data[58]
				vent_email,--str_data[59]
				cob_contacto,--str_data[60]
				cob_puesto,--str_data[61]
				cob_calle,--str_data[62]
				cob_numero,--str_data[63]
				cob_colonia,--str_data[64]
				cob_cp,--str_data[65]
				cob_entre_calles,--str_data[66]
				cob_pais_id,--str_data[67]::integer
				cob_estado_id,--str_data[68]::integer
				cob_municipio_id,--str_data[69]::integer
				cob_telefono1,--str_data[70]
				cob_extension1,--str_data[71]
				cob_fax,--str_data[72]
				cob_telefono2,--str_data[73]
				cob_extension2,--str_data[74]
				cob_email,--str_data[75]
				comentarios,--str_data[76]
				ctb_cta_id_pasivo,--str_data[77]::integer,
				transportista,--str_data[78]::boolean,
				empresa_id,--emp_id
				sucursal_id,--suc_id
				borrado_logico,--false,
				momento_creacion,--now()
				id_usuario_creacion--usuario_id
			)
			VALUES(nuevo_folio,str_data[6],str_data[7],str_data[8],str_data[9],str_data[10],str_data[11],str_data[12],str_data[13],str_data[14],str_data[15]::integer,str_data[16]::integer,str_data[17]::integer,str_data[18],str_data[19],str_data[20],str_data[21],str_data[22],str_data[23],str_data[24],str_data[25],str_data[26]::integer,str_data[27]::integer,str_data[28]::integer,str_data[29]::integer,str_data[30]::integer,str_data[31]::integer,str_data[32]::integer,str_data[33]::integer,str_data[34]::integer,str_data[35]::boolean,str_data[36]::double precision,str_data[37]::integer,str_data[38]::double precision,str_data[39]::integer,str_data[40]::integer,str_data[41]::boolean,str_data[42],str_data[43],str_data[44],str_data[45],str_data[46],str_data[47],str_data[48],str_data[49],str_data[50],str_data[51]::integer,str_data[52]::integer,str_data[53]::integer,str_data[54],str_data[55],str_data[56],str_data[57],str_data[58],str_data[59],str_data[60],str_data[61],str_data[62],str_data[63],str_data[64],str_data[65],str_data[66],str_data[67]::integer,str_data[68]::integer,str_data[69]::integer,str_data[70],str_data[71],str_data[72],str_data[73],str_data[74],str_data[75],str_data[76], str_data[77]::integer,str_data[78]::boolean, emp_id, suc_id, false, now(), usuario_id);
			*/
			valor_retorno := '1';
		END IF;

		
		IF command_selected = 'edit' THEN 
			/*
			UPDATE cxp_prov SET rfc=str_data[6],curp=str_data[7],razon_social=str_data[8],clave_comercial=str_data[9],calle=str_data[10],numero=str_data[11],colonia=str_data[12],cp=str_data[13],entre_calles=str_data[14],pais_id=str_data[15]::integer,estado_id=str_data[16]::integer,municipio_id=str_data[17]::integer,localidad_alternativa=str_data[18],telefono1=str_data[19],extension1=str_data[20],fax=str_data[21],telefono2=str_data[22],extension2=str_data[23],correo_electronico=str_data[24],web_site=str_data[25],impuesto=str_data[26]::integer,cxp_prov_zona_id=str_data[27]::integer,grupo_id=str_data[28]::integer,proveedortipo_id=str_data[29]::integer,clasif_1=str_data[30]::integer,clasif_2=str_data[31]::integer,clasif_3=str_data[32]::integer,moneda_id=str_data[33]::integer,tiempo_entrega_id=str_data[34]::integer,estatus=str_data[35]::boolean,limite_credito=str_data[36]::double precision,dias_credito_id=str_data[37]::integer,
				descuento=str_data[38]::double precision,credito_a_partir=str_data[39]::integer,cxp_prov_tipo_embarque_id=str_data[40]::integer,flete_pagado=str_data[41]::boolean,condiciones=str_data[42],observaciones=str_data[43],vent_contacto=str_data[44],vent_puesto=str_data[45],vent_calle=str_data[46],vent_numero=str_data[47],vent_colonia=str_data[48],vent_cp=str_data[49],vent_entre_calles=str_data[50],vent_pais_id=str_data[51]::integer,vent_estado_id=str_data[52]::integer,vent_municipio_id=str_data[53]::integer,vent_telefono1=str_data[54],vent_extension1=str_data[55],vent_fax=str_data[56],vent_telefono2=str_data[57],vent_extension2=str_data[58],vent_email=str_data[59],cob_contacto=str_data[60],cob_puesto=str_data[61],cob_calle=str_data[62],cob_numero=str_data[63],cob_colonia=str_data[64],cob_cp=str_data[65],cob_entre_calles=str_data[66],cob_pais_id=str_data[67]::integer,cob_estado_id=str_data[68]::integer,cob_municipio_id=str_data[69]::integer,
				cob_telefono1=str_data[70],cob_extension1=str_data[71],cob_fax=str_data[72],cob_telefono2=str_data[73],cob_extension2=str_data[74],cob_email=str_data[75],comentarios=str_data[76], ctb_cta_id_pasivo=str_data[77]::integer,transportista=str_data[78]::boolean, momento_actualizacion=now(),id_usuario_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;
			*/
			UPDATE cxp_prov SET rfc=str_data[6],curp=str_data[7],razon_social=str_data[8],clave_comercial=str_data[9],calle=str_data[10],numero=str_data[11],colonia=str_data[12],cp=str_data[13],entre_calles=str_data[14],pais_id=str_data[15]::integer,estado_id=str_data[16]::integer,municipio_id=str_data[17]::integer,localidad_alternativa=str_data[18],telefono1=str_data[19],extension1=str_data[20],fax=str_data[21],telefono2=str_data[22],extension2=str_data[23],correo_electronico=str_data[24],web_site=str_data[25],impuesto=str_data[26]::integer,cxp_prov_zona_id=str_data[27]::integer,grupo_id=str_data[28]::integer,proveedortipo_id=str_data[29]::integer,clasif_1=str_data[30]::integer,clasif_2=str_data[31]::integer,clasif_3=str_data[32]::integer,moneda_id=str_data[33]::integer,tiempo_entrega_id=str_data[34]::integer,estatus=str_data[35]::boolean,limite_credito=str_data[36]::double precision,dias_credito_id=str_data[37]::integer,
				descuento=str_data[38]::double precision,credito_a_partir=str_data[39]::integer,cxp_prov_tipo_embarque_id=str_data[40]::integer,flete_pagado=str_data[41]::boolean,condiciones=str_data[42],observaciones=str_data[43],vent_contacto=str_data[44],vent_puesto=str_data[45],vent_calle=str_data[46],vent_numero=str_data[47],vent_colonia=str_data[48],vent_cp=str_data[49],vent_entre_calles=str_data[50],vent_pais_id=str_data[51]::integer,vent_estado_id=str_data[52]::integer,vent_municipio_id=str_data[53]::integer,vent_telefono1=str_data[54],vent_extension1=str_data[55],vent_fax=str_data[56],vent_telefono2=str_data[57],vent_extension2=str_data[58],vent_email=str_data[59],cob_contacto=str_data[60],cob_puesto=str_data[61],cob_calle=str_data[62],cob_numero=str_data[63],cob_colonia=str_data[64],cob_cp=str_data[65],cob_entre_calles=str_data[66],cob_pais_id=str_data[67]::integer,cob_estado_id=str_data[68]::integer,cob_municipio_id=str_data[69]::integer,
				cob_telefono1=str_data[70],cob_extension1=str_data[71],cob_fax=str_data[72],cob_telefono2=str_data[73],cob_extension2=str_data[74],cob_email=str_data[75],comentarios=str_data[76], ctb_cta_id_pasivo=str_data[77]::integer, ctb_cta_id_egreso=str_data[78]::integer, ctb_cta_id_ietu=str_data[79]::integer, ctb_cta_id_comple=str_data[80]::integer, ctb_cta_id_pasivo_comple=str_data[81]::integer, transportista=str_data[82]::boolean, momento_actualizacion=now(),id_usuario_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxp_prov SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina catalogo de proveedores
	


	--Catalogo de Empleados
	IF app_selected = 4 THEN
		IF command_selected = 'new' THEN

			id_tipo_consecutivo:=15;--Consecutivo de clave empleado
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--RAISE EXCEPTION '%','datos: '||extra_data;
			--RAISE EXCEPTION '%','nombre_consecutivo: '||nombre_consecutivo;
			--RAISE EXCEPTION '%','cadena_extra: '||cadena_extra;
			--RAISE EXCEPTION '%','numero_control_client: '||numero_control_client;

			IF trim(str_data[13])='' THEN
				str_data[13]:='2014-01-01';
			END IF;

			IF trim(str_data[61])='' THEN
				str_data[61]:='0';
			END IF;

			IF trim(str_data[62])='' THEN
				str_data[62]:='0';
			END IF;
			
			INSERT INTO gral_empleados(
				clave,--nuevo_folio,                       
				nombre_pila,--=str_data[5],
				apellido_paterno,--=str_data[6],
				apellido_materno,--=str_data[7],
				imss,--=str_data[8],
				infonavit,--=str_data[9],
				curp,--=str_data[10],
				rfc,--=str_data[11],
				fecha_nacimiento,--=str_data[12]::date,
				fecha_ingreso,--=str_data[13]::date,
				gral_escolaridad_id,--=str_data[14]::integer,
				gral_sexo_id,--=str_data[15]::integer,
				gral_civil_id,--=str_data[16]::integer,
				gral_religion_id,--=str_data[17]::integer,
				gral_sangretipo_id,--=str_data[30]::integer,
				gral_puesto_id,--=str_data[33]::integer,
				gral_categ_id,--=str_data[35]::integer,
				gral_suc_id_empleado,--=str_data[34]::integer,
				telefono,--=str_data[18],
				telefono_movil,--=str_data[19],
				correo_personal,--=str_data[20],
				gral_pais_id,--=str_data[21]::integer,
				gral_edo_id,--=str_data[22]::integer,
				gral_mun_id,--=str_data[23]::integer,
				calle,--=str_data[24],
				numero,--=str_data[25],
				colonia,--=str_data[26],
				cp,--=str_data[27],
				contacto_emergencia,--=str_data[28],
				telefono_emergencia,--=str_data[29],
				enfermedades,--=str_data[31],
				alergias,--=str_data[32],
				comentarios,--=str_data[36],
				comision_agen,--=str_data[41],
				region_id_agen,--=str_data[48],
				comision2_agen,--=str_data[42],
				comision3_agen,--=str_data[43],
				comision4_agen,--=str_data[44],
				dias_tope_comision,--=str_data[45],
				dias_tope_comision2,--=str_data[46],
				dias_tope_comision3,--=str_data[47],
				tipo_comision,--str_data[49]::integer,
				monto_tope_comision,--=str_data[50],
				monto_tope_comision2,--=str_data[51],
				monto_tope_comision3,--=str_data[52],
				correo_empresa,--str_data[53],
				no_int,--str_data[54],
				nom_regimen_contratacion_id,--str_data[55]::integer,
				nom_tipo_contrato_id,--str_data[56]::integer,
				nom_tipo_jornada_id,--str_data[57]::integer,
				nom_periodicidad_pago_id,--str_data[58]::integer,
				tes_ban_id,--str_data[59]::integer,
				nom_riesgo_puesto_id,--str_data[60]::integer,
				salario_base,--str_data[61]::double precision,
				salario_integrado,--str_data[62]::double precision,
				registro_patronal,--str_data[63],
				clabe, --str_data[64],
				genera_nomina, --str_data[67]::boolean,
				gral_depto_id, --str_data[68]::integer,
				momento_creacion,--now()
				gral_usr_id_creacion,
				gral_emp_id,
				gralsuc_id
				)VALUES (
				--Informaci√≥n: data_string: 4___new___1___0___[3]ADMIN___[4]SANTOS___[5]CAMPOS___[6]12345678901___[7]12345678901___[8]MASN831210MK7___[9]MASN831210MK7___[10]2012-08-09___[11]2012-08-15___3___2___2___7___1234567891_________2___19___986___AV.JUAREZ___12___MARIA LUISA___64988___EZEQUIEL CARDENAS___1234567891___2_________4
					nuevo_folio,                       
					str_data[5],
					str_data[6],
					str_data[7],
					str_data[8],
					str_data[9],
					str_data[10],
					str_data[11],
					str_data[12]::date,
					str_data[13]::date,
					str_data[14]::integer,
					str_data[15]::integer,
					str_data[16]::integer,
					str_data[17]::integer,
					str_data[30]::integer,
					str_data[33]::integer,
					str_data[35]::integer,
					str_data[34]::integer,
					str_data[18],
					str_data[19],
					str_data[20],
					str_data[21]::integer,
					str_data[22]::integer,
					str_data[23]::integer,
					str_data[24],
					str_data[25],
					str_data[26],
					str_data[27],
					str_data[28],
					str_data[29],
					str_data[31],
					str_data[32],
					str_data[36],
					str_data[41]::double precision,
					str_data[48]::integer,
					str_data[42]::double precision,
					str_data[43]::double precision,
					str_data[44]::double precision,
					str_data[45]::double precision,
					str_data[46]::double precision,
					str_data[47]::double precision,
					str_data[49]::integer,
					str_data[50]::double precision,
					str_data[51]::double precision,
					str_data[52]::double precision,
					str_data[53],
					str_data[54],
					str_data[55]::integer,
					str_data[56]::integer,
					str_data[57]::integer,
					str_data[58]::integer,
					str_data[59]::integer,
					str_data[60]::integer,
					str_data[61]::double precision,
					str_data[62]::double precision,
					str_data[63],
					str_data[64],
					str_data[67]::boolean,
					str_data[68]::integer,
					now(),
					usuario_id::integer,
					emp_id::integer, 
					suc_id::integer 
				)RETURNING id INTO ultimo_id;
				


			IF trim(str_data[37])<>'' THEN 
				--Si existe el nombre del usuario hay que crear el registro.
				
				--Crea el usuario
				INSERT INTO gral_usr(username,password,enabled,gral_empleados_id)VALUES(str_data[37],str_data[38],str_data[40]::boolean,ultimo_id::integer)
				RETURNING id INTO ultimo_id_usr;
				
				--Asigna sucursal al usuario
				INSERT INTO gral_usr_suc(gral_usr_id,gral_suc_id) VALUES(ultimo_id_usr,str_data[34]::integer);
				
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				
				IF extra_data[1]<>'sin datos' THEN
					FOR cont_fila IN 1 .. total_filas LOOP
						SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
						--Aqui se vuelven a crear los registros para asignar roles al usuario
						INSERT INTO gral_usr_rol(gral_usr_id,gral_rol_id) VALUES(ultimo_id_usr,extra_data[cont_fila]::integer);
					END LOOP;
				END IF;
			END IF;

			
			--Verificar si incluye NOMINA
			IF incluye_nomina THEN 
				--str_data[65] Percepciones
				IF str_data[65] is not null AND str_data[65]!='' THEN
					--Convertir en arreglo la cadena de Percepciones
					SELECT INTO str_percep string_to_array(str_data[65],',');
					
					FOR iter_y IN array_lower(str_percep,1) .. array_upper(str_percep,1) LOOP
						INSERT INTO gral_empleado_percep(gral_empleado_id,nom_percep_id) VALUES (ultimo_id,str_percep[iter_y]::integer);
					END LOOP;
				END IF;

				--str_data[66] deducciones
				IF str_data[66] is not null AND str_data[66]!='' THEN
					--Convertir en arreglo la cadena de Percepciones
					SELECT INTO str_deduc string_to_array(str_data[66],',');
					
					FOR iter_y IN array_lower(str_deduc,1) .. array_upper(str_deduc,1) LOOP
						INSERT INTO gral_empleado_deduc(gral_empleado_id,nom_deduc_id) VALUES (ultimo_id,str_deduc[iter_y]::integer);
					END LOOP;
				END IF;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			--SELECT INTO str_data string_to_array(''||campos_data||'','___');
			--RAISE EXCEPTION '%',str_data[1];
			--RAISE EXCEPTION '%',identificador;
			UPDATE gral_empleados SET 
				nombre_pila=str_data[5],
				apellido_paterno=str_data[6],
				apellido_materno=str_data[7],
				imss=str_data[8],
				infonavit=str_data[9],
				curp=str_data[10],
				rfc=str_data[11],
				fecha_nacimiento=str_data[12]::date,
				fecha_ingreso=str_data[13]::date,
				gral_escolaridad_id=str_data[14]::integer,
				gral_sexo_id=str_data[15]::integer,
				gral_civil_id=str_data[16]::integer,
				gral_religion_id=str_data[17]::integer,
				gral_sangretipo_id=str_data[30]::integer,
				gral_puesto_id=str_data[33]::integer,
				gral_categ_id=str_data[35]::integer,
				gral_suc_id_empleado=str_data[34]::integer,
				telefono=str_data[18],
				telefono_movil=str_data[19],
				correo_personal=str_data[20],
				gral_pais_id=str_data[21]::integer,
				gral_edo_id=str_data[22]::integer,
				gral_mun_id=str_data[23]::integer,
				calle=str_data[24],
				numero=str_data[25],
				colonia=str_data[26],
				cp=str_data[27],
				contacto_emergencia=str_data[28],
				telefono_emergencia=str_data[29],
				enfermedades=str_data[31],
				alergias=str_data[32],
				comentarios=str_data[36],
				comision_agen=str_data[41]::double precision,
				region_id_agen=str_data[48]::integer,
				comision2_agen=str_data[42]::double precision,
				comision3_agen=str_data[43]::double precision,
				comision4_agen=str_data[44]::double precision,
				dias_tope_comision=str_data[45]::double precision,
				dias_tope_comision2=str_data[46]::double precision,
				dias_tope_comision3=str_data[47]::double precision,
				tipo_comision=str_data[49]::integer,
				monto_tope_comision=str_data[50]::double precision,
				monto_tope_comision2=str_data[51]::double precision,
				monto_tope_comision3=str_data[52]::double precision,
				correo_empresa=str_data[53],
				no_int=str_data[54],
				nom_regimen_contratacion_id=str_data[55]::integer,
				nom_tipo_contrato_id=str_data[56]::integer,
				nom_tipo_jornada_id=str_data[57]::integer,
				nom_periodicidad_pago_id=str_data[58]::integer,
				tes_ban_id=str_data[59]::integer,
				nom_riesgo_puesto_id=str_data[60]::integer,
				salario_base=str_data[61]::double precision,
				salario_integrado=str_data[62]::double precision,
				registro_patronal=str_data[63],
				clabe=str_data[64],
				genera_nomina=str_data[67]::boolean,
				gral_depto_id=str_data[68]::integer,
				momento_actualizacion=now()::timestamp with time zone,
				gral_usr_id_actualizacion=usuario_id
			WHERE id=str_data[4]::integer;
			
			
			IF trim(str_data[37])<>'' THEN 
				IF (SELECT count(id) FROM gral_usr WHERE gral_empleados_id=str_data[4]::integer)<=0 THEN 
					--Crea el usuario
					INSERT INTO gral_usr(username,password,enabled,gral_empleados_id)VALUES(str_data[37],str_data[38],str_data[40]::boolean,str_data[4]::integer)
					RETURNING id INTO ultimo_id_usr;
				ELSE
					UPDATE gral_usr SET username=str_data[37], password=str_data[38], enabled=str_data[40]::boolean
					WHERE gral_empleados_id=str_data[4]::integer RETURNING id INTO ultimo_id_usr;
				END IF;
				
				--Buscar el registro en gral_usr_suc
				SELECT count(id) FROM gral_usr_suc WHERE gral_usr_id=ultimo_id_usr INTO exis;
				
				IF exis > 0 THEN
					--Actualizar la sucursal del usuario
					UPDATE gral_usr_suc SET gral_suc_id=str_data[34]::integer WHERE gral_usr_id=ultimo_id_usr;
				ELSE 
					--Crear registro
					INSERT INTO gral_usr_suc(gral_usr_id, gral_suc_id)VALUES(ultimo_id_usr, str_data[34]::integer);
				END IF;
			ELSE
				IF (SELECT count(id) FROM gral_usr WHERE gral_empleados_id=str_data[4]::integer AND enabled=true)>=0 THEN 
					UPDATE gral_usr SET enabled=false WHERE gral_empleados_id=str_data[4]::integer AND enabled=true;
				END IF;
			END IF;
			
			
			--Elimina todos los roles asignados actualmente
			delete from gral_usr_rol where gral_usr_id=ultimo_id_usr;


			IF trim(str_data[37])<>'' THEN 
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;

				--RAISE EXCEPTION '%','extra_data[1]: '||extra_data[1];
				
				IF extra_data[1]<>'sin_datos' THEN
					FOR cont_fila IN 1 .. total_filas LOOP
						SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
						--Aqui se vuelven a crear los registros
						INSERT INTO gral_usr_rol(gral_usr_id,gral_rol_id  )
						VALUES(ultimo_id_usr,extra_data[cont_fila]::integer);
					END LOOP;
				END IF;
			END IF;



			--Verificar si incluye NOMINA
			IF incluye_nomina THEN 
				--Elimina las Percepciones asignadas actualmente
				delete from gral_empleado_percep where gral_empleado_id=str_data[4]::integer;
				
				--str_data[65] Percepciones
				IF str_data[65] is not null AND str_data[65]!='' THEN
					--Convertir en arreglo la cadena de Percepciones
					SELECT INTO str_percep string_to_array(str_data[65],',');
					--Aqui se vuelven a crear registros de las percepciones asignadas
					FOR iter_y IN array_lower(str_percep,1) .. array_upper(str_percep,1) LOOP
						INSERT INTO gral_empleado_percep(gral_empleado_id,nom_percep_id) VALUES (str_data[4]::integer,str_percep[iter_y]::integer);
					END LOOP;
				END IF;


				--Elimina las Deducciones asignadas actualmente
				delete from gral_empleado_deduc where gral_empleado_id=str_data[4]::integer;
				
				--str_data[66] deducciones
				IF str_data[66] is not null AND str_data[66]!='' THEN
					--Convertir en arreglo la cadena de Percepciones
					SELECT INTO str_deduc string_to_array(str_data[66],',');

					--Aqui se vuelven a crear registros de las Deducciones asignadas
					FOR iter_y IN array_lower(str_deduc,1) .. array_upper(str_deduc,1) LOOP
						INSERT INTO gral_empleado_deduc(gral_empleado_id,nom_deduc_id) VALUES (str_data[4]::integer,str_deduc[iter_y]::integer);
					END LOOP;
				END IF;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_empleados SET borrado_logico=true,  momento_baja=now(), gral_usr_id_baja=usuario_id::integer 
			WHERE id=str_data[4]::integer;
			
			--Deshabilitar usuario y cambiar el nombre del username, esto para evitar conservar el nombre del usuario.
			--No es posible eliminar el registro porque se utliza como llave foranea en varias tablas
			UPDATE gral_usr SET username='01010101010101010101010101010101010101010101010101', enabled=false WHERE gral_empleados_id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;

	END IF;--termina catalogo de empleados
	
	
	
	
	-- Catalogo de Clientes
	IF app_selected = 5 THEN
		IF command_selected = 'new' THEN

			id_tipo_consecutivo:=1;--Folio de proveedor
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--RAISE EXCEPTION '%','emp_id: '||emp_id;
			--RAISE EXCEPTION '%','nombre_consecutivo: '||nombre_consecutivo;
			--RAISE EXCEPTION '%','cadena_extra: '||cadena_extra;
			--RAISE EXCEPTION '%','numero_control_client: '||numero_control_client;
			
			INSERT INTO cxc_clie(
					numero_control,--nuevo_folio
					rfc,--str_data[6]
					curp,--str_data[7]
					razon_social,--str_data[8]
					clave_comercial,--str_data[9]
					calle,--str_data[10]
					numero,--str_data[11]
					entre_calles,--str_data[12]
					numero_exterior,--str_data[13]
					colonia,--str_data[14]
					cp,--str_data[15]
					pais_id,--str_data[16]::integer
					estado_id,--str_data[17]::integer
					municipio_id,--str_data[18]::integer
					localidad_alternativa,--str_data[19]
					telefono1,--str_data[20]
					extension1,--str_data[21]
					fax,--str_data[22]
					telefono2,--str_data[23]
					extension2,--str_data[24]
					email,--str_data[25]
					cxc_agen_id,--str_data[26]::integer
					contacto,--str_data[27]
					zona_id,--str_data[28]::integer
					cxc_clie_grupo_id,--str_data[29]::integer
					clienttipo_id,--str_data[30]::integer
					clasif_1,--str_data[31]::integer
					clasif_2,--str_data[32]::integer
					clasif_3,--str_data[33]::integer
					moneda,--str_data[34]::integer
					filial,--str_data[35]::boolean
					estatus,--str_data[36]::boolean
					gral_imp_id,--str_data[37]::integer
					limite_credito,--str_data[38]::double precision
					dias_credito_id,--str_data[39]::integer
					credito_suspendido,--str_data[40]::boolean
					credito_a_partir,--str_data[41]::integer
					cxp_prov_tipo_embarque_id,--str_data[42]::integer
					dias_caducidad_cotizacion,--str_data[43]::integer
					condiciones,--str_data[44]
					observaciones,--str_data[45]
					contacto_compras_nombre,--str_data[46]
					contacto_compras_puesto,--str_data[47]
					contacto_compras_calle,--str_data[48]
					contacto_compras_numero,--str_data[49]
					contacto_compras_colonia,--str_data[50]
					contacto_compras_cp,--str_data[51]
					contacto_compras_entre_calles,--str_data[52]
					contacto_compras_pais_id,--str_data[53]::integer
					contacto_compras_estado_id,--str_data[54]::integer
					contacto_compras_municipio_id,--str_data[55]::integer
					contacto_compras_telefono1,--str_data[56]
					contacto_compras_extension1,--str_data[57]
					contacto_compras_fax,--str_data[58]
					contacto_compras_telefono2,--str_data[59]
					contacto_compras_extension2,--str_data[60]
					contacto_compras_email,--str_data[61]
					contacto_pagos_nombre,--str_data[62]
					contacto_pagos_puesto,--str_data[63]
					contacto_pagos_calle,--str_data[64]
					contacto_pagos_numero,--str_data[65]
					contacto_pagos_colonia,--str_data[66]
					contacto_pagos_cp,--str_data[67]
					contacto_pagos_entre_calles,--str_data[68]
					contacto_pagos_pais_id,--str_data[69]::integer
					contacto_pagos_estado_id,--str_data[70]::integer
					contacto_pagos_municipio_id,--str_data[71]::integer
					contacto_pagos_telefono1,--str_data[72]
					contacto_pagos_extension1,--str_data[73]
					contacto_pagos_fax,--str_data[74]
					contacto_pagos_telefono2,--str_data[75]
					contacto_pagos_extension2,--str_data[76]
					contacto_pagos_email,--str_data[77]
					empresa_immex,--str_data[78]::boolean,
					tasa_ret_immex,--str_data[79]::double precision,
					dia_revision,--str_data[80]::smallint,
					dia_pago,--str_data[81]::smallint,
					cta_pago_mn,--str_data[82],
					cta_pago_usd,--str_data[83],
					ctb_cta_id_activo,--str_data[84]::integer,
					ctb_cta_id_ingreso,--str_data[85]::integer,
					ctb_cta_id_ietu,--str_data[86]::integer,
					ctb_cta_id_comple,--str_data[87]::integer,
					ctb_cta_id_activo_comple,--str_data[88]::integer,
					lista_precio,--str_data[89]::integer,
					fac_metodos_pago_id,--str_data[90]::integer,
					empresa_id,--emp_id
					sucursal_id,--suc_id
					borrado_logico,--false
					momento_creacion,--now()
					id_usuario_creacion--usuario_id
				)VALUES (
					nuevo_folio,
					str_data[6],
					str_data[7],
					str_data[8],
					str_data[9],
					str_data[10],
					str_data[11],
					str_data[12],
					str_data[13],
					str_data[14],
					str_data[15],
					str_data[16]::integer,
					str_data[17]::integer,
					str_data[18]::integer,
					str_data[19],
					str_data[20],
					str_data[21],
					str_data[22],
					str_data[23],
					str_data[24],
					str_data[25],
					str_data[26]::integer,
					str_data[27],
					str_data[28]::integer,
					str_data[29]::integer,
					str_data[30]::integer,
					str_data[31]::integer,
					str_data[32]::integer,
					str_data[33]::integer,
					str_data[34]::integer,
					str_data[35]::boolean,
					str_data[36]::boolean,
					str_data[37]::integer,
					str_data[38]::double precision,
					str_data[39]::integer,
					str_data[40]::boolean,
					str_data[41]::integer,
					str_data[42]::integer,
					str_data[43]::integer,
					str_data[44],
					str_data[45],
					str_data[46],
					str_data[47],
					str_data[48],
					str_data[49],
					str_data[50],
					str_data[51],
					str_data[52],
					str_data[53]::integer,
					str_data[54]::integer,
					str_data[55]::integer,
					str_data[56],
					str_data[57],
					str_data[58],
					str_data[59],
					str_data[60],
					str_data[61],
					str_data[62],
					str_data[63],
					str_data[64],
					str_data[65],
					str_data[66],
					str_data[67],
					str_data[68],
					str_data[69]::integer,
					str_data[70]::integer,
					str_data[71]::integer,
					str_data[72],
					str_data[73],
					str_data[74],
					str_data[75],
					str_data[76],
					str_data[77],
					str_data[78]::boolean,
					str_data[79]::double precision,
					str_data[80]::smallint,
					str_data[81]::smallint,
					str_data[82],
					str_data[83],
					str_data[84]::integer,
					str_data[85]::integer,
					str_data[86]::integer,
					str_data[87]::integer,
					str_data[88]::integer,
					str_data[89]::integer,
					str_data[90]::integer,
					emp_id,
					suc_id,
					false,
					now(),
					usuario_id
				)RETURNING id INTO ultimo_id;
			
				
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1] calle
					--str_filas[2] numero
					--str_filas[3] colonia
					--str_filas[4] idpais
					--str_filas[5] identidad
					--str_filas[6] idlocalidad
					--str_filas[7] codigop
					--str_filas[8] localternativa
					--str_filas[9] telefono
					--str_filas[10] numfax
					
					INSERT INTO erp_clients_consignacions(cliente_id, calle, numero, colonia, pais_id, estado_id, municipio_id, cp, localidad_alternativa, telefono, fax, momento_creacion)
					VALUES(ultimo_id, str_filas[1], str_filas[2], str_filas[3], str_filas[4]::integer, str_filas[5]::integer, str_filas[6]::integer, str_filas[7], str_filas[8], str_filas[9], str_filas[10], now());
					
				END LOOP;
				
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			--SELECT INTO str_data string_to_array(''||campos_data||'','___');
			--RAISE EXCEPTION '%',str_data[1];
			--RAISE EXCEPTION '%',identificador;
			UPDATE cxc_clie SET 
					rfc=str_data[6],
					curp=str_data[7],
					razon_social=str_data[8],
					clave_comercial=str_data[9],
					calle=str_data[10],
					numero=str_data[11],
					entre_calles=str_data[12],
					numero_exterior=str_data[13],
					colonia=str_data[14],
					cp=str_data[15],
					pais_id=str_data[16]::integer,
					estado_id=str_data[17]::integer,
					municipio_id=str_data[18]::integer,
					localidad_alternativa=str_data[19],
					telefono1=str_data[20],
					extension1=str_data[21],
					fax=str_data[22],
					telefono2=str_data[23],
					extension2=str_data[24],
					email=str_data[25],
					cxc_agen_id=str_data[26]::integer,
					contacto=str_data[27],
					zona_id=str_data[28]::integer,
					cxc_clie_grupo_id=str_data[29]::integer,
					clienttipo_id=str_data[30]::integer,
					clasif_1=str_data[31]::integer,
					clasif_2=str_data[32]::integer,
					clasif_3=str_data[33]::integer,
					moneda=str_data[34]::integer,
					filial=str_data[35]::boolean,
					estatus=str_data[36]::boolean,
					gral_imp_id=str_data[37]::integer,
					limite_credito=str_data[38]::double precision,
					dias_credito_id=str_data[39]::integer,
					credito_suspendido=str_data[40]::boolean,
					credito_a_partir=str_data[41]::integer,
					cxp_prov_tipo_embarque_id=str_data[42]::integer,
					dias_caducidad_cotizacion=str_data[43]::integer,
					condiciones=str_data[44],
					observaciones=str_data[45],
					contacto_compras_nombre=str_data[46],
					contacto_compras_puesto=str_data[47],
					contacto_compras_calle=str_data[48],
					contacto_compras_numero=str_data[49],
					contacto_compras_colonia=str_data[50],
					contacto_compras_cp=str_data[51],
					contacto_compras_entre_calles=str_data[52],
					contacto_compras_pais_id=str_data[53]::integer,
					contacto_compras_estado_id=str_data[54]::integer,
					contacto_compras_municipio_id=str_data[55]::integer,
					contacto_compras_telefono1=str_data[56],
					contacto_compras_extension1=str_data[57],
					contacto_compras_fax=str_data[58],
					contacto_compras_telefono2=str_data[59],
					contacto_compras_extension2=str_data[60],
					contacto_compras_email=str_data[61],
					contacto_pagos_nombre=str_data[62],
					contacto_pagos_puesto=str_data[63],
					contacto_pagos_calle=str_data[64],
					contacto_pagos_numero=str_data[65],
					contacto_pagos_colonia=str_data[66],
					contacto_pagos_cp=str_data[67],
					contacto_pagos_entre_calles=str_data[68],
					contacto_pagos_pais_id=str_data[69]::integer,
					contacto_pagos_estado_id=str_data[70]::integer,
					contacto_pagos_municipio_id=str_data[71]::integer,
					contacto_pagos_telefono1=str_data[72],
					contacto_pagos_extension1=str_data[73],
					contacto_pagos_fax=str_data[74],
					contacto_pagos_telefono2=str_data[75],
					contacto_pagos_extension2=str_data[76],
					contacto_pagos_email=str_data[77],
					empresa_immex=str_data[78]::boolean,
					tasa_ret_immex=str_data[79]::double precision,
					dia_revision=str_data[80]::smallint,
					dia_pago=str_data[81]::smallint,
					cta_pago_mn=str_data[82],
					cta_pago_usd=str_data[83],
					ctb_cta_id_activo=str_data[84]::integer,
					ctb_cta_id_ingreso=str_data[85]::integer,
					ctb_cta_id_ietu=str_data[86]::integer,
					ctb_cta_id_comple=str_data[87]::integer,
					ctb_cta_id_activo_comple=str_data[88]::integer,
					lista_precio=str_data[89]::integer,
					fac_metodos_pago_id=str_data[90]::integer,
					momento_actualizacion = now(),
					id_usuario_actualizacion = usuario_id,
					empresa_id=emp_id,
					sucursal_id=suc_id
			WHERE id=str_data[4]::integer;
			
			--eliminar direcciones de este cliente en la tabla clients_consignacions
			DELETE FROM erp_clients_consignacions WHERE cliente_id = str_data[4]::integer;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--aqui se vuelven a crear los registros
					INSERT INTO erp_clients_consignacions(cliente_id,calle,numero,colonia,pais_id,estado_id,municipio_id,cp,localidad_alternativa,telefono,fax,momento_creacion)
					VALUES(str_data[3]::integer,str_filas[1],str_filas[2],str_filas[3],str_filas[4]::integer,str_filas[5]::integer,str_filas[6]::integer,str_filas[7],str_filas[8],str_filas[9],str_filas[10],now());
					
				END LOOP;
				
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxc_clie SET borrado_logico=true, momento_baja=now(),id_usuario_baja = str_data[3]::integer WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;

	END IF;--termina catalogo de clientes
	
	
	
	-- Catalogo de Productos
	IF app_selected = 8 THEN
		
		IF str_data[15]::integer=0 THEN
			meta_imp:='exento';
		END IF;
		IF str_data[15]::integer=1 THEN
			meta_imp:='iva_1';
		END IF;
		IF str_data[15]::integer=2 THEN
			meta_imp:='tasa_cero';
		END IF;
		
		--query para verificar si la Empresa actual incluye Modulo de Produccion, Modulo de Contabilidad y Modulo de Envasado
		SELECT incluye_produccion, incluye_contabilidad, encluye_envasado FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, incluye_modulo_contabilidad, incluye_modulo_envasado;
		
		IF command_selected = 'new' THEN
			id_tipo_consecutivo:=3;--Folio de pproducto

			--alter para catalogo productos
			--ALTER TABLE inv_prod ADD COLUMN archivo_pdf character varying DEFAULT '';
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			--UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			--WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			--nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			nuevo_folio := str_data[31];
			tipo_producto:=str_data[18]::integer;
			INSERT INTO inv_prod(	
				sku,--nuevo_folio
				descripcion,--str_data[5]
				codigo_barras,--str_data[6]
				tentrega,--str_data[7]::integer,
				inv_clas_id,--str_data[8]::integer
				inv_stock_clasif_id,--str_data[9]::integer
				estatus,--str_data[10]::boolean
				inv_prod_familia_id,--str_data[11]::integer
				subfamilia_id,--str_data[12]::integer
				inv_prod_grupo_id,--str_data[13]::integer
				ieps,--str_data[14]::integer
				--meta_impuesto,--meta_imp
				gral_impto_id,--str_data[15]::integer,
				inv_prod_linea_id,--str_data[16]::integer
				inv_mar_id,--str_data[17]::integer
				tipo_de_producto_id,--str_data[18]::integer
				inv_seccion_id,--str_data[19]::integer
				unidad_id,--str_data[20]::integer
				requiere_numero_lote,--str_data[21]::boolean
				requiere_nom,--str_data[22]::boolean
				requiere_numero_serie,--str_data[23]::boolean
				requiere_pedimento,--str_data[24]::boolean
				permitir_stock,--str_data[25]::boolean
				venta_moneda_extranjera,--str_data[26]::boolean
				compra_moneda_extranjera,--str_data[27]::boolean
				cxp_prov_id,--str_data[29]::integer
				densidad,--str_data[30]::double precision
				valor_maximo,--str_data[32]::double precision
				valor_minimo,--str_data[33]::double precision
				punto_reorden,--str_data[34]::double precision
				ctb_cta_id_gasto, --str_data[35]::integer,
				ctb_cta_id_costo_venta, --str_data[36]::integer,
				ctb_cta_id_venta, --str_data[37]::integer,
				borrado_logico,--false
				momento_creacion,--now()
				id_usuario_creacion,--usuario_id
				empresa_id,--emp_id
				sucursal_id,--suc_id
				descripcion_corta,--str_data[40]
				descripcion_larga,--str_data[41]
				archivo_img,--str_data[38]
				archivo_pdf,--str_data[39]
				inv_prod_presentacion_id,--str_data[42]::integer
				flete,--str_data[43]::boolean,
				no_clie,--str_data[44]
				gral_mon_id,--str_data[45]::integer
				gral_imptos_ret_id, --str_data[46]::integer
				cfdi_prodserv_id --str_data[47]::integer
			) values(
				nuevo_folio,
				str_data[5],
				str_data[6],
				str_data[7]::integer,
				str_data[8]::integer,
				str_data[9]::integer,
				str_data[10]::boolean,
				str_data[11]::integer,
				str_data[12]::integer,
				str_data[13]::integer,
				str_data[14]::integer,
				--meta_imp,
				str_data[15]::integer,
				str_data[16]::integer,
				str_data[17]::integer,
				str_data[18]::integer,
				str_data[19]::integer,
				str_data[20]::integer,
				str_data[21]::boolean,
				str_data[22]::boolean,
				str_data[23]::boolean,
				str_data[24]::boolean,
				str_data[25]::boolean,
				str_data[26]::boolean,
				str_data[27]::boolean,
				str_data[29]::integer,
				str_data[30]::double precision,
				str_data[32]::double precision,
				str_data[33]::double precision,
				str_data[34]::double precision,
				str_data[35]::integer,
				str_data[36]::integer,
				str_data[37]::integer,
				false,
				now(),
				usuario_id,
				emp_id,
				suc_id,
				str_data[40],
				str_data[41],
				str_data[38],
				str_data[39],
				str_data[42]::integer,
				str_data[43]::boolean,
				str_data[44],
				str_data[45]::integer,
				str_data[46]::integer,
				str_data[47]::integer
			)RETURNING id INTO id_producto;
			
			--convertir en arreglo los id de presentaciones de producto
			SELECT INTO str_pres string_to_array(str_data[28],',');
			
			--obtiene numero de elementos del arreglo str_pres
			tot_filas:= array_length(str_pres,1);
			
			
			--Si el tiopo de producto es diferente de 3 y 4, hay que guardar presentaciones
			--tipo=3 Kit
			--tipo=4 Servicios
			--IF str_data[18]::integer!=3 AND str_data[18]::integer!=4 THEN
				
				FOR cont_fila_pres IN 1 .. tot_filas LOOP
					--Crea registros de presentaciones  en tabla inv_prod_pres_x_prod
					INSERT INTO inv_prod_pres_x_prod(producto_id,presentacion_id) VALUES (id_producto,str_pres[cont_fila_pres]::integer);
					
					--Crea registro por cada presentacion en la tabla de precios 
					INSERT INTO inv_pre (gral_emp_id, inv_prod_id, inv_prod_presentacion_id, momento_creacion,borrado_logico,precio_1, precio_2, precio_3, precio_4, precio_5, precio_6, precio_7, precio_8, precio_9, precio_10, gral_mon_id_pre1, gral_mon_id_pre2, gral_mon_id_pre3, gral_mon_id_pre4, gral_mon_id_pre5, gral_mon_id_pre6, gral_mon_id_pre7, gral_mon_id_pre8, gral_mon_id_pre9, gral_mon_id_pre10, descuento_1,descuento_2,descuento_3,descuento_4,descuento_5,descuento_6,descuento_7,descuento_8,descuento_9,descuento_10,default_precio_1,default_precio_2,default_precio_3,default_precio_4,default_precio_5,default_precio_6,default_precio_7,default_precio_8,default_precio_9,default_precio_10,operacion_precio_1,operacion_precio_2,operacion_precio_3,operacion_precio_4,operacion_precio_5,operacion_precio_6,operacion_precio_7,operacion_precio_8,operacion_precio_9,operacion_precio_10,calculo_precio_1,calculo_precio_2,calculo_precio_3,calculo_precio_4,calculo_precio_5,calculo_precio_6,calculo_precio_7,calculo_precio_8,calculo_precio_9,calculo_precio_10,redondeo_precio_1,redondeo_precio_2,redondeo_precio_3,redondeo_precio_4,redondeo_precio_5,redondeo_precio_6,redondeo_precio_7,redondeo_precio_8,redondeo_precio_9,redondeo_precio_10) 
					VALUES(emp_id, id_producto,str_pres[cont_fila_pres]::integer, now(), false, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,0,0,0,0,0,0,0,0,0 ,0,0,0,0,0,0,0,0,0,0,  1,1,1,1,1,1,1,1,1,1 ,1,1,1,1,1,1,1,1,1,1,  0,0,0,0,0,0,0,0,0,0);
				END LOOP;
			--END IF;
			
			IF incluye_modulo_produccion=TRUE THEN 
				--para Producto 3=Kit
				IF tipo_producto=3 THEN
					total_filas:= array_length(extra_data,1);
					cont_fila:=1;
					IF extra_data[1]<>'sin datos' THEN
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							--str_filas[1] eliminado
							IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--ya no se valida nada
								--str_filas[1]	producto_ingrediente_id
								--str_filas[2] 	porcentaje
								--INSERT INTO inv_prod_formulaciones(producto_formulacion_id,producto_ingrediente_id,porcentaje) VALUES (id_producto,str_filas[1]::integer,str_filas[2]::double precision);
								INSERT INTO inv_kit(producto_kit_id,producto_elemento_id,cantidad) 
								VALUES (id_producto,str_filas[1]::integer,str_filas[2]::double precision);
							END IF;
						END LOOP;
					END IF;
				END IF;	
			ELSE
				--para Producto 1=TERMINADO, 2=INTERMEDIO, 3=KIT, 8=DESARROLLO
				IF tipo_producto=1 OR tipo_producto=2 OR tipo_producto=3 OR tipo_producto=8 THEN 
					total_filas:= array_length(extra_data,1);
					cont_fila:=1;
					IF extra_data[1]<>'sin datos' THEN
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							--str_filas[1] eliminado
							IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--ya no se valida nada
								--str_filas[1]	producto_ingrediente_id
								--str_filas[2] 	porcentaje
								--INSERT INTO inv_prod_formulaciones(producto_formulacion_id,producto_ingrediente_id,porcentaje) VALUES (id_producto,str_filas[1]::integer,str_filas[2]::double precision);
								INSERT INTO inv_kit(producto_kit_id,producto_elemento_id,cantidad) VALUES(id_producto,str_filas[1]::integer,str_filas[2]::double precision);
							END IF;
						END LOOP;
					END IF;
				END IF;
			END IF;
			
			
			--Si el tipo de producto es DIFERENTE DE 3=Kit Y 4=Servicios
			IF str_data[18]::integer<>3 AND str_data[18]::integer<>4 THEN
				--Genera registro en la tabla inv_exi
				FOR fila2 IN EXECUTE('SELECT distinct inv_suc_alm.almacen_id FROM gral_suc JOIN inv_suc_alm ON inv_suc_alm.sucursal_id=gral_suc.id WHERE gral_suc.empresa_id='||emp_id||' ORDER BY inv_suc_alm.almacen_id') LOOP
					INSERT INTO inv_exi(inv_prod_id, inv_alm_id, ano, exi_inicial, transito) VALUES(id_producto, fila2.almacen_id, ano_actual, 0, 0);
				END LOOP;
				
				if str_data[45]::integer=1 then 
					--Si es MN, el tipo de cambio es 1
					valor1:=1;
				else
					--Buscar el tipo de cambio del d√≠a
					SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=str_data[45]::integer ORDER BY momento_creacion DESC LIMIT 1 into valor1;
					if valor1 is null then valor1:=1; end if;
				end if;
				
				--Genera registro en la tabla 
				INSERT INTO inv_prod_cost_prom(inv_prod_id, ano,gral_mon_id_1,gral_mon_id_2,gral_mon_id_3,gral_mon_id_4,gral_mon_id_5,gral_mon_id_6,gral_mon_id_7,gral_mon_id_8,gral_mon_id_9,gral_mon_id_10,gral_mon_id_11,gral_mon_id_12,tipo_cambio_1,tipo_cambio_2,tipo_cambio_3,tipo_cambio_4,tipo_cambio_5,tipo_cambio_6,tipo_cambio_7,tipo_cambio_8,tipo_cambio_9,tipo_cambio_10,tipo_cambio_11,tipo_cambio_12) 
				VALUES(id_producto, ano_actual,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,str_data[45]::integer,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1,valor1);
			END IF;
			
			valor_retorno := '1';
		END IF;--termina nuevo producto
		
		
		IF command_selected = 'edit' THEN
			nuevo_folio := str_data[31];
			tipo_producto:=str_data[18]::integer;
			UPDATE inv_prod SET 
				sku=nuevo_folio,--nuevo_folio, 
				descripcion=str_data[5],
				codigo_barras=str_data[6],
				tentrega=str_data[7]::integer,
				inv_clas_id=str_data[8]::integer,
				inv_stock_clasif_id=str_data[9]::integer,
				estatus=str_data[10]::boolean,
				inv_prod_familia_id=str_data[11]::integer,
				subfamilia_id=str_data[12]::integer,
				inv_prod_grupo_id=str_data[13]::integer,
				ieps=str_data[14]::integer,
				--meta_impuesto=meta_imp,
				gral_impto_id=str_data[15]::integer,
				inv_prod_linea_id=str_data[16]::integer,
				inv_mar_id=str_data[17]::integer,
				tipo_de_producto_id=str_data[18]::integer,
				inv_seccion_id=str_data[19]::integer,
				unidad_id=str_data[20]::integer,
				requiere_numero_lote=str_data[21]::boolean,
				requiere_nom=str_data[22]::boolean,
				requiere_numero_serie=str_data[23]::boolean,
				requiere_pedimento=str_data[24]::boolean,
				permitir_stock=str_data[25]::boolean,
				venta_moneda_extranjera=str_data[26]::boolean,
				compra_moneda_extranjera=str_data[27]::boolean,
				cxp_prov_id=str_data[29]::integer,
				densidad=str_data[30]::double precision,
				valor_maximo=str_data[32]::double precision,
				valor_minimo=str_data[33]::double precision,
				punto_reorden=str_data[34]::double precision,
				ctb_cta_id_gasto=str_data[35]::integer,
				ctb_cta_id_costo_venta=str_data[36]::integer,
				ctb_cta_id_venta=str_data[37]::integer,
				momento_actualizacion=now(),
				id_usuario_actualizacion=usuario_id,
				descripcion_corta=str_data[40],
				descripcion_larga=str_data[41],
				archivo_img=str_data[38],
				archivo_pdf=str_data[39],
				inv_prod_presentacion_id=str_data[42]::integer,
				flete=str_data[43]::boolean,
				no_clie=str_data[44],
				gral_mon_id=str_data[45]::integer,
				gral_imptos_ret_id=str_data[46]::integer,
				cfdi_prodserv_id=str_data[47]::integer				
			WHERE id=str_data[4]::integer;
			
			--convertir en arreglo los id de presentaciones de producto
			SELECT INTO str_pres string_to_array(str_data[28],',');
			
			--obtiene numero de elementos del arreglo str_pres
			tot_filas:= array_length(str_pres,1);
			
			--elimina los registros de las presentaciones del producto
			DELETE FROM inv_prod_pres_x_prod WHERE producto_id=str_data[4]::integer;
			
			--Si el tiopo de producto es diferente de 3 y 4, hay que guardar presentaciones
			--tipo=3 Kit
			--tipo=4 Servicios
			--IF str_data[18]::integer!=3 AND str_data[18]::integer!=4 THEN
				--aqui se vuelven a crear los registros de las presentaciones del producto
				FOR cont_fila_pres IN 1 .. tot_filas LOOP
					INSERT INTO inv_prod_pres_x_prod(producto_id,presentacion_id) VALUES (str_data[4]::integer,str_pres[cont_fila_pres]::integer);
				END LOOP;
			--END IF;
			
			FOR fila IN EXECUTE('SELECT id, inv_prod_id, inv_prod_presentacion_id FROM inv_prod_costos WHERE inv_prod_id='||str_data[4]::integer||' AND ano=EXTRACT(YEAR FROM now())') LOOP
				exis:=0;
				SELECT count(id) FROM inv_prod_pres_x_prod WHERE producto_id=fila.inv_prod_id AND presentacion_id=fila.inv_prod_presentacion_id INTO exis;
				IF exis<=0 THEN 
					DELETE FROM inv_prod_costos WHERE id=fila.id;
				END IF;
			END LOOP;
			
			FOR fila IN EXECUTE('SELECT id, inv_prod_id, inv_prod_presentacion_id FROM inv_pre WHERE inv_prod_id='||str_data[4]::integer||' AND gral_emp_id='||emp_id) LOOP
				exis:=0;
				SELECT count(id) FROM inv_prod_pres_x_prod WHERE producto_id=fila.inv_prod_id AND presentacion_id=fila.inv_prod_presentacion_id INTO exis;
				IF exis<=0 THEN 
					DELETE FROM inv_pre WHERE id=fila.id;
				END IF;
			END LOOP;
			
			IF controlExisPres THEN 
				FOR fila IN EXECUTE('SELECT id, inv_prod_id, inv_prod_presentacion_id FROM inv_exi_pres WHERE inv_prod_id='||str_data[4]::integer) LOOP
					exis:=0;
					SELECT count(id) FROM inv_prod_pres_x_prod WHERE producto_id=fila.inv_prod_id AND presentacion_id=fila.inv_prod_presentacion_id INTO exis;
					IF exis<=0 THEN 
						DELETE FROM inv_exi_pres WHERE id=fila.id;
					END IF;
				END LOOP;

				FOR fila IN EXECUTE('select id, inv_prod_id, inv_prod_presentacion_id from env_conf where inv_prod_id='||str_data[4]::integer) LOOP
					exis:=0;
					SELECT count(id) FROM inv_prod_pres_x_prod WHERE producto_id=fila.inv_prod_id AND presentacion_id=fila.inv_prod_presentacion_id INTO exis;
					IF exis<=0 THEN 
						DELETE FROM env_conf WHERE id=fila.id;
						DELETE FROM env_conf_det WHERE env_conf_id=fila.id;
					END IF;
				END LOOP;
			END IF;
			
				
			IF incluye_modulo_produccion=TRUE THEN 
				--para Producto 3=Kit
				IF tipo_producto=3 THEN
					--elimina los prod ingredientes de la tabla inv_kit
					DELETE FROM inv_kit  WHERE producto_kit_id = str_data[4]::integer;
					
					total_filas:= array_length(extra_data,1);
					cont_fila:=1;
					IF extra_data[1] != 'sin datos' THEN
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							--str_filas[1] eliminado
							IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
								--ya no se valida nada
								--str_filas[1]	producto_elemento_id
								--str_filas[2] 	cantidad
								INSERT INTO inv_kit(producto_kit_id,producto_elemento_id,cantidad) VALUES (str_data[4]::integer,str_filas[1]::integer,str_filas[2]::double precision);
							END IF;
						END LOOP;
					END IF;
				END IF;	
			ELSE
				
				--Para Producto 1=TERMINADO, 2=INTERMEDIO, 3=KIT, 8=DESARROLLO
				IF tipo_producto=1 OR tipo_producto=2 OR tipo_producto=3 OR tipo_producto=8 THEN 
					--elimina los prod ingredientes de la tabla inv_kit
					DELETE FROM inv_kit  WHERE producto_kit_id=str_data[4]::integer;

					--RAISE EXCEPTION '%','extra_data: '||extra_data;
					
					total_filas:= array_length(extra_data,1);
					cont_fila:=1;
					IF extra_data[1] != 'sin datos' THEN
						FOR cont_fila IN 1 .. total_filas LOOP
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							--str_filas[1] eliminado
							IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
								--str_filas[1]	producto_elemento_id
								--str_filas[2] 	cantidad
								INSERT INTO inv_kit(producto_kit_id,producto_elemento_id,cantidad) VALUES (str_data[4]::integer,str_filas[1]::integer,str_filas[2]::double precision);
							END IF;
						END LOOP;
					END IF;
				END IF;	
			END IF;
			
			valor_retorno := '1';
		END IF;--termina edit producto
		
		
		
		IF command_selected = 'delete' THEN
			valor_retorno := '1';
			
			IF incluye_modulo_produccion=TRUE THEN
				--aqui buscamos si el producto es formulado
				SELECT count(inv_prod_id) FROM pro_estruc  WHERE inv_prod_id=str_data[4]::integer AND borrado_logico=FALSE INTO exis;
				IF exis > 0 THEN
					valor_retorno := '01';
				ELSE
					exis:=0; --inicializar variable
					--aqui buscamos si el producto forma parte de una formula
					SELECT count(pro_estruc_det.inv_prod_id) FROM pro_estruc_det JOIN pro_estruc ON pro_estruc.id=pro_estruc_det.pro_estruc_id WHERE pro_estruc_det.inv_prod_id=str_data[4]::integer  AND pro_estruc.borrado_logico=FALSE 
					INTO exis;
					
					IF exis > 0 THEN
						valor_retorno := '02';
					END IF;
				END IF;
				
				IF valor_retorno='1' THEN 
					--si el valor retorno sigue igual a 1, entonces tambien buscamos en la tabla de kits
					SELECT count(producto_elemento_id) FROM inv_kit WHERE producto_elemento_id=str_data[4]::integer INTO exis;
					IF exis > 0 THEN
						valor_retorno := '03';
					END IF;
				END IF;
			ELSE
				SELECT count(producto_elemento_id) FROM inv_kit WHERE producto_elemento_id=str_data[4]::integer INTO exis;
				IF exis > 0 THEN
					valor_retorno := '04';
				END IF;
			END IF;
			
			
			IF incluye_modulo_envasado=TRUE THEN 
				--verificamos que el producto no forme parte de una configuracion de envase
				exis:=0;
				SELECT count(env_conf_det.inv_prod_id) FROM env_conf JOIN  env_conf_det ON env_conf_det.env_conf_id=env_conf.id WHERE env_conf_det.inv_prod_id=str_data[4]::integer AND env_conf.borrado_logico=FALSE 
				INTO exis;
				IF exis > 0 THEN
					valor_retorno := '05';
				END IF;
			END IF;


			IF (select sum((inv_exi.exi_inicial - inv_exi.transito - inv_exi.reservado  + inv_exi.entradas_1 - inv_exi.salidas_1 + inv_exi.entradas_2 - inv_exi.salidas_2 + inv_exi.entradas_3 - inv_exi.salidas_3 + inv_exi.entradas_4 - inv_exi.salidas_4 + inv_exi.entradas_5 - inv_exi.salidas_5 + inv_exi.entradas_6 - inv_exi.salidas_6 + inv_exi.entradas_7 - inv_exi.salidas_7 + inv_exi.entradas_8 - inv_exi.salidas_8 + inv_exi.entradas_9 - inv_exi.salidas_9 + inv_exi.entradas_10 - inv_exi.salidas_10 + inv_exi.entradas_11 - inv_exi.salidas_11 + inv_exi.entradas_12 - inv_exi.salidas_12)) AS existencia FROM inv_exi WHERE inv_prod_id=str_data[4]::integer)>0.0001 THEN 
				--No se puede eliminar porque hay existencia en uno o mas almacenes
				valor_retorno := '06';
			END IF;
			
			
			--Si valor retorno es igual a 1, entonces procedemos a eliminar el producto
			IF valor_retorno='1' THEN 
				UPDATE inv_prod SET borrado_logico=true, momento_baja=now(), id_usuario_baja = usuario_id
				WHERE id = str_data[4]::integer;
				
				--elimina los registros de las formulacion del producto
				DELETE FROM inv_kit  WHERE producto_kit_id = str_data[4]::integer;
				
				--elimina los registros de las presentaciones del producto
				DELETE FROM inv_prod_pres_x_prod WHERE producto_id=str_data[4]::integer;
				
				DELETE FROM inv_prod_costos WHERE inv_prod_id=str_data[4]::integer AND ano=EXTRACT(YEAR FROM now());

				DELETE FROM inv_pre WHERE inv_prod_id=str_data[4]::integer AND gral_emp_id=emp_id;

				DELETE FROM inv_exi_pres WHERE inv_prod_id=str_data[4]::integer;
			END IF;
			
			--valor_retorno := '1';
		END IF;
	END IF;
	--termina catalogo de productos
	
	
	
	
	-- prefacturas
	IF app_selected = 13 THEN
		IF command_selected = 'new' THEN
			
			--str_data[3]	id_usuario
			--str_data[4]	id_prefactura
			--str_data[5] 	id_cliente
			--str_data[6]	moneda
			--str_data[7]	observaciones
			--str_data[8]	subtotal
			--str_data[9]	impuesto
			--str_data[10]	total
			--str_data[11]	tipo_cambio
			--str_data[12]	id_vendedor
			--str_data[13]	id_condiciones
			--str_data[14]	orden_compra
			--str_data[15]	refacturar
			--str_data[16]	id_metodo_pago
			--str_data[17]	no_cuenta
			--str_data[19]	tipo_documento
			
			
			--crea registro en tabla erp_proceso y retorna el id del registro creado
			INSERT INTO  erp_proceso(proceso_flujo_id,empresa_id,sucursal_id)VALUES(2, emp_id, suc_id) RETURNING id into ultimo_id_proceso;
			
			--crear registro en la tabla cotizacions y retorna el id del registro creado
			 INSERT INTO  erp_prefacturas(
				  cliente_id,
				  moneda_id,
				  observaciones,
				  subtotal,
				  impuesto,
				  total,
				  proceso_id,
				  tipo_cambio,
				  empleado_id,
				  terminos_id,
				  orden_compra,
				  refacturar,
				  fac_metodos_pago_id,
				  no_tarjeta,
				  id_usuario_creacion,
				  momento_creacion
			)
			VALUES(
				  str_data[5]::integer,
				  str_data[6]::integer,
				  str_data[7],
				  str_data[8]::double precision,
				  str_data[9]::double precision,
				  str_data[10]::double precision,
				  ultimo_id_proceso,
				  str_data[11]::double precision,
				  str_data[12]::integer,
				  str_data[13]::integer,
				  str_data[14],
				  str_data[15]::boolean,
				  str_data[16]::integer,
				  str_data[17],
				  str_data[3]::integer,
				  now()
			) RETURNING id into ultimo_id;
			
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					
					--crea registros para tabla invfisico-detalles
					INSERT INTO erp_prefacturas_detalles(
						  producto_id,
						  presentacion_id,
						  tipo_impuesto_id,
						  cantidad,
						  precio_unitario,
						  prefacturas_id,
						  momento_creacion
					)VALUES(
						  str_filas[3]::integer,
						  str_filas[4]::integer,
						  str_filas[5]::integer,
						  str_filas[6]::double precision,
						  str_filas[7]::double precision,
						  ultimo_id,
						  now()
					);
					
					IF str_data[16]='true' THEN
						
						
					END IF;
					
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;--termina nueva prefactura
		
		
		
		IF command_selected = 'edit' THEN
			--str_data[3]	id_usuario
			--str_data[4]	id_prefactura
			--str_data[5] 	id_cliente
			--str_data[6]	moneda
			--str_data[7]	observaciones
			--str_data[8]	subtotal
			--str_data[9]	impuesto
			--str_data[10]	total
			--str_data[11]	tipo_cambio
			--str_data[12]	id_vendedor
			--str_data[13]	id_condiciones
			--str_data[14]	orden_compra
			--str_data[15]	refacturar
			--str_data[16]	id_metodo_pago
			--str_data[17]	no_cuenta
			--str_data[19]	tipo_documento
			UPDATE erp_prefacturas SET 
				cliente_id = str_data[5]::integer, 
				moneda_id = str_data[6]::integer, 
				observaciones = str_data[7], 
				subtotal = str_data[8]::double precision, 
				impuesto = str_data[9]::double precision, 
				total = str_data[10]::double precision, 
				tipo_cambio = str_data[11]::double precision,
				empleado_id=str_data[12]::integer,
				terminos_id=str_data[13]::integer,
				orden_compra=str_data[14],
				refacturar=str_data[15]::boolean, 
				fac_metodos_pago_id=str_data[16]::integer,
				no_tarjeta=str_data[17],
				id_usuario_actualizacion = str_data[3]::integer,
				momento_actualizacion = now()
			WHERE id = str_data[4]::integer;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				--str_filas[1] 0:eliminado, 1:no eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					
					--verifica si trae un id. Este id es el id del registro en la tabla cotizacions_detalles
					IF str_filas[2] !='0' THEN
						--RAISE EXCEPTION '%','No es nuevo';
						--actualiza registros en la tabla invfisico-detalles
						UPDATE erp_prefacturas_detalles SET cantidad = str_filas[6]::double precision,precio_unitario = str_filas[7]::double precision,tipo_impuesto_id = str_filas[5]::integer
						WHERE  id = str_filas[2]::integer  AND prefacturas_id = str_data[4]::integer;
					ELSE
						--RAISE EXCEPTION '%','Este si es nuevo es nuevo: '||str_filas[2];
						--crea nuevos registros
						INSERT INTO erp_prefacturas_detalles(prefacturas_id,producto_id,presentacion_id,tipo_impuesto_id,cantidad,precio_unitario,momento_creacion)
						VALUES(str_data[4]::integer,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::integer,str_filas[6]::double precision,str_filas[7]::double precision,now());
					END IF;
				ELSE
					--elimina registro que se elimino en el grid
					DELETE FROM erp_prefacturas_detalles where id = str_filas[2]::integer  AND prefacturas_id = str_data[4]::integer;
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;--termina edit prefactura
		
		IF command_selected = 'delete' THEN
			UPDATE erp_prefacturas SET borrado_logico = true, momento_baja = now(),id_usuario_baja = str_data[3]::integer
			where id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
	END IF;--termina prefacturas
	
	
	-- pagos
	IF app_selected = 14 THEN

		id_tipo_consecutivo:=11;--Numero de transaccion pago CXC
		
		--aqui entra para tomar el consecutivo del folio  la sucursal actual
		UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
		WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
		
		--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
		--nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

		
		--nuevo folio transaccion
		folio_transaccion := nuevo_consecutivo::bigint;
		
		
		IF command_selected = 'pago' THEN
			--obtiene id de la forma de pago
			SELECT id FROM erp_pagos_formas WHERE titulo ILIKE str_data[11] LIMIT 1 into id_forma_pago;
			
			id_anticipo := 0;
			monto_anticipo_actual:=0;
			--obtener id del anticipo
			SELECT COUNT(id) FROM cxc_ant WHERE numero_transaccion = str_data[23]::bigint AND cliente_id=str_data[4]::integer and borrado_logico=false INTO rowCount;
			IF rowCount > 0 THEN
				SELECT id, anticipo_actual FROM cxc_ant WHERE numero_transaccion = str_data[23]::bigint AND cliente_id = str_data[4]::integer   LIMIT 1 
				INTO id_anticipo, monto_anticipo_actual;
			END IF;
			
			INSERT INTO erp_pagos (
					numero_transaccion,
					momento_creacion,
					forma_pago_id,
					numero_cheque,
					referencia,
					numero_tarjeta,
					observaciones,
					id_usuario_pago,
					banco_id,
					moneda_id,
					monto_pago,
					cliente_id,
					fecha_deposito,
					numerocuenta_id,
					movimiento,
					bancokemikal_id,
					tipo_cambio,
					anticipo_id,
					empresa_id,
					sucursal_id
				)
			VALUES (folio_transaccion,
					now(),
					id_forma_pago,
					str_data[12],
					str_data[13],
					str_data[14],
					str_data[10],
					str_data[3]::integer,
					str_data[9]::integer,
					str_data[7]::integer,
					str_data[16]::double precision,
					str_data[4]::integer,
					str_data[17]::timestamp with time zone,
					str_data[19]::integer,
					str_data[18],
					str_data[20]::integer,
					str_data[21]::double precision,
					id_anticipo,
					emp_id, 
					suc_id
				) RETURNING id into ultimo_id;
				
			--str_data[3]	id_usuario
			--str_data[4]	cliente_id
			--str_data[5]	deuda_pesos
			--str_data[6]	deuda_usd
			--str_data[7]	moneda
			--str_data[8]	fecha+" "+hora+":"+minutos+":"+segundos
			--str_data[9]	banco
			--str_data[10]	observaciones
			--str_data[11]	forma_pago
			--str_data[12]	cheque
			--str_data[13]	referencia
			--str_data[14]	tarjeta
			--str_data[15]	antipo
			--str_data[16]	monto_pago
			--str_data[17]	fecha_deposito
			--str_data[18]	ficha_movimiento_deposito
			--str_data[19]	ficha_cuenta_deposito
			--str_data[20]	ficha_banco_kemikal
			--str_data[21]	tipo_cambio
			--str_data[22]	anticipo_gastado
			--str_data[23]	no_transaccion_anticipo
			--str_data[24]	saldo_a_favor
			
			--RAISE EXCEPTION '%','Si llega aqui: id_pago: '||ultimo_id_pago;
			--------------------saldando facturas--------------------------------
			--SELECT INTO item string_to_array(''||valores||'','&');
			
			SELECT INTO veces array_upper(extra_data,1);
			WHILE incrementa <= veces LOOP
				SELECT INTO iterar string_to_array(extra_data[incrementa],'___');
				--RAISE EXCEPTION '%', iterar[1];
				--iterar[1]	factura_vista
				--iterar[2]	saldado
				--iterar[3]	saldo
				--iterar[4]	tipocambio(este tipo de cambio no se utiliza, el tipo de cambio esta en pagos)
				
				SELECT moneda_id FROM fac_docs WHERE serie_folio=iterar[1] INTO id_moneda_factura;
				
				INSERT INTO erp_pagos_detalles (pago_id,serie_folio,cantidad,momento_pago,fac_moneda_id) 
				VALUES (ultimo_id,iterar[1],iterar[3]::double precision,str_data[8]::timestamp with time zone, id_moneda_factura);
				
				IF iterar[2]::boolean = true THEN
					UPDATE erp_h_facturas SET pagado=true WHERE serie_folio = iterar[1]::character varying;
					UPDATE fac_cfds SET pagado=true WHERE serie_folio ilike iterar[1]::character varying;
					--UPDATE erp_notacargos SET pagado=true WHERE serie_folio ilike iterar[1]::character varying;
				END IF;
				incrementa:= 1 + incrementa;
			END LOOP;

			sql_pagos:='SELECT serie_folio,cantidad FROM erp_pagos_detalles WHERE pago_id = '||ultimo_id;
			--RAISE EXCEPTION '%','Si llega aqui: sql-pagos: '||string_pagos;
			
			FOR fila IN EXECUTE(sql_pagos) LOOP
				EXECUTE 'SELECT monto_total,total_pagos	from  erp_h_facturas where serie_folio ilike '''||fila.serie_folio||'''' 
				INTO total_factura,monto_pagos;

				--sacar suma total de pagos para esta factura
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=fila.serie_folio AND cancelacion=FALSE) AS sbt  INTO suma_pagos;

				--sacar suma total de notas de credito para esta factura
				--SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM (SELECT sum(total) FROM fac_nota_credito WHERE serie_folio_factura=fila.serie_folio AND cancelado=FALSE) AS subtabla INTO suma_notas_credito;
				SELECT total_notas_creditos FROM erp_h_facturas WHERE serie_folio=fila.serie_folio INTO suma_notas_credito;
				
				nuevacantidad_monto_pago:=round((suma_pagos)::numeric,4)::double precision;
				nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,4)::double precision;
				
				--actualiza cantidades cada vez que se realice un pago
				UPDATE erp_h_facturas SET 
					total_pagos=nuevacantidad_monto_pago, 
					total_notas_creditos=suma_notas_credito,
					saldo_factura=nuevo_saldo_factura, 
					momento_actualizacion=now(),
					fecha_ultimo_pago=str_data[17]::date
				WHERE serie_folio=fila.serie_folio;
			END LOOP;
			
			--Inicia guardar saldos a favor y actualizar anticipos
			IF id_anticipo !=0 THEN
				--aqui entra porque el pago es de un anticipo y actualiza cantidades del anticipo
				IF monto_anticipo_actual >= str_data[22]::double precision THEN
					saldo_anticipo := monto_anticipo_actual - str_data[22]::double precision;
					IF saldo_anticipo <=0 THEN
					    UPDATE cxc_ant SET anticipo_actual=0, borrado_logico = true, id_usuario_actualizacion = str_data[3]::integer, momento_baja = now()
					    WHERE cliente_id = str_data[4]::integer AND id = id_anticipo;
					ELSE
					    UPDATE cxc_ant SET anticipo_actual = saldo_anticipo, id_usuario_baja = str_data[3]::integer, momento_actualizacion = now()
					    WHERE cliente_id = str_data[4]::integer AND id = id_anticipo;
					END IF;
				END IF;
			ELSE
				--Aqui entra porque el pago no es de un anticipo
				IF str_data[24]::double precision > 0 THEN
					/*
					INSERT INTO erp_pagosxaplicar( 
						cliente_id,
						moneda_id,
						monto_inicial,
						monto_actual,
						momento_creacion,
						id_usuario_creacion,
						empresa_id,
						sucursal_id)
					VALUES(
						str_data[4]::integer,
						str_data[7]::integer,
						str_data[24]::double precision,
						str_data[24]::double precision,
						now(),str_data[3]::integer,
						emp_id,
						suc_id	
					);
					*/
					--Aqu√≠ se genera una nuevo numero de transaccion para el anticipo des saldo a favor
					--aqui entra para tomar el consecutivo del folio  la sucursal actual


--GAS 14-ago-2019
/*
					UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
					WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
										--nuevo folio transaccion
					folio_transaccion := nuevo_consecutivo::bigint;

					INSERT INTO cxc_ant(
						numero_transaccion,--folio_transaccion,
						cliente_id,--str_data[4]::integer,
						moneda_id,--str_data[7]::integer,
						anticipo_inicial,--str_data[24]::double precision,
						anticipo_actual,--str_data[24]::double precision,
						fecha_anticipo_usuario,--now(),
						observaciones,--'ANTICIPO GENERADO DESDE UN PAGO COMO SALDO A FAVOR DEL CLIENTE'
						momento_creacion,--now(),
						id_usuario_creacion,--str_data[3]::integer,
						empresa_id,--emp_id,
						sucursal_id--suc_id
					)
					VALUES(
						folio_transaccion,
						str_data[4]::integer,
						str_data[7]::integer,
						str_data[24]::double precision,
						str_data[24]::double precision,
						now(),
						'ANTICIPO GENERADO DESDE UN PAGO COMO SALDO A FAVOR DEL CLIENTE',
						now(),
						str_data[3]::integer,
						emp_id,
						suc_id					

					);
*/ -- GAS 14 ago 2019
				END IF;
			
			END IF;
			
--GAS			valor_retorno = folio_transaccion::character varying||'___'||ultimo_id::character varying;
			valor_retorno = folio_transaccion::character varying;
		END IF;--termina registro de pago
		
		
		
		--registro de anticipo
		IF command_selected = 'anticipo' THEN
			
			SELECT INTO str_data string_to_array(''||campos_data||'','___');	
			--str_data[3] 	id_usuario
			--str_data[4] 	fecha_anticipo
			--str_data[5] 	monto_anticipo
			--str_data[6] 	id_moneda
                        --str_data[7]   id_cliente
                        --str_data[8]   observaciones
                                
			INSERT INTO cxc_ant(
				numero_transaccion,
				cliente_id,
				moneda_id,
				anticipo_inicial,
				anticipo_actual,
				fecha_anticipo_usuario,
				observaciones,
				momento_creacion,
				id_usuario_creacion,
				empresa_id,
				sucursal_id
			)
			VALUES(
				folio_transaccion,
				str_data[7]::integer,
				str_data[6]::integer,
				str_data[5]::double precision,
				str_data[5]::double precision,
				str_data[4]::timestamp with time zone,
				str_data[8],
				now(),
				str_data[3]::integer,
				emp_id,
				suc_id
			);
			valor_retorno := folio_transaccion::character varying;			
		END IF;--termina registro de anticipo
		
		
		
		--cancelacion de pagos
		IF command_selected = 'cancelacion' THEN
			--str_data[3]	id_usuario
			--str_data[4]	cancelar_por
			--str_data[5]	observaciones_canc
			--str_data[6]	numero_trans
			--str_data[7]	fecha_cancelacion

			--folio_transaccion:=str_data[6]::bigint;
			
			--TIPO CANCELACION POR FACTURAS
			IF str_data[4]='1' THEN
				id_anticipo:=0;
				--obtiene id del pago y id de anticipo
				SELECT id,anticipo_id,tipo_cambio FROM erp_pagos WHERE numero_transaccion=str_data[6]::bigint ORDER BY id DESC LIMIT 1 INTO id_pago,id_anticipo, tipo_cambio_pago;
				--RAISE EXCEPTION '%','monto cancelado: SELECT id,anticipo_id FROM erp_pagos WHERE numero_transaccion ILIKE '||str_data[3];
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					--arreglo[cont_fila] serie_folio
					--RAISE EXCEPTION '%','SERIE_FOLIO: '||extra_data[cont_fila]||'   id_pago:'||id_pago;
					
					--actualiza tabla erp_pagos_detalles
					UPDATE erp_pagos_detalles SET cancelacion = true, momento_cancelacion = str_data[7]::timestamp with time zone 
					WHERE pago_id = id_pago AND serie_folio ilike extra_data[cont_fila] RETURNING id,cantidad into id_pagos_detalles,monto_cancelado;
					
					--verificar monto_cancelado
					--RAISE EXCEPTION '%','monto cancelado: '||monto_cancelado;
					
					SELECT monto_total,total_pagos_cancelados,moneda_id from  erp_h_facturas where serie_folio=extra_data[cont_fila]
					INTO total_factura,total_monto_cancelados,id_moneda_factura;
					
					SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio=extra_data[cont_fila] AND cancelacion=FALSE ) AS sbt  INTO suma_pagos;

					--sacar total de notas de credito
					SELECT total_notas_creditos FROM erp_h_facturas WHERE serie_folio=extra_data[cont_fila] INTO suma_notas_credito;
					
					nuevacantidad_monto_cancelados:=round((total_monto_cancelados + monto_cancelado)::numeric,4)::double precision;
					--nuevo_saldo_factura:=round((total_factura - suma_pagos)::numeric,4)::double precision;
					nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,4)::double precision;

					
					--RAISE EXCEPTION '%','TotFact='||total_factura||' SaldoFact='||saldo_factura||' TotalCan='||total_monto_cancelados||' NuevoTotCan='||nuevacantidad_monto_cancelados;
					
					--actualiza cantidades cada vez que se realice una cancelacion
					UPDATE erp_h_facturas SET 
						total_pagos = suma_pagos,
						total_notas_creditos=suma_notas_credito,
						total_pagos_cancelados = nuevacantidad_monto_cancelados, 
						saldo_factura=nuevo_saldo_factura,
						pagado = false
					where serie_folio ilike extra_data[cont_fila]
					RETURNING moneda_id into id_moneda_factura;
					
					UPDATE fac_cfds SET pagado=false WHERE serie_folio=extra_data[cont_fila];
					
					INSERT INTO  erp_pagos_cancelacion_detalles(pagos_detalles_id,numero_transaccion,momento_creacion_usuario,id_usuario_creacion,observaciones,momento_creacion)
					VALUES( id_pagos_detalles,folio_transaccion, str_data[7]::timestamp with time zone, str_data[3]::integer, str_data[5], now());
					
					
					--actualiza anticipos al cancelar un pago que fue originado de un anticipo
					IF id_anticipo !=0 THEN
						SELECT anticipo_actual,moneda_id FROM cxc_ant WHERE id = id_anticipo INTO monto_anticipo_actual, id_moneda_anticipo;
						
						IF id_moneda_factura = 1 THEN 
							IF id_moneda_anticipo = 2 THEN 
								saldo_anticipo:=monto_anticipo_actual + (monto_cancelado / tipo_cambio_pago);
							END IF;
							IF id_moneda_anticipo = 1 THEN 
								saldo_anticipo:=monto_anticipo_actual + monto_cancelado;
							END IF;
						END IF;
						IF id_moneda_factura = 2 THEN 
							IF id_moneda_anticipo = 2 THEN 
								saldo_anticipo:=monto_anticipo_actual + monto_cancelado;
							END IF;
							IF id_moneda_anticipo = 1 THEN 
								saldo_anticipo:=monto_anticipo_actual + (monto_cancelado * tipo_cambio_pago);
							END IF;
						END IF;
						
						--RAISE EXCEPTION '%','saldo_anticipo: '||saldo_anticipo;
						UPDATE cxc_ant SET anticipo_actual = saldo_anticipo,
									id_usuario_actualizacion = str_data[3]::integer, 
									momento_actualizacion = now(),
									borrado_logico = false,
									momento_baja = null
						WHERE id = id_anticipo;
					END IF;
					
				END LOOP;
				valor_retorno:=folio_transaccion::character varying;
				--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
			END IF;--TERMINA TIPO CANCELACION POR FACTURAS
			
			
			
			
			--TIPO CANCELACION POR NUMERO DE TRANSACCION
			IF str_data[4]='2' THEN
				--obtiene id del pago
				
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					id_anticipo:=0;
					--extra_data[cont_fila] numero de transaccion
					SELECT id,anticipo_id,tipo_cambio FROM erp_pagos WHERE numero_transaccion = extra_data[cont_fila]::bigint LIMIT 1 INTO id_pago,id_anticipo,tipo_cambio_pago;
					--RAISE EXCEPTION '%','id_pago: '||id_pago;
					
					--cancela todas las facturas pagadas con esta transaccion
					UPDATE erp_pagos_detalles SET cancelacion = true, momento_cancelacion = str_data[7]::timestamp with time zone 
					WHERE pago_id = id_pago;
					
					
					sql_pagos:='SELECT id,serie_folio, cantidad FROM erp_pagos_detalles WHERE  erp_pagos_detalles.pago_id = '||id_pago;
					
					FOR fila IN EXECUTE (sql_pagos) LOOP
						SELECT monto_total,total_pagos_cancelados,moneda_id from  erp_h_facturas where serie_folio=fila.serie_folio
						INTO total_factura,total_monto_cancelados,id_moneda_factura;
						
						--RAISE EXCEPTION '%','total_factura '||total_factura;
						--RAISE EXCEPTION '%','total_monto_cancelados: '||total_monto_cancelados;
						
						SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END  from(	SELECT sum(cantidad) FROM erp_pagos_detalles WHERE serie_folio = fila.serie_folio AND cancelacion=FALSE ) AS sbt  INTO suma_pagos;
						--RAISE EXCEPTION '%','suma_pagos '||suma_pagos;

						SELECT total_notas_creditos FROM erp_h_facturas WHERE serie_folio=fila.serie_folio INTO suma_notas_credito;
						
						nuevacantidad_monto_cancelados:=round((total_monto_cancelados + fila.cantidad)::numeric,4)::double precision;
						--nuevo_saldo_factura:=round((total_factura - suma_pagos)::numeric,4)::double precision;
						nuevo_saldo_factura:=round((total_factura-suma_pagos-suma_notas_credito)::numeric,4)::double precision;
						
						
						--actualiza cantidades cada vez que se realice una cancelacion
						UPDATE erp_h_facturas SET 
							total_pagos = suma_pagos,
							total_notas_creditos=suma_notas_credito,
							total_pagos_cancelados = nuevacantidad_monto_cancelados, 
							saldo_factura=nuevo_saldo_factura,
							pagado = false
						where serie_folio ilike fila.serie_folio
						RETURNING moneda_id into id_moneda_factura;
						
						UPDATE fac_cfds SET pagado=false WHERE serie_folio ilike fila.serie_folio;
						
						
						INSERT INTO  erp_pagos_cancelacion_detalles(pagos_detalles_id,numero_transaccion,momento_creacion_usuario,id_usuario_creacion,observaciones,momento_creacion)
						VALUES( fila.id, folio_transaccion, str_data[7]::timestamp with time zone, str_data[3]::integer, str_data[5], now());
						
						--actualiza anticipos al cancelar un pago que fue originado de un anticipo
						IF id_anticipo !=0 THEN
							--SELECT anticipo_actual FROM cxc_ant WHERE id = id_anticipo INTO monto_anticipo_actual;
							SELECT anticipo_actual,moneda_id FROM cxc_ant WHERE id = id_anticipo INTO monto_anticipo_actual, id_moneda_anticipo;
							
							IF id_moneda_factura = 1 THEN 
								IF id_moneda_anticipo = 2 THEN 
									saldo_anticipo:=monto_anticipo_actual + (fila.cantidad / tipo_cambio_pago);
								END IF;
								IF id_moneda_anticipo = 1 THEN 
									saldo_anticipo:=monto_anticipo_actual + fila.cantidad;
								END IF;
							END IF;
							IF id_moneda_factura = 2 THEN 
								IF id_moneda_anticipo = 2 THEN 
									saldo_anticipo:=monto_anticipo_actual + fila.cantidad;
								END IF;
								IF id_moneda_anticipo = 1 THEN 
									saldo_anticipo:=monto_anticipo_actual + (fila.cantidad * tipo_cambio_pago);
								END IF;
							END IF;
							
							--RAISE EXCEPTION '%','moneda_factura:'||id_moneda_factura||'  moneda_anticipo:'||id_moneda_anticipo||'  monto_anticipo_actual:'||monto_anticipo_actual||'  monto_cancelado:'||fila.cantidad||'  saldo_anticipo:'||saldo_anticipo; 
							
							UPDATE cxc_ant SET anticipo_actual = saldo_anticipo,
										id_usuario_actualizacion = str_data[3]::integer, 
										momento_actualizacion = now(),
										borrado_logico = false,
										momento_baja = null
							WHERE id = id_anticipo;
						END IF;
						
					END LOOP;
					--RAISE EXCEPTION '%','TotFact='||total_factura||' SaldoFact='||saldo_factura||' TotalCan='||total_monto_cancelados||' NuevoTotCan='||nuevacantidad_monto_cancelados;
					
					--valor_retorno:= valor_retorno||extra_data[cont_fila]||',';
					
					--RAISE EXCEPTION '%','valor_retorno: '||valor_retorno;
					
				END LOOP;
				valor_retorno:= folio_transaccion::character varying;
				
			END IF;--TERMINA TIPO CANCELACION POR NUMERO DE TRANSACCION
			
		END IF;--termina termina cancelacion de pagos
		
	END IF;--termina pagos
	
	
	
	
	-- Catalogo de centros de costo
	IF app_selected = 15 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			--str_data[6] 	descripcion
			INSERT INTO ctb_cc (titulo,descripcion, momento_creacion, id_usuario_creacion,empresa_id,borrado_logico)
			VALUES (str_data[5],str_data[6], now(),usuario_id, emp_id,false);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE ctb_cc SET titulo=str_data[5],descripcion=str_data[6],id_usuario_actualizacion=usuario_id,momento_actualizacion=now(),borrado_logico=false
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_cc SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de centros de costo
	
	
	-- Catalogo de centros de Tipos de Poliza
	IF app_selected = 16 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	tipo
			--str_data[6] 	descripcion
			--str_data[7] 	grupo
			INSERT INTO ctb_tpol (titulo, ctb_tpol_grupo_id, tipo, empresa_id, borrado_logico, momento_creacion, id_usuario_creacion)
			VALUES (str_data[6], str_data[7]::integer, str_data[5]::integer, emp_id, false,now(),usuario_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE ctb_tpol SET titulo=str_data[6],ctb_tpol_grupo_id=str_data[7]::integer, tipo=str_data[5]::integer,id_usuario_actualizacion=usuario_id,momento_actualizacion=now()
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_tpol SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Tipos de poliza
	
	
	
	-- Catalogo de conceptos contables
	IF app_selected = 17 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			--str_data[6] 	descripcion
			INSERT INTO ctb_con (titulo,descripcion, momento_creacion, id_usuario_creacion,empresa_id,borrado_logico)
			VALUES (str_data[5],str_data[6], now(),usuario_id, emp_id,false);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE ctb_con SET titulo=str_data[5],descripcion=str_data[6],id_usuario_actualizacion=usuario_id,momento_actualizacion=now(),borrado_logico=false
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_con SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de conceptos contables
	
	
	-- Catalogo de Clasificacion de Cuentas(Cuentas de Mayor)
	IF app_selected = 18 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	ctamayor
			--str_data[6]	clasificacion
			--str_data[7]	des_espanol
			--str_data[8]	des_ingles
			--str_data[9]	des_otro
			INSERT INTO ctb_may (ctb_may_clase_id,clasificacion,descripcion,descripcion_ing,descripcion_otr,borrado_logico,	empresa_id,momento_creacion,id_usuario_creacion)
			VALUES (str_data[5]::integer,str_data[6]::smallint, str_data[7], str_data[8], str_data[9], false,emp_id,now(),usuario_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE ctb_may SET ctb_may_clase_id=str_data[5]::integer,clasificacion=str_data[6]::smallint, descripcion=str_data[7],descripcion_ing=str_data[8],descripcion_otr=str_data[9],id_usuario_actualizacion=usuario_id,momento_actualizacion=now(),borrado_logico=false
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE ctb_may SET borrado_logico=true, momento_baja=now(), id_usuario_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Clasificacion de Cuentas(Cuentas de Mayor)
	
	
	
	-- Catalogo de Catalogo de Agentes
	IF app_selected = 19 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	nombre_agente
			--str_data[6]	usuario_agente
			--str_data[7]	comision
			--str_data[8]	region

			INSERT INTO cxc_agen(nombre, comision, gral_reg_id,gral_usr_id,borrado_logico,momento_creacion,gral_usr_id_creacion)
			VALUES(str_data[5],str_data[7]::double precision,str_data[8]::integer,str_data[6]::integer,false,now(),usuario_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_agen SET nombre=str_data[5],
						comision=str_data[7]::double precision,
						gral_reg_id=str_data[8]::integer,
						gral_usr_id=str_data[6]::integer,
						gral_usr_id_actualizacion=usuario_id,
						momento_actualizacion=now()
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxc_agen SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de Agentes
	
	
	-- Catalogo de Catalogo Clientes Clasificacion 1
	IF app_selected = 20 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			INSERT INTO cxc_clie_clas1 (titulo) VALUES (str_data[5]);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_clie_clas1 SET titulo=str_data[5] WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			DELETE FROM cxc_clie_clas1 WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Clientes Clasificacion 1
	

	-- Catalogo de Catalogo Clientes Clasificacion 2
	IF app_selected = 21 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			INSERT INTO cxc_clie_clas2 (titulo) VALUES (str_data[5]);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_clie_clas2 SET titulo=str_data[5] WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			DELETE FROM cxc_clie_clas2 WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Clientes Clasificacion 2
	
	
	-- Catalogo de Catalogo Clientes Clasificacion 3
	IF app_selected = 22 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			INSERT INTO cxc_clie_clas3 (titulo) VALUES (str_data[5]);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_clie_clas3 SET titulo=str_data[5] WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			DELETE FROM cxc_clie_clas3 WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Clientes Clasificacion 3

	
	
	-- Catalogo de Zonas de  Clientes
        IF app_selected = 23 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxc_clie_zonas (titulo,borrado_logico) VALUES (str_data[5],false);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_clie_zonas SET titulo=str_data[5] WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        --DELETE FROM cxc_clie_zonas WHERE id=str_data[4]::integer;
                        UPDATE cxc_clie_zonas
                        SET borrado_logico = true
                        WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo zonas de  Clientes
        


        -- Catalogo de  Grupos de  Clientes
        IF app_selected = 24 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxc_clie_grupos (titulo,borrado_logico) VALUES (str_data[5],false);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_clie_grupos SET titulo=str_data[5] WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        --DELETE FROM cxc_clie_grupos WHERE id=str_data[4]::integer;
                        UPDATE cxc_clie_grupos
                        SET borrado_logico = true
                        WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Grupos de  Clientes

	
	
	-- Catalogo de Catalogo Proveedores Clasificacion 1
        IF app_selected = 25 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_clas1 (titulo, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
                        VALUES (str_data[5], false, now(),usuario_id, emp_id, suc_id );
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_clas1 SET titulo=str_data[5], momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
			UPDATE cxp_prov_clas1 SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja=usuario_id 
			WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Proveedores Clasificacion 1
	
	
        -- Catalogo de Catalogo Proveedores Clasificacion 2
        IF app_selected = 26 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_clas2 (titulo, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
                        VALUES (str_data[5], false, now(),usuario_id, emp_id, suc_id);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_clas1 SET titulo=str_data[5], momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
			UPDATE cxp_prov_clas1 SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja=usuario_id 
			WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Proveedores Clasificacion 2
	
	
	
        -- Catalogo de Catalogo Proveedores Clasificacion 3
        IF app_selected = 27 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_clas3 (titulo, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
                        VALUES (str_data[5], false, now(), usuario_id, emp_id, suc_id);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_clas1 SET titulo=str_data[5], momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
			UPDATE cxp_prov_clas1 SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja=usuario_id 
			WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Proveedores Clasificacion 3

	-- Catalogo de Zonas de  Proveedores
        IF app_selected = 28 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_zonas (titulo) VALUES (str_data[5]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_zonas SET titulo=str_data[5] WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxp_prov_zonas WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo zonas de  proveedores
        
	
	
        -- Catalogo de  Grupos de  Proveedores
        IF app_selected = 29 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        INSERT INTO cxp_prov_grupos (titulo) VALUES (str_data[5]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_grupos SET titulo=str_data[5] WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxp_prov_grupos WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Grupos de  proveedores
	
	
	
	
	
	-- Catalogo de tipos de movimientos  de  Proveedores
        IF app_selected = 31 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        --str_data[6]         descripcion
                        --str_data[7]         moneda_id
                        INSERT INTO cxp_mov_tipos (titulo,moneda_id,descripcion) VALUES (str_data[5],str_data[7]::integer,str_data[6]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_mov_tipos SET titulo=str_data[5],descripcion=str_data[6],moneda_id=str_data[7]::integer
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxp_mov_tipos WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo tipos de  movimientos de proveedores
        
        -- Catalogo de tipos de movimientos  de  clientes
	IF app_selected = 32 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        --str_data[6]         descripcion
                        --str_data[7]         moneda_id
                        INSERT INTO cxc_mov_tipos (titulo,moneda_id,descripcion) VALUES (str_data[5],str_data[7]::integer,str_data[6]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_mov_tipos SET titulo=str_data[5],descripcion=str_data[6],moneda_id=str_data[7]::integer 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxc_mov_tipos WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo tipos de movimientos  de  clientes
	
	
        -- Catalogo de tipos de mensajes  de  clientes
        IF app_selected = 33 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         titulo
                        --str_data[6]         descripcion
                        --str_data[7]         moneda_id
                        INSERT INTO cxc_clie_mensajes (cxc_mov_tipo_id,cxc_clie_id,msg_1) VALUES (str_data[4]::integer,str_data[5]::integer,str_data[6]);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_clie_mensajes SET cxc_mov_tipo_id=str_data[4],cxc_clie_id=str_data[5] ,msg_1=str_data[6] 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxc_mov_tipos WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo tipos de  mensajes de clientes
	
	
	
	
	
	-- Catalogo de Catalogo de tipos de movimientos de inventarios
	IF app_selected = 35 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	tipo
			--str_data[6]	descripcion
			--str_data[7]	mov_de_ajuste

			INSERT INTO inv_mov_tipos(titulo, descripcion, ajuste,momento_creacion, borrado_logico, grupo, afecta_compras, 
			afecta_ventas, considera_consumo, tipo_costo)
			VALUES(str_data[5],str_data[6],str_data[7]::boolean,now(), false, str_data[8]::smallint,str_data[9]::boolean,
			str_data[10]::boolean,str_data[11]::boolean,str_data[12]::smallint);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE inv_mov_tipos SET titulo=str_data[5],
						descripcion=str_data[6],
						ajuste=str_data[7]::boolean,
						momento_actualizacion=now(), 
						grupo=str_data[8]::smallint, 
						afecta_compras=str_data[9]::boolean, 
						afecta_ventas=str_data[10]::boolean, 
						considera_consumo=str_data[11]::boolean, 
						tipo_costo=str_data[12]::smallint
						
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_mov_tipos SET borrado_logico=true, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de tipos de movimientos de inventarios




	-- Catalogo de Catalogo de invsecciones
	IF app_selected = 37 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	estatus

			INSERT INTO inv_secciones(titulo, descripcion, activa,momento_creacion, borrado_logico,gral_usr_id_creacion,gral_emp_id,gral_suc_id)
			VALUES(str_data[5],str_data[6],str_data[7]::boolean,now(), false, usuario_id, emp_id, suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE inv_secciones SET titulo=str_data[5],
						descripcion=str_data[6],
						activa=str_data[7]::boolean,
						momento_actualizacion=now(),
						gral_usr_id_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_secciones SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja=usuario_id
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de invsecciones


	-- Catalogo de inventario de  Marcas
	IF app_selected = 38 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			--str_data[6]     estatus
			--strd_data[7]    url
			INSERT INTO inv_mar (titulo,borrado_logico,url,momento_creacion,estatus, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
			VALUES (str_data[5],false,str_data[7],now(),str_data[6]::boolean,  usuario_id, emp_id, suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE inv_mar SET titulo=str_data[5],
					    estatus=str_data[6]::boolean,
					    momento_actualizacion=now(),
					    gral_usr_id_actualizacion=usuario_id
			WHERE inv_mar.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_mar SET momento_baja=now(),
					    borrado_logico=true,
					    gral_usr_id_baja=usuario_id
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Marcas

	-- Catalogo de inv_prod_lineas
	IF app_selected = 39 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	seccion
			--str_data[8]	marcas
			
			INSERT INTO inv_prod_lineas(titulo, descripcion, inv_seccion_id,momento_creacion, borrado_logico,gral_usr_id_creacion, gral_emp_id, gral_suc_id)
			VALUES(str_data[5],str_data[6],str_data[7]::integer,now(), false, usuario_id, emp_id, suc_id) 
			RETURNING id INTO ultimo_id;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN
				--RAISE EXCEPTION '%' ,extra_data[cont_fila]::integer;
				FOR cont_fila IN 1 .. total_filas LOOP
					insert into inv_lm(inv_prod_linea_id,inv_mar_id) 
					values(ultimo_id, extra_data[cont_fila]::integer);
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_prod_lineas SET titulo=str_data[5],
						descripcion=str_data[6],
						inv_seccion_id=str_data[7]::integer,
						momento_actualizacion=now(),
						gral_usr_id_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;

			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			IF extra_data[1] != 'sin datos' THEN
				delete from inv_lm where inv_prod_linea_id=str_data[4]::integer;
				FOR cont_fila IN 1 .. total_filas LOOP
					insert into inv_lm(inv_prod_linea_id,inv_mar_id) values(str_data[4]::integer, extra_data[cont_fila]::integer);
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_prod_lineas SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;----termina Catalogo de inv_prod_lineas



	-- Catalogo de  Zonas de invetarios
	IF app_selected = 40 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         descripcion
			--str_data[6]     estatus
			--strd_data[7]    zona
			INSERT INTO inv_zonas (titulo,descripcion,borrado_logico,momento_creacion,estatus) VALUES (str_data[7],str_data[5],false,now(),str_data[6]::boolean);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
		
			UPDATE inv_zonas SET titulo=str_data[7],						
						estatus=str_data[6]::boolean,
						descripcion=str_data[5],
						momento_actualizacion=now()
						WHERE inv_zonas.id = str_data[4]::integer;
						valor_retorno := '1';
		END IF;
			
		IF command_selected = 'delete' THEN
			 UPDATE inv_zonas SET momento_baja=now(),
					    borrado_logico=true
					    WHERE id = str_data[4]::integer;
					    valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Zonas de invetarios
	
	
	
	
	
	-- Catalogo de tes_mov_tipos
	IF app_selected = 41 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	grupo--int
			--str_data[8]	tipo
			--str_data[9]	conconsecutivo
			--str_data[10]	conciliacionautomatica
			
			INSERT INTO tes_mov_tipos(titulo, descripcion, tipo,consecutivo,grupo,conciliacion, borrado_logico, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion) 
			VALUES(str_data[5],str_data[6],str_data[8]::boolean,str_data[9]::boolean, str_data[7]::integer, str_data[10]::boolean, false, now(), emp_id, suc_id, usuario_id ) RETURNING id INTO ultimo_id;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE tes_mov_tipos SET titulo=str_data[5],
						descripcion=str_data[6],
						tipo=str_data[8]::boolean,
						consecutivo=str_data[9]::boolean,
						grupo=str_data[7]::integer,
						conciliacion=str_data[10]::boolean, 
						borrado_logico=false,
						momento_actualizacion=now(),
						gral_usr_id_actualizacion=usuario_id
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE tes_mov_tipos SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de tes_mov_tipos
	
	
	
	
	-- Catalogo de tes_ban
	IF app_selected = 42 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	clave
			
			INSERT INTO tes_ban(titulo, descripcion, borrado_logico, momento_creacion,gral_usr_id_creacion,gral_emp_id, gral_suc_id, clave) 
			VALUES(str_data[5],str_data[6],false, now(), usuario_id, emp_id, suc_id, str_data[7]) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN			
			UPDATE tes_ban SET titulo=str_data[5],descripcion=str_data[6],clave=str_data[7],borrado_logico=false,momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id 
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE tes_ban SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de tes_ban




	
	-- Catalogo de Familias
        IF app_selected = 43 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         familia
                        --str_data[6]         descripcion
                        INSERT INTO inv_prod_familias (titulo,descripcion,momento_creacion, borrado_logico, gral_usr_id_creacion, gral_emp_id, gral_suc_id, inv_prod_tipo_id)
                        VALUES (str_data[5],str_data[6],now(),false,  usuario_id, emp_id, suc_id, str_data[7]::integer)
                        RETURNING id INTO ultimo_id;
                        
                        UPDATE inv_prod_familias SET identificador_familia_padre=ultimo_id WHERE id=ultimo_id;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE inv_prod_familias SET titulo=str_data[5],descripcion=str_data[6],momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_id, inv_prod_tipo_id=str_data[7]::integer 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        UPDATE inv_prod_familias SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina catalogo de Familias

	-- Catalogo de Conceptos Bancarios(tes_con)
	IF app_selected = 44 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			
			INSERT INTO tes_con(titulo, descripcion, tipo, borrado_logico,gral_usr_id_creacion,gral_emp_id,gral_suc_id, momento_creacion) 
			VALUES(str_data[5],str_data[6],str_data[7]::boolean,false,usuario_id, emp_id, suc_id, now()) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE tes_con SET 
				titulo=str_data[5],
				descripcion=str_data[6],
				tipo=str_data[7]::boolean,
				borrado_logico=false,
				gral_usr_id_actualizacion=usuario_id,
				momento_actualizacion=now() 
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE tes_con SET borrado_logico=true,gral_usr_id_baja=usuario_id, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de tes_con
	
	
	
	-- Catalogo de  producto grupos
        IF app_selected = 45 THEN
                IF command_selected = 'new' THEN
                       --id [4]                 id
                        --str_data[5]         grupo
                        --str_data[6]     descripcion
                        
                        INSERT INTO inv_prod_grupos (titulo,descripcion,borrado_logico, gral_usr_id_creacion, gral_emp_id, gral_suc_id, momento_creacion) 
                        VALUES (str_data[5],str_data[6],false, usuario_id, emp_id, suc_id, now());
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
			UPDATE inv_prod_grupos SET 
				titulo=str_data[5],						
				descripcion=str_data[6],
				momento_actualizacion=now(),
				gral_usr_id_actualizacion=usuario_id
			WHERE inv_prod_grupos.id = str_data[4]::integer;
			valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE inv_prod_grupos SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id
                         WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo producto grupos	
	
	
	
	-- Catalogo de  Plazas
        IF app_selected = 46 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         plaza
                        --str_data[6]     nombre
                        --str_data[7]     id_zona
                        INSERT INTO gral_plazas (titulo,descripcion,momento_creacion,borrado_logico,empresa_id,estatus,inv_zonas_id) VALUES (str_data[5],str_data[6],now(),false,emp_id,str_data[8]::boolean,str_data[7]::integer);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE gral_plazas SET titulo=str_data[5], descripcion=str_data[6], inv_zonas_id =str_data[7]::integer, momento_actualizacion=now(), estatus=str_data[8]::boolean 
                        WHERE gral_plazas.id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE gral_plazas SET momento_baja=now(), borrado_logico=true WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Plazas



	-- Catalogo de inv_pre
	IF app_selected = 47 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[76]	select_presentacion
			
			INSERT INTO inv_pre(
				inv_prod_id, 
				precio_1,
				precio_2,
				precio_3,
				precio_4,
				precio_5,
				precio_6,
				precio_7,
				precio_8,
				precio_9,
				precio_10,
				descuento_1,
				descuento_2,
				descuento_3,
				descuento_4,
				descuento_5,
				descuento_6,
				descuento_7,
				descuento_8,
				descuento_9,
				descuento_10, 
				default_precio_1, --str_data[26]::double precision
				default_precio_2, --str_data[27]::double precision
				default_precio_3, --str_data[28]::double precision
				default_precio_4, --str_data[29]::double precision
				default_precio_5, --str_data[30]::double precision
				default_precio_6, --str_data[31]::double precision
				default_precio_7, --str_data[32]::double precision
				default_precio_8, --str_data[33]::double precision
				default_precio_9, --str_data[34]::double precision
				default_precio_10, --str_data[35]::double precision
				base_precio_1, --str_data[36]::integer
				base_precio_2, --str_data[37]::integer
				base_precio_3, --str_data[38]::integer
				base_precio_4, --str_data[39]::integer
				base_precio_5, --str_data[40]::integer
				base_precio_6, --str_data[41]::integer
				base_precio_7, --str_data[42]::integer
				base_precio_8, --str_data[43]::integer
				base_precio_9, --str_data[44]::integer
				base_precio_10, --str_data[45]::integer
				calculo_precio_1, --str_data[46]::integer
				calculo_precio_2, --str_data[47]::integer
				calculo_precio_3, --str_data[48]::integer
				calculo_precio_4, --str_data[49]::integer
				calculo_precio_5, --str_data[50]::integer
				calculo_precio_6, --str_data[51]::integer
				calculo_precio_7, --str_data[52]::integer
				calculo_precio_8, --str_data[53]::integer
				calculo_precio_9, --str_data[54]::integer
				calculo_precio_10, --str_data[55]::integer
				operacion_precio_1, --str_data[56]::integer
				operacion_precio_2, --str_data[57]::integer
				operacion_precio_3, --str_data[58]::integer
				operacion_precio_4, --str_data[59]::integer
				operacion_precio_5, --str_data[60]::integer
				operacion_precio_6, --str_data[61]::integer
				operacion_precio_7, --str_data[62]::integer
				operacion_precio_8, --str_data[63]::integer
				operacion_precio_9, --str_data[64]::integer
				operacion_precio_10, --str_data[65]::integer
				redondeo_precio_1, --str_data[66]::integer
				redondeo_precio_2, --str_data[67]::integer
				redondeo_precio_3, --str_data[68]::integer
				redondeo_precio_4, --str_data[69]::integer
				redondeo_precio_5, --str_data[70]::integer
				redondeo_precio_6, --str_data[71]::integer
				redondeo_precio_7, --str_data[72]::integer
				redondeo_precio_8, --str_data[73]::integer
				redondeo_precio_9, --str_data[74]::integer
				redondeo_precio_10, --str_data[75]::integer
				inv_prod_presentacion_id, --str_data[76]::integer
				gral_mon_id_pre1, --str_data[77]::integer
				gral_mon_id_pre2, --str_data[78]::integer
				gral_mon_id_pre3, --str_data[79]::integer
				gral_mon_id_pre4, --str_data[80]::integer
				gral_mon_id_pre5, --str_data[81]::integer
				gral_mon_id_pre6, --str_data[82]::integer
				gral_mon_id_pre7, --str_data[83]::integer
				gral_mon_id_pre8, --str_data[84]::integer
				gral_mon_id_pre9, --str_data[85]::integer
				gral_mon_id_pre10, --str_data[86]::integer
				gral_emp_id, --emp_id
				gral_usr_id_creacion, --usuario_id, 
				borrado_logico,--FALSE
				momento_creacion --now()
			) 
			VALUES(str_data[5]::integer,
				str_data[6]::double precision,str_data[7]::double precision,str_data[8]::double precision,str_data[9]::double precision,str_data[10]::double precision,str_data[11]::double precision,str_data[12]::double precision,str_data[13]::double precision,str_data[14]::double precision,str_data[15]::double precision,
				str_data[16]::double precision,str_data[17]::double precision,str_data[18]::double precision,str_data[19]::double precision,str_data[20]::double precision,str_data[21]::double precision,str_data[22]::double precision,str_data[23]::double precision,str_data[24]::double precision,str_data[25]::double precision,
				str_data[26]::double precision,str_data[27]::double precision,str_data[28]::double precision,str_data[29]::double precision,str_data[30]::double precision,str_data[31]::double precision,str_data[32]::double precision,str_data[33]::double precision,str_data[34]::double precision,str_data[35]::double precision,
				str_data[36]::integer,str_data[37]::integer,str_data[38]::integer,str_data[39]::integer,str_data[40]::integer,str_data[41]::integer,str_data[42]::integer,str_data[43]::integer,str_data[44]::integer,str_data[45]::integer,
				str_data[46]::integer,str_data[47]::integer,str_data[48]::integer,str_data[49]::integer,str_data[50]::integer,str_data[51]::integer,str_data[52]::integer,str_data[53]::integer,str_data[54]::integer,str_data[55]::integer,
				str_data[56]::integer,str_data[57]::integer,str_data[58]::integer,str_data[59]::integer,str_data[60]::integer,str_data[61]::integer,str_data[62]::integer,str_data[63]::integer,str_data[64]::integer,str_data[65]::integer,
				str_data[66]::integer,str_data[67]::integer,str_data[68]::integer,str_data[69]::integer,str_data[70]::integer,str_data[71]::integer,str_data[72]::integer,str_data[73]::integer,str_data[74]::integer,str_data[75]::integer,
				str_data[76]::integer, str_data[77]::integer, str_data[78]::integer, str_data[79]::integer, str_data[80]::integer, str_data[81]::integer, str_data[82]::integer, str_data[83]::integer, str_data[84]::integer, str_data[85]::integer, str_data[86]::integer,
				emp_id,usuario_id,false,now()
			) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_pre SET precio_1=str_data[6]::double precision,
				precio_2=str_data[7]::double precision,
				precio_3=str_data[8]::double precision,
				precio_4=str_data[9]::double precision,
				precio_5=str_data[10]::double precision,
				precio_6=str_data[11]::double precision,
				precio_7=str_data[12]::double precision,
				precio_8=str_data[13]::double precision,
				precio_9=str_data[14]::double precision,
				precio_10=str_data[15]::double precision,
				descuento_1=str_data[16]::double precision,
				descuento_2=str_data[17]::double precision,
				descuento_3=str_data[18]::double precision,
				descuento_4=str_data[19]::double precision,
				descuento_5=str_data[20]::double precision,
				descuento_6=str_data[21]::double precision,
				descuento_7=str_data[22]::double precision,
				descuento_8=str_data[23]::double precision,
				descuento_9=str_data[24]::double precision,
				descuento_10=str_data[25]::double precision,
				default_precio_1 = str_data[26]::double precision,
				default_precio_2 = str_data[27]::double precision,
				default_precio_3 = str_data[28]::double precision,
				default_precio_4 = str_data[29]::double precision,
				default_precio_5 = str_data[30]::double precision,
				default_precio_6 = str_data[31]::double precision,
				default_precio_7 = str_data[32]::double precision,
				default_precio_8 = str_data[33]::double precision,
				default_precio_9 = str_data[34]::double precision,
				default_precio_10 = str_data[35]::double precision,
				base_precio_1 = str_data[36]::integer,
				base_precio_2 = str_data[37]::integer,
				base_precio_3 = str_data[38]::integer,
				base_precio_4 = str_data[39]::integer,
				base_precio_5 = str_data[40]::integer,
				base_precio_6 = str_data[41]::integer,
				base_precio_7 = str_data[42]::integer,
				base_precio_8 = str_data[43]::integer,
				base_precio_9 = str_data[44]::integer,
				base_precio_10 = str_data[45]::integer,
				calculo_precio_1 = str_data[46]::integer,
				calculo_precio_2 = str_data[47]::integer,
				calculo_precio_3 = str_data[48]::integer,
				calculo_precio_4 = str_data[49]::integer,
				calculo_precio_5 = str_data[50]::integer,
				calculo_precio_6 = str_data[51]::integer,
				calculo_precio_7 = str_data[52]::integer,
				calculo_precio_8 = str_data[53]::integer,
				calculo_precio_9 = str_data[54]::integer,
				calculo_precio_10 = str_data[55]::integer,
				operacion_precio_1 = str_data[56]::integer,
				operacion_precio_2 = str_data[57]::integer,
				operacion_precio_3 = str_data[58]::integer,
				operacion_precio_4 = str_data[59]::integer,
				operacion_precio_5 = str_data[60]::integer,
				operacion_precio_6 = str_data[61]::integer,
				operacion_precio_7 = str_data[62]::integer,
				operacion_precio_8 = str_data[63]::integer,
				operacion_precio_9 = str_data[64]::integer,
				operacion_precio_10 = str_data[65]::integer,
				redondeo_precio_1 = str_data[66]::integer,
				redondeo_precio_2 = str_data[67]::integer,
				redondeo_precio_3 = str_data[68]::integer,
				redondeo_precio_4 = str_data[69]::integer,
				redondeo_precio_5 = str_data[70]::integer,
				redondeo_precio_6 = str_data[71]::integer,
				redondeo_precio_7 = str_data[72]::integer,
				redondeo_precio_8 = str_data[73]::integer,
				redondeo_precio_9 = str_data[74]::integer,
				redondeo_precio_10 = str_data[75]::integer,
				inv_prod_presentacion_id=str_data[76]::integer,
				gral_mon_id_pre1 = str_data[77]::integer,
				gral_mon_id_pre2 = str_data[78]::integer,
				gral_mon_id_pre3 = str_data[79]::integer,
				gral_mon_id_pre4 = str_data[80]::integer,
				gral_mon_id_pre5 = str_data[81]::integer,
				gral_mon_id_pre6 = str_data[82]::integer,
				gral_mon_id_pre7 = str_data[83]::integer,
				gral_mon_id_pre8 = str_data[84]::integer,
				gral_mon_id_pre9 = str_data[85]::integer,
				gral_mon_id_pre10 = str_data[86]::integer,
				gral_usr_id_actualizacion = usuario_id,
				borrado_logico=false,
				momento_actualizacion=now() 
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_pre SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de inv_pre
	



	-- Catalogo de SubFamilias
        IF app_selected = 48 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         familia
                        --str_data[6]         descripcion
                        --str_data[7]         select_familia
                        INSERT INTO inv_prod_familias (titulo,descripcion,identificador_familia_padre,momento_creacion, borrado_logico, gral_usr_id_creacion, gral_emp_id, gral_suc_id,inv_prod_tipo_id)
                        VALUES (str_data[5],str_data[6],str_data[7]::integer,now(),false, usuario_id, emp_id, suc_id, str_data[8]::integer);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE inv_prod_familias SET titulo=str_data[5],descripcion=str_data[6],identificador_familia_padre=str_data[7]::integer,momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_id, inv_prod_tipo_id=str_data[8]::integer 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        UPDATE inv_prod_familias SET borrado_logico=true, momento_baja=now(), gral_usr_id_baja=usuario_id  WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina catalogo de SubFamilias

        	

	-- Catalogo de unidades
	IF app_selected = 49 THEN
		IF command_selected = 'new' THEN
			INSERT INTO inv_prod_unidades (titulo,borrado_logico,titulo_abr,decimales)
				VALUES (str_data[6],false, str_data[5],str_data[7]::integer);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE inv_prod_unidades SET titulo=str_data[6],
						     titulo_abr=str_data[5],
						     decimales=str_data[7]::integer
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			eliminar_registro=true;


			IF eliminar_registro=TRUE THEN
				exis:=0;
				SELECT count(id) FROM inv_prod WHERE empresa_id=emp_id AND borrado_logico=false AND unidad_id=str_data[4]::integer 
				INTO exis;
				IF exis>0 THEN 
					valor_retorno := 'La Unidad de Medida no pudo ser eliminada porque est&aacute; asignado uno o m&aacute;s productos.';
					eliminar_registro=FALSE;
				END IF;
			END IF;

			IF eliminar_registro=TRUE THEN
				UPDATE inv_prod_unidades SET borrado_logico=true  WHERE inv_prod_unidades.id=str_data[4]::integer;
				valor_retorno := 'La Unidadde Medida fue eliminada con exito.';
			END IF;
		END IF;
	END IF;--termina catalogo de unidades
	
	
	
	-- Catalogo de  inventario de Clasicacion de   stock
        IF app_selected = 50 THEN
                IF command_selected = 'new' THEN
			--str_data[4]         id
                        --str_data[5]        titulo
                        --str_data[6]     descripcion
                        INSERT INTO inv_stock_clasificaciones (titulo,descripcion,borrado_logico,momento_creacion,gral_emp_id,gral_suc_id,gral_usr_id_creacion) 
                        VALUES (str_data[5],str_data[6],false,now(),emp_id,suc_id,usuario_id);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE inv_stock_clasificaciones SET  
				titulo=str_data[5],   						
				      descripcion=str_data[6],
				      momento_actualizacion= now(),
				      gral_usr_id_actualizacion=usuario_id
				WHERE inv_stock_clasificaciones.id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE inv_stock_clasificaciones SET borrado_logico=true,
                                                 gral_usr_id_baja= usuario_id
			 WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo inventario Clasificacion stock
	
	


	-- Catalogo de Comisiones
	IF app_selected = 51 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			
			INSERT INTO inv_com(  inv_prod_id,
			  limite_inferior,--smallint
			  limite_superior,
			  comision,
			  comision_valor,
			  nivel,
			  escala ,
			 borrado_logico, momento_creacion ) 
			VALUES(str_data[5]::integer,
			str_data[8]::double precision,
			str_data[9]::double precision,
			str_data[10]::double precision,
			str_data[11]::double precision,
			str_data[7]::smallint,
			str_data[6]::smallint,
			false, now()) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_com SET 
			  limite_inferior=str_data[8]::double precision,
			  limite_superior=str_data[9]::double precision,
			  comision=str_data[10]::double precision,
			  comision_valor=str_data[11]::double precision,
			  nivel=str_data[7]::smallint,
			  escala=str_data[6]::smallint ,
			borrado_logico=false,
			momento_actualizacion=now() 
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_com SET borrado_logico=true, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de Comisiones


	
	
	
	-- Catalogo de  inventario de Clasicaciones
        IF app_selected = 52 THEN
                IF command_selected = 'new' THEN
			--str_data[4]         id
                        --str_data[5]         titulo
                        --str_data[6]         descripcion
                        --str_data[7]         factorseguridad
                        --str_data[8]         stockseguridad
                        INSERT INTO inv_clas (titulo,descripcion,borrado_logico,stock_seguridad,factor_maximo,momento_creacion,gral_emp_id,gral_suc_id,gral_usr_id_creacion) 
                        VALUES (str_data[5],str_data[6],false,str_data[7]::double precision,str_data[8]::double precision,now(),emp_id,suc_id,usuario_id);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                
                        UPDATE inv_clas SET  titulo=str_data[5],   						
					      descripcion=str_data[6],
					      momento_actualizacion= now(),
					      stock_seguridad=str_data[7]::double precision,
					      factor_maximo=str_data[8]::double precision,
					      gral_usr_id_actualizacion=usuario_id
			WHERE inv_clas.id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE inv_clas SET borrado_logico=true,
				             momento_baja=now(),
                                             gral_usr_id_baja= usuario_id
			 WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo inventario Clasificaciones



	-- Catalogo de inv_pre_ofe
	IF app_selected = 53 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			
			INSERT INTO inv_pre_ofe(  inv_prod_id,
			  precio_oferta,
			  descto_max,
			  criterio_oferta,
			  precio_lista_1,precio_lista_2,
			  precio_lista_3,precio_lista_4,
			  precio_lista_5,precio_lista_6,
			  precio_lista_7,precio_lista_8,
			  precio_lista_9,precio_lista_10,
			  fecha_inicial,fecha_final,
			  tipo_descto_precio,
			 borrado_logico, momento_creacion ) 
			VALUES(str_data[5]::integer,
			str_data[8]::double precision,
			0,
			str_data[10]::boolean,
			str_data[11]::boolean,
			str_data[12]::boolean,
			str_data[13]::boolean,
			str_data[14]::boolean,
			str_data[15]::boolean,
			str_data[16]::boolean,
			str_data[17]::boolean,
			str_data[18]::boolean,
			str_data[19]::boolean,
			str_data[20]::boolean,
			str_data[6]::date,
			str_data[7]::date,
			str_data[21]::boolean,
			false, now()) RETURNING id INTO ultimo_id;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			
			UPDATE inv_pre_ofe SET 
			  precio_oferta=str_data[8]::double precision,
			  descto_max=0,
			  criterio_oferta=str_data[10]::boolean,
			  precio_lista_1=str_data[11]::boolean,precio_lista_2=str_data[12]::boolean,
			  precio_lista_3=str_data[13]::boolean,precio_lista_4=str_data[14]::boolean,
			  precio_lista_5=str_data[15]::boolean,precio_lista_6=str_data[16]::boolean,
			  precio_lista_7=str_data[17]::boolean,precio_lista_8=str_data[18]::boolean,
			  precio_lista_9=str_data[19]::boolean,precio_lista_10=str_data[20]::boolean,
			  fecha_inicial=str_data[6]::date,fecha_final=str_data[7]::date,
			  tipo_descto_precio=str_data[21]::boolean,
			borrado_logico=false,
			momento_actualizacion=now() 
			WHERE id = str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE inv_pre_ofe SET borrado_logico=true, momento_baja=now() WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de inv_pre_ofe




	-- Catalogo de  inventario plazas-sucursales
	IF app_selected = 54 THEN
		--str_data[1]         app_selected
		--str_data[2]         command_selected
		--str_data[3]         id_sucursal
		--str_data[4]         plazasAgregadas
			
		IF str_data[4] = '' THEN
			 DELETE FROM gral_suc_pza WHERE sucursal_id=str_data[3]::integer; 
			valor_retorno := '1';
		END IF;
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		
		IF str_data[4] != '' THEN
			DELETE FROM gral_suc_pza WHERE sucursal_id=str_data[3]::integer;  
			
			--convertir en arreglo las plazasAgregadas
			SELECT INTO str_filas string_to_array(str_data[4],',');
			
			--obtiene numero de elementos del arreglo str_fila
			tot_filas:= array_length(str_fila,1);
			
			--crea registros gral_suc_pza
			FOR cont_fila_pres IN 1 .. tot_filas LOOP
				INSERT INTO gral_suc_pza(plaza_id,sucursal_id) VALUES (str_fila[cont_fila_pres]::integer,str_data[3]::integer);
			END LOOP;
			
			valor_retorno := '1';
		END IF;
                
        END IF;--termina Catalogo inventario plazas-sucursales
	
	
	
	-- Catalogo Direcciones de proveedores
       IF app_selected = 56 THEN
             IF command_selected = 'new' THEN
		--str_data[4]        id                --str_data[5]        calle
                --str_data[6]	     codigoPostal      --str_data[7]        colonia
                --str_data[8]        entreCalles       --str_data[9]	     extDos
                --str_data[10]       extUno            --str_data[11]       numExterior
                --str_data[12]	     numInterior       --str_data[13]       proveedor
                --str_data[14]       id_estado         --str_data[15]	     id_municipio
                --str_data[16]       id_pais           --str_data[17]       telDos
                --str_data[18]	     telUno
                
		INSERT INTO cxp_prov_dir(proveedor_id,calle,entre_calles,numero_interior,numero_exterior,colonia,cp,pais_id,estado_id,municipio_id,telefono1,extension1,telefono2,borrado_logico,momento_creacion,id_usuario_creacion,gral_emp_id,gral_suc_id ) 
		VALUES (str_data[13]::integer,str_data[5],str_data[8],str_data[12],str_data[11],str_data[7]::character varying,str_data[6]::integer,str_data[16]::integer,str_data[14]::integer,str_data[15]::integer,str_data[18],str_data[10],str_data[17],false,now(),usuario_id,emp_id,suc_id );
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxp_prov_dir SET 
				proveedor_id=str_data[13]::INTEGER,
				calle        	=str_data[5],  --calle
				entre_calles 	=str_data[8], --entre calles
				numero_interior =str_data[12], --numero interior
				numero_exterior =str_data[11], --numeroexterior
				colonia 	=str_data[7], --colonia
				cp 		=str_data[6], --cp
				pais_id 	=str_data[16]::INTEGER,--pais
				estado_id 	=str_data[14]::INTEGER, --edo
				municipio_id 	=str_data[15]::INTEGER, --mpio
				telefono1 	=str_data[18],--567
				extension1 	=str_data[10],--5678
				telefono2 	=str_data[17],--56789	
				extension2 	=str_data[9],--567890				
				momento_actualizacion =now(),
				id_usuario_actualizacion= usuario_id						
                        WHERE cxp_prov_dir.id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE cxp_prov_dir SET momento_baja=now(),
                                            borrado_logico=true,
                                            id_usuario_baja=usuario_id
                         WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo Direcciones de proveedores
	
	
	

	--Catalogo de Chequera
	IF app_selected = 59 THEN
		--str_data[1]  app_selected                     str_data[11]  id_estado                         
		--str_data[2]  command_selected			str_data[12]  id_moneda				str_data[21]  telefono1
		--str_data[3]  id_usuario			str_data[13]  id_banco			        str_data[22]  extencion1
		--str_data[4]  id				str_data[14]  chk_imprimir_chequeningles	str_data[23]  telefono2	
		--str_data[5]  chequera				str_data[15]  calle				str_data[24]  extencion2		
		--str_data[6]  chk_modificar_consecutivo 	str_data[16]  numero				str_data[25]  fax
		--str_data[7]  chk_modificar_fecha		str_data[17]  colonia				str_data[26]  gerente
		--str_data[8]  chk_modificar_cheque		str_data[18]  cp				str_data[27]  ejecutivo
		--str_data[9]  id_pais				str_data[19]  numero_sucursal		        str_data[28]  email;
		--str_data[10]  id_municipio			str_data[20]  nombre_sucursal        		str_data[29]  id_cta_activo
		
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  inventario de Clasicaciones
                IF command_selected = 'new' THEN
			INSERT INTO tes_che (titulo ,aut_modif_consecutivo,   aut_modif_fecha ,    aut_modif_cheque ,       gral_pais_id ,  gral_mun_id ,                gral_edo_id ,            moneda_id ,          tes_ban_id ,  imp_cheque_ingles,  calle  ,  numero  ,  colonia ,  codigo_postal ,num_sucursal ,  nombre_sucursal  ,  telefono1  ,  extencion1  ,  telefono2  ,  extencion2  ,  fax  ,  gerente  ,  ejecutivo  ,  email  ,  momento_creacion , borrado_logico ,  gral_usr_id_creacion ,    gral_emp_id ,  gral_suc_id, ctb_cta_id_activo) 
			VALUES (str_data[5],str_data[6]::boolean, str_data[7]::boolean,str_data[8]::boolean,str_data[9]::integer,str_data[10]::integer, str_data[11]::integer, str_data[12]::integer,str_data[13]::integer,str_data[14]::boolean, str_data[15], str_data[16], str_data[17], str_data[18]::integer, str_data[19]::integer,str_data[20],str_data[21],str_data[22],str_data[23],str_data[24],str_data[25],str_data[26],str_data[27], str_data[28], now(), false,usuario_id, emp_id, suc_id, str_data[29]::integer);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE tes_che SET  titulo=str_data[5],
                        aut_modif_consecutivo =  str_data[6]::boolean,
                        aut_modif_fecha =str_data[7]::boolean,
                        aut_modif_cheque=str_data[8]::boolean,
                        gral_pais_id=str_data[9]::integer,
                        gral_mun_id =str_data[10]::integer, 
                        gral_edo_id = str_data[11]::integer,
                        moneda_id= str_data[12]::integer,
                        tes_ban_id =str_data[13]::integer,
                        imp_cheque_ingles=str_data[14]::boolean  ,
                        calle   =str_data[15],
                        numero = str_data[16] ,
                        colonia= str_data[17],
                        codigo_postal =str_data[18]::integer,
                        num_sucursal =str_data[19]::integer , 
                        nombre_sucursal =str_data[20],
                        telefono1 =str_data[21],
                        extencion1  =str_data[22],
                        telefono2 =str_data[23],
                        extencion2  =str_data[24],
                        fax  =str_data[25],
                        gerente =str_data[26] ,
                        ejecutivo =str_data[27],
                        email =str_data[28],
                        ctb_cta_id_activo=str_data[29]::integer,
			momento_actualizacion=now(),
			gral_usr_id_actualizacion=usuario_id
			WHERE tes_che.id = str_data[4]::integer;
			
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                         UPDATE tes_che SET borrado_logico=true,momento_baja=now(),gral_usr_id_baja= usuario_id
			 WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
	END IF;--termina Catalogo Chequeras


	




	-- Catalogo de inventario de  Presentaciones
	IF app_selected = 68 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			--str_data[6]         cantidad-equivalencia
			INSERT INTO inv_prod_presentaciones (titulo,borrado_logico,momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id, cantidad) 
			VALUES (str_data[5],false,now(), usuario_id, emp_id, suc_id,str_data[6]::double precision );
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE inv_prod_presentaciones SET titulo=str_data[5], cantidad = str_data[6]::double precision, momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_id
			WHERE inv_prod_presentaciones.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			eliminar_registro=true;
			
			IF eliminar_registro=TRUE THEN 
				exis:=0;
				SELECT count(id) FROM inv_prod_pres_x_prod WHERE presentacion_id=str_data[4]::integer
				INTO exis;
				IF exis>0 THEN 
					valor_retorno := 'La presentaci&oacute;n no pudo ser eliminada porque est&aacute; asignado como presentaci&oacute;n de uno o m&aacute;s productos.';
					eliminar_registro=FALSE;
				END IF;
			END IF;
			
			IF eliminar_registro=TRUE THEN
				exis:=0;
				SELECT count(id) FROM inv_prod WHERE empresa_id=emp_id AND borrado_logico=FALSE AND inv_prod_presentacion_id=str_data[4]::integer 
				INTO exis;
				IF exis>0 THEN 
					valor_retorno := 'La presentaci&oacute;n no pudo ser eliminada porque est&aacute; asignado como presentaci&oacute;n default de uno o m&aacute;s productos.';
					eliminar_registro=FALSE;
				END IF;
			END IF;
			
			--Verificar si hay que validar existencias de Presentaciones
			IF controlExisPres=true THEN 
				IF eliminar_registro=TRUE THEN
					exis:=0;
					SELECT count(id) FROM env_conf WHERE gral_emp_id=emp_id AND borrado_logico=FALSE AND inv_prod_presentacion_id=str_data[4]::integer 
					INTO exis;
					IF exis > 0 THEN 
						valor_retorno := 'La presentaci&oacute;n no pudo ser eliminada porque est&aacute; asociado a un registro en el cat&aacute;logo de configuraci&oacute;n de envases.';
						eliminar_registro=FALSE;
					ELSE
						--Eliminar registro de existencias por presentaciones si es que existe
						DELETE FROM inv_exi_pres WHERE inv_prod_presentacion_id=str_data[4]::integer;
					END IF;
				END IF;
			END IF;
			
			
			IF eliminar_registro=TRUE THEN
				UPDATE inv_prod_presentaciones SET momento_baja=now(), borrado_logico=true, gral_usr_id_baja=usuario_id WHERE id = str_data[4]::integer;
				
				--Eliminar de la tabla de costos
				DELETE FROM inv_prod_costos WHERE ano=EXTRACT(YEAR  FROM now()) AND inv_prod_presentacion_id=str_data[4]::integer;
				
				--Eliminar de la Lista de Precios
				DELETE FROM inv_pre WHERE gral_emp_id=emp_id AND inv_prod_presentacion_id=str_data[4]::integer;
				
				valor_retorno := 'La presentacion fue eliminada.';
			END IF;
			
		END IF;
	END IF;--termina Catalogo Presentaciones




	--Catalogo de formulas
	IF app_selected = 69 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  id_prod_master
		--str_data[6]  inv_prod_id
		--str_data[7]  nivel
		--str_data[8]  producto_elemento_id
		--str_data[9]  cantidad
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas


                IF command_selected = 'new' THEN
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
		
			IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
				
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--aqui se vuelven a crear los registros
					INSERT INTO inv_formulas ( inv_prod_id_master ,  inv_prod_id ,          producto_elemento_id ,     cantidad ,                         nivel ) 
					VALUES (                  str_data[5]::integer,  str_data[6]::integer,  str_filas[1]::integer,      str_filas[2]::Double precision,   str_data[7]::integer);
					valor_retorno := '1';
					
				END LOOP;
			END IF;
		END IF;
                
                IF command_selected = 'edit' THEN
                        total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;

			DELETE FROM  inv_formulas WHERE inv_formulas.inv_prod_id_master = str_data[5]::integer AND inv_formulas.inv_prod_id=str_data[6]::integer AND inv_formulas.nivel=str_data[7]::integer;
			--RAISE EXCEPTION '%','update:'||'DELETE FROM  inv_formulas WHERE inv_formulas.inv_prod_id_master = '||str_data[5]::integer||' AND inv_formulas.inv_prod_id='||str_data[6]::integer||' AND inv_formulas.nivel='||str_data[7]::integer||' ';
			--IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					INSERT INTO inv_formulas ( inv_prod_id_master ,  inv_prod_id ,          producto_elemento_id ,     cantidad ,                         nivel ) 
					VALUES (                  str_data[5]::integer,  str_data[6]::integer,  str_filas[1]::integer,      str_filas[2]::Double precision,   str_data[7]::integer);
				END LOOP;
			--END IF;
			valor_retorno := '1';
                END IF;

                IF command_selected = 'delete' THEN
                         DELETE  FROM inv_formulas 
			 WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
	END IF;--termina Catalogo de formulas
	
	
	
	
	-- Catalogo de inventario de  Vehiculos
	IF app_selected = 73 THEN
		IF command_selected = 'new' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id
			--str_data[5]	select_tipo_unidad
			--str_data[6]	select_clase
			--str_data[7]	select_marca
			--str_data[8]	select_anio
			--str_data[9]	color
			--str_data[10]	no_economico
			--str_data[11]	select_tipo_placa
			--str_data[12]	placas
			--str_data[13]	no_serie
			--str_data[14]	select_tipo_rodada
			--str_data[15]	select_tipo_caja
			--str_data[16]	cap_volumen
			--str_data[17]	cap_peso
			--str_data[18]	select_clasif2
			--str_data[19]	id_prov
			--str_data[20]	id_operador
			--str_data[21]	comentarios
			

			--Folio Catalogo de Unidades(LOG)
			id_tipo_consecutivo:=53;
			
			--Aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

			
			INSERT INTO log_vehiculos (
				folio, --nuevo_folio,
				log_vehiculo_tipo_id, --str_data[5]::integer,
				log_vehiculo_clase_id, --str_data[6]::integer,
				log_vehiculo_marca_id, --str_data[7]::integer,
				anio, --str_data[8]::integer,
				color, --str_data[9],
				numero_economico, --str_data[10],
				log_vehiculo_tipo_placa_id, --str_data[11]::integer,
				placa, --str_data[12],
				numero_serie, --str_data[13],
				log_vehiculo_tipo_rodada_id, --str_data[14]::integer,
				log_vehiculo_tipo_caja_id, --str_data[15]::integer,
				cap_volumen, --str_data[16]::double precision,
				cap_peso, --str_data[17]::double precision,
				clasificacion2, --str_data[18]::integer,
				cxp_prov_id, --str_data[19]::integer,
				log_chofer_id, --str_data[20]::integer,
				comentarios, --str_data[21],
				gral_emp_id, --emp_id,
				gral_suc_id, --suc_id,
				borrado_logico, --false,
				momento_crea, --espacio_tiempo_ejecucion,
				gral_usr_id_crea --usuario_id
			) 
			VALUES (nuevo_folio, str_data[5]::integer, str_data[6]::integer, str_data[7]::integer, str_data[8]::integer, str_data[9], str_data[10], str_data[11]::integer, str_data[12], str_data[13], str_data[14]::integer, str_data[15]::integer, str_data[16]::double precision, str_data[17]::double precision, str_data[18]::integer, str_data[19]::integer, str_data[20]::integer, str_data[21], emp_id, suc_id, false, espacio_tiempo_ejecucion, usuario_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE log_vehiculos SET log_vehiculo_tipo_id=str_data[5]::integer, log_vehiculo_clase_id=str_data[6]::integer, log_vehiculo_marca_id=str_data[7]::integer, anio=str_data[8]::integer, color=str_data[9], numero_economico=str_data[10], log_vehiculo_tipo_placa_id=str_data[11]::integer, placa=str_data[12], numero_serie=str_data[13], log_vehiculo_tipo_rodada_id=str_data[14]::integer, log_vehiculo_tipo_caja_id=str_data[15]::integer, cap_volumen=str_data[16]::double precision, cap_peso=str_data[17]::double precision, clasificacion2=str_data[18]::integer, cxp_prov_id=str_data[19]::integer, log_chofer_id=str_data[20]::integer, comentarios=str_data[21], momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
			WHERE log_vehiculos.id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE log_vehiculos SET momento_baja=espacio_tiempo_ejecucion, gral_usr_id_baja=usuario_id, borrado_logico=true 
			WHERE log_vehiculos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Vehiculo
	
	
	
	
	-- Catalogo de inventario de  Puestos
	IF app_selected = 75 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			INSERT INTO gral_puestos (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE gral_puestos SET titulo=str_data[5],
					    momento_actualizacion=now(),
					    gral_usr_id_actualizacion=usuario_id
			WHERE gral_puestos.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_puestos SET momento_baja=now(),borrado_logico=true 
			WHERE gral_puestos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Puestos
	
	
	-- Catalogo de inventario de  escolaridades
	IF app_selected = 77 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO gral_escolaridads (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_escolaridads SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id
			WHERE gral_escolaridads.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			UPDATE gral_escolaridads SET momento_baja=now(),borrado_logico=true 
			WHERE gral_escolaridads.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Escolaridades



	-- Catalogo de inventario de  Religiones
	IF app_selected = 78 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO gral_religions (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE gral_religions SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id
			WHERE gral_religions.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			UPDATE gral_religions SET momento_baja=now(),borrado_logico=true 
			WHERE gral_religions.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Religiones
	
	
	
	-- Catalogo de inventario de  tipos de sangre
	IF app_selected = 79 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO gral_sangretipos (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_sangretipos SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id
			WHERE gral_sangretipos.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			UPDATE gral_sangretipos SET momento_baja=now(),borrado_logico=true 
			WHERE gral_sangretipos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Tipo de sangre




	
	-- Catalogo de inventario de  departamentos
	IF app_selected = 82 THEN
		IF command_selected = 'new' THEN
		--RAISE EXCEPTION '%','titulo'||str_data[5];
			--str_data[4]         id select * from gral_deptos
			--str_data[5]         titulo
			INSERT INTO gral_deptos (titulo,costo_prorrateo,vigente, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id,    gral_suc_id) 
			VALUES (str_data[5], str_data[6]::double precision, true,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
			
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_deptos SET titulo=str_data[5],
					      costo_prorrateo=str_data[6]::double precision,
					      momento_actualizacion=now(),
					      gral_usr_id_actualizacion=usuario_id
		        WHERE gral_deptos.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update gral_deptos SET momento_baja=now(),
					      borrado_logico=true 
			WHERE gral_deptos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  departamentos
	
	
	-- Catalogo de inventario de  tipo de equipos
	IF app_selected = 83 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO pro_tipo_equipo (titulo,borrado_logico,momento_creacion,gral_usr_id_creacion,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE pro_tipo_equipo SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_id
		        WHERE pro_tipo_equipo.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update pro_tipo_equipo SET momento_baja=now(),borrado_logico=true 
			WHERE pro_tipo_equipo.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  tipo de equipos




	-- Catalogo de inventario de  dias no laborables
	IF app_selected = 84 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        fecha_no_laborable
			--str_data[6]        descripcion
			INSERT INTO gral_dias_no_laborables (fecha_no_laborable, descripcion, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
			VALUES (str_data[5]::date,str_data[6],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN		
			UPDATE gral_dias_no_laborables SET fecha_no_laborable=str_data[5]::date,
					      descripcion = str_data[6],
					      momento_actualizacion=now(),
					      gral_usr_id_actualizacion=usuario_id
		        WHERE gral_dias_no_laborables.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update gral_dias_no_laborables SET momento_baja=now(),
					      borrado_logico=true 
			WHERE gral_dias_no_laborables.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  dias no laborables




	-- Catalogo de inventario de  categorias
	IF app_selected = 85 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        titulo(categ)
			--str_data[6]        sueldo_por_hora 	
			--str_data[7]        sueldo_por_horas_ext 
			--str_data[8]        gral_puesto_id (puesto)select * from gral_categ
			INSERT INTO gral_categ (titulo,      sueldo_por_hora,               sueldo_por_horas_ext,          gral_puesto_id,          borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
			VALUES (                str_data[5], str_data[6]::double precision, str_data[7]::double precision, str_data[8]::integer,    false,          now(),            usuario_id,           emp_id,      suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_categ SET titulo=str_data[5],
			                      sueldo_por_hora=str_data[6]::double precision,
			                      sueldo_por_horas_ext=str_data[7]::double precision,
			                      gral_puesto_id=str_data[8]::integer,
					      momento_actualizacion=now(),
					      gral_usr_id_actualizacion=usuario_id
		        WHERE gral_categ.id = str_data[4]::integer;
			valor_retorno := '0';


		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update gral_categ SET momento_baja=now(),
					      borrado_logico=true 
			WHERE gral_categ.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  tipo de categorias



	
	-- Catalogo de inventario de  turnos
	IF app_selected = 92 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        turno
			--str_data[6]        hora_ini 	
			--str_data[7]        hora_fin 
			--str_data[8]        gral_deptos_id (depto) select * from gral_deptos_turnos
			INSERT INTO gral_deptos_turnos (turno,       hora_ini,                         hora_fin,                         gral_deptos_id,          borrado_logico, momento_creacion, gral_usr_id_creacion, gral_emp_id, gral_suc_id) 
			VALUES (                        str_data[5]::integer, str_data[6]::time with time zone, str_data[7]::time with time zone, str_data[8]::integer,    false,          now(),            usuario_id,           emp_id,      suc_id);
			valor_retorno := '1';
		END IF;
			
		IF command_selected = 'edit' THEN
			UPDATE gral_deptos_turnos SET turno=str_data[5]::integer,
			                      hora_ini=str_data[6]::time with time zone,
			                      hora_fin=str_data[7]::time with time zone,
			                      gral_deptos_id=str_data[8]::integer,
					      momento_actualizacion=now(),
					      gral_usr_id_actualizacion=usuario_id
		        WHERE gral_deptos_turnos.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;

		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update gral_deptos_turnos SET momento_baja=now(),
					      borrado_logico=true 
			WHERE gral_deptos_turnos.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  tipo de turnos
	


	--Catalogo de productos equivalentes 
	IF app_selected = 96 THEN 
		--str_data[1]  app_selected 
		--str_data[2]  command_selected     
		--str_data[3]  id_usuario 
		--str_data[4]  id 
		--str_data[5]  inv_prod_id 
		--str_data[6]  inv_prod_id_equiv
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];


		IF command_selected = 'new' THEN 
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo 
			cont_fila:=1; 

			IF extra_data[1] != 'sin datos' THEN 
				FOR cont_fila IN 1 .. total_filas LOOP 
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___'); 
					--aqui se vuelven a crear los registros 
					INSERT INTO inv_prod_equiv ( inv_prod_id ,          inv_prod_id_equiv ,    observaciones )  
					VALUES (                     str_data[5]::integer,  str_filas[2]::integer,  str_filas[3]); 
					valor_retorno := '1'; 
				END LOOP; 
			END IF; 
		END IF; 

		IF command_selected = 'edit' THEN 
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo 
			cont_fila:=1; 
			--DELETE FROM  inv_prod_equiv WHERE inv_prod_equiv.id = '||str_data[4]::integer||' AND inv_formulas.inv_prod_id='||str_data[6]::integer||' AND inv_formulas.nivel='||str_data[7]::integer||' ';
			DELETE  FROM inv_prod_equiv WHERE inv_prod_id = str_data[5]::integer;
			--IF extra_data[1] = 'sin datos' THEN 
				FOR cont_fila IN 1 .. total_filas LOOP 
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___'); 
					--aqui se vuelven a crear los registros 
					INSERT INTO inv_prod_equiv ( inv_prod_id ,          inv_prod_id_equiv ,    observaciones )  
					VALUES (                     str_data[5]::integer,  str_filas[2]::integer,  str_filas[3]); 
				END LOOP; 
				valor_retorno := '1';
			--END IF;
		END IF; 

		IF command_selected = 'delete' THEN 
			DELETE  FROM inv_prod_equiv  
			WHERE inv_prod_id = str_data[4]::integer; 
			valor_retorno := '1'; 
		END IF; 

	END IF;--termina Catalogo de productos equivalentes 

	
	
	-- Aplicativo de edicion de codigo ISO
	IF app_selected = 99 THEN
		IF command_selected = 'edit' THEN
			UPDATE gral_docs_conf SET valor=str_data[5] WHERE gral_docs_conf.gral_doc_id = str_data[4]::integer and campo='CODIGO1';
			
			UPDATE gral_docs_conf SET valor=str_data[6] WHERE gral_docs_conf.gral_doc_id = str_data[4]::integer and campo='CODIGO2';

			UPDATE gral_docs SET momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_id
			WHERE gral_docs.id = str_data[4]::integer;
			
			valor_retorno := '0';
		END IF;
	END IF;--termina Catalogo Puestos

	
	
	-- Catalogo de Motivos de Visitas
	IF app_selected = 109 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        descripcion
			
			id_tipo_consecutivo:=33;--Folio de motivo de visita
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO crm_motivos_visita (folio_mv,
						descripcion,
						borrado_logico, 
						momento_creacion, 
						gral_usr_id_creacion, 
						gral_emp_id, 
						gral_suc_id) 
						
					VALUES ( nuevo_folio,
						str_data[5],
						false,          
						now(),            
						usuario_id,           
						emp_id,      
						suc_id);
			valor_retorno := '1';
		END IF;	
		IF command_selected = 'edit' THEN
			UPDATE crm_motivos_visita SET descripcion=str_data[5],
						      momento_actualizacion=now(),
						      gral_usr_id_actualizacion=usuario_id	      
		        WHERE crm_motivos_visita.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_motivos_visita SET momento_baja=now(),borrado_logico=true 
			WHERE crm_motivos_visita.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de Motivos de Visita


	
	-- Catalogo de Formas de Contacto
	IF app_selected = 110 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        descripcion
			
			id_tipo_consecutivo:=34;--Folio de forma de contacto
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO crm_formas_contacto (folio_fc,
						descripcion,
						borrado_logico, 
						momento_creacion, 
						gral_usr_id_creacion, 
						gral_emp_id, 
						gral_suc_id) 
						
					VALUES ( nuevo_folio,
						str_data[5],
						false,          
						now(),            
						usuario_id,           
						emp_id,      
						suc_id);
			valor_retorno := '1';
		END IF;	
		IF command_selected = 'edit' THEN
			UPDATE crm_formas_contacto SET descripcion=str_data[5],
						      momento_actualizacion=now(),
						      gral_usr_id_actualizacion=usuario_id	      
		        WHERE crm_formas_contacto.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_formas_contacto SET momento_baja=now(),borrado_logico=true 
			WHERE crm_formas_contacto.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Formas de Contacto
	
	-- Catalogo de Motivos de Llamada
	IF app_selected = 111 THEN
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        descripcion
			
			id_tipo_consecutivo:=35;--Folio de motivo de llamada
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO crm_motivos_llamada (folio_mll,
						descripcion,
						borrado_logico, 
						momento_creacion, 
						gral_usr_id_creacion, 
						gral_emp_id, 
						gral_suc_id) 
						
					VALUES ( nuevo_folio,
						str_data[5],
						false,          
						now(),            
						usuario_id,           
						emp_id,      
						suc_id);
			valor_retorno := '1';
		END IF;	
		IF command_selected = 'edit' THEN
			UPDATE crm_motivos_llamada SET descripcion=str_data[5],
						      momento_actualizacion=now(),
						      gral_usr_id_actualizacion=usuario_id	      
		        WHERE crm_motivos_llamada.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update crm_motivos_llamada SET momento_baja=now(),borrado_logico=true 
			WHERE crm_motivos_llamada.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Motivos de Llamada
	

	--Catalogo de Prospectos(CRM)
	IF app_selected = 113 THEN
		IF command_selected = 'new' THEN
			id_tipo_consecutivo:=38;--Folio Catalogo de Prospectos
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--RAISE EXCEPTION '%','emp_id: '||emp_id;
			--RAISE EXCEPTION '%','nombre_consecutivo: '||nombre_consecutivo;
			--RAISE EXCEPTION '%','cadena_extra: '||cadena_extra;
			--RAISE EXCEPTION '%','numero_control_client: '||numero_control_client;
			
			INSERT INTO crm_prospectos(
					numero_control,--nuevo_folio
					
					estatus ,--str_data[5]
					crm_etapas_prospecto_id ,--str_data[6]
					tipo_prospecto_id,--str_data[7]

					rfc,--str_data[8]
					razon_social,--str_data[9]
					calle,--str_data[10]
					numero,--str_data[11]
					entre_calles,--str_data[12]
					numero_exterior,--str_data[13]
					colonia,--str_data[14]
					cp,--str_data[15]
					pais_id,--str_data[16]::integer
					estado_id,--str_data[17]::integer
					municipio_id,--str_data[18]::integer
					localidad_alternativa,--str_data[19]
					telefono1,--str_data[20]
					extension1,--str_data[21]
					fax,--str_data[22]
					telefono2,--str_data[23]
					extension2,--str_data[24]
					email,--str_data[25]
					contacto,--str_data[26]
					clasificacion_id, --str_data[27] ,
					tipo_industria_id,--str_data[28],
					observaciones,--str_data[29]
					
					momento_creacion,--now()
					gral_usr_id_creacion,--usuario_id
					gral_emp_id,--emp_id
					gral_suc_id--suc_id
				)VALUES (
					nuevo_folio,
					str_data[5]::integer,
					str_data[6]::integer,
					str_data[7]::integer,

					str_data[8],
					str_data[9],
					str_data[10],
					str_data[11],
					str_data[12],
					str_data[13],
					str_data[14],
					str_data[15],
					str_data[16]::integer,
					str_data[17]::integer,
					str_data[18]::integer,
					str_data[19],
					str_data[20],
					str_data[21],
					str_data[22],
					str_data[23],
					str_data[24],
					str_data[25],
					str_data[26],
					str_data[27]::integer,
					str_data[28]::integer,
					str_data[29],
				
					now(),
					usuario_id,
					emp_id,
					suc_id
				)RETURNING id INTO ultimo_id;
			
				
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			--SELECT INTO str_data string_to_array(''||campos_data||'','___');
			--RAISE EXCEPTION '%',str_data[1];
			--RAISE EXCEPTION '%',identificador;
			--RAISE EXCEPTION '%','total  de filas???'||str_data[5]||'___'||str_data[6]||'___'||str_data[7]||'___'||str_data[8]||'___'||str_data[9]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10]||'___'||str_data[10];
			UPDATE crm_prospectos SET 
					--numero_control,--nuevo_folio
					estatus=str_data[5]::integer,
					crm_etapas_prospecto_id=str_data[6]::integer,
					tipo_prospecto_id=str_data[7]::integer,

					rfc=str_data[8],
					razon_social=str_data[9],
					calle=str_data[10],
					numero=str_data[11],
					entre_calles=str_data[12],
					numero_exterior=str_data[13],
					colonia=str_data[14],
					cp=str_data[15],
					pais_id=str_data[16]::integer,
					estado_id=str_data[17]::integer,
					municipio_id=str_data[18]::integer,
					localidad_alternativa=str_data[19],
					telefono1=str_data[20],
					extension1=str_data[21],
					fax=str_data[22],
					telefono2=str_data[23],
					extension2=str_data[24],
					email=str_data[25],
					contacto=str_data[26],
					clasificacion_id=str_data[27]::integer ,
					tipo_industria_id=str_data[28]::integer,
					observaciones=str_data[29],
					borrado_logico=false,
					momento_creacion=now(),
					gral_usr_id_actualizacion=usuario_id
					--gral_emp_id,--emp_id
					--gral_suc_id--suc_id
			WHERE id=str_data[4]::integer;
			
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE crm_prospectos SET borrado_logico=true, momento_baja=now(),gral_usr_id_baja = str_data[3]::integer WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Prospectos(CRM)

	
	
	-- Catalogo de Direcciones Fiscales de Clientes
	IF app_selected = 118 THEN
		IF command_selected = 'new' THEN
			--str_data[1] app_selected
			--str_data[2] command_selected
			--str_data[3] id_usuario
			--str_data[4] identificador
			--str_data[5] id_cliente
			--str_data[6] calle
			--str_data[7] numero_int
			--str_data[8] numero_ext
			--str_data[9] colonia
			--str_data[10] cp
			--str_data[11] select_pais
			--str_data[12] select_estado
			--str_data[13] select_municipio
			--str_data[14] entrecalles
			--str_data[15] tel1
			--str_data[16] ext1
			--str_data[17] fax
			--str_data[18] tel2
			--str_data[19] ext2
			--str_data[20] email
			--str_data[21] contacto
			
			INSERT INTO cxc_clie_df
			(
				cxc_clie_id,--str_data[5]::integer,
				calle,--str_data[6],
				numero_interior,--str_data[7],
				numero_exterior,--str_data[8],
				colonia,--str_data[9],
				cp,--str_data[10],
				gral_pais_id,--str_data[11]::integer,
				gral_edo_id,--str_data[12]::integer,
				gral_mun_id,--str_data[13]::integer,
				entre_calles,--str_data[14],
				telefono1,--str_data[15],
				extension1,--str_data[16],
				telefono2,--str_data[18],
				extension2,--str_data[19],
				fax,--str_data[17],
				email,--str_data[20],
				contacto,--str_data[21],
				momento_creacion,--now(),
				gra_usr_id_creacion--usuario_id
			)
			VALUES(str_data[5]::integer, str_data[6], str_data[7], str_data[8], str_data[9], str_data[10], str_data[11]::integer, str_data[12]::integer, str_data[13]::integer, str_data[14], str_data[15], str_data[16], str_data[18], str_data[19], str_data[17], str_data[20], str_data[21], now(), usuario_id);
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE cxc_clie_df SET cxc_clie_id=str_data[5]::integer, calle=str_data[6], numero_interior=str_data[7], numero_exterior=str_data[8], colonia=str_data[9], cp=str_data[10], gral_pais_id=str_data[11]::integer, gral_edo_id=str_data[12]::integer, gral_mun_id=str_data[13]::integer, entre_calles=str_data[14], telefono1=str_data[15], extension1=str_data[16], telefono2=str_data[18], extension2=str_data[19], fax=str_data[17], email=str_data[20], contacto=str_data[21], momento_actualizacion=now(), gra_usr_id_actualizacion=usuario_id
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE cxc_clie_df SET momento_baja=now(),borrado_logico=true, gra_usr_id_baja=usuario_id
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Direcciones Fiscales de Clientes








	
	-- Actualizador de Tipos de Cambio
	IF app_selected = 119 THEN
		IF command_selected = 'new'  or command_selected = 'edit' THEN
		--119___edit____1___4____3___2013-01-18___555
		--app_selected+"___"+command_selected+"___"+id_usuario+"___"+id+"___"+moneda_id+"___"+fecha+"___"+tipo_cambio;
		--RAISE EXCEPTION '%','DataString::'||str_data[1]||'___'||str_data[2]||'____'||str_data[3]||'___'||str_data[4]||'____'||str_data[5]||'___'||str_data[6]||'___'||str_data[7]||'___'||str_data[8];
			----str_data[1]    app_selected       119
			----str_data[2]    command_selected   edit
			----str_data[3]    id_usuario         1
		        ----str_data[4]         id            4
			----str_data[5]         moneda_id     3
			----str_data[6]     fecha             2013-01-18
			----strd_data[7]    tipo_cambio       555
			----strd_data[8]     fecha_de_hoy   
/*		         RAISE EXCEPTION '%','id Encontrado::'||'select count(erp_monedavers.id ) as cantidad_registros
			from  erp_monedavers 
			WHERE erp_monedavers.moneda_id='||str_data[5]::integer ||' and to_char(erp_monedavers.momento_creacion,''yyyy-mm-dd'') = '''||str_data[8]||'''';
*/
			
			select count(erp_monedavers.id ) as cantidad_registros
			from  erp_monedavers 
			WHERE erp_monedavers.moneda_id=str_data[5]::integer  and to_char(erp_monedavers.momento_creacion,'yyyy-mm-dd') = str_data[8]
			INTO exis;
			
			--INSERT INTO erp_monedavers (valor ,  momento_creacion )
			--VALUES                (str_data[7],   now())
			--app_selected+"___"+command_selected+"___"+id_usuario+"___"+id+"___"+moneda_id+"___"+fecha+"___"+tipo_cambio;
			IF exis = 0 THEN
				INSERT INTO erp_monedavers (valor ,  momento_creacion,moneda_id ,version) VALUES (str_data[7]::double precision,   now(), str_data[5]::integer,'ERP');  
			ELSE --select * from erp_monedavers where moneda_id=3
				UPDATE erp_monedavers SET momento_creacion=now(),valor=str_data[7]::double precision, version ='ERP'
				WHERE erp_monedavers.moneda_id=str_data[5]::integer and to_char(erp_monedavers.momento_creacion,'yyyy-mm-dd') = str_data[8];
			END IF;
			
			 
			valor_retorno := '1';
			
		END IF;
	END IF;--termina Actualizador de Tipos de cambio
	
	
	
	
	
	--Empieza Job Actualiza Moneda
	IF app_selected = 121 THEN
	/*GAS-SEP
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        valor
			--str_data[5]        tc
			--str_data[6]        moneda_desc
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');

					--RAISE EXCEPTION '%','extra_data[cont_fila]::'||extra_data[cont_fila];
					
					if str_filas[2]::double precision>0 then 
						select id from gral_mon where descripcion ilike '%'||str_filas[1]||'%' and borrado_logico=false limit 1 INTO ultimo_id;

						IF ultimo_id is not null THEN 
							select count(id) as cantidad from erp_monedavers where moneda_id=ultimo_id and momento_creacion > (select (select now())::date) INTO rowCount;
							
							IF rowCount <= 0 THEN 
								INSERT INTO erp_monedavers (moneda_id, valor, momento_creacion, version) 
								VALUES (ultimo_id, str_filas[2]::double precision, now(), str_filas[3]);
							end if;
						end if;
					end if;
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;	
	*/	
	END IF;--termina Job Actualiza Moneda
	
	
	
	
	--Aplicativo Actualizador de Contrase√±a del usuario
	IF app_selected = 155 THEN
		IF command_selected = 'edit' THEN
			UPDATE gral_usr SET password=str_data[5] WHERE id=str_data[3]::integer;
			
			valor_retorno := '1';
		END IF;	
		
	END IF;--termina Aplicativo Actualizador de Contrase√±a del usuario
	
	
	
	-- Catalogo de inventario de  IEPS
	IF app_selected = 167 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	descripcion
			--str_data[7]	tasa
			INSERT INTO gral_ieps (titulo,descripcion,tasa,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],str_data[6],str_data[7]::double precision,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE gral_ieps SET titulo=str_data[5],descripcion=str_data[6],tasa=str_data[7]::double precision,momento_actualizacion=now(),gral_usr_id_actualiza=usuario_id
			WHERE gral_ieps.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_ieps SET momento_baja=now(),borrado_logico=true 
			WHERE gral_ieps.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo IEPS


	-- Catalogo de inventario de  Percepciones
	IF app_selected = 170 THEN
		IF command_selected = 'new' THEN
			id_tipo_consecutivo:=48;--Folio Catalogo de Percepciones
			
			--aqui entra para tomar el consecutivo del folio de la Percepcionesactual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			nuevo_folio:= lpad(nuevo_folio, 3, '0');
			
			--str_data[4]	id
			--str_data clave nuevo_folio
			--str_data[5]	titulo
			--str_data[6]	activo
			--str_data[7]	tipopercepciones
			INSERT INTO nom_percep (clave,titulo,activo,nom_percep_tipo_id,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (nuevo_folio,str_data[5],str_data[6]::boolean,str_data[7]::integer,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE nom_percep SET titulo=str_data[5],activo=str_data[6]::boolean,nom_percep_tipo_id=str_data[7]::integer,momento_actualiza=now(),gral_usr_id_actualiza=usuario_id
			WHERE nom_percep.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE nom_percep SET momento_baja=now(),borrado_logico=true WHERE nom_percep.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Percepciones
	
	
	
	-- Catalogo de inventario de  Deducciones
	IF app_selected = 171 THEN
		IF command_selected = 'new' THEN
			id_tipo_consecutivo:=49;--Folio Catalogo de Deducciones
			
			--aqui entra para tomar el consecutivo del folio  de Deducciones actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			nuevo_folio:= lpad(nuevo_folio, 3, '0');
			
			--str_data[4]	id
			--str_data clave nuevo_folio
			--str_data[5]	titulo
			--str_data[6]	activo
			--str_data[7]	tipopercepciones
			INSERT INTO nom_deduc (clave,titulo,activo,nom_deduc_tipo_id,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (nuevo_folio,str_data[5],str_data[6]::boolean,str_data[7]::integer,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE nom_deduc SET titulo=str_data[5],activo=str_data[6]::boolean,nom_deduc_tipo_id=str_data[7]::integer, momento_actualiza=now(), gral_usr_id_actualiza=usuario_id 
			WHERE nom_deduc.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE nom_deduc SET momento_baja=now(),borrado_logico=true WHERE nom_deduc.id = str_data[4]::integer; 
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo Deducciones


	
	-- Catalogo de inventario de  Periodicidad de Pago
	IF app_selected = 172 THEN
		IF command_selected = 'new' THEN

			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	no_periodos
			--str_data[7]	activo
			INSERT INTO nom_periodicidad_pago (titulo,no_periodos,activo,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],str_data[6]::integer,str_data[7]::boolean,false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE nom_periodicidad_pago SET titulo=str_data[5],no_periodos=str_data[6]::integer,activo=str_data[7]::boolean,momento_actualiza=now(), gral_usr_id_actualiza=usuario_id 
			WHERE nom_periodicidad_pago.id = str_data[4]::integer;
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE nom_periodicidad_pago SET momento_baja=now(),borrado_logico=true, gral_usr_id_baja=usuario_id  WHERE nom_periodicidad_pago.id = str_data[4]::integer; 
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo Periodicidad de Pago




-- Catalogo de Configuraci√≥n Periodicidad de Pago
	IF app_selected = 174 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data clave nuevo_folio
			--str_data[5]	a√±o
			--str_data[6]	tipoperiodicidad
			--str_data[7]	descripcion
			
			INSERT INTO nom_periodos_conf (ano,nom_periodicidad_pago_id,prefijo,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5]::integer,str_data[6]::integer,str_data[7],false,now(),usuario_id,emp_id,suc_id)
			RETURNING id INTO ultimo_id;
			valor_retorno := '1';
			
			total_filas:= array_length(extra_data,1);
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	id_reg 
					--str_filas[2]	id_periodo 
					--str_filas[3]	folio 
					--str_filas[4]	tituloperiodo
					--str_filas[5]	fecha_inicio 
					--str_filas[6]	fecha_final
					
					--crea registro en nom_periodos_conf_det
					INSERT INTO nom_periodos_conf_det(
						nom_periodos_conf_id,--str_data[4]::integer,
						folio,--str_filas[3]	folio 
						titulo,--str_filas[4]	tituloperiodo 
						fecha_ini,--str_filas[5]	fecha_inicio
						fecha_fin--str_filas[6]	fecha_final
						
					 ) VALUES(ultimo_id, str_filas[3]::integer, str_filas[4], str_filas[5]::date,str_filas[6]::date);
					 --RETURNING id INTO ultimo_id;
					 valor_retorno := '1';
				END LOOP;
			END IF;
			
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE nom_periodos_conf SET ano=str_data[5]::integer,nom_periodicidad_pago_id=str_data[6]::integer,prefijo=str_data[7],momento_actualiza=now(),gral_usr_id_actualiza=usuario_id 
			WHERE nom_periodos_conf.id = str_data[4]::integer;
			valor_retorno := '0';
			
			total_filas:= array_length(extra_data,1);
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP 
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	id_reg 
					--str_filas[2]	id_periodo 
					--str_filas[3]	folio 
					--str_filas[4]	tituloperiodo
					--str_filas[5]	fecha_inicio 
					--str_filas[6]	fecha_final
					
					UPDATE nom_periodos_conf_det SET folio=str_filas[3]::integer,titulo=str_filas[4],fecha_ini=str_filas[5]::date,fecha_fin=str_filas[6]::date
					WHERE nom_periodos_conf_det.id = str_filas[1]::integer;
					valor_retorno := '0';
				END LOOP;
			END IF;
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE nom_periodos_conf SET momento_baja=now(),borrado_logico=true 
			WHERE nom_periodos_conf.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;-- Catalogo de Configuraci√≥n Periodicidad de Pago

	
	-- Catalogo de descuentos  de  clientes
	IF app_selected = 176 THEN
                IF command_selected = 'new' THEN
                        --str_data[4]         id
                        --str_data[5]         cliente
                        --str_data[6]         valor
                        INSERT INTO cxc_clie_descto (cxc_clie_id,tipo,valor) VALUES (str_data[5]::integer,1,str_data[6]::double precision);
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'edit' THEN
                        UPDATE cxc_clie_descto SET cxc_clie_id=str_data[5]::integer,valor=str_data[6]::double precision 
                        WHERE id = str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
                
                IF command_selected = 'delete' THEN
                        DELETE FROM cxc_clie_descto WHERE id=str_data[4]::integer;
                        valor_retorno := '1';
                END IF;
        END IF;--termina Catalogo descuentos  de  clientes

        
	--Catalogo de IVA Trasladado
	IF app_selected = 204 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	tasa
			--str_data[7]	cta_id
			
			if str_data[6]::double precision>0 then 
				str_data[6] := str_data[6]::double precision/100;
			end if;
			
			INSERT INTO gral_imptos (descripcion,iva_1,momento_creacion,gral_usr_id_crea,borrado_logico) VALUES (str_data[5],str_data[6]::double precision,espacio_tiempo_ejecucion,usuario_id,false) 
			RETURNING id INTO ultimo_id;

			if incluye_modulo_contabilidad then 
				IF EXISTS (SELECT * FROM information_schema.tables WHERE table_name='gral_impto_cta') THEN
					insert into gral_impto_cta(gral_impto_id,ctb_cta_id,momento_actualiza,gral_usr_id_actualiza,gral_suc_id) 
					values(ultimo_id,str_data[7]::integer,espacio_tiempo_ejecucion,usuario_id,suc_id);
				END IF;
			end if;
						
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN 
			if str_data[6]::double precision>0 then 
				str_data[6] := str_data[6]::double precision/100;
			end if;
			
			UPDATE gral_imptos SET descripcion=str_data[5],iva_1=str_data[6]::double precision,momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualiza=usuario_id 
			WHERE id=str_data[4]::integer;

			if incluye_modulo_contabilidad then 
				IF EXISTS (SELECT * FROM information_schema.tables WHERE table_name='gral_impto_cta') THEN 
					if (select count(id) from gral_impto_cta where gral_impto_id=str_data[4]::integer)>0 then 
						update gral_impto_cta set ctb_cta_id=str_data[7]::integer, momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
						where gral_impto_id=str_data[4]::integer;
					else 
						insert into gral_impto_cta(gral_impto_id,ctb_cta_id,momento_actualiza,gral_usr_id_actualiza,gral_suc_id) 
						values(str_data[4]::integer,str_data[7]::integer,espacio_tiempo_ejecucion,usuario_id,suc_id);
					end if;
				END IF;
			end if;
			
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_imptos SET momento_baja=espacio_tiempo_ejecucion,gral_usr_id_cancela=usuario_id,borrado_logico=true 
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo de IVA Trasladado


	--Catalogo de IVA Retenido
	IF app_selected = 205 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	titulo
			--str_data[6]	tasa
			--str_data[7]	cta_id
			
			INSERT INTO gral_imptos_ret(titulo,tasa,momento_creacion,gral_usr_id_crea,borrado_logico) 
			VALUES (str_data[5],str_data[6]::double precision,espacio_tiempo_ejecucion,usuario_id,false) 
			RETURNING id INTO ultimo_id;
			
			if incluye_modulo_contabilidad then 
				IF EXISTS (SELECT * FROM information_schema.tables WHERE table_name='gral_impto_ret_cta') THEN
					insert into gral_impto_ret_cta(gral_impto_ret_id,ctb_cta_id,momento_actualiza,gral_usr_id_actualiza,gral_suc_id) 
					values(ultimo_id,str_data[7]::integer,espacio_tiempo_ejecucion,usuario_id,suc_id);
				END IF;
			end if;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN 
			UPDATE gral_imptos_ret SET titulo=str_data[5],tasa=str_data[6]::double precision,momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualiza=usuario_id 
			WHERE id=str_data[4]::integer;
			
			if incluye_modulo_contabilidad then 
				IF EXISTS (SELECT * FROM information_schema.tables WHERE table_name='gral_impto_ret_cta') THEN 
					if (select count(id) from gral_impto_ret_cta where gral_impto_ret_id=str_data[4]::integer)>0 then 
						update gral_impto_ret_cta set ctb_cta_id=str_data[7]::integer, momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
						where gral_impto_ret_id=str_data[4]::integer;
					else 
						insert into gral_impto_ret_cta(gral_impto_ret_id,ctb_cta_id,momento_actualiza,gral_usr_id_actualiza,gral_suc_id) 
						values(str_data[4]::integer,str_data[7]::integer,espacio_tiempo_ejecucion,usuario_id,suc_id);
					end if;
				END IF;
			end if;
			
			valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE gral_imptos_ret SET momento_baja=espacio_tiempo_ejecucion,gral_usr_id_cancela=usuario_id,borrado_logico=true 
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo de IVA Retenido



	--Catalogo de Metodos de Pago
	IF app_selected = 209 THEN
		IF command_selected = 'new' THEN
			--str_data[4]	id
			--str_data[5]	clave
			--str_data[6]	titulo
			
			INSERT INTO fac_metodos_pago(clave_sat,titulo,momento_creacion,gral_usr_id_creacion,borrado_logico) 
			VALUES (str_data[5],str_data[6],espacio_tiempo_ejecucion,usuario_id,false);
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN 
			UPDATE fac_metodos_pago SET clave_sat=str_data[5],titulo=str_data[6],momento_actualiza=espacio_tiempo_ejecucion,gral_usr_id_actualizacion=usuario_id 
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE fac_metodos_pago SET momento_baja=espacio_tiempo_ejecucion,gral_usr_id_baja=usuario_id,borrado_logico=true 
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo de Metodos de Pago














	
	
	
	
	RETURN valor_retorno;
	
END;$$;


--
-- Name: gral_bus_catalogos(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gral_bus_catalogos(campos_data text) RETURNS SETOF record
    LANGUAGE plpgsql STABLE
    AS $$ 
DECLARE



	str_data text[];
	app_selected integer;
	id_user integer;
	emp_id integer;
	suc_id integer;

	sql_query text;
	fila         record;
	total_items  int:=0;

	cadena_where text;
	primer_cond integer;
	f_final character varying;

	numero_cta_may smallint = 0;
	clasif_cta_may smallint = 0;
	cadena_where2 text;
	id_agente integer;
	exis integer=0;
	ano_actual integer;
	mes_actual integer;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	--id_almacen integer;
	--incrementa int:=1;
	
	
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	--aplicativo seleccionado
	app_selected := str_data[1]::integer;
	id_user := str_data[2]::integer;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = id_user
	INTO emp_id, suc_id;
	
	
	cadena_where:='';
	primer_cond := 0;


	
	--buscador del Catalogo de Almacenes
	IF app_selected = 1 THEN
		IF str_data[4]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND inv_alm.almacen_tipo_id='||str_data[4];
		END IF;
		sql_query := 'SELECT DISTINCT inv_alm.id 
				FROM inv_alm
				JOIN inv_suc_alm ON inv_suc_alm.almacen_id=inv_alm.id
				JOIN gral_suc ON gral_suc.id=inv_suc_alm.sucursal_id
				WHERE gral_suc.empresa_id='||emp_id||' AND inv_alm.borrado_logico=FALSE AND inv_alm.titulo ILIKE '''||str_data[3]||''' '||cadena_where;
	END IF;	--termina buscador  del Catalogo de almacenes 
	
	--RAISE EXCEPTION '%','sql_query: '||sql_query;
	
	--buscador de proveedores
	IF app_selected = 2 THEN
		sql_query := 'select id from cxp_prov where empresa_id='||emp_id||' and sucursal_id='||suc_id||' and borrado_logico=FALSE and razon_social ILIKE '''||str_data[3]||''' AND rfc ilike '''||str_data[4]||''' AND folio ilike '''||str_data[5]||''';';
	END IF;	--termina buscador de proveedores
	--RAISE EXCEPTION '%','sql_query: '||sql_query;
	
	--buscador de empleados
        IF app_selected = 4 THEN
                IF str_data[4]::integer=0 THEN
                        sql_query := 'SELECT id FROM gral_empleados WHERE borrado_logico=false AND gral_emp_id = '||emp_id;
                END IF;
                ---por clave empleado
                IF str_data[4]::integer=1 THEN
                        sql_query := 'SELECT id FROM gral_empleados WHERE borrado_logico=false AND gral_emp_id = '|| emp_id ||'  AND  clave ilike '''||str_data[3]||'''';
                END IF;
                --por nombre
                IF str_data[4]::integer=2 THEN
                        sql_query := 'SELECT id FROM gral_empleados WHERE borrado_logico=false AND gral_emp_id = '|| emp_id ||' AND nombre_pila ilike '''||str_data[3]||'''';
                END IF;
                --por curp
                IF str_data[4]::integer=3 THEN
                        sql_query := 'SELECT id FROM gral_empleados WHERE borrado_logico=false AND gral_emp_id = '|| emp_id ||' AND curp ilike '''||str_data[3]||'''';
                END IF;
                --por puesto
                IF str_data[4]::integer=4 THEN
                        sql_query := 'SELECT id FROM gral_empleados WHERE borrado_logico=false AND gral_emp_id = '|| emp_id ||' AND gral_puesto_id '||str_data[3]||'';
                END IF;
        END IF;        --termina buscador de empleados


	
	--buscador de clientes
	IF app_selected = 5 THEN
		--str_data[3]	nocontrol
		--str_data[4]	razonsoc
		--str_data[5]	rfc
		
		IF str_data[3]<>'' THEN
			cadena_where:= cadena_where ||' and numero_control ilike '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]<>'%%' THEN
			cadena_where:= cadena_where ||' and razon_social ilike '''||str_data[4]||'''';
		END IF;

		IF str_data[5]<>'%%' THEN
			cadena_where:= cadena_where ||' and rfc ilike '''||str_data[5]||'''';
		END IF;
		
		sql_query := 'select id from cxc_clie where borrado_logico=false and empresa_id='||emp_id||' and borrado_logico=false '||cadena_where;
		
	END IF;	--termina buscador de clientes
	
	
	
	
	
	--buscador de productos
	IF app_selected = 8 THEN
		--str_data[3]	sku
		--str_data[4]	descripcion
		--str_data[5]	por_tipo
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND  inv_prod.descripcion ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND inv_prod.tipo_de_producto_id='||str_data[5]::integer;
		END IF;
		
		sql_query := 'SELECT id FROM inv_prod WHERE empresa_id='||emp_id||' AND borrado_logico=FALSE '||cadena_where;
		
	END IF;	--termina buscador de productos
	
	
	
	--buscador de entradas
	IF app_selected = 9 THEN
		--str_data[3]	folio
		--str_data[4]	orden_compra
		--str_data[5]	factura
		--str_data[6]	proveedor
		--str_data[7]	tipoDoc
		--str_data[8]	codigo
		--str_data[9]	producto
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND com_fac.no_entrada ilike '''||str_data[3]||'''';
		END IF;

		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND com_fac.factura ilike '''||str_data[5]||'''';
		END IF;

		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND com_fac.orden_de_compra ilike '''||str_data[4]||'''';
		END IF;

		IF str_data[6] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike '''||str_data[6]||'''';
		END IF;

		IF str_data[7]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND com_fac.tipo_documento='||str_data[7];
		END IF;

		IF str_data[8] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike '''||str_data[8]||'''';
		END IF;
		
		IF str_data[9] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike '''||str_data[9]||'''';
		END IF;
		
		sql_query := 'SELECT DISTINCT com_fac.id
			FROM com_fac
			JOIN com_fac_detalle on com_fac_detalle.com_fac_id=com_fac.id
			JOIN inv_prod on inv_prod.id=com_fac_detalle.producto_id
			LEFT JOIN cxp_prov on cxp_prov.id=com_fac.proveedor_id
			WHERE com_fac.empresa_id='||emp_id||'  AND com_fac.borrado_logico=FALSE '||cadena_where;
	END IF;	--termina buscador de entradas



	--buscador de Aplicativo Traspasos
	IF app_selected = 10 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	codigo
		--str_data[5]	descripcion
		--str_data[6]	alm_origen
		--str_data[7]	alm_destino
		--str_data[8]	fecha_inicial
		--str_data[9]	fecha_final
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_tras.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[5]||'''';
		END IF;
		
		IF str_data[6] != '0' THEN
			cadena_where:= cadena_where ||' AND inv_tras.inv_alm_id_origen='||str_data[6]||'';
		END IF;
		
		IF str_data[7] != '0' THEN
			cadena_where:= cadena_where ||' AND inv_tras.inv_alm_id_destino='||str_data[7]||'';
		END IF;
		
		--busqueda por fecha de traspaso
		IF str_data[8] != '' THEN
			IF str_data[9] = '' THEN
				f_final:=str_data[8];
			ELSE
				f_final:=str_data[9];
			END IF;
			cadena_where:=cadena_where||' AND to_char(inv_tras.fecha_traspaso::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[8]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := '
			SELECT DISTINCT inv_tras.id
			FROM inv_tras
			JOIN inv_tras_det ON inv_tras_det.inv_tras_id=inv_tras.id
			JOIN inv_prod ON inv_prod.id=inv_tras_det.inv_prod_id
			WHERE inv_tras.gral_emp_id='||emp_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Aplicativo Traspasos
	
	
	
	
	--Buscador de Aplicativo Cotizaciones
	IF app_selected = 12 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	tipo
		--str_data[8]	incluye_crm
		
		IF str_data[3] != '%%' THEN
			IF str_data[7]::integer = 0 THEN 
				IF str_data[8]::boolean=false THEN		
					cadena_where:= cadena_where ||' AND poc_cot.folio ILIKE  '''||str_data[3]||'''';
				ELSE
					cadena_where:= cadena_where ||' AND sbt.folio ILIKE  '''||str_data[3]||'''';
				END IF;
			ELSE
				cadena_where:= cadena_where ||' AND poc_cot.folio ILIKE  '''||str_data[3]||'''';
			END IF;
		END IF;
		
		IF str_data[4] != '%%' THEN
			--cadena_where:= cadena_where ||' AND cxc_clie.razon_social ILIKE  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			
			IF str_data[7]::integer = 0 THEN 
				IF str_data[8]::boolean=false THEN		
					cadena_where:=cadena_where||' AND to_char(poc_cot.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
				ELSE
					cadena_where:=cadena_where||' AND to_char(sbt.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
				END IF;
			ELSE
				cadena_where:=cadena_where||' AND to_char(poc_cot.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
			END IF;
		END IF;
		
		IF str_data[7] != '0' THEN
			IF str_data[7]::integer = 0 THEN 
				IF str_data[8]::boolean=false THEN		
					cadena_where:= cadena_where ||' AND poc_cot.tipo='||str_data[7];
				ELSE
					cadena_where:= cadena_where ||' AND sbt.tipo='||str_data[7];
				END IF;
			ELSE
				cadena_where:= cadena_where ||' AND poc_cot.tipo='||str_data[7];
			END IF;
		END IF;

		IF str_data[9] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[9]||'''';
		END IF;
		
		IF str_data[10] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[10]||'''';
		END IF;
		
		
		--str_data[11]	agente
		IF str_data[11]::integer = 0 THEN
			--busca si el usuario tiene rol de ADMINISTRADOR
			SELECT count(gral_usr_id) FROM gral_usr_rol WHERE gral_usr_id=id_user AND gral_rol_id=1 INTO exis;
			
			IF exis=0 THEN
				--si el usuario no tiene rol de ADMINISTRADOR, entonces hay que filtrar solo registros del agente
				--en otro caso NO HAY filtro, se debe mostrar todos los registros de las Cotizaciones realizadas
				SELECT gral_usr.gral_empleados_id FROM gral_usr WHERE gral_usr.id=id_user INTO id_agente;
				
				IF str_data[7]::integer = 0 THEN 
					IF str_data[8]::boolean=false THEN		
						cadena_where:=cadena_where||' AND poc_cot.cxc_agen_id='||id_agente;
					ELSE
						cadena_where:=cadena_where||' AND sbt.cxc_agen_id='||id_agente;
					END IF;
				ELSE
					cadena_where:=cadena_where||' AND poc_cot.cxc_agen_id='||id_agente;
				END IF;
			END IF;
		ELSE
			IF str_data[7]::integer = 0 THEN 
				IF str_data[8]::boolean=false THEN		
					cadena_where:=cadena_where||' AND poc_cot.cxc_agen_id='||str_data[11];
				ELSE
					cadena_where:=cadena_where||' AND sbt.cxc_agen_id='||str_data[11];
				END IF;
			ELSE
				cadena_where:=cadena_where||' AND poc_cot.cxc_agen_id='||str_data[11];
			END IF;
		END IF;
		
		
		IF str_data[7]::integer = 0 THEN 
			IF str_data[8]::boolean=false THEN
				sql_query := 'SELECT DISTINCT poc_cot.id FROM poc_cot 
						JOIN poc_cot_detalle ON poc_cot_detalle.poc_cot_id=poc_cot.id
						JOIN inv_prod ON inv_prod.id = poc_cot_detalle.inv_prod_id  
						JOIN poc_cot_clie ON poc_cot_clie.poc_cot_id=poc_cot.id  
						JOIN cxc_clie ON cxc_clie.id =  poc_cot_clie.cxc_clie_id  
						JOIN erp_proceso ON erp_proceso.id=poc_cot.proceso_id 
						WHERE poc_cot.borrado_logico=false 
						AND erp_proceso.empresa_id='||emp_id||'
						AND cxc_clie.razon_social ILIKE  '''||str_data[4]||''' '||cadena_where;
			ELSE
				sql_query := 'SELECT 
					DISTINCT sbt.id
				FROM (
					SELECT DISTINCT poc_cot.id,
						poc_cot.folio,
						poc_cot.tipo,
						poc_cot.momento_creacion,
						poc_cot.proceso_id,
						poc_cot.cxc_agen_id
					FROM poc_cot 
					JOIN poc_cot_clie ON poc_cot_clie.poc_cot_id=poc_cot.id  
					JOIN cxc_clie ON (cxc_clie.id=poc_cot_clie.cxc_clie_id AND cxc_clie.razon_social ILIKE  '''||str_data[4]||'''  AND poc_cot.tipo=1 )
					WHERE poc_cot.borrado_logico=false
					
					UNION
					
					SELECT DISTINCT poc_cot.id,
						poc_cot.folio,
						poc_cot.tipo,
						poc_cot.momento_creacion,
						poc_cot.proceso_id,
						poc_cot.cxc_agen_id
					FROM poc_cot 
					JOIN poc_cot_prospecto ON poc_cot_prospecto.poc_cot_id=poc_cot.id  
					JOIN crm_prospectos ON (crm_prospectos.id=poc_cot_prospecto.crm_prospecto_id AND crm_prospectos.razon_social ILIKE '''||str_data[4]||'''   AND poc_cot.tipo=2) 
					WHERE poc_cot.borrado_logico=false
				) AS sbt
				JOIN poc_cot_detalle ON poc_cot_detalle.poc_cot_id=sbt.id
				JOIN inv_prod ON inv_prod.id = poc_cot_detalle.inv_prod_id  
				JOIN erp_proceso ON erp_proceso.id=sbt.proceso_id 
				WHERE erp_proceso.empresa_id='||emp_id||' '||cadena_where;
			END IF;

		END IF;
		

		
		IF str_data[7]::integer = 1 THEN 
			sql_query := 'SELECT DISTINCT poc_cot.id FROM poc_cot 
					JOIN poc_cot_detalle ON poc_cot_detalle.poc_cot_id=poc_cot.id
					JOIN inv_prod ON inv_prod.id = poc_cot_detalle.inv_prod_id  
					JOIN poc_cot_clie ON poc_cot_clie.poc_cot_id=poc_cot.id  
					JOIN cxc_clie ON cxc_clie.id =  poc_cot_clie.cxc_clie_id  
					JOIN erp_proceso ON erp_proceso.id=poc_cot.proceso_id 
					WHERE poc_cot.borrado_logico=false AND erp_proceso.empresa_id='||emp_id||' 
					AND cxc_clie.razon_social ILIKE  '''||str_data[4]||''' '||cadena_where;
		END IF;
		
		IF str_data[7]::integer=2 THEN 
			sql_query := 'SELECT DISTINCT poc_cot.id FROM poc_cot 
					JOIN poc_cot_detalle ON poc_cot_detalle.poc_cot_id=poc_cot.id
					JOIN inv_prod ON inv_prod.id = poc_cot_detalle.inv_prod_id  
					LEFT JOIN poc_cot_prospecto ON poc_cot_prospecto.poc_cot_id=poc_cot.id  
					LEFT JOIN crm_prospectos ON (crm_prospectos.id=poc_cot_prospecto.crm_prospecto_id ) 
					JOIN erp_proceso ON erp_proceso.id=poc_cot.proceso_id 
					WHERE poc_cot.borrado_logico=false AND erp_proceso.empresa_id='||emp_id||' 
					AND crm_prospectos.razon_social ILIKE '''||str_data[4]||''' '||cadena_where;
		END IF;
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;
	--Termina Aplicativo Cotizaciones
	
	
	
	--buscador de prefacturas
	IF app_selected = 13 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	cliente
		--str_data[4]	fecha_inicial
		--str_data[5]	fecha_final
		--str_data[6]	codigo
		--str_data[7]	producto
		--str_data[8]	agente
		--str_data[9]	folio_pedido
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[3]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[4] != '' THEN
			IF str_data[5] = '' THEN
				f_final:=str_data[4];
			ELSE
				f_final:=str_data[5];
			END IF;
			cadena_where:=cadena_where||' AND to_char(erp_prefacturas.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[4]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		IF str_data[6] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[6]||'''';
		END IF;
		
		IF str_data[7] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[7]||'''';
		END IF;
		
		IF str_data[8]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND erp_prefacturas.empleado_id='||str_data[8];
		END IF;

		IF str_data[9] != '%%' THEN
			cadena_where:= cadena_where ||' AND erp_prefacturas.folio_pedido ilike  '''||str_data[9]||'''';
		END IF;
		
		sql_query := 'SELECT DISTINCT erp_prefacturas.id 
				FROM erp_prefacturas 
				LEFT JOIN erp_prefacturas_detalles ON erp_prefacturas_detalles.prefacturas_id = erp_prefacturas.id 
				JOIN inv_prod ON inv_prod.id = erp_prefacturas_detalles.producto_id
				JOIN erp_proceso ON erp_proceso.id = erp_prefacturas.proceso_id
				LEFT JOIN cxc_clie ON cxc_clie.id = erp_prefacturas.cliente_id  
				WHERE erp_proceso.empresa_id='||emp_id||' AND  erp_proceso.sucursal_id='||suc_id||' '
				'AND erp_prefacturas.borrado_logico=FALSE  '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de prefacturas
	
	
	--buscador carteras
	IF app_selected = 14 THEN	
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	num_transaccion
		--str_data[4]	factura
		--str_data[5]	cliente
		--str_data[6]	fecha_inicial
		--str_data[7]	fecha_final
		primer_cond:=0;
		IF str_data[3] != '' THEN
			cadena_where:= cadena_where ||' AND erp_pagos.numero_transaccion='||str_data[3];
			primer_cond:=1;
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND erp_pagos_detalles.serie_folio ilike  '''||str_data[4]||'''';
			primer_cond:=1;
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[5]||'''';
			primer_cond:=1;
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[6] != '' THEN
			IF str_data[7] = '' THEN
				f_final:=str_data[6];
			ELSE
				f_final:=str_data[7];
			END IF;
			cadena_where:=cadena_where||' AND to_char(erp_pagos.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
			primer_cond:=1;
		END IF;
		
		IF primer_cond=0 THEN
			cadena_where:= cadena_where ||' AND to_char(erp_pagos.momento_creacion,''yyyymmdd'') = (select to_char(MAX(erp_pagos.momento_creacion),''yyyymmdd'') FROM erp_pagos  WHERE empresa_id='||emp_id||' AND sucursal_id='||suc_id||')';
		END IF;
		
		sql_query := 'SELECT erp_pagos.id 
		FROM erp_pagos
		LEFT JOIN erp_pagos_detalles ON erp_pagos_detalles.pago_id = erp_pagos.id
		LEFT JOIN cxc_clie on cxc_clie.id = erp_pagos.cliente_id   
		WHERE erp_pagos.empresa_id='||emp_id||' AND erp_pagos.sucursal_id='||suc_id||' '||cadena_where;

		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador carteras
	
	
	
	--buscador de centro de costos
	IF app_selected = 15 THEN
		sql_query := 'SELECT id FROM ctb_cc WHERE empresa_id= '||emp_id||' AND borrado_logico=FALSE AND titulo ILIKE '''||str_data[3]||''' AND descripcion ILIKE '''||str_data[4]||''';';
	END IF;	--termina buscador de centros de costos
	
	
	--buscador de Tipos de Poliza
	IF app_selected = 16 THEN
		IF str_data[3] != '' THEN
			cadena_where:= cadena_where ||' AND tipo= '||str_data[3];
		END IF;
		IF str_data[5] != '0' THEN
			cadena_where:= cadena_where ||' AND ctb_tpol_grupo_id= '||str_data[5];
		END IF;
		sql_query := 'SELECT id FROM ctb_tpol WHERE borrado_logico=FALSE AND empresa_id='||emp_id||' '||cadena_where||' AND titulo ILIKE '''||str_data[4]||''';';
	END IF;	--termina buscador de Tipos de Poliza
	
	
	
	--buscador de conceptos contables
	IF app_selected = 17 THEN
		sql_query := 'SELECT id FROM ctb_con WHERE empresa_id= '||emp_id||' AND borrado_logico=FALSE AND titulo ILIKE '''||str_data[3]||''' AND descripcion ILIKE '''||str_data[4]||''';';
	END IF;	--termina buscador de conceptos contables
	
	--buscador Clasificacion de cuentas(Cuentas de Mayor)
	IF app_selected = 18 THEN
		IF str_data[3] != '' THEN
			cadena_where:= cadena_where ||' AND clasificacion= '||str_data[3];
		END IF;
		IF str_data[5] != '0' THEN
			cadena_where:= cadena_where ||' AND ctb_may_clase_id= '||str_data[5];
		END IF;
		
		sql_query := 'SELECT id FROM ctb_may WHERE empresa_id ='||emp_id||' AND borrado_logico=FALSE
				AND (descripcion ILIKE '''||str_data[4]||''' OR descripcion_ing ILIKE '''||str_data[4]||''' OR descripcion_otr ILIKE '''||str_data[4]||''') '||cadena_where;
		
	END IF;	--termina buscador Clasificacion de cuentas(Cuentas de Mayor)
	
	
	--buscador de Agentes
	IF app_selected = 19 THEN
		
		IF str_data[5]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND cxc_agen.gral_reg_id='||str_data[5];
		END IF;
		
		sql_query := 'SELECT cxc_agen.id FROM cxc_agen
				JOIN gral_usr ON gral_usr.id=cxc_agen.gral_usr_id
				JOIN gral_usr_suc ON gral_usr_suc.gral_usr_id=gral_usr.id
				JOIN gral_suc ON gral_suc.id=gral_usr_suc.gral_suc_id
				WHERE cxc_agen.borrado_logico = FALSE AND gral_suc.empresa_id='||emp_id||'  '||cadena_where||
				' AND cxc_agen.nombre ILIKE '''||str_data[3]||''' AND gral_usr.username ILIKE '''||str_data[4]||'''';
		
	END IF;	--termina buscador  de Agentes
	
	--buscador de Catalogo Clientes Clasificacion 1
	IF app_selected = 20 THEN
		sql_query := 'SELECT id FROM cxc_clie_clas1 WHERE titulo ILIKE '''||str_data[3]||''';';
	END IF;	--termina Catalogo Clientes Clasificacion 1
	
	--buscador de Catalogo Clientes Clasificacion 2
	IF app_selected = 21 THEN
		sql_query := 'SELECT id FROM cxc_clie_clas2 WHERE titulo ILIKE '''||str_data[3]||''';';
	END IF;	--termina Catalogo Clientes Clasificacion 2
	
	--buscador de Catalogo Clientes Clasificacion 3
	IF app_selected = 22 THEN
		sql_query := 'SELECT id FROM cxc_clie_clas3 WHERE titulo ILIKE '''||str_data[3]||''';';
	END IF;	--termina Catalogo Clientes Clasificacion 3
	
	--buscador de Catalogo de Zonas de Clientes
        IF app_selected = 23 THEN
                sql_query := 'SELECT id FROM cxc_clie_zonas WHERE titulo ILIKE '''||str_data[3]||''';';
        END IF;        --termina Catalogo de Zonas de Clientes
        
        --buscador de Catalogo de Grupos de Clientes
        IF app_selected = 24 THEN
                sql_query := 'SELECT id FROM cxc_clie_grupos WHERE titulo ILIKE '''||str_data[3]||''';';
        END IF;        --termina Catalogo de Grupos de Clientes
	
	
	--buscador de Catalogo Proveedores Clasificacion 1
        IF app_selected = 25 THEN
                sql_query := 'SELECT id FROM cxp_prov_clas1 WHERE titulo ILIKE '''||str_data[3]||''' AND borrado_logico=FALSE AND gral_emp_id= '||emp_id;
        END IF;--termina Catalogo Proveedores Clasificacion 1
        
        --buscador de Catalogo Proveedores Clasificacion 2
        IF app_selected = 26 THEN
                sql_query := 'SELECT id FROM cxp_prov_clas2 WHERE titulo ILIKE '''||str_data[3]||''' AND borrado_logico=FALSE AND gral_emp_id= '||emp_id;
        END IF;--termina Catalogo Proveedores Clasificacion 2
        
        --buscador de Catalogo Proveedores Clasificacion 3
        IF app_selected = 27 THEN
                sql_query := 'SELECT id FROM cxp_prov_clas3 WHERE titulo ILIKE '''||str_data[3]||''' AND borrado_logico=FALSE AND gral_emp_id= '||emp_id;
        END IF;--termina Catalogo Proveedores Clasificacion 3


	--buscador de Catalogo zona de Proveedores
        IF app_selected = 28 THEN
                sql_query := 'SELECT id FROM cxp_prov_zonas WHERE titulo ILIKE '''||str_data[3]||''';';
        END IF;        --termina Catalogo Zona de proveedores

        --buscador de Catalogo zona de Proveedores
        IF app_selected = 29 THEN
                sql_query := 'SELECT id FROM cxp_prov_grupos WHERE titulo ILIKE '''||str_data[3]||''';';
        END IF;        --termina Catalogo Zona de proveedores
	
	
	--Buscador de Facturas de Proveedores
	IF app_selected = 30 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	factura
		--str_data[4]	proveedor
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		
		--busqueda por fecha factura
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=' AND to_char(cxp_facturas.fecha_factura, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := 'SELECT cxp_facturas.id
				FROM cxp_facturas
				JOIN cxp_prov ON cxp_prov.id=cxp_facturas.cxc_prov_id 
				WHERE cxp_facturas.serie_folio ILIKE '''||str_data[3]||''' 
				AND cxp_prov.razon_social ILIKE '''||str_data[4]||''' 
				AND cxp_facturas.empresa_id='||emp_id||' 
				AND cxp_facturas.sucursal_id='||suc_id||' '||cadena_where;
	END IF;
	--Termina buscador Facturas de Proveedores
	
	
	
	
	--buscador de Catalogo tipo de movimiento de proveedores
        IF app_selected = 31 THEN
                sql_query := 'SELECT id 
                             FROM cxp_mov_tipos 
                             WHERE titulo ILIKE '''||str_data[3]||''' AND gral_emp_id='||emp_id;
        END IF;        --termina Catalogo tipo de movimiento de proveedores


        --buscador de Catalogo movimientos de clientes
        IF app_selected = 32 THEN
                sql_query := 'SELECT id 
                             FROM cxc_mov_tipos 
                             WHERE titulo ILIKE '''||str_data[3]||''';';
        END IF;        --termina Catalogo  de mensajes de clientes

        
        --buscador de Catalogo menssajes de clientes
        IF app_selected = 33 THEN
                sql_query := 'SELECT id FROM cxc_clie_mensajes WHERE msg_1 ILIKE '''||str_data[3]||''';';
                
        END IF;        --termina Catalogo mensajes de clientes
	








	--buscador de Catalogo de tipos de movimientos inventario
        IF app_selected = 35 THEN
                sql_query := 'SELECT id FROM inv_mov_tipos WHERE titulo ILIKE '''||str_data[3]||''' and  descripcion ILIKE '''||str_data[4]||''' and borrado_logico=false;';
        END IF;        --termina Catalogo de tipos de movimientos inventario

	
	
	--Buscador para el Aplicativo Cancelacion de Facturas de clientes
	IF app_selected = 36 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	factura
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	codigo
		--str_data[8]	producto
		--str_data[9]	agente
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND fac_docs.serie_folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(fac_docs.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[7] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[7]||'''';
		END IF;
		
		IF str_data[8] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[8]||'''';
		END IF;
		
		IF str_data[9]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND fac_docs.cxc_agen_id='||str_data[9];
		END IF;
		
		sql_query := 'SELECT DISTINCT fac_docs.id 
				FROM fac_docs 
				JOIN fac_docs_detalles ON fac_docs_detalles.fac_doc_id = fac_docs.id 
				JOIN inv_prod ON inv_prod.id = fac_docs_detalles.inv_prod_id
				JOIN erp_proceso ON erp_proceso.id = fac_docs.proceso_id
				LEFT JOIN cxc_clie ON cxc_clie.id = fac_docs.cxc_clie_id   
				WHERE erp_proceso.empresa_id='||emp_id||' 
				AND  erp_proceso.sucursal_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de facturas de clientes

	

	--buscador de Catalogo de inv_secciones
        IF app_selected = 37 THEN
                sql_query := 'SELECT id FROM inv_secciones WHERE titulo ILIKE '''||str_data[3]||''' AND  descripcion ILIKE '''||str_data[4]||''' AND borrado_logico=false AND gral_emp_id='||emp_id;
        END IF;        --termina buscador de Catalogo de inv_secciones

	--buscador del catalogo de Marcas
	IF app_selected = 38 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	descripcion
		sql_query := 'SELECT inv_mar.id
				FROM inv_mar 
				WHERE inv_mar.borrado_logico=false 
				AND titulo ILIKE '''||str_data[3]||''' AND gral_emp_id='||emp_id;
	END IF;	--termina buscador del catalogo   de marcas
	
	
	--buscador de Catalogo de inv_prod_lineas
        IF app_selected = 39 THEN
                sql_query := 'SELECT id FROM inv_prod_lineas WHERE titulo ILIKE '''||str_data[3]||''' and  descripcion ILIKE '''||str_data[4]||''' and borrado_logico=false AND gral_emp_id='||emp_id;
        END IF;--termina buscador de Catalogo inv_prod_lineas
	
	
	
	--buscador de Zonas de invetarios
	IF app_selected =40 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	descripcion
		--str_data[4]	estatus
		/*
		IF str_data[3] != '' then
			cadena_where:=cadena_where ||' where titulo ILIKE '''||str_data[3]||'''';
		END IF;
		*/
		if str_data[4] !='sinestatus' then
			cadena_where:=cadena_where || ' and inv_zonas.estatus='''||str_data[4]||'''::boolean ';
		end if;
		
		sql_query := 'SELECT inv_zonas.id  FROM inv_zonas 
				WHERE borrado_logico=false AND titulo ILIKE '''||str_data[3]||''' '||cadena_where;
		--RAISE EXCEPTION '%',sql_query;							
	END IF;	--termina buscador  de zonas de inventarios

	
	
	--buscador de Catalogo de tes_mov_tipos
        IF app_selected = 41 THEN
                sql_query := 'SELECT id FROM tes_mov_tipos WHERE titulo ILIKE '''||str_data[3]||''' and  descripcion ILIKE '''||str_data[4]||''' and borrado_logico=false  AND gral_emp_id='||emp_id;
        END IF;        
        --termina buscador de Catalogo tes_mov_tipos
        
	
	--buscador de Catalogo de tesban
        IF app_selected = 42 THEN
                sql_query := 'SELECT id FROM tes_ban WHERE titulo ILIKE '''||str_data[3]||''' and  descripcion ILIKE '''||str_data[4]||''' and borrado_logico=false  AND gral_emp_id='||emp_id;
        END IF;        
        --termina buscador de Catalogo tes_ban

	
	--buscador de Catalogo de familias
        IF app_selected = 43 THEN
                sql_query := 'select id FROM inv_prod_familias WHERE borrado_logico=FALSE AND id=identificador_familia_padre AND titulo ILIKE '''||str_data[3]||''' AND  descripcion ILIKE '''||str_data[4]||''' AND borrado_logico=false AND gral_emp_id='||emp_id;
        END IF;--termina buscador de Catalogo de familias
	
	--buscador de Catalogo de Conceptos bancarios
        IF app_selected = 44 THEN
                sql_query := 'SELECT id FROM tes_con WHERE titulo ILIKE '''||str_data[3]||''' and  descripcion ILIKE '''||str_data[4]||''' AND borrado_logico=false  AND gral_emp_id='||emp_id;
        END IF;
        --termina buscador de Catalogo tescon
	
	
	--buscador de producto grupos
	IF app_selected =45 THEN
		--str_data[5]	grupo
		--str_data[6]	descripcion
		sql_query := 'SELECT inv_prod_grupos.id
				FROM inv_prod_grupos
				WHERE titulo ILIKE '''||str_data[3]||''' AND borrado_logico=FALSE AND gral_emp_id='||emp_id;
				--RAISE EXCEPTION '%',sql_query;							
	END IF;	--termina buscador  de productos
	
	
	
	--buscador de producto plazas
	IF app_selected =46 THEN
		--el 3 es el primero de la cadena buscador
		sql_query := 'SELECT gral_plazas.id
				FROM gral_plazas
				WHERE titulo ILIKE '''||str_data[3]||''' AND borrado_logico=false AND empresa_id='||emp_id||';';
				--RAISE EXCEPTION '%',sql_query;							
	END IF;	--termina buscador  de plazas
	
	
	
	--buscador de Catalogo de invprec
        IF app_selected = 47 THEN
		--str_data[1] 	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	tipo_prod
		--str_data[4]	codigo
		--str_data[5]	descripcion
		--str_data[6]	presentacion
		IF str_data[3]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND inv_prod.tipo_de_producto_id='||str_data[3];
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ILIKE '''||str_data[5]||'''';
		END IF;
		
		IF str_data[6]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND inv_pre.inv_prod_presentacion_id='||str_data[6];
		END IF;
		
                sql_query := 'SELECT inv_pre.id 
			FROM inv_pre 
			JOIN inv_prod ON inv_prod.id=inv_pre.inv_prod_id 
			WHERE inv_pre.borrado_logico=false AND gral_emp_id='||emp_id||' '||cadena_where||';';
		--RAISE EXCEPTION '%',sql_query;	
        END IF;
        --termina buscador de Catalogo invprec

	
	
	
	--buscador de Catalogo de Subfamilias
        IF app_selected = 48 THEN
		IF str_data[5]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND identificador_familia_padre='||str_data[5];
		END IF;
		sql_query := 'SELECT id 
				FROM inv_prod_familias 
				WHERE id !=identificador_familia_padre
				AND titulo ILIKE '''||str_data[3]||''' 
				AND descripcion ILIKE '''||str_data[4]||''' 
				AND borrado_logico=false AND gral_emp_id='||emp_id||' '||cadena_where;
        END IF;--termina buscador de Catalogo de Subfamilias
	


	--buscador de Catalogo de UNIDADES
        IF app_selected = 49 THEN
		IF str_data[4] != '' THEN
			cadena_where:= cadena_where ||' WHERE  titulo_abr ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[3] != 'sinvalor' THEN
			cadena_where:= cadena_where ||' and  inv_prod_unidades.decimales='||str_data[3]::integer;
		END IF;
		
		sql_query := 'SELECT id 
				FROM inv_prod_unidades' 
				||cadena_where;
		--RAISE EXCEPTION '%',sql_query;		
        END IF;--termina buscador de Catalogo de UNIDADES

	
	
	--buscador de clasificacion stock
	IF app_selected =50 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	clasificacion
		
		sql_query := 'select inv_stock_clasificaciones.id from inv_stock_clasificaciones 
		     WHERE titulo ILIKE '''||str_data[3]||''' and borrado_logico=false and gral_emp_id='||emp_id||';';
		--RAISE EXCEPTION '%',sql_query;							
	END IF;	--termina buscador  de clasificacion stock
	
	


	--buscador de Comisiones de arti-culos
        IF app_selected = 51 THEN
                sql_query := 'select inv_com.id from inv_com join inv_prod on inv_prod.id=inv_com.inv_prod_id where inv_prod.descripcion ILIKE '''||str_data[3]||''' and  inv_com.borrado_logico=false;';
        END IF;
        --termina buscador de Comisiones de arti-culos
	
	
	
	
	--buscador de clasificaciones
	IF app_selected =52 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	clasificacion
		
		sql_query := 'select inv_clas.id       
			     from inv_clas 
			     WHERE titulo ILIKE '''||str_data[3]||''' AND borrado_logico=false AND gral_emp_id='||emp_id||';';
		
		--RAISE EXCEPTION '%',sql_query;							
	END IF;	--termina buscador  de clasificaciones
	
	
	
	
	--buscador de inv_pre_ofe
        IF app_selected = 53 THEN
                sql_query := 'select inv_pre_ofe.id from inv_pre_ofe join inv_prod on inv_prod.id=inv_pre_ofe.inv_prod_id where inv_prod.descripcion ILIKE '''||str_data[3]||''' and  inv_pre_ofe.borrado_logico=false;';
        END IF;
        --termina buscador de inv_pre_ofe
	
	
	
	
	--buscador de Orden presubensamble
        IF app_selected = 55 THEN
                sql_query := 'SELECT DISTINCT inv_ord_subensamble.id FROM inv_ord_subensamble 
                JOIN inv_ord_subensamble_detalle ON inv_ord_subensamble_detalle.inv_ord_subensamble_id=inv_ord_subensamble.id 
                JOIN inv_prod ON inv_prod.id=inv_ord_subensamble_detalle.inv_prod_id_subensamble
                WHERE inv_ord_subensamble.folio ILIKE '''||str_data[3]||''' 
                AND inv_prod.sku ILIKE '''||str_data[4]||''' 
                AND inv_prod.descripcion ILIKE '''||str_data[5]||''' 
                AND inv_ord_subensamble.gral_emp_id='||emp_id||';';
        END IF;
        --termina buscador de Orden presubensamble
	--RAISE EXCEPTION '%',sql_query;
	
	

	--buscador de  direcciones de proveedores
	IF app_selected = 56 THEN
		--str_data[5]	grupo
		--str_data[6]	descripcion
			IF str_data[3]!= '0' THEN
			cadena_where='and cxp_prov_dir.proveedor_id = '||str_data[3]::integer;
			END IF;
	
		sql_query := 'SELECT cxp_prov_dir.id
				FROM cxp_prov_dir
				JOIN gral_suc ON gral_suc.id=cxp_prov_dir.gral_emp_id
				WHERE cxp_prov_dir.borrado_logico=FALSE AND gral_emp_id='||emp_id||' '||cadena_where;
			--RAISE EXCEPTION '%',sql_query;							
	END IF;	--termina buscador  de direcciones de proveedores

	
	
	
	--buscador de Orden subensamble 
        IF app_selected = 58 THEN
                sql_query := 'SELECT DISTINCT inv_ord_subensamble.id FROM inv_ord_subensamble 
			JOIN inv_ord_subensamble_detalle ON inv_ord_subensamble_detalle.inv_ord_subensamble_id=inv_ord_subensamble.id 
			JOIN inv_prod ON inv_prod.id=inv_ord_subensamble_detalle.inv_prod_id_subensamble
			JOIN inv_proceso  ON inv_proceso.id=inv_ord_subensamble.proceso_id
			WHERE inv_ord_subensamble.folio ILIKE '''||str_data[3]||''' 
			AND inv_prod.sku ILIKE '''||str_data[4]||''' 
			AND inv_prod.descripcion ILIKE '''||str_data[5]||''' 
			AND inv_proceso.proceso_flujo_id=2  
			AND inv_ord_subensamble.gral_emp_id='||emp_id||';';
        END IF;
        --buscador de Orden subensamble 
	

	--buscador de Chequera 
	IF app_selected = 59 THEN
		IF str_data[3]::integer<>0 THEN
			cadena_where:= cadena_where ||' AND tes_che.tes_ban_id='||str_data[3]::integer;
		END IF;
		
		sql_query := 'SELECT tes_che.id FROM tes_che  where tes_che.gral_emp_id='||emp_id||' AND tes_che.borrado_logico=false'||cadena_where;
			
	END IF;
	--buscador de Chequera

	
	--buscador de pagos a proveedores
	IF app_selected = 60 THEN	
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	num_transaccion
		--str_data[4]	factura
		--str_data[5]	proveedor
		--str_data[6]	fecha_inicial
		--str_data[7]	fecha_final
		IF str_data[3] <> '' THEN
			cadena_where:= cadena_where ||' AND cxp_pagos.numero_transaccion='||str_data[3];
			primer_cond:=1;
		END IF;
		
		IF str_data[4] <> '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_pagos_detalles.serie_folio ilike  '''||str_data[4]||'''';
			primer_cond:=1;
		END IF;
		
		IF str_data[5] <> '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike  '''||str_data[5]||'''';
			primer_cond:=1;
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[6] != '' THEN
			IF str_data[7] = '' THEN
				f_final:=str_data[6];
			ELSE
				f_final:=str_data[7];
			END IF;
			cadena_where:=cadena_where||' AND to_char(cxp_pagos.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
			primer_cond:=1;
		END IF;
		
		IF primer_cond=0 THEN
			cadena_where:= cadena_where ||' AND to_char(cxp_pagos.momento_creacion,''yyyymmdd'') = (select to_char(MAX(cxp_pagos.momento_creacion),''yyyymmdd'') FROM cxp_pagos WHERE gral_emp_id='||emp_id||' AND gral_suc_id='||suc_id||')';
		END IF;
		
		sql_query := 'SELECT cxp_pagos.id 
		FROM cxp_pagos
		LEFT JOIN cxp_pagos_detalles ON cxp_pagos_detalles.cxp_pago_id = cxp_pagos.id
		LEFT JOIN cxp_prov on cxp_prov.id = cxp_pagos.cxp_prov_id   
		WHERE cxp_pagos.gral_emp_id='||emp_id||' AND cxp_pagos.gral_suc_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%',sql_query;
	END IF;	--termina buscador de pagos proveedores
	
	
	
	
	
	--buscador de Anticipos de proveedores
	IF app_selected = 61 THEN	
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	num_transaccion
		--str_data[4]	proveedor
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		IF str_data[3] <> '' THEN
			cadena_where:= cadena_where ||' AND cxp_ant.folio ilike  '''||str_data[3]||'''';
			primer_cond:=1;
		END IF;

		IF str_data[4] <> '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike  '''||str_data[4]||'''';
			primer_cond:=1;
		END IF;

		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(cxp_ant.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
			primer_cond:=1;
		END IF;
		/*
		IF primer_cond=0 THEN
			cadena_where:= cadena_where ||' AND to_char(cxp_ant.momento_creacion,''yyyymmdd'') = (select to_char(MAX(cxp_ant.momento_creacion),''yyyymmdd'') FROM cxp_ant WHERE gral_emp_id='||emp_id||' AND gral_suc_id='||suc_id||')';
		END IF;
		*/
		sql_query := 'SELECT cxp_ant.id FROM cxp_ant LEFT JOIN cxp_prov on cxp_prov.id = cxp_ant.cxp_prov_id WHERE cxp_ant.gral_emp_id='||emp_id||' AND cxp_ant.gral_suc_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%',sql_query;
	END IF;
	--termina buscador de pagos proveedores
	
	
	
	--buscador de Parametros de Anticipos de proveedores
	IF app_selected = 62 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	id_sucursal
		IF str_data[3]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND gral_suc_id='||str_data[3];
		END IF;
		
		sql_query := 'SELECT id FROM cxp_ant_par WHERE borrado_logico=false AND gral_emp_id='||emp_id||' '||cadena_where;
	END IF;	--termina buscador Parametros de Anticipos de proveedores
	
	
	
	--buscador de pedidos de clientes
	IF app_selected = 64 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	codigo
		--str_data[8]	descripcion producto
		--str_data[9]	Agente
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND poc_pedidos.folio ilike  '''||str_data[3]||'''';
		END IF;

		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(poc_pedidos.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[7] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[7]||'''';
		END IF;
		
		IF str_data[8] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[8]||'''';
		END IF;

		IF str_data[9]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND poc_pedidos.cxc_agen_id='||str_data[9];
		END IF;
		sql_query := 'SELECT DISTINCT poc_pedidos.id 
				FROM poc_pedidos 
				LEFT JOIN poc_pedidos_detalle ON poc_pedidos_detalle.poc_pedido_id = poc_pedidos.id  
				LEFT JOIN inv_prod ON inv_prod.id = poc_pedidos_detalle.inv_prod_id  
				JOIN erp_proceso ON erp_proceso.id = poc_pedidos.proceso_id
				LEFT JOIN cxc_clie ON cxc_clie.id = poc_pedidos.cxc_clie_id  
				WHERE erp_proceso.empresa_id='||emp_id||' AND  erp_proceso.sucursal_id='||suc_id||' AND poc_pedidos.borrado_logico=FALSE  '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de pedidos de clientes
	
	
	--buscador de Aplicativo Autorizacion de Pedidos de Clientes
	IF app_selected = 65 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	codigo
		--str_data[8]	descripcion producto
		--str_data[9]	Agente
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND poc_pedidos.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(poc_pedidos.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		IF str_data[7] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[7]||'''';
		END IF;
		
		IF str_data[8] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[8]||'''';
		END IF;
		
		IF str_data[9]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND poc_pedidos.cxc_agen_id='||str_data[9];
		END IF;
		
		sql_query := 'SELECT DISTINCT poc_pedidos.id 
				FROM poc_pedidos 
				LEFT JOIN poc_pedidos_detalle ON poc_pedidos_detalle.poc_pedido_id = poc_pedidos.id  
				LEFT JOIN inv_prod ON inv_prod.id = poc_pedidos_detalle.inv_prod_id  
				JOIN erp_proceso ON erp_proceso.id = poc_pedidos.proceso_id
				LEFT JOIN cxc_clie ON cxc_clie.id = poc_pedidos.cxc_clie_id  
				WHERE erp_proceso.empresa_id='||emp_id||' AND poc_pedidos.borrado_logico=FALSE  '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Aplicativo Autorizacion de Pedidos de Clientes
	

	
	--buscador de Aplicativo Remisiones de Clientes
	IF app_selected = 66 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	codigo
		--str_data[8]	producto
		--str_data[9]	Agente
		--str_data[10]	Folio Pedido
		
		IF str_data[3] <> '%%' THEN
			cadena_where:= cadena_where ||' AND fac_rems.folio ilike  '''||str_data[3]||'''';
		END IF;

		
		IF str_data[4] <> '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] <> '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(fac_rems.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[7] <> '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[7]||'''';
		END IF;
		
		IF str_data[8] <> '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[8]||'''';
		END IF;
		
		IF str_data[9]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND fac_rems.cxc_agen_id='||str_data[9];
		END IF;

		IF str_data[10] <> '%%' THEN
			cadena_where:= cadena_where ||' AND fac_rems.folio_pedido ilike  '''||str_data[10]||'''';
		END IF;
		
		
		sql_query := 'SELECT DISTINCT fac_rems.id 
				FROM fac_rems 
				JOIN fac_rems_detalles ON fac_rems_detalles.fac_rems_id = fac_rems.id 
				JOIN inv_prod ON inv_prod.id = fac_rems_detalles.inv_prod_id
				JOIN erp_proceso ON erp_proceso.id = fac_rems.proceso_id
				LEFT JOIN cxc_clie ON cxc_clie.id = fac_rems.cxc_clie_id  
				WHERE erp_proceso.empresa_id='||emp_id||' 
				AND  erp_proceso.sucursal_id='||suc_id||'  '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Aplicativo Remisiones de Clientes
	
	
	
	--buscador catalogo configuracion de produccion
        IF app_selected = 67 THEN
                
                sql_query := 'select pro_procesos.id from pro_procesos join (
                select id from inv_prod where sku ilike '''||str_data[5]||''' and descripcion ilike '''||str_data[6]||''' ) as subt_a 
                on pro_procesos.inv_prod_id=subt_a.id where pro_procesos.folio ilike '''||str_data[3]||''' and 
                pro_procesos.titulo ilike '''||str_data[4]||''' and borrado_logico= false and 
                pro_procesos.gral_emp_id='||emp_id||'; ';
                
                --sql_query := 'SELECT id FROM pro_procesos where borrado_logico=false';
        END IF;
        --buscador catalogo configuracion de produccion
	

	--buscador del catalogo de Presentaciones
	IF app_selected = 68 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	descripcion
		sql_query := 'SELECT inv_prod_presentaciones.id
				FROM inv_prod_presentaciones 
				WHERE inv_prod_presentaciones.borrado_logico=false 
				AND titulo ILIKE '''||str_data[3]||'''';
				
				--AND titulo ILIKE '''||str_data[3]||''' AND gral_emp_id='||emp_id;
	END IF;	--termina buscador del catalogo   de marcas




	--buscador catalogo de formulas
        IF app_selected = 69 THEN
                IF str_data[4]='0' THEN
                        
                        sql_query := 'select pro_estruc.id join (
                        select id from inv_prod where sku ilike '''||str_data[3]||''' and descripcion ilike '''||str_data[4]||''' and borrado_logico=false and sucursal_id='||emp_id||'
                        ) as tmp1 on tmp1.id=pro_estruc.inv_prod_id where pro_estruc.gral_emp_id='||emp_id||' ';
                ELSE
                        sql_query := '
                        select pro_estructmp.pro_estruc_id as id from (
				select distinct pro_subproceso_prod.pro_estruc_id, pro_estruc.inv_prod_id 
				from pro_procesos 
				join pro_subproceso_prod on pro_subproceso_prod.pro_procesos_id=pro_procesos.id 
				join pro_estruc on (pro_estruc.id=pro_subproceso_prod.pro_estruc_id AND pro_estruc.borrado_logico=false)
				where pro_procesos.id='||str_data[5]::integer||' 
                        ) as pro_estructmp join (
				select id from inv_prod where sku ilike '''||str_data[3]||''' and descripcion ilike '''||str_data[4]||''' and borrado_logico=false and sucursal_id='||emp_id||'
                        ) as tmp1 on tmp1.id=pro_estructmp.inv_prod_id ';
                END IF;
                
        END IF; --termina buscador Para formulas



	--buscador de Notas de Credito
	IF app_selected = 70 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	factura
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND fac_nota_credito.serie_folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(fac_nota_credito.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[7] != '%%' THEN
			cadena_where:= cadena_where ||' AND fac_nota_credito.serie_folio_factura ilike  '''||str_data[7]||'''';
		END IF;

		
		sql_query := 'SELECT DISTINCT fac_nota_credito.id 
				FROM fac_nota_credito 
				LEFT JOIN cxc_clie ON cxc_clie.id = fac_nota_credito.cxc_clie_id   
				WHERE fac_nota_credito.gral_emp_id='||emp_id||' AND  fac_nota_credito.gral_suc_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Notas de Credito
	
	
	--buscador de Aplicativo Programacion de Rutas
	IF app_selected = 71 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	factura
		--str_data[5]	cliente
		--str_data[6]	fecha_inicial
		--str_data[7]	fecha_final
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_fac_rev_cob.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND erp_h_facturas.serie_folio ilike  '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[5]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[6] != '' THEN
			IF str_data[7] = '' THEN
				f_final:=str_data[6];
			ELSE
				f_final:=str_data[7];
			END IF;
			cadena_where:=cadena_where||' AND to_char(cxc_fac_rev_cob.fecha_proceso, ''yyyymmdd'')::integer between (to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := 'SELECT cxc_fac_rev_cob.id 
				FROM cxc_fac_rev_cob
				JOIN cxc_fac_rev_cob_detalle ON cxc_fac_rev_cob_detalle.cxc_fac_rev_cob_id=cxc_fac_rev_cob.id
				JOIN erp_h_facturas ON erp_h_facturas.id=cxc_fac_rev_cob_detalle.erp_h_facturas_id
				JOIN cxc_clie ON cxc_clie.id=erp_h_facturas.cliente_id 
				WHERE cxc_fac_rev_cob.gral_emp_id='||emp_id||' AND  cxc_fac_rev_cob.gral_suc_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Aplicativo Programacion de Rutas
	
	
	
	
	
	--catalogo de Rutas
	IF app_selected = 72 THEN
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||'  and log_rutas.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||'   and log_vehiculos.marca ilike  '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||'  and log_choferes.nombre ilike  '''||str_data[5]||'''';
		END IF;
		sql_query := 'SELECT log_rutas.id
				from log_rutas
				join  log_choferes on log_choferes.id=log_rutas.log_chofer_id
				join log_vehiculos on log_vehiculos.id=log_rutas.log_vehiculo_id 
				WHERE log_rutas.gral_emp_id='||emp_id||' AND log_rutas.gral_suc_id='||suc_id||' AND log_rutas.borrado_logico=false 
				'||cadena_where;
	--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--Catalogo de Rutas
	



	--buscador del catalogo de vehiculos
	IF app_selected = 73 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	numero economico
		--str_data[4]	marca
		IF str_data[3] !='%%' THEN
			cadena_where=' and numero_economico ilike '''||str_data[3]||'''';
		END IF;
		IF str_data[4] !='%%' THEN
			cadena_where=cadena_where||' and marca ilike '''||str_data[4]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM log_vehiculos WHERE gral_emp_id='||emp_id||' and gral_suc_id='||suc_id||' and borrado_logico=false '||cadena_where;
	END IF;	--termina buscador del catalogo vehiculos



	--buscador del catalogo de PUESTOS
	IF app_selected = 75 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	TITULO
		IF str_data[3] !='%%' THEN
			cadena_where='and titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'select id from gral_puestos where gral_emp_id='||emp_id||' and borrado_logico=false '||cadena_where;
	END IF;	--termina buscador del catalogo de puestos



	
	--buscador de Aplicativo Devoluciones de mercancia
	IF app_selected = 76 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	factura
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	codigo
		--str_data[8]	producto
		--str_data[9]	Agente
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND fac_docs.serie_folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(fac_docs.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[7] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[7]||'''';
		END IF;
		
		IF str_data[8] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[8]||'''';
		END IF;
		
		IF str_data[9]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND fac_docs.cxc_agen_id='||str_data[9];
		END IF;
		
		sql_query := 'SELECT DISTINCT fac_docs.id 
				FROM fac_docs 
				JOIN fac_docs_detalles ON fac_docs_detalles.fac_doc_id = fac_docs.id 
				JOIN inv_prod ON inv_prod.id = fac_docs_detalles.inv_prod_id
				JOIN erp_proceso ON erp_proceso.id = fac_docs.proceso_id
				LEFT JOIN cxc_clie ON cxc_clie.id = fac_docs.cxc_clie_id   
				WHERE erp_proceso.empresa_id='||emp_id||' 
				AND  erp_proceso.sucursal_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Aplicativo Devoluciones de mercancia


	--buscador del catalogo de escolaridades
	IF app_selected = 77 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	TITULO
		IF str_data[3] !='%%' THEN
			cadena_where='AND gral_escolaridads.titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id
			      FROM gral_escolaridads 
			      WHERE gral_escolaridads.gral_emp_id='||emp_id||' AND gral_escolaridads.borrado_logico=false '||cadena_where;
	END IF;	--termina buscador del catalogo escolaridad


	--buscador del catalogo de religiones
	IF app_selected = 78 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	TITULO
		IF str_data[3] !='%%' THEN
			cadena_where='AND gral_religions.titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM gral_religions WHERE gral_religions.gral_emp_id='||emp_id||' AND gral_religions.borrado_logico=false '||cadena_where;
	END IF;	--termina buscador del catalogo religiones



	--buscador del catalogo de tipo de sangre
	IF app_selected = 79 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	TITULO
		IF str_data[3] !='%%' THEN
			cadena_where='AND gral_sangretipos.titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id
			      FROM gral_sangretipos 
			      WHERE gral_sangretipos.gral_emp_id='||emp_id||' AND gral_sangretipos.borrado_logico=false '||cadena_where;
	END IF;	--termina buscador del catalogo tipo de sangre



	--buscador del catalogo de departamentos
	IF app_selected = 82 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	TITULO
		--str_data[3]	costo
		IF str_data[3] !='%%' THEN
			cadena_where='AND gral_deptos.titulo ilike '''||str_data[3]||'''';
		END IF;
		IF str_data[4] !='' THEN
			cadena_where=cadena_where||'AND gral_deptos.costo_prorrateo = '''||str_data[4]||'''';
		END IF;    
		sql_query := 'SELECT id
			      FROM gral_deptos 
			      WHERE gral_deptos.gral_emp_id='||emp_id||' AND gral_deptos.vigente=true AND gral_deptos.borrado_logico=false '||cadena_where;
				--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador del catalogo departamentos
	
	
	
	
	--buscador del catalogo de tipo de Equipo
        IF app_selected = 83 THEN
                --str_data[1]        app_selected
                --str_data[2]        id_usuario
                --str_data[3]        TITULO
                IF str_data[3] !='%%' THEN
                        cadena_where='AND pro_tipo_equipo.titulo ilike '''||str_data[3]||'''';
                END IF;
                
                sql_query := 'SELECT id
                              FROM pro_tipo_equipo 
                              WHERE pro_tipo_equipo.gral_emp_id='||emp_id||' AND pro_tipo_equipo.borrado_logico=false '||cadena_where;
        END IF;        --termina buscador del catalogo tipo de equipo



	--buscador del catalogo de DIAS NO LABORABLES
	IF app_selected = 84 THEN
			--str_data[1]        app_selected
			--str_data[2]        id_usuario
			--str_data[3]        fecha_no_laborable date
			--str_data[4]        descripcion string	
			--str_data[5]        gral_puesto_id (puesto) integer   
		IF str_data[3] != '' THEN
			cadena_where=' AND gral_dias_no_laborables.fecha_no_laborable = '''||str_data[3]||'''::date';
		END IF;		

		IF str_data[4] != '' THEN
			cadena_where = cadena_where||' AND gral_dias_no_laborables.descripcion ILIKE '''||str_data[4]||'''';
		END IF;
		
		sql_query := 'SELECT id
			      FROM gral_dias_no_laborables 
			      WHERE gral_dias_no_laborables.gral_emp_id='||emp_id||' AND gral_dias_no_laborables.borrado_logico=false '||cadena_where;
	END IF;	--termina buscador del catalogo dias no laborables
	
	
	
	
	
	--buscador del catalogo de categorias
	IF app_selected = 85 THEN
			--str_data[1]        app_selected
			--str_data[2]        id_usuario
			
			--str_data[3]        titulo(categ) char
			--str_data[4]        sueldo_por_hora double	
			--str_data[5]        sueldo_por_horas_ext double
			--str_data[6]        gral_puesto_id (puesto) integer
		IF str_data[3] !='' THEN
			cadena_where=' AND gral_categ.titulo ilike '''||str_data[3]||'''';
		END IF;
		

		IF str_data[4] != '' THEN
			cadena_where = cadena_where||' AND gral_categ.sueldo_por_hora = '||str_data[4]::double precision;
		END IF;
		
		
		IF str_data[5] != '' THEN
			cadena_where = cadena_where||' AND gral_categ.sueldo_por_horas_ext = '||str_data[5]::double precision;
		END IF;
		
		
		IF str_data[6] != '0' THEN
			cadena_where = cadena_where||' AND gral_categ.gral_puesto_id = '||str_data[6]::integer;
		END IF;
		
		sql_query := 'SELECT id
			      FROM gral_categ 
			      WHERE gral_categ.gral_emp_id='||emp_id||' AND gral_categ.borrado_logico=false '||cadena_where;
	END IF;	--termina buscador del catalogo categorias

        
	
	
	--buscador de Ordenes de Entrada
	IF app_selected=87 THEN
		--str_data[3]	folio
		--str_data[4]	orden_compra
		--str_data[5]	factura
		--str_data[6]	proveedor
		--str_data[7]	tipo_doc
		--str_data[8]	codigo
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_oent.folio ilike '''||str_data[3]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_oent.folio_documento ilike '''||str_data[5]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_oent.orden_de_compra ilike '''||str_data[4]||'''';
		END IF;
		
		IF str_data[6] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike '''||str_data[6]||'''';
		END IF;

		IF str_data[7] != '0' THEN
			cadena_where:= cadena_where ||' AND inv_oent.tipo_documento='||str_data[7]||' ';
		END IF;

		IF str_data[8] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[8]||'''';
		END IF;

		
		sql_query := '
			SELECT DISTINCT inv_oent.id
			FROM inv_oent
			LEFT JOIN inv_oent_detalle ON inv_oent_detalle.inv_oent_id=inv_oent.id
			LEFT JOIN inv_prod ON inv_prod.id=inv_oent_detalle.inv_prod_id
			LEFT JOIN cxp_prov on cxp_prov.id=inv_oent.cxp_prov_id
			WHERE inv_oent.gral_emp_id='||emp_id||'  AND inv_oent.borrado_logico=FALSE '||cadena_where;
	END IF;	--termina buscador de Ordenes de Entrada
	
	
	

	--buscador catalogo preorden de produccion
        IF app_selected = 89 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	tipo
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND pro_preorden_prod.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '0' THEN
			cadena_where:= cadena_where ||' AND pro_preorden_prod.pro_orden_tipos_id='||str_data[4]||'';
		ELSE
			cadena_where:= cadena_where ||' AND 1=1';
		END IF;
		
		sql_query := 'select id from pro_preorden_prod where borrado_logico=false and gral_emp_id='||emp_id||' '||cadena_where;
        END IF;
        --buscador catalogo preorden de produccion
	
	
	
	--buscador de Orden de Compra
        IF app_selected = 90 THEN
                --str_data[1]        app_selected
                --str_data[2]        id_usuario
                --str_data[3]        folio
                --str_data[4]        proveedor
                --str_data[5]        fecha_inicial
                --str_data[6]        fecha_final
                --str_data[7]        codigo
                --str_data[8]        producto

                IF trim(str_data[3]) != '%%' THEN 
                        cadena_where:= cadena_where ||' AND com_orden_compra.folio ilike'''||str_data[3]||'''';
                END IF;
                
                IF str_data[4] != '%%' THEN
                        cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike  '''||str_data[4]||'''';
                END IF;
                
                --busqueda por fecha creacion
                IF str_data[5] != '' THEN
                        IF str_data[6] = '' THEN
                                f_final:=str_data[5];
                        ELSE
                                f_final:=str_data[6];
                        END IF;
                        cadena_where:=cadena_where||' AND to_char(com_orden_compra.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
                END IF;

                --str_data[7]        codigo
                IF str_data[7] != '%%' THEN
                        cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[7]||'''';
                END IF;
                
                --str_data[8]        producto
                IF str_data[8] != '%%' THEN
                        cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[8]||'''';
                END IF;
                
                sql_query := 'SELECT DISTINCT com_orden_compra.id  
                                FROM com_orden_compra 
                                JOIN com_orden_compra_detalle ON com_orden_compra_detalle.com_orden_compra_id = com_orden_compra.id
                                JOIN com_proceso ON com_proceso.id = com_orden_compra.com_proceso_id
                                LEFT JOIN cxp_prov ON cxp_prov.id = com_orden_compra.proveedor_id  
                                LEFT JOIN inv_prod ON inv_prod.id =com_orden_compra_detalle.inv_prod_id  
                                WHERE com_proceso.gral_emp_id='||emp_id||' 
                                AND  com_proceso.gral_suc_id='||suc_id||' 
                                AND com_orden_compra.borrado_logico=FALSE  '||cadena_where;
                --RAISE EXCEPTION '%' ,sql_query; 
        END IF;        --termina ORDEN COMPRA
	
	
	

	
	--buscador de Aplicativo Autorizacion de Orden de Compra
	IF app_selected = 91 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	proveedor
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND com_orden_compra.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(com_orden_compra.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := 'SELECT DISTINCT com_orden_compra.id 
				FROM com_orden_compra 
				JOIN com_proceso ON com_proceso.id = com_orden_compra.com_proceso_id
				LEFT JOIN cxp_prov ON cxp_prov.id = com_orden_compra.proveedor_id  
				WHERE com_proceso.gral_emp_id='||emp_id||' AND  com_proceso.gral_suc_id='||suc_id||' AND com_orden_compra.borrado_logico=FALSE  '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Aplicativo Autorizacion de Orden de Compra
	
	
	
	--buscador del catalogo de TURNOS
	IF app_selected = 92 THEN
			--str_data[1]        app_selected
			--str_data[2]        id_usuario
			
			--str_data[3]        titulo(categ) char
			--str_data[4]        sueldo_por_hora double	
			--str_data[5]        sueldo_por_horas_ext double
			--str_data[6]        gral_puesto_id (puesto) integer
		IF str_data[3] !='' THEN
			cadena_where=' AND gral_deptos_turnos.turno = '''||str_data[3]||'''';
		END IF;
		

		IF str_data[4] != '' THEN
			cadena_where = cadena_where||' AND gral_deptos_turnos.hora_ini = '''||str_data[4]||'''::time with time zone';
		END IF;
		
		
		IF str_data[5] != '' THEN
			cadena_where = cadena_where||' AND gral_deptos_turnos.hora_fin = '''||str_data[5]||'''::time with time zone';
		END IF;
		
		
		IF str_data[6] != '0' THEN
			cadena_where = cadena_where||' AND gral_deptos_turnos.gral_deptos_id = '||str_data[6]::integer;
		END IF;
		
			sql_query := 'SELECT id
				      FROM gral_deptos_turnos 
				      WHERE gral_deptos_turnos.gral_emp_id='||emp_id||' AND gral_deptos_turnos.borrado_logico=false '||cadena_where;
	END IF;	--termina buscador del catalogo TURNOS

	
	
	--buscador catalogo orden de produccion
        IF app_selected = 93 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	tipo
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND pro_orden_prod.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '0' THEN
			cadena_where:= cadena_where ||' AND pro_orden_prod.pro_orden_tipos_id='||str_data[4]||'';
		ELSE
			cadena_where:= cadena_where ||' AND 1=1';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where2:= ' sku ilike '''||str_data[5]||'''';
		ELSE
			cadena_where2:= ' sku ilike ''%%''';
		END IF;
		
		--sql_query := 'select id from pro_orden_prod where borrado_logico=false and gral_emp_id='||emp_id||' '||cadena_where;
		sql_query := 'select id from (
			select pro_orden_prod.id, (select inv_prod.sku from pro_orden_prod_det 
			join inv_prod on pro_orden_prod_det.inv_prod_id=inv_prod.id where pro_orden_prod_id=pro_orden_prod.id limit 1) as sku 
			from pro_orden_prod where borrado_logico=false and gral_emp_id='||emp_id||' '||cadena_where||' 
			) as op_tmp where '||cadena_where2;
			
		--RAISE EXCEPTION '%' ,sql_query;
		
        END IF;
        --buscador catalogo orden de produccion



	
	--buscador de Aplicativo Ordenes de Salida
	IF app_selected = 94 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	orden_compra
		--str_data[5]	folio_doc
		--str_data[6]	cliente
		--str_data[7]	fecha_inicial
		--str_data[8]	fecha_final
		--str_data[9]	tipo_doc
		--str_data[10]	codigo
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_osal.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_osal.orden_compra ilike  '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_osal.folio_documento ilike  '''||str_data[5]||'''';
		END IF;
		
		IF str_data[6] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[6]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[7] != '' THEN
			IF str_data[8] = '' THEN
				f_final:=str_data[7];
			ELSE
				f_final:=str_data[8];
			END IF;
			cadena_where:=cadena_where||' AND to_char(inv_osal.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[7]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[9] != '0' THEN
			cadena_where:= cadena_where ||' AND inv_osal.tipo_documento='||str_data[9]||' ';
		END IF;

		IF str_data[10] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[10]||'''';
		END IF;
		
		sql_query := 'SELECT DISTINCT inv_osal.id
				FROM inv_osal
				LEFT JOIN inv_osal_detalle ON inv_osal_detalle.inv_osal_id = inv_osal.id
				LEFT JOIN inv_prod ON inv_prod.id = inv_osal_detalle.inv_prod_id
				LEFT JOIN cxc_clie ON cxc_clie.id = inv_osal.cxc_clie_id
				WHERE inv_osal.gral_emp_id='||emp_id||' AND  inv_osal.gral_suc_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Aplicativo Ordenes de Salida
	
	
	
	
	--buscador de Aplicativo Ajustes de Invetario
	IF app_selected = 95 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	tipo_mov
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	codigo producto
		--str_data[8]	descripcion producto

		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_mov.referencia ilike  '''||str_data[3]||'''';
		END IF;

		IF str_data[4] != '0' THEN
			cadena_where:= cadena_where ||' AND inv_mov.inv_mov_tipo_id= '||str_data[4];
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(inv_mov.fecha_mov, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[7] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[7]||'''';
		END IF;

		IF str_data[8] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[8]||'''';
		END IF;
		
		sql_query := '
			SELECT DISTINCT inv_mov.id
			FROM inv_mov
			JOIN inv_mov_tipos ON inv_mov_tipos.id=inv_mov.inv_mov_tipo_id
			JOIN inv_mov_detalle ON inv_mov_detalle.inv_mov_id=inv_mov.id
			JOIN inv_prod ON inv_prod.id=inv_mov_detalle.producto_id
			WHERE inv_mov_tipos.ajuste=TRUE
			AND inv_prod.empresa_id='||emp_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Aplicativo Ajustes de Invetario
	
	

	--buscador catalogo de productos equivalentes 
        IF app_selected = 96 THEN 
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	descripcion
                IF str_data[3]!='' THEN 
                        cadena_where:=cadena_where||' AND inv_prod.sku ilike '''||str_data[3]||'''';
		END IF;

		IF str_data[4]!='' THEN 
                        cadena_where:=cadena_where||' AND inv_prod.descripcion ilike '''||str_data[4]||'''';
		END IF;
			sql_query :=' SELECT DISTINCT inv_prod_equiv.inv_prod_id as id 
			FROM inv_prod_equiv 
			JOIN inv_prod ON inv_prod.id = inv_prod_equiv.inv_prod_id  
			WHERE inv_prod.empresa_id='||emp_id||'
			AND inv_prod.sucursal_id='||suc_id||' 
			AND inv_prod.borrado_logico=false '||cadena_where;
			
			--RAISE EXCEPTION '% :esto es queryyyyyyy???' ,sql_query;
        END IF; --termina buscador Para productos equivalentes

	
	--buscador de Aplicativo Impresion de Etiquetas
	IF app_selected = 98  THEN
                IF str_data[3]!='%%' THEN 
                        cadena_where:=cadena_where||' AND inv_etiquetas.folio ilike '''||str_data[3]||'''';
                END IF;
                IF str_data[4]!='%%' THEN 
                        cadena_where:=cadena_where||' AND inv_etiquetas.folio_origen ilike '''||str_data[4]||'''';
                END IF;
                IF str_data[5]::integer != '0' THEN 
                        cadena_where:=cadena_where||' AND inv_etiquetas.tipo_origen =' ||str_data[5]::integer;
                END IF;
                
                sql_query := 'select id from inv_etiquetas where inv_etiquetas.borrado_logico = false '||cadena_where;
        END IF; --termina buscador de Aplicativo Impresion de Etiquetas


	
	--buscador del aplicativo de edicion de codigo ISO
	IF app_selected = 99 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	TITULO
		IF str_data[3] !='%%' THEN
			cadena_where='AND gral_docs.titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id
			      FROM gral_docs
			      WHERE gral_emp_id='||emp_id||''||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;	      
	END IF;	
	--termina buscador del aplicativo de edicion de codigo ISO
	
	
	
	
	
	
	
	--buscador de Ordenes de Devolucion
	IF app_selected = 100 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	factura
		--str_data[5]	cliente
		--str_data[6]	fecha_inicial
		--str_data[7]	fecha_final
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_odev.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_odev.folio_documento ilike  '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_odev.razon_social ilike  '''||str_data[5]||'''';
		END IF;
		
		--busqueda por fecha devolucion
		IF str_data[6] != '' THEN
			IF str_data[7] = '' THEN
				f_final:=str_data[6];
			ELSE
				f_final:=str_data[7];
			END IF;
			cadena_where:=cadena_where||' AND to_char(inv_odev.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := 'SELECT DISTINCT inv_odev.id 
				FROM inv_odev 
				LEFT JOIN cxc_clie ON cxc_clie.id = inv_odev.cxc_clie_id   
				WHERE inv_odev.gral_emp_id='||emp_id||' AND  inv_odev.gral_suc_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Ordenes de Devolucion
	
	


	
	--buscador de Notas de Credito de Proveedores
	IF app_selected = 101 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	nota_credito
		--str_data[5]	proveedor
		--str_data[6]	fecha_inicial
		--str_data[7]	fecha_final

		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_nota_credito.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_nota_credito.serie_folio ilike  '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike  '''||str_data[5]||'''';
		END IF;
		
		--busqueda por fecha devolucion
		IF str_data[6] != '' THEN
			IF str_data[7] = '' THEN
				f_final:=str_data[6];
			ELSE
				f_final:=str_data[7];
			END IF;
			cadena_where:=cadena_where||' AND to_char(cxp_nota_credito.fecha_expedicion::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := 'SELECT DISTINCT cxp_nota_credito.id FROM cxp_nota_credito
				LEFT JOIN cxp_prov ON cxp_prov.id=cxp_nota_credito.cxp_prov_id
				WHERE cxp_nota_credito.gral_emp_id='||emp_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de Notas de Credito Proveedores
	
	
	
	--buscador Facturas de Compras para Devoluciones a Proveedores
	IF app_selected=102 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	nota_credito
		--str_data[5]	proveedor
		--str_data[6]	fecha_inicial
		--str_data[7]	fecha_final

		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_nota_credito.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_nota_credito.serie_folio ilike  '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike  '''||str_data[5]||'''';
		END IF;
		
		--busqueda por fecha devolucion
		IF str_data[6] != '' THEN
			IF str_data[7] = '' THEN
				f_final:=str_data[6];
			ELSE
				f_final:=str_data[7];
			END IF;
			cadena_where:=cadena_where||' AND to_char(cxp_nota_credito.fecha_expedicion::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := 'SELECT DISTINCT cxp_nota_credito.id FROM cxp_nota_credito
				LEFT JOIN cxp_prov ON cxp_prov.id=cxp_nota_credito.cxp_prov_id
				WHERE cxp_nota_credito.tipo=3 AND cxp_nota_credito.gral_emp_id='||emp_id||' '||cadena_where;
	END IF;	--termina buscador Facturas de Compras para Devoluciones a Proveedores



	--REQUISICION DE ORDEN DE COMOPRA
	IF app_selected = 104 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	proveedor
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final

		IF str_data[3] != '' THEN 
			cadena_where:= cadena_where ||' AND com_oc_req.folio ilike'''||str_data[3]||'''';
		END IF;

		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(com_oc_req.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := 'SELECT DISTINCT com_oc_req.id  
				FROM com_oc_req  
				WHERE com_oc_req.gral_emp_id='||emp_id||' AND  com_oc_req.gral_suc_id='||suc_id||' AND com_oc_req.borrado_logico=FALSE  AND com_oc_req.cancelado =false '  ||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query; 
	END IF;	--termina REQUUISICION DE ORDEN COMPRA

	
	
	--buscador de Aplicativo Ordenes de Traspaso
	IF app_selected = 105 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	codigo
		--str_data[5]	descripcion
		--str_data[6]	alm_origen
		--str_data[7]	alm_destino
		--str_data[8]	fecha_inicial
		--str_data[9]	fecha_final
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_otras.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[5]||'''';
		END IF;
		
		IF str_data[6] != '0' THEN
			cadena_where:= cadena_where ||' AND inv_otras.inv_alm_id_origen='||str_data[6]||'';
		END IF;
		
		IF str_data[7] != '0' THEN
			cadena_where:= cadena_where ||' AND inv_otras.inv_alm_id_destino='||str_data[7]||'';
		END IF;
		
		--busqueda por fecha de traspaso
		IF str_data[8] != '' THEN
			IF str_data[9] = '' THEN
				f_final:=str_data[8];
			ELSE
				f_final:=str_data[9];
			END IF;
			cadena_where:=cadena_where||' AND to_char(inv_otras.fecha::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[8]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := '
			SELECT DISTINCT inv_otras.id
			FROM inv_otras
			JOIN inv_otras_det ON inv_otras_det.inv_otras_id=inv_otras.id
			JOIN inv_prod ON inv_prod.id=inv_otras_det.inv_prod_id
			WHERE inv_otras.gral_emp_id='||emp_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de aplicativo Ordenes de Traspaso

	




	--buscador de Aplicativo Catalogo de Cuentas Contables
	IF app_selected = 106 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	cta_mayor
		--str_data[4]	descripcion
		--str_data[5]	sucursal
		
		cadena_where:='';
		IF str_data[3]<>'0' THEN
			SELECT ctb_may_clase_id, clasificacion FROM ctb_may WHERE id=str_data[3]::integer INTO numero_cta_may, clasif_cta_may;
			cadena_where:= cadena_where ||' AND ctb_cta.cta_mayor='||numero_cta_may||' AND ctb_cta.clasifica='||clasif_cta_may;
		END IF;
		
		IF str_data[4]<>'%%' THEN
			cadena_where:= cadena_where ||' AND (ctb_cta.descripcion ilike  '''||str_data[4]||''' OR ctb_cta.descripcion_ing ilike  '''||str_data[4]||''' OR ctb_cta.descripcion_otr ilike  '''||str_data[4]||''') ';
		END IF;
		
		IF str_data[5]<>'0' THEN
			cadena_where:= cadena_where ||' AND ctb_cta.gral_suc_id='||str_data[5];
		END IF;
		
		sql_query := 'SELECT DISTINCT ctb_cta.id FROM ctb_cta WHERE borrado_logico=false AND ctb_cta.gral_emp_id='||emp_id||' '||cadena_where;
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador de aplicativo Catalogo de Cuentas Contables

	
	
	--buscador de Orden de compra (muestra todas las ordenes de compra realizadas atraves de una ovarias requisiciones)
	IF app_selected = 107 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	proveedor
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final

		IF str_data[3] != '' THEN 
			cadena_where:= cadena_where ||' AND com_orden_compra.folio ilike'''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '' THEN
			cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(com_orden_compra.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := 'SELECT DISTINCT com_orden_compra.id  
				FROM com_orden_compra 
				JOIN com_proceso ON com_proceso.id = com_orden_compra.com_proceso_id
				LEFT JOIN cxp_prov ON cxp_prov.id = com_orden_compra.proveedor_id  
				WHERE com_proceso.gral_emp_id='||emp_id||' AND  com_proceso.gral_suc_id='||suc_id||' AND com_orden_compra.borrado_logico=FALSE  '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query; 
	END IF;	--termina la requisicon conevrtida en ORDEN COMPRA
	

	--buscador catalogo de formulas en desarrollo
	IF app_selected = 108 THEN
		sql_query := 'select pro_estructmp.id from (
	       select id, inv_prod_id from pro_estruc where borrado_logico=false and tipo_formula=2 AND gral_emp_id='||emp_id||' 
		 ) as pro_estructmp join (
		select id from inv_prod where sku ilike '''||str_data[3]||''' and descripcion ilike '''||str_data[4]||''' and borrado_logico=false and empresa_id='||emp_id||'
		) as tmp1 on tmp1.id=pro_estructmp.inv_prod_id ';
	END IF; --termina buscador Para formulas en desarrollo



	
	--buscador de Motivos de Visita
	IF app_selected=109 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		
		--str_data[3]	descripcion
		IF str_data[3] != '%%' THEN
			cadena_where:=cadena_where||'AND crm_motivos_visita.descripcion ilike '''||str_data[3]||'''';
		END IF;

		sql_query :='SELECT DISTINCT crm_motivos_visita.id FROM crm_motivos_visita
				WHERE gral_emp_id='||emp_id||' '||cadena_where;

		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador de Motivos de Visita

	

	--buscador de Formas de Contacto
	IF app_selected=110 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		
		--str_data[3]	descripcion
		IF str_data[3] != '%%' THEN
			cadena_where:=cadena_where||'AND crm_formas_contacto.descripcion ilike '''||str_data[3]||'''';
		END IF;

		sql_query :='SELECT DISTINCT crm_formas_contacto.id FROM crm_formas_contacto
				WHERE gral_emp_id='||emp_id||' '||cadena_where;

		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador de Formas de Contacto

	--buscador de Motivo de LLamada
	IF app_selected=111 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		
		--str_data[3]	descripcion
		IF trim(str_data[3]) <> '%%' THEN
			cadena_where:=cadena_where||'AND descripcion ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query :='SELECT DISTINCT id FROM crm_motivos_llamada WHERE gral_emp_id='||emp_id||' and borrado_logico=false '||cadena_where;
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador de Motivo de LLamada

	--buscador de Instrumentos Medicion
	IF app_selected=112 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		
		--str_data[3]	titulo
		IF str_data[3] != '%%' THEN
			cadena_where:=cadena_where||'AND pro_instrumentos.titulo ilike '''||str_data[3]||'''';
		END IF;

		sql_query :='SELECT DISTINCT pro_instrumentos.id FROM pro_instrumentos
				WHERE gral_emp_id='||emp_id||' '||cadena_where;

		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador de Instrumentos Medicion


	--Buscador de catalogo de prospectos(CRM)
	IF app_selected =113 THEN
                IF str_data[4]::integer=0 THEN
                        sql_query := 'SELECT id FROM crm_prospectos WHERE borrado_logico=false AND gral_emp_id = '||emp_id;
                END IF;
                
                IF str_data[4]::integer=1 THEN
                        sql_query := 'SELECT id FROM crm_prospectos WHERE borrado_logico=false AND gral_emp_id = '|| emp_id ||'  AND  numero_control ilike '''||str_data[3]||'''';
                END IF;
                
                IF str_data[4]::integer=2 THEN
                        sql_query := 'SELECT id FROM crm_prospectos WHERE borrado_logico=false AND gral_emp_id = '|| emp_id ||' AND rfc ilike '''||str_data[3]||'''';
                END IF;
                
                IF str_data[4]::integer=3 THEN
                        sql_query := 'SELECT id FROM crm_prospectos WHERE borrado_logico=false AND gral_emp_id = '|| emp_id ||' AND razon_social ilike '''||str_data[3]||'''';
                END IF;
                
                
        END IF;  --termina buscador de Prospectos(CRM)
	



--Buscador de Registro de Llamadas (CRM)
	IF app_selected=114 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	tipo_visita
		--str_data[5]	contacto
		--str_data[6]	agente
		--str_data[7]	fecha_inicial
		--str_data[8]	fecha_final
		
		--str_data[3]	folio
		IF str_data[3] != '%%' THEN
			cadena_where:=cadena_where||' AND crm_registro_llamadas.folio ilike '''||str_data[3]||'''';
		END IF;

		--str_data[4]	tipo_visita
		IF str_data[4]::integer != 0 THEN
			cadena_where:=cadena_where||' AND crm_contactos.tipo_contacto='||str_data[4]::integer;
		END IF;
		
		--str_data[5]	contacto
		IF str_data[5] != '%%' THEN
			cadena_where:=cadena_where||' AND replace(crm_contactos.nombre||crm_contactos.apellido_paterno||crm_contactos.apellido_materno,'' '','''') ilike replace('''||str_data[5]||''','' '', '''') ';
		END IF;
		
		--str_data[6]	agente
		IF str_data[6]::integer = 0 THEN
			--busca si el usuario tiene rol de ADMINISTRADOR
			SELECT count(gral_usr_id) FROM gral_usr_rol WHERE gral_usr_id=id_user AND gral_rol_id=1 INTO exis;
			
			IF exis=0 THEN
				--si el usuario no tiene rol de ADMINISTRADOR, entonces hay que filtrar solo registros del agente
				--en otro caso NO HAY filtro, se debe mostrar todos los registros de visitas
				SELECT gral_usr.gral_empleados_id FROM gral_usr WHERE gral_usr.id=id_user INTO id_agente;
				cadena_where:=cadena_where||' AND crm_registro_llamadas.gral_empleado_id='||id_agente;
			END IF;
		ELSE
			cadena_where:=cadena_where||' AND crm_registro_llamadas.gral_empleado_id='||str_data[6]::integer;
		END IF;
		
		
		--busqueda por fecha de traspaso
		IF str_data[7] != '' THEN
			IF str_data[8] = '' THEN
				f_final:=str_data[7];
			ELSE
				f_final:=str_data[8];
			END IF;
			cadena_where:=cadena_where||' AND to_char(crm_registro_llamadas.fecha::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[7]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query :='SELECT DISTINCT crm_registro_llamadas.id 
			FROM crm_registro_llamadas
			JOIN crm_contactos ON crm_contactos.id=crm_registro_llamadas.crm_contacto_id
			WHERE crm_registro_llamadas.borrado_logico=false AND crm_registro_llamadas.gral_emp_id='||emp_id||' '||cadena_where;

		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador Aplicativo Registro de Llamadas(CRM)
	



	--buscador de Aplicativo Registro de Visitas(CRM)
	IF app_selected=115 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	tipo_visita
		--str_data[5]	contacto
		--str_data[6]	agente
		--str_data[7]	fecha_inicial
		--str_data[8]	fecha_final
		--str_data[9]	cliente
		
		--str_data[3]	folio
		IF trim(str_data[3])<>'%%' THEN
			cadena_where:=cadena_where||' AND crm_registro_visitas.folio ilike '''||str_data[3]||'''';
		END IF;
		
		--str_data[4]	tipo_visita
		IF str_data[4]::integer != 0 THEN
			cadena_where:=cadena_where||' AND crm_contactos.tipo_contacto='||str_data[4]::integer;
		END IF;
		
		--str_data[5]	contacto
		IF trim(str_data[5])<>'%%' THEN
			cadena_where:=cadena_where||' AND replace(crm_contactos.nombre||crm_contactos.apellido_paterno||crm_contactos.apellido_materno,'' '','''') ilike replace('''||str_data[5]||''','' '', '''') ';
		END IF;
		
		--str_data[6]	agente
		IF str_data[6]::integer = 0 THEN
			--busca si el usuario tiene rol de ADMINISTRADOR
			SELECT count(gral_usr_id) FROM gral_usr_rol WHERE gral_usr_id=id_user AND gral_rol_id=1 INTO exis;
			
			IF exis=0 THEN
				--si el usuario no tiene rol de ADMINISTRADOR, entonces hay que filtrar solo registros del agente
				--en otro caso NO HAY filtro, se debe mostrar todos los registros de visitas
				SELECT gral_usr.gral_empleados_id FROM gral_usr WHERE gral_usr.id=id_user INTO id_agente;
				cadena_where:=cadena_where||' AND crm_registro_visitas.gral_empleado_id='||id_agente;
			END IF;
		ELSE 
			cadena_where:=cadena_where||' AND crm_registro_visitas.gral_empleado_id='||str_data[6]::integer;
		END IF;
		
		--Busqueda por fecha de traspaso
		IF trim(str_data[7])<>'' THEN
			IF trim(str_data[8]) = '' THEN
				f_final:=str_data[7];
			ELSE
				f_final:=str_data[8];
			END IF;
			cadena_where:=cadena_where||' AND to_char(crm_registro_visitas.fecha::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[7]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		--str_data[9]	cliente/prospecto
		IF trim(str_data[9])<>'%%' THEN
			cadena_where:=cadena_where||' AND sbt.cliente ilike '''||str_data[9]||'''';
		END IF;
		
		sql_query :='
		SELECT DISTINCT crm_registro_visitas.id 
		FROM crm_registro_visitas 
		JOIN crm_contactos ON crm_contactos.id=crm_registro_visitas.crm_contacto_id
		left join (
			select crm_contactos.tipo_contacto, crm_contactos.id as contacto_id,cxc_clie.razon_social as cliente from crm_contactos join crm_contacto_cli on crm_contacto_cli.crm_contactos_id=crm_contactos.id join cxc_clie on cxc_clie.id=crm_contacto_cli.cxc_clie_id where crm_contactos.tipo_contacto=1 
			union 
			select crm_contactos.tipo_contacto,crm_contactos.id as contacto_id,crm_prospectos.razon_social as cliente from crm_contactos join crm_contacto_pro on crm_contacto_pro.crm_contactos_id=crm_contactos.id join crm_prospectos on crm_prospectos.id=crm_contacto_pro.crm_prospectos_id where crm_contactos.tipo_contacto=2 
		) as sbt on sbt.contacto_id=crm_contactos.id 		
		WHERE crm_registro_visitas.borrado_logico=false AND crm_registro_visitas.gral_emp_id='||emp_id||' '||cadena_where;
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador Aplicativo Registro de Visitas(CRM)



	--buscador de Direcciones Fiscales de clientes
	IF app_selected = 118 THEN
		--str_data[3]	nocontrol
		--str_data[4]	razonsoc
		--str_data[5]	rfc
		
		IF str_data[3]!='' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.numero_control ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]!='%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ILIKE '''||str_data[4]||'''';
		END IF;

		IF str_data[5]!='%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.rfc ILIKE '''||str_data[5]||'''';
		END IF;

		sql_query := 'SELECT cxc_clie_df.id  
		FROM cxc_clie_df 
		JOIN cxc_clie ON cxc_clie.id = cxc_clie_df.cxc_clie_id 
		WHERE cxc_clie_df.borrado_logico=false 
		AND cxc_clie.empresa_id = '|| emp_id ||' '||cadena_where;
	END IF;	--termina buscador de clientes



        IF app_selected =119 THEN
                --str_data[1]        app_selected
                --str_data[2]        id_usuario
                --str_data[3]        fecha
                --str_data[4]        moneda_id
                primer_cond:=0;
                IF str_data[3] != '' then
                        primer_cond:=1;
                        cadena_where:=cadena_where ||'where to_char(erp_monedavers.momento_creacion,''yyyy-mm-dd'')= '''||str_data[3]||'''';
                END IF;
                
                if str_data[4]::integer != 0 then
                        if primer_cond = 1 then
                                cadena_where:=cadena_where || ' and erp_monedavers.moneda_id ='||str_data[4]::integer;
                        else
                                cadena_where:=cadena_where || ' where erp_monedavers.moneda_id ='||str_data[4]::integer;
                        end if;
                end if;
                
                sql_query := 'SELECT erp_monedavers.id  FROM erp_monedavers  '||cadena_where;
                --RAISE EXCEPTION '%',sql_query;                                                
        END IF;        --termina buscador  de tipos de cambio
        
	
	--buscador de crm_oportunidades
	IF app_selected=120 THEN
		----str_data[1]	app_selected
		----str_data[2]	id_usuario
		----str_data[3]	contacto
		----str_data[4]	etapa venta
		----str_data[5]	tipo oportunidad
		----str_data[6]	agente
		
		IF str_data[4] != '0' THEN
			cadena_where:=cadena_where||' AND crm_oportunidades.crm_etapas_venta_id='||str_data[4]::integer||'';
		END IF;
		
		IF str_data[5] != '0' THEN
			cadena_where:=cadena_where||' AND crm_oportunidades.crm_tipos_oportunidad_id='||str_data[5]::integer||'';
		END IF;
		
		IF str_data[6] != '0' THEN
			cadena_where:=cadena_where||' AND crm_oportunidades.gral_empleados_id='||str_data[6]::integer||'';
		END IF;

		IF str_data[3] != '' AND str_data[3] != ' ' THEN
			cadena_where2 := ' join (select  id from crm_contactos where 
			(nombre ||'' ''||apellido_paterno ||'' ''||apellido_materno) ilike '''||str_data[3]||''' 
			AND borrado_logico=false AND gral_emp_id='||emp_id||') as con_tmp on 
			con_tmp.id=tmp.crm_contactos_id ';
		END IF;
		
		sql_query :='select tmp.id from (SELECT DISTINCT crm_oportunidades.id, crm_oportunidades.crm_contactos_id FROM crm_oportunidades 
				WHERE crm_oportunidades.gral_emp_id='||emp_id||' AND borrado_logico=false'||cadena_where||' 
				) as tmp '||cadena_where2;
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador de crm_oportunidades
	
	
	
	
	--buscador de descarga de ficha tecnica
	IF app_selected = 122 THEN
		--str_data[3]	sku
		--str_data[4]	descripcion
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND  inv_prod.descripcion ILIKE '''||str_data[4]||'''';
		END IF;
		
		
		sql_query := 'SELECT id FROM inv_prod WHERE empresa_id = '|| emp_id ||' AND borrado_logico=FALSE '||cadena_where;
		
	END IF;	--buscador de descarga de ficha tecnica




	--buscador de Metas
	IF app_selected = 123 THEN
		/*+"___"+select_agente//5
			+"___"+opciones//6
			+"___"+cant_llamadas//7
			+"___"+cant_visitas//8
			+"___"+cant_prospectos//9
			+"___"+ano//10
			+"___"+mes//11*/
		--str_data[5]	agente
		IF str_data[3]::integer = 0 THEN
			--busca si el usuario tiene rol de ADMINISTRADOR
			SELECT count(gral_usr_id) FROM gral_usr_rol WHERE gral_usr_id=id_user AND gral_rol_id=1 INTO exis;
			
			IF exis=0 THEN
				--si el usuario no tiene rol de ADMINISTRADOR, entonces hay que filtrar solo registros del agente
				--en otro caso NO HAY filtro, se debe mostrar todos los registros de visitas
				SELECT gral_usr.gral_empleados_id FROM gral_usr WHERE gral_usr.id=id_user INTO id_agente;
				cadena_where:=cadena_where||' AND crm_metas.gral_empleado_id='||id_agente;
			END IF;
		ELSE
			cadena_where:=cadena_where||' AND crm_metas.gral_empleado_id='||str_data[3]::integer;
		END IF;

		sql_query :='SELECT DISTINCT crm_metas.id FROM crm_metas
			WHERE crm_metas.borrado_logico=false AND crm_metas.gral_emp_id='||emp_id||' '||cadena_where;

		--RAISE EXCEPTION '%' ,sql_query;
	END IF;
	---termina buscador de metas



	--BUSCADOR DEL REGISTRO DE CASOS
	 IF app_selected =124 THEN

		IF str_data[3] != '' then
			cadena_where:='AND crm_registro_casos.folio ilike '''||str_data[3]||'''';
		END IF;
		if str_data[4]::integer != 0 then 
			cadena_where:=cadena_where ||'AND crm_registro_casos.tipo='||str_data[4]::integer||'';
		end if;
		IF str_data[5]::integer != 0 then
			if str_data[4]::integer = 1 then
				cadena_where:=cadena_where ||'AND crm_registro_casos_clie.id_cliente='||str_data[5]::integer||'';
			else
				cadena_where:=cadena_where ||'AND crm_registro_casos_prospectos.id_prospecto='||str_data[5]::integer||'';
			end if;
		END IF;
		IF str_data[7]::integer != 0 then
			cadena_where:=cadena_where ||'AND crm_registro_casos.prioridad='||str_data[7]::integer||'';
		END IF;

		IF str_data[8] != '' then
			cadena_where:=cadena_where ||'AND to_char(crm_registro_casos.fecha_cierre,''yyyy-mm-dd'')= '''||str_data[8]::timestamp with time zone||'''';
		END IF;

		IF str_data[9]::integer = 0 THEN
			--busca si el usuario tiene rol de ADMINISTRADOR ¬† ¬† ¬† ¬† ¬† ¬† ¬†
			SELECT count(gral_usr_id) FROM gral_usr_rol WHERE gral_usr_id=id_user AND gral_rol_id=1 INTO exis;
			
			IF exis=0 THEN
				--si el usuario no tiene rol de ADMINISTRADOR, entonces hay que filtrar solo registros del agente
				--en otro caso NO HAY filtro, se debe mostrar todos los registros de casos
				SELECT gral_usr.gral_empleados_id FROM gral_usr WHERE gral_usr.id=id_user INTO id_agente;
				cadena_where:=cadena_where||' AND crm_registro_casos.gral_empleado_id='||id_agente;
			END IF;
		ELSE
			cadena_where:=cadena_where ||' AND crm_registro_casos.gral_empleado_id='||str_data[9]::integer;
		END IF;

		--RAISE EXCEPTION '%','cadena::'||cadena_where;
		sql_query := 'SELECT crm_registro_casos.id as id
		FROM crm_registro_casos 
		LEFT JOIN crm_registro_casos_prospectos on crm_registro_casos_prospectos.id_crm_registro_casos=crm_registro_casos.id
		LEFT JOIN crm_registro_casos_clie ON crm_registro_casos_clie.id_crm_registro_casos=crm_registro_casos.id
		LEFT JOIN cxc_clie on cxc_clie.id=crm_registro_casos_clie.id_cliente
		LEFT JOIN crm_prospectos on crm_prospectos.id=crm_registro_casos_prospectos.id_prospecto
		LEFT JOIN cxc_agen ON cxc_agen.id=crm_registro_casos.gral_empleado_id 
		WHERE crm_registro_casos.borrado_logico=false AND crm_registro_casos.gral_emp_id='||emp_id||' '||cadena_where;

		--RAISE EXCEPTION '%','sql_query::'||sql_query;
	END IF;
	--Termina Buscador de  Registro de Casos
	
	
	--buscador de Aplicativo Control de Costos
	IF app_selected=125 THEN
		--str_data[3]	tipo_prod
		--str_data[4]	mar
		--str_data[5]	fam
		--str_data[6]	subfam
		--str_data[7]	producto
		--str_data[8]	pres
		--str_data[9]	tipo_costo;
		--str_data[10]	tipo_busqueda;--false=Solo Busqueda de datos, true=Simulacion(Calculo de costos de acuerdo a parametros)
		--str_data[11]	importacion
		--str_data[12]	directo
		--str_data[13]	pminimo
		--str_data[14]	tipo_cambio
		--str_data[15]	codigo
		--str_data[16]	a√±o
		--str_data[17]	mes
		
		IF str_data[16]::integer > 0 THEN
			ano_actual:=str_data[16]::integer;
		END IF;
		
		IF str_data[17]::integer > 0 THEN
			mes_actual:=str_data[17]::integer;
		END IF;
		
		--tipo de producto
		IF str_data[3]::integer!=0 THEN
			cadena_where:=' AND inv_prod.tipo_de_producto_id='||str_data[3];
		END IF;
		
		--marca
		IF str_data[4]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.inv_mar_id='||str_data[4];
		END IF;
		
		--familia
		IF str_data[5]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.inv_prod_familia_id='||str_data[5];
		END IF;
		
		--SubFamilia
		IF str_data[6]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.subfamilia_id='||str_data[6];
		END IF;
		
		--str_data[7]	producto
		IF str_data[7]!='%%' AND str_data[7]!='' THEN
			cadena_where:=cadena_where||' AND inv_prod.descripcion ILIKE '''||str_data[7]||'''';
		END IF;

		--str_data[15]	sku
		IF str_data[15]!='%%' AND str_data[15]!='' THEN
			cadena_where:=cadena_where||' AND inv_prod.sku ILIKE '''||str_data[15]||'''';
		END IF;
		
		--str_data[8]	pres
		IF str_data[8]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod_presentaciones.id='||str_data[8];
		END IF;
		
			
		sql_query :='SELECT 
				inv_prod.id AS  id
			FROM inv_prod
			JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
			JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
			JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
			LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
			WHERE inv_prod.borrado_logico=false 
			AND inv_prod.empresa_id='||emp_id||' AND inv_prod_cost_prom.ano='||ano_actual||' '||cadena_where;

		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador Aplicativo Control de Costos
	
	
	
	--buscador de Aplicativo Actualizador de Listas de Precios a Partir de Precio Minimo
	IF app_selected=126 THEN
		--str_data[4]	tipo_producto
		--str_data[5]	marca
		--str_data[6]	familia
		--str_data[7]	subfamilia
		--str_data[8]	codigo
		--str_data[9]	producto
		--str_data[10]	presentacion;
		
		--tipo de producto
		IF str_data[4]::integer!=0 THEN
			cadena_where:=' AND inv_prod.tipo_de_producto_id='||str_data[4];
		END IF;
		
		--marca
		IF str_data[5]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.inv_mar_id='||str_data[5];
		END IF;
		
		--familia
		IF str_data[6]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.inv_prod_familia_id='||str_data[6];
		END IF;
		
		--SubFamilia
		IF str_data[7]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.subfamilia_id='||str_data[7];
		END IF;
		
		--str_data[8]	codigo
		IF str_data[8]!='%%' AND str_data[8]!='' THEN
			cadena_where:=cadena_where||' AND inv_prod.sku ILIKE '''||str_data[8]||'''';
		END IF;
		
		--str_data[9]	producto
		IF str_data[9]!='%%' AND str_data[9]!='' THEN
			cadena_where:=cadena_where||' AND inv_prod.descripcion ILIKE '''||str_data[9]||'''';
		END IF;
		
		--str_data[10]	pres
		IF str_data[10]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod_pres_x_prod.presentacion_id='||str_data[10];
		END IF;
		
		sql_query :='	
		SELECT 
			inv_prod.id
		FROM inv_prod
		JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
		LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
		LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
		WHERE inv_prod.borrado_logico=false 
		AND inv_prod.empresa_id='||emp_id||' 
		AND inv_prod_cost_prom.ano='||ano_actual||' '||cadena_where;
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador Aplicativo Actualizador de Listas de Precios a Partir de Precio Minimo
	
	
	
	
	--buscador de crm_contactos
	IF app_selected=127 THEN
		----str_data[1]	app_selected
		----str_data[2]	id_usuario
		----str_data[3]	nombre
		----str_data[4]	busquedatipo_contacto
		----str_data[5]	busqueda_agente
		
		--Tipo_contacto
		IF str_data[4]::integer!=0 THEN
			cadena_where:=' AND crm_contactos.tipo_contacto='||str_data[4];
		END IF;
		
		--busqueda_agente
		IF str_data[5]::integer!=0 THEN
			cadena_where:= cadena_where||' AND crm_contactos.gral_empleado_id='||str_data[5];
		END IF;
		
		sql_query :='select id from crm_contactos 
		where crm_contactos.nombre||'' ''||crm_contactos.apellido_paterno||'' ''||
		crm_contactos.apellido_materno ilike '''||str_data[3]||'''  
		AND gral_emp_id='||emp_id||'  
		AND borrado_logico=false '||cadena_where||';';
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador de crm_contactos

	

	--buscador de Actualizador de Saludo y Despedida para Cotizaciones
	IF app_selected=131 THEN
		----str_data[1]	app_selected
		----str_data[2]	id_usuario

		--obtiene todas porque el buscador no se esta utilizando, solo hay dos registros
		sql_query :='SELECT distinct id FROM poc_cot_saludo_despedida WHERE gral_emp_id='||emp_id||';';
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador de Actualizador de Saludo y Despedida para Cotizaciones



	--buscador de Catalogo de Incoterms para Cotizaciones
	IF app_selected=132 THEN
		----str_data[1]	app_selected
		----str_data[2]	id_usuario
		----str_data[3]	nombre
		----str_data[4]	descripcion

		--str_data[3]	codigo
		IF str_data[3]!='%%' THEN
			cadena_where:=cadena_where||' AND poc_cot_incoterms.nombre ILIKE '''||str_data[3]||'''';
		END IF;
		
		--str_data[4]	producto
		IF str_data[4]!='%%' THEN
			cadena_where:=cadena_where||' AND (poc_cot_incoterms.descripcion_esp ILIKE '''||str_data[4]||''' OR poc_cot_incoterms.descripcion_ing ILIKE '''||str_data[4]||''' )';
		END IF;
		
		--obtiene todas porque el buscador no se esta utilizando, solo hay dos registros
		sql_query :='SELECT distinct id FROM poc_cot_incoterms WHERE gral_emp_id='||emp_id||' AND borrado_logico=false '||cadena_where||';';
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;--Termina buscador de Catalogo de Incoterms para Cotizaciones
	


	--buscador de Catalogo de Politicas de Pago
	IF app_selected = 134 THEN
		sql_query := 'SELECT id FROM poc_cot_politicas_pago WHERE gral_emp_id='||emp_id||'AND borrado_logico=false AND descripcion ILIKE '''||str_data[3]||''';';
	END IF;        --termina Catalogo de Politicas de Pago

	--buscador de Catalogo de Condiciones comerciales
	IF app_selected = 135 THEN
		sql_query := 'SELECT id FROM poc_cot_condiciones_com WHERE gral_emp_id='||emp_id||'AND borrado_logico=false AND descripcion ILIKE '''||str_data[3]||''';';
	END IF;        --termina Catalogo de Condiciones comerciales



	--buscador de Catalogo de Equipos Adicionales
	IF app_selected = 140 THEN
		--select  id from pro_equipos_adic WHERE gral_emp_id=1 AND borrado_logico=false AND titulo ILIKE '%%' AND titulo_corto ILIKE '%%'
		sql_query := 'SELECT id FROM pro_equipos_adic WHERE gral_emp_id='||emp_id||' AND borrado_logico=false AND titulo ILIKE '''||str_data[3]||''' AND titulo_corto ILIKE '''||str_data[4]||''';';
	END IF;
	
	
	
	--buscador de Catalogo de Equipos 
	IF app_selected = 141 THEN
		--str_data[5]	Tipo de Equipo
		
		IF str_data[5]::integer<>0 THEN
			cadena_where:=cadena_where||' AND pro_tipo_equipo_id='||str_data[5];
		END IF;
		
		--select  id from pro_equipos_adic WHERE gral_emp_id=1 AND borrado_logico=false AND titulo ILIKE '%%' AND titulo_corto ILIKE '%%'
		
		sql_query := 'SELECT id FROM pro_equipos WHERE gral_emp_id='||emp_id||' AND borrado_logico=false AND titulo ILIKE '''||str_data[3]||''' AND titulo_corto ILIKE '''||str_data[4]||''' '||cadena_where||';';
		
	END IF;        
	--termina Catalogo de Equipos 



	--buscador para el Aplicativo Consulta de Facturas de clientes
	IF app_selected = 142 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	factura
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	codigo
		--str_data[8]	producto
		--str_data[9]	agente
		--str_data[10]	folio_pedido
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND fac_docs.serie_folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(fac_docs.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[7] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[7]||'''';
		END IF;
		
		IF str_data[8] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[8]||'''';
		END IF;
		
		IF str_data[9]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND fac_docs.cxc_agen_id='||str_data[9];
		END IF;
		
		IF str_data[10] <> '%%' THEN
			cadena_where:= cadena_where ||' AND fac_docs.folio_pedido ilike  '''||str_data[10]||'''';
		END IF;
		
		sql_query := 'SELECT DISTINCT fac_docs.id 
				FROM fac_docs 
				JOIN fac_docs_detalles ON fac_docs_detalles.fac_doc_id = fac_docs.id 
				JOIN inv_prod ON inv_prod.id = fac_docs_detalles.inv_prod_id
				JOIN erp_proceso ON erp_proceso.id = fac_docs.proceso_id
				LEFT JOIN cxc_clie ON cxc_clie.id = fac_docs.cxc_clie_id   
				WHERE erp_proceso.empresa_id='||emp_id||' 
				AND  erp_proceso.sucursal_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--Termina buscador de Aplicativo Consulta de Facturas de clientes




	--Buscador para el Aplicativo de Aseguramiento de Calidad
        IF app_selected = 143 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		--str_data[4]	tipo
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND pro_orden_prod.folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '0' THEN
			cadena_where:= cadena_where ||' AND pro_orden_prod.pro_orden_tipos_id='||str_data[4]||'';
		ELSE
			cadena_where:= cadena_where ||' AND 1=1';
		END IF;
		
		IF str_data[5] != '%%' THEN
			cadena_where2:= ' sku ilike '''||str_data[5]||'''';
		ELSE
			cadena_where2:= ' sku ilike ''%%''';
		END IF;
		
		--sql_query := 'select id from pro_orden_prod where borrado_logico=false and gral_emp_id='||emp_id||' '||cadena_where;
		sql_query := 'select id from (
			select pro_orden_prod.id, (select inv_prod.sku from pro_orden_prod_det 
			join inv_prod on pro_orden_prod_det.inv_prod_id=inv_prod.id where pro_orden_prod_id=pro_orden_prod.id limit 1) as sku 
			from pro_orden_prod where borrado_logico=false and gral_emp_id='||emp_id||' '||cadena_where||' 
			) as op_tmp where '||cadena_where2;
			
		--RAISE EXCEPTION '%' ,sql_query;
		
        END IF;
        --Termina Buscador para el Aplicativo de Aseguramiento de Calidad


	--Buscador de Aplicativo Captura de Costos
	IF app_selected=145 THEN
		--str_data[3]	sku
		--str_data[4]	descripcion
		--str_data[5]	por_tipo
		--str_data[6]	anoActual
		--str_data[7]	mesActual
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND  inv_prod.descripcion ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND inv_prod.tipo_de_producto_id='||str_data[5]::integer;
		END IF;
		
		sql_query := 'SELECT inv_prod_cost_prom.id  FROM inv_prod_cost_prom
				JOIN inv_prod ON inv_prod.id=inv_prod_cost_prom.inv_prod_id
				WHERE inv_prod_cost_prom.ano='||str_data[6]||' 
				AND inv_prod.empresa_id = '|| emp_id ||' 
				AND borrado_logico=FALSE '||cadena_where;
	END IF;	
	--Termina buscador de Aplicativo Captura de Costos
	

	--buscador del aplicativo de Cancelacion de Anticipos
	IF app_selected = 146 THEN	
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	num_transaccion
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		primer_cond:=0;
		IF str_data[3] != '' THEN
			cadena_where:= cadena_where ||' AND cxc_ant.numero_transaccion='||str_data[3];
			primer_cond:=1;
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
			primer_cond:=1;
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(cxc_ant.fecha_anticipo_usuario, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
			primer_cond:=1;
		END IF;
		/*
		IF primer_cond=0 THEN
			cadena_where:= cadena_where ||' AND to_char(cxc_ant.fecha_anticipo_usuario,''yyyymmdd'') = (select to_char(MAX(cxc_ant.fecha_anticipo_usuario),''yyyymmdd'') FROM cxc_ant  WHERE empresa_id='||emp_id||' AND sucursal_id='||suc_id||')';
		END IF;
		*/
		sql_query := '
		SELECT cxc_ant.id FROM cxc_ant JOIN cxc_clie ON cxc_clie.id=cxc_ant.cliente_id
		WHERE cxc_ant.empresa_id='||emp_id||' 
		AND cxc_ant.sucursal_id='||suc_id||' '||cadena_where;

		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--termina buscador del aplicativo de Cancelacion de Anticipos
	



	--Buscador del Catalogo de Remitentes
	IF app_selected = 147 THEN
		--str_data[3]	folio
		--str_data[4]	remitente
		--str_data[5]	rfc
		--str_data[6]	tipo
		
		IF str_data[3]!='' THEN
			cadena_where:= cadena_where ||' AND cxc_remitentes.folio ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]!='%%' THEN
			cadena_where:= cadena_where ||' AND cxc_remitentes.razon_social ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5]!='%%' THEN
			cadena_where:= cadena_where ||' AND cxc_remitentes.rfc ILIKE '''||str_data[5]||'''';
		END IF;
		
		IF str_data[6]::integer<>0 THEN
			cadena_where:= cadena_where ||' AND cxc_remitentes.tipo='||str_data[6];
		END IF;
		
		sql_query := 'select distinct id from cxc_remitentes where borrado_logico=false 
		AND gral_emp_id='|| emp_id ||' '||cadena_where;
	END IF;	--Termina Buscador del Catalogo de Remitentes


	--Buscador del Catalogo de Destinatarios
	IF app_selected = 148 THEN
		--str_data[3]	folio
		--str_data[4]	remitente
		--str_data[5]	rfc
		--str_data[6]	tipo
		
		IF str_data[3]!='' THEN
			cadena_where:= cadena_where ||' AND cxc_destinatarios.folio ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]!='%%' THEN
			cadena_where:= cadena_where ||' AND cxc_destinatarios.razon_social ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5]!='%%' THEN
			cadena_where:= cadena_where ||' AND cxc_destinatarios.rfc ILIKE '''||str_data[5]||'''';
		END IF;
		
		IF str_data[6]::integer<>0 THEN
			cadena_where:= cadena_where ||' AND cxc_destinatarios.tipo='||str_data[6];
		END IF;
		
		sql_query := 'select distinct id from cxc_destinatarios where borrado_logico=false and gral_emp_id='||emp_id||' and gral_suc_id='||suc_id||' '||cadena_where;
	END IF;	
	--Termina Buscador del Catalogo de Destinatarios


	
	--Buscador del Catalogo de Agentes Aduanales
	IF app_selected = 149 THEN
		--str_data[3]	folio
		--str_data[4]	agente_aduanal
		--str_data[5]	tipo
		
		IF str_data[3]!='' THEN
			cadena_where:= cadena_where ||' AND cxc_agentes_aduanales.folio ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]!='%%' THEN
			cadena_where:= cadena_where ||' AND cxc_agentes_aduanales.razon_social ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5]::integer<>0 THEN
			cadena_where:= cadena_where ||' AND cxc_agentes_aduanales.tipo='||str_data[5];
		END IF;
		
		sql_query := 'select distinct id from cxc_agentes_aduanales where borrado_logico=false and gral_emp_id='|| emp_id ||' and gral_suc_id='||suc_id||' '||cadena_where;
	END IF;	--Termina Buscador del Agentes Aduanales
	
	
	--Buscador de Aplicativo de Asignacion de Remitentes a Clientes
	IF app_selected = 150 THEN
		--str_data[3]	nocontrol
		--str_data[4]	razonsoc
		--str_data[5]	rfc
		
		IF str_data[3]<>'' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.numero_control ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ILIKE '''||str_data[4]||'''';
		END IF;

		IF str_data[5]<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.rfc ILIKE '''||str_data[5]||'''';
		END IF;

		sql_query := 'SELECT distinct cxc_clie.id FROM cxc_clie 
		join cxc_clie_remitente on cxc_clie_remitente.cxc_clie_id=cxc_clie.id where borrado_logico=false  
		and cxc_clie.empresa_id='|| emp_id ||' and cxc_clie.sucursal_id='||suc_id||' and borrado_logico=false '||cadena_where;
	END IF;	--Termina buscador de Aplicativo de Asignacion de Remitentes a Clientes
	
	
	--Buscador de Aplicativo de Asignacion de Destinatarios a Clientes
	IF app_selected = 151 THEN
		--str_data[3]	nocontrol
		--str_data[4]	razonsoc
		--str_data[5]	rfc
		
		IF str_data[3]<>'' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.numero_control ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5]<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.rfc ILIKE '''||str_data[5]||'''';
		END IF;
		
		sql_query := 'SELECT distinct cxc_clie.id FROM cxc_clie 
		JOIN cxc_clie_dest ON cxc_clie_dest.cxc_clie_id=cxc_clie.id WHERE borrado_logico=false  
		AND cxc_clie.empresa_id='|| emp_id ||' and cxc_clie.sucursal_id='||suc_id||'AND borrado_logico=FALSE '||cadena_where;
	END IF;	--Termina buscador de Aplicativo de Asignacion de Destinatarios a Clientes


	
	--Buscador de Aplicativo de Asignacion de Agentes Aduanales a Clientes
	IF app_selected = 152 THEN
		--str_data[3]	nocontrol
		--str_data[4]	razonsoc
		--str_data[5]	rfc
		
		IF str_data[3]!='' THEN
			cadena_where:= cadena_where ||' and cxc_clie.numero_control ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]!='%%' THEN
			cadena_where:= cadena_where ||' and cxc_clie.razon_social ILIKE '''||str_data[4]||'''';
		END IF;
		
		IF str_data[5]!='%%' THEN
			cadena_where:= cadena_where ||' and cxc_clie.rfc ILIKE '''||str_data[5]||'''';
		END IF;
		
		sql_query := 'select distinct cxc_clie.id from cxc_clie 
		join cxc_clie_agen_aduanal on cxc_clie_agen_aduanal.cxc_clie_id=cxc_clie.id where borrado_logico=false  
		and cxc_clie.empresa_id='|| emp_id ||' and cxc_clie.sucursal_id='||suc_id||' and borrado_logico=false '||cadena_where;
	END IF;	--Termina buscador de Aplicativo de Asignacion de Agentes Aduanales a Clientes
	
	
	
	
	--Buscador del catalogo de Operadores(Choferes)
        IF app_selected = 154 THEN
                --str_data[1]        app_selected
                --str_data[2]        id_usuario
                --str_data[3]        clave_operador
                --str_data[4]        nombre
                --str_data[5]        sucursal
                --str_data[6]        transportista
                IF str_data[4]<>'%%' THEN
                        cadena_where='AND replace(nombre || CASE WHEN apellido_paterno is NULL THEN '''' ELSE apellido_paterno END || CASE WHEN apellido_materno is NULL THEN '''' ELSE apellido_materno END,'' '', '''') ilike '''||replace(str_data[4], ' ', '')||'''';
                END IF;
                
                IF str_data[3]<>'%%' THEN
                        cadena_where=cadena_where||' AND clave ilike '''||str_data[3]||'''';
                END IF;

                IF str_data[5]::integer<>0 THEN
                        cadena_where=cadena_where||' AND gral_suc_id='||str_data[5];
                END IF;

                IF str_data[6]::integer<>0 THEN
                        cadena_where=cadena_where||' and cxp_prov_id='||str_data[6];
                END IF;
                
                sql_query := 'select distinct  id from log_choferes where gral_emp_id='||emp_id||' and borrado_logico=false '||cadena_where;
        END IF;        
        --termina buscador del catalogo Operadores

	
	--Buscador de Aplicativo Actualizador de Contrase√±a de Usuario
	IF app_selected = 155 THEN
		sql_query := 'select gral_usr.id from gral_usr left join gral_empleados on gral_empleados.id=gral_usr.gral_empleados_id where gral_usr.id='||id_user||';';
	END IF;	--Termina Buscador de Aplicativo Actualizador de Contrase√±a de Usuario

	
	--Buscador del catalogo de IEPS
	IF app_selected = 167 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	TITULO
		IF trim(str_data[3])<>'%%' THEN
			cadena_where='AND titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM gral_ieps WHERE gral_emp_id='||emp_id||' AND borrado_logico=false '||cadena_where;
	END IF;	
	--Termina buscador del catalogo de IEPS


	--Buscador del catalogo de Percepcines
	IF app_selected = 170 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	TITULO
		IF str_data[3] !='%%' THEN
			cadena_where='AND titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM nom_percep WHERE gral_emp_id='||emp_id||' AND borrado_logico=false '||cadena_where;
	END IF;	--termina buscador del catalogo de Percepciones

	
	--Buscador del catalogo de Deducciones
	IF app_selected = 171 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	TITULO
		IF str_data[3]<>'%%' THEN
			cadena_where='AND titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM nom_deduc WHERE gral_emp_id='||emp_id||' AND borrado_logico=false '||cadena_where;
	END IF;
	--Termina buscador del catalogo de Deducciones


	--Buscador del catalogo de Periodicidad de Pago
	IF app_selected = 172 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	titulo
		IF str_data[3] !='%%' THEN
			cadena_where='AND titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM nom_periodicidad_pago WHERE gral_emp_id='||emp_id||' AND borrado_logico=false '||cadena_where;
	END IF;
	--Termina buscador del catalogo de Periodicidad de Pago
	

	--Buscador para el Aplicativo de Facturacion de Nominas
	IF app_selected = 173 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	no_periodo
		--str_data[4]	titulo_periodo
		--str_data[5]	tipo_periodo
		--str_data[6]	fecha_inicial
		--str_data[7]	fecha_final
		
		IF str_data[3]<>'%%' THEN
			cadena_where=' AND (nom_periodos_conf.prefijo||nom_periodos_conf_det.folio) ilike '''||str_data[3]||'''';
		END IF;

		IF str_data[4]<>'%%' THEN
			cadena_where=' AND nom_periodos_conf_det.titulo ilike '''||str_data[4]||'''';
		END IF;

		IF str_data[5]::integer<>0 THEN
			cadena_where=' AND fac_nomina.nom_periodicidad_pago_id='||str_data[5]||' ';
		END IF;
		
		--Busqueda por Fecha de Pago
		IF str_data[6]<>'' THEN
			IF str_data[7]='' THEN
				f_final:=str_data[6];
			ELSE
				f_final:=str_data[7];
			END IF;
			cadena_where:=cadena_where||' AND to_char(fac_nomina.fecha_pago::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := '
		SELECT fac_nomina.id FROM fac_nomina 
		JOIN nom_periodos_conf_det ON nom_periodos_conf_det.id=fac_nomina.nom_periodicidad_pago_id 
		JOIN nom_periodos_conf ON nom_periodos_conf.id=nom_periodos_conf_det.nom_periodos_conf_id
		WHERE fac_nomina.gral_emp_id='||emp_id||' '||cadena_where;
	END IF;
	--Termina buscador para el Aplicativo de Facturacion de Nominas


	--Buscador del catalogo de Configuracion de  Periodicidad de Pago
	IF app_selected = 174 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	anio
		--str_data[4]	titulo

		IF str_data[3]::integer != 0 THEN
			cadena_where:= cadena_where ||' AND nom_periodos_conf.ano='||str_data[3];
		END IF;
		
		IF str_data[4] !='%%' THEN
			cadena_where:= cadena_where ||' AND nom_periodicidad_pago.titulo ilike  '''||str_data[4]||'''';
		END IF;
		
		sql_query := 'SELECT nom_periodos_conf.id FROM nom_periodos_conf 
		JOIN nom_periodicidad_pago on nom_periodicidad_pago.id=nom_periodos_conf.nom_periodicidad_pago_id
		WHERE nom_periodos_conf.gral_emp_id = '|| emp_id ||' AND nom_periodos_conf.borrado_logico=FALSE '||cadena_where;
		
	
	END IF;
	--Termina buscador para el Aplicativo de Configuracion de  Periodicidad de Pago



	--Buscador del Aplicativo de Configurcion de Parametros de Facturacion
	IF app_selected = 175 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		sql_query := 'SELECT id FROM fac_par WHERE gral_emp_id='||emp_id||' AND borrado_logico=false';
	END IF;
	--Termina buscador del Aplicativo de Configurcion de Parametros de Facturacion



	--Buscador de Catalogo descuentos  Clientes
	IF app_selected = 176 THEN
		--str_data[3]	nocontrol
		--str_data[4]	razonsoc
		
		IF str_data[3]<>'' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.numero_control ILIKE '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4]<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ILIKE '''||str_data[4]||'''';
		END IF;
		sql_query := 'SELECT cxc_clie_descto.id FROM cxc_clie_descto 
		JOIN cxc_clie on cxc_clie.id=cxc_clie_descto.cxc_clie_id
		WHERE cxc_clie.empresa_id='|| emp_id ||' AND cxc_clie.borrado_logico=FALSE '||cadena_where;
	END IF;	--Termina buscador de Catalogo descuentos de Clientes



	--Buscador de Polizas Contables(CTB)
	IF app_selected = 179 THEN
		--str_data[3]	sucursal
		--str_data[4]	tipo_pol
		--str_data[5]	status
		--str_data[6]	concepto
		--str_data[7]	poliza
		--str_data[8]	fecha_inicial
		--str_data[9]	fecha_final

		--sucursal
		IF str_data[3]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND ctb_pol.gral_suc_id='||str_data[3];
		ELSE
			--cadena_where:= cadena_where ||' AND ctb_pol.gral_suc_id='||suc_id;
		END IF;
		
		--tipo_pol
		IF str_data[4]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND ctb_pol.ctb_tpol_id='||str_data[4];
		END IF;

		--status
		IF str_data[5]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND ctb_pol.status='||str_data[5];
		END IF;

		--concepto
		IF str_data[6]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND ctb_pol.ctb_con_id='||str_data[6];
		END IF;

		--poliza
		IF trim(str_data[7])<>'%%' THEN
			cadena_where:= cadena_where ||' AND ctb_pol.poliza::character varying ILIKE '''||trim(str_data[7])||'''';
		END IF;
		
		--Fecha de Poliza
		IF str_data[8] <> '' THEN
			IF str_data[9] = '' THEN
				f_final:=str_data[8];
			ELSE
				f_final:=str_data[9];
			END IF;
			cadena_where:=cadena_where||' AND to_char(ctb_pol.fecha_cap, ''yyyymmdd'')::integer between (to_char('''||str_data[8]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		sql_query := 'select distinct ctb_pol.id from ctb_pol 
		WHERE ctb_pol.gral_emp_id='|| emp_id ||' 
		AND ctb_pol.borrado_logico=FALSE '||cadena_where;
	END IF;	
	--Termina buscador de Polizas Contables


	
	--Aplicativo Carga de Documentos(LOG)
	IF app_selected = 180 THEN
		--str_data[3]	sucursal
		--str_data[4]	folio
		--str_data[5]	cliente
		--str_data[6]	almacen
		--str_data[7]	fecha_inicial
		--str_data[8]	fecha_final
		
		--sucursal
		IF str_data[3]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND log_doc.gral_suc_id='||str_data[3];
		END IF;
		
		--folio
		IF trim(str_data[4])<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_doc.folio ilike  '''||str_data[4]||'''';
		END IF;

		--cliente
		IF trim(str_data[5])<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[5]||'''';
		END IF;

		--almacen
		IF str_data[6]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND log_doc.inv_alm_id='||str_data[6];
		END IF;
		
		--str_data[7]	fecha_inicial
		--str_data[8]	fecha_final
		IF trim(str_data[7]) <> '' THEN
			IF trim(str_data[8]) = '' THEN
				f_final:=str_data[7];
			ELSE
				f_final:=str_data[8];
			END IF;
			cadena_where:=cadena_where||' AND to_char(log_doc.fecha_carga::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[7]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := '
		SELECT DISTINCT log_doc.id 
		FROM log_doc 
		JOIN cxc_clie ON cxc_clie.id=log_doc.cxc_clie_id 
		WHERE log_doc.gral_emp_id='|| emp_id ||' AND log_doc.borrado_logico=false '||cadena_where ||';';
	END IF;	
	--Termina buscador Aplicativo Carga de Documentos(LOG)
	



	--Aplicativo Administrador de Viajes(LOG)
	IF app_selected = 181 THEN
		--str_data[3]	sucursal
		--str_data[4]	folio
		--str_data[5]	no_carga
		--str_data[6]	no_pedido
		--str_data[7]	operador
		--str_data[8]	unidad
		--str_data[9]	poblcion
		--str_data[10]	destinatario
		--str_data[11]	fecha_inicial
		--str_data[12]	fecha_final
		
		--sucursal
		IF str_data[3]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND log_viaje.gral_suc_id='||str_data[3];
		END IF;
		
		--folio
		IF trim(str_data[4])<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_viaje.folio ilike  '''||str_data[4]||'''';
		END IF;

		--no_carga
		IF trim(str_data[5])<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_doc_carga.no_carga ilike  '''||str_data[5]||'''';
		END IF;
		
		--no_pedido
		IF trim(str_data[6])<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_doc_ped.no_pedido ilike  '''||str_data[6]||'''';
		END IF;

		--operador
		IF trim(str_data[7])<>'%%' THEN
			cadena_where:= cadena_where 'AND replace(log_choferes.nombre || CASE WHEN log_choferes.apellido_paterno is NULL THEN '''' ELSE log_choferes.apellido_paterno END || CASE WHEN log_choferes.apellido_materno is NULL THEN '''' ELSE log_choferes.apellido_materno END,'' '', '''') ilike '''||replace(trim(str_data[7]), ' ', '')||'''';
		END IF;

		--str_data[8]	unidad
		IF trim(str_data[8])<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_vehiculos.marca ilike  '''||str_data[8]||'''';
		END IF;
		
		--str_data[9]	poblcion
		IF trim(str_data[9])<>'%%' THEN
			cadena_where:= cadena_where ||' AND gral_mun.titulo ilike  '''||str_data[9]||'''';
		END IF;
		
		--str_data[10]	destinatario
		IF trim(str_data[10])<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_destinatarios.razon_social ilike  '''||str_data[10]||'''';
		END IF;
		
		--str_data[11]	fecha_inicial
		--str_data[12]	fecha_final
		IF trim(str_data[11]) <> '' THEN
			IF trim(str_data[12]) = '' THEN
				f_final:=str_data[11];
			ELSE
				f_final:=str_data[12];
			END IF;
			cadena_where:=cadena_where||' AND to_char(log_viaje.fecha::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[11]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := '
		SELECT DISTINCT log_viaje.id
		FROM log_viaje
		JOIN log_viaje_det ON log_viaje_det.log_viaje_id=log_viaje.id
		JOIN log_doc_carga ON log_doc_carga.id=log_viaje_det.log_doc_carga_id
		JOIN log_doc_ped ON log_doc_ped.id=log_viaje_det.log_doc_ped_id
		LEFT JOIN log_choferes ON log_choferes.id=log_viaje.log_chofer_id
		JOIN log_vehiculos ON log_vehiculos.id=log_viaje.log_vehiculo_id
		JOIN gral_mun ON gral_mun.id=log_viaje_det.gral_mun_id
		JOIN cxc_destinatarios ON cxc_destinatarios.id=log_doc_ped.cxc_dest_id
		WHERE log_viaje.gral_emp_id='|| emp_id ||' AND log_viaje.borrado_logico=false '||cadena_where ||';';
	END IF;	
	--Termina buscador Aplicativo Administrador de Viajes(LOG)




	--Buscador del Aplicativo de Configurcion de Parametros de Contabilidad(CTB)
	IF app_selected = 183 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		sql_query := 'SELECT id FROM ctb_par WHERE gral_emp_id='||emp_id||' AND borrado_logico=false;';
	END IF;
	--Termina buscador del Aplicativo de Configurcion de Parametros de Contabilidad(CTB)




	--Buscador del catalogo de Vehiculos Marca
	IF app_selected = 182 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	titulo
		IF trim(str_data[3])<>'%%' THEN
			cadena_where='AND titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM log_vehiculo_marca WHERE gral_emp_id='||emp_id||' AND borrado_logico=false '||cadena_where;
	END IF;
	--Termina buscador del catalogo de Vehiculos Marca


	--Buscador del catalogo de Vehiculos Tipo Rodada
	IF app_selected = 183 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	titulo
		IF trim(str_data[3])<>'%%' THEN
			cadena_where='AND titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM log_vehiculo_tipo_rodada WHERE gral_emp_id='||emp_id||' AND borrado_logico=false '||cadena_where;
	END IF;
	--Termina buscador del catalogo de Vehiculos Tipo Rodada


	--Buscador del catalogo de Vehiculos Tipo Caja
	IF app_selected = 184 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	titulo
		IF trim(str_data[3])<>'%%' THEN
			cadena_where='AND titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM log_vehiculo_tipo_caja WHERE gral_emp_id='||emp_id||' AND borrado_logico=false '||cadena_where;
	END IF;
	--Termina buscador del catalogo de Vehiculos Tipo Caja




	--Buscador del Catalogo de Servicios Adicionales(LOG)
	IF app_selected = 185 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	busqueda_codigo
		--str_data[4]	busqueda_descripcion

		IF trim(str_data[3]) <> '%%' THEN
			cadena_where:= cadena_where ||' and inv_prod.sku ilike '''||str_data[3]||'''';
		END IF;
		
		IF trim(str_data[4]) <> '%%' THEN
			cadena_where:= cadena_where ||' and  inv_prod.descripcion ilike '''||str_data[4]||'''';
		END IF;
		
		sql_query := 'select distinct log_serv_adic.id from log_serv_adic 
		join inv_prod on inv_prod.id=log_serv_adic.inv_prod_id 
		where inv_prod.empresa_id='||emp_id||'  and inv_prod.sucursal_id='||suc_id||' and inv_prod.borrado_logico=false '||cadena_where;
	END IF;
	--Termina buscador Catalogo de Servicios Adicionales(LOG)




	--Buscador del Catalogo de Tipos de Unidades
	IF app_selected = 187 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	titulo
		IF trim(str_data[3])<>'%%' THEN
			cadena_where='AND titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT id FROM log_vehiculo_tipo WHERE gral_emp_id='||emp_id||' AND borrado_logico=false '||cadena_where;
	END IF;
	--Termina buscador del Catalogo Tipos de Unidades

	
	
	--Aplicativo Captura de Numero de Facturas(LOG)
	IF app_selected = 188 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	no_carga
		--str_data[4]	no_pedido
		--str_data[5]	poblcion
		--str_data[6]	destinatario
		--str_data[7]	fecha_inicial
		--str_data[8]	fecha_final
		--str_data[9]	folio
		
		--no_carga
		IF trim(str_data[3])<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_doc_carga.no_carga ilike  '''||str_data[3]||'''';
		END IF;
		
		--no_pedido
		IF trim(str_data[4])<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_doc_ped.no_pedido ilike  '''||str_data[4]||'''';
		END IF;
		
		--str_data[5]	poblcion
		IF trim(str_data[5])<>'%%' THEN
			cadena_where:= cadena_where ||' AND gral_mun.titulo ilike  '''||str_data[5]||'''';
		END IF;
		
		--str_data[6]	destinatario
		IF trim(str_data[6])<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_destinatarios.razon_social ilike  '''||str_data[6]||'''';
		END IF;
		
		--folio
		IF trim(str_data[9])<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_doc_carga.folio ilike  '''||str_data[9]||'''';
		END IF;
		
		--str_data[7]	fecha_inicial
		--str_data[8]	fecha_final
		IF trim(str_data[7]) <> '' THEN
			IF trim(str_data[8]) = '' THEN
				f_final:=str_data[7];
			ELSE
				f_final:=str_data[8];
			END IF;
			cadena_where:=cadena_where||' AND to_char(log_doc.fecha_carga::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[7]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		sql_query := '
		SELECT DISTINCT log_doc_carga.id 
		FROM log_doc 
		join log_doc_carga on log_doc_carga.log_doc_id=log_doc.id 
		JOIN log_doc_ped ON log_doc_ped.log_doc_carga_id=log_doc_carga.id
		LEFT JOIN gral_mun ON gral_mun.id=log_doc_ped.gral_mun_id 
		LEFT JOIN cxc_destinatarios ON cxc_destinatarios.id=log_doc_ped.cxc_dest_id
		WHERE log_doc.gral_emp_id='|| emp_id ||' and log_doc.gral_suc_id='||suc_id||' and log_doc.borrado_logico=false '||cadena_where ||';';
	END IF;	
	--Termina buscador Aplicativo Captura de Numero de Facturas(LOG)
	
	
	
	--Buscador del Tarifario
	IF app_selected = 189 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	titulo
		IF str_data[3]<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_ruta.titulo ilike  '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'SELECT log_ruta.id FROM log_ruta WHERE log_ruta.gral_emp_id='||emp_id||' and log_ruta.gral_suc_id='||suc_id||' and log_ruta.borrado_logico=FALSE '||cadena_where;
	END IF;
	--Termina buscador del Tarifario



	--Buscador del Catalogo de Tipo de Rechazo
	IF app_selected = 190 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	titulo
		IF str_data[3]<>'%%' THEN
			cadena_where:= cadena_where ||' and log_tipo_rechazo.titulo ilike  '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'select log_tipo_rechazo.id from log_tipo_rechazo where log_tipo_rechazo.gral_emp_id='|| emp_id ||' and log_tipo_rechazo.borrado_logico=false '||cadena_where;
	END IF;
	--Termina buscador Catalogo de Tipo de Rechazo






	--Buscador para el Aplicativo Addendas (Es el mismo buscador de Consulta de Facturas de clientes)
	IF app_selected = 193 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	factura
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	codigo
		--str_data[8]	producto
		--str_data[9]	agente
		--str_data[10]	folio_pedido
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND fac_docs.serie_folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND to_char(fac_docs.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[7] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[7]||'''';
		END IF;
		
		IF str_data[8] != '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike  '''||str_data[8]||'''';
		END IF;
		
		IF str_data[9]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND fac_docs.cxc_agen_id='||str_data[9];
		END IF;
		
		IF str_data[10] <> '%%' THEN
			cadena_where:= cadena_where ||' AND fac_docs.folio_pedido ilike  '''||str_data[10]||'''';
		END IF;
		
		sql_query := 'SELECT DISTINCT fac_docs.id 
				FROM fac_docs 
				JOIN fac_docs_detalles ON fac_docs_detalles.fac_doc_id = fac_docs.id 
				JOIN inv_prod ON inv_prod.id = fac_docs_detalles.inv_prod_id
				JOIN erp_proceso ON erp_proceso.id = fac_docs.proceso_id
				LEFT JOIN cxc_clie ON cxc_clie.id = fac_docs.cxc_clie_id   
				WHERE erp_proceso.empresa_id='||emp_id||' 
				AND  erp_proceso.sucursal_id='||suc_id||' '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	--Termina buscador de Aplicativo Consulta de Facturas de clientes
	
	
	
	
	--Buscador del Tarifario de Venta por Poblacion(LOG)
	IF app_selected = 194 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	poblacion
		--str_data[4]	cliente
		
		IF trim(str_data[3])<>'%%' THEN
			cadena_where:= cadena_where ||' AND gral_mun.titulo ilike  '''||str_data[3]||'''';
		END IF;
		
		IF trim(str_data[4])<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		sql_query := '
		select 
			distinct log_tarifario_venta.id 
		from log_tarifario_venta 
		join log_tarifario_venta_det on log_tarifario_venta_det.log_tarifario_venta_id=log_tarifario_venta.id 
		join log_tarifa_tipo on (log_tarifa_tipo.id=log_tarifario_venta_det.log_tarifa_tipo_id  and log_tarifa_tipo.tipo=1) 
		join cxc_clie on cxc_clie.id=log_tarifario_venta.cxc_clie_id 
		join gral_mun on gral_mun.id=log_tarifario_venta.gral_mun_id 
		WHERE log_tarifario_venta.gral_emp_id='||emp_id||' 
		and log_tarifario_venta.gral_suc_id='||suc_id||' 
		and log_tarifario_venta.borrado_logico=FALSE '||cadena_where;
	END IF;
	--Termina buscador del Tarifario de Venta por Poblacion(LOG)



	--Buscador del Tarifario de Venta por Rango(LOG)
	IF app_selected = 195 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	tipo_tarifa
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		
		IF str_data[3]::integer > 0 THEN
			cadena_where:= cadena_where ||' AND log_tarifario_venta_det.log_tarifa_tipo_id='||str_data[3];
		END IF;
		
		IF trim(str_data[4])<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--Busqueda por fecha de vigencia de tarifa
		IF trim(str_data[5])<>'' THEN
			IF trim(str_data[6]) = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' AND (to_char(log_tarifario_venta_det.fecha_inicio::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
			cadena_where:=cadena_where||' OR to_char(log_tarifario_venta_det.fecha_fin::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer))';
		END IF;
		
		sql_query := '
		select 
			log_tarifario_venta.id 
		from log_tarifario_venta 
		join log_tarifario_venta_det on log_tarifario_venta_det.log_tarifario_venta_id=log_tarifario_venta.id 
		join log_tarifa_tipo on (log_tarifa_tipo.id=log_tarifario_venta_det.log_tarifa_tipo_id  and log_tarifa_tipo.tipo=2) 
		join cxc_clie on cxc_clie.id=log_tarifario_venta.cxc_clie_id 
		WHERE log_tarifario_venta.gral_emp_id='||emp_id||' and log_tarifario_venta.gral_suc_id='||suc_id||' and log_tarifario_venta.borrado_logico=FALSE '||cadena_where;
	END IF;
	--Termina buscador del Tarifario de Venta por Rango(LOG)



	--Buscador de Facturas de Proveedores version 2 para logistik
	IF app_selected = 196 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	factura
		--str_data[4]	proveedor
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		
		--busqueda por fecha factura
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=' AND to_char(cxp_facturas.fecha_factura, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := 'SELECT cxp_facturas.id
				FROM cxp_facturas
				JOIN cxp_prov ON cxp_prov.id=cxp_facturas.cxc_prov_id 
				WHERE cxp_facturas.serie_folio ILIKE '''||str_data[3]||''' 
				AND cxp_prov.razon_social ILIKE '''||str_data[4]||''' 
				AND cxp_facturas.empresa_id='||emp_id||' 
				AND cxp_facturas.sucursal_id='||suc_id||' '||cadena_where;
	END IF;
	--Termina buscador Facturas de Proveedores version 2 para logistik



	
	--Entradas al Almacen(LOG)
	IF app_selected = 197 THEN
		--str_data[3]	sucursal
		--str_data[4]	folio
		--str_data[5]	cliente
		--str_data[6]	almacen
		--str_data[7]	fecha_inicial
		--str_data[8]	fecha_final
		
		--sucursal
		IF str_data[3]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND log_entrada.gral_suc_id='||str_data[3];
		END IF;
		
		--folio
		IF trim(str_data[4])<>'%%' THEN
			cadena_where:= cadena_where ||' AND log_entrada.folio ilike  '''||str_data[4]||'''';
		END IF;

		--cliente
		IF trim(str_data[5])<>'%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[5]||'''';
		END IF;

		--almacen
		IF str_data[6]::integer <> 0 THEN
			cadena_where:= cadena_where ||' AND log_entrada.inv_alm_id='||str_data[6];
		END IF;
		
		
		--str_data[7]	fecha_inicial
		--str_data[8]	fecha_final
		IF trim(str_data[7]) <> '' THEN
			IF trim(str_data[8]) = '' THEN
				f_final:=str_data[7];
			ELSE
				f_final:=str_data[8];
			END IF;
			cadena_where:=cadena_where||' AND to_char(log_entrada.fecha::timestamp with time zone, ''yyyymmdd'')::integer between (to_char('''||str_data[7]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;
		
		sql_query := '
		SELECT DISTINCT log_entrada.id 
		FROM log_entrada 
		JOIN cxc_clie ON cxc_clie.id=log_entrada.cxc_clie_id 
		WHERE log_entrada.gral_emp_id='|| emp_id ||' AND log_entrada.borrado_logico=false '||cadena_where ||';';
	END IF;	
	--Termina buscador Aplicativo Entradas al Almacen(LOG)

	


	--Buscador para el Aplicativo Ordenes de Salida con Impresion de Etiqueta
	IF app_selected = 200 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	factura
		--str_data[4]	cliente
		--str_data[5]	fecha_inicial
		--str_data[6]	fecha_final
		--str_data[7]	codigo
		--str_data[8]	producto
		--str_data[9]	agente
		--str_data[10]	folio_pedido
		
		IF str_data[3] != '%%' THEN
			cadena_where:= cadena_where ||' AND fac_docs.serie_folio ilike  '''||str_data[3]||'''';
		END IF;
		
		IF str_data[4] != '%%' THEN
			cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike  '''||str_data[4]||'''';
		END IF;
		
		--busqueda por fecha creacion
		IF str_data[5] != '' THEN
			IF str_data[6] = '' THEN
				f_final:=str_data[5];
			ELSE
				f_final:=str_data[6];
			END IF;
			cadena_where:=cadena_where||' and to_char(fac_docs.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[5]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		IF str_data[7]<>'%%' THEN
			cadena_where:= cadena_where ||' and inv_prod.sku ilike  '''||str_data[7]||'''';
		END IF;
		
		IF str_data[8]<>'%%' THEN
			cadena_where:= cadena_where ||' and inv_prod.descripcion ilike  '''||str_data[8]||'''';
		END IF;
		
		IF str_data[9]::integer <> 0 THEN
			cadena_where:= cadena_where ||' and fac_docs.cxc_agen_id='||str_data[9];
		END IF;
		
		IF str_data[10]<>'%%' THEN
			cadena_where:= cadena_where ||' and fac_docs.folio_pedido ilike  '''||str_data[10]||'''';
		END IF;
		
		sql_query := '
		select distinct fac_docs.id 
		from fac_docs 
		join fac_docs_detalles ON fac_docs_detalles.fac_doc_id = fac_docs.id 
		join inv_prod ON inv_prod.id = fac_docs_detalles.inv_prod_id
		join erp_proceso ON (erp_proceso.id=fac_docs.proceso_id and erp_proceso.empresa_id='||emp_id||' and erp_proceso.sucursal_id='||suc_id||') 
		left join cxc_clie ON cxc_clie.id=fac_docs.cxc_clie_id 
		where fac_docs.cancelado=false '||cadena_where;
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;	
	--Termina buscador de Aplicativo Ordenes de Salida con Impresion de Etiqueta
	
	
	
	--Buscador de Etiquetas de Entrada(INV)
	IF app_selected=202 THEN
		--str_data[3]	folio
		--str_data[4]	orden_compra
		--str_data[5]	factura
		--str_data[6]	proveedor
		--str_data[7]	tipo_doc
		--str_data[8]	codigo
		
		IF trim(str_data[3]) <> '%%' THEN
			cadena_where:= cadena_where ||' AND inv_oent.folio ilike '''||str_data[3]||'''';
		END IF;
		
		IF trim(str_data[5]) <> '%%' THEN
			cadena_where:= cadena_where ||' AND inv_oent.folio_documento ilike '''||str_data[5]||'''';
		END IF;
		
		IF trim(str_data[4]) <> '%%' THEN
			cadena_where:= cadena_where ||' AND inv_oent.orden_de_compra ilike '''||str_data[4]||'''';
		END IF;
		
		IF trim(str_data[6]) <> '%%' THEN
			cadena_where:= cadena_where ||' AND cxp_prov.razon_social ilike '''||str_data[6]||'''';
		END IF;

		IF trim(str_data[7]) <> '0' THEN
			cadena_where:= cadena_where ||' AND inv_oent.tipo_documento='||str_data[7]||' ';
		END IF;

		IF trim(str_data[8]) <> '%%' THEN
			cadena_where:= cadena_where ||' AND inv_prod.sku ilike  '''||str_data[8]||'''';
		END IF;

		
		sql_query := '
		SELECT DISTINCT inv_oent.id
		FROM inv_oent
		LEFT JOIN inv_oent_detalle ON inv_oent_detalle.inv_oent_id=inv_oent.id
		LEFT JOIN inv_prod ON inv_prod.id=inv_oent_detalle.inv_prod_id
		LEFT JOIN cxp_prov on cxp_prov.id=inv_oent.cxp_prov_id
		WHERE inv_oent.gral_emp_id='||emp_id||' 
		AND inv_oent.borrado_logico=false and inv_oent.gral_suc_id='||suc_id||' '||cadena_where;
	END IF;	--termina buscador de Ordenes de Entrada
	
	

	--Aplicativo Definicion de Asientos Contables(CTB)
	IF app_selected = 203 THEN
		--str_data[3]	id_sucursal
		--str_data[4]	tipo_pol
		--str_data[5]	folio
		--str_data[6]	nombre
		
		--tipo_pol
		IF str_data[4]::integer<>0 THEN
			cadena_where:= cadena_where ||' AND ctb_tmov.ctb_tpol_id='||str_data[4];
		END IF;
		
		--folio
		IF trim(str_data[5])<>'%%' THEN
			cadena_where:= cadena_where ||' AND ctb_tmov.folio ilike '''||str_data[5]||'''';
		END IF;
		
		--nombre del asiento
		IF trim(str_data[6])<>'%%' THEN
			cadena_where:= cadena_where ||' AND ctb_tmov.titulo ilike '''||str_data[6]||'''';
		END IF;

		
		sql_query := '
		SELECT DISTINCT ctb_tmov.id 
		FROM ctb_tmov 
		WHERE ctb_tmov.gral_emp_id='|| emp_id ||' AND ctb_tmov.borrado_logico=false '||cadena_where ||';';
	END IF;	
	--Termina buscador Aplicativo Entradas al Almacen(LOG)

	
	--Buscador del catalogo de IVA Trasladado
	IF app_selected = 204 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	titulo
		IF trim(str_data[3])<>'%%' THEN
			cadena_where='and descripcion ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'select id from gral_imptos where borrado_logico=false '||cadena_where;
	END IF;	
	--Termina buscador del catalogo de IVA Trasladado

	
	--Buscador del catalogo de IVA Retenido
	IF app_selected = 205 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	titulo
		IF trim(str_data[3])<>'%%' THEN
			cadena_where='and titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query := 'select id from gral_imptos_ret where gral_emp_id='||emp_id||' and borrado_logico=false '||cadena_where;
	END IF;	
	--Termina buscador del catalogo de IVA Retenido



	--Buscador de Aplicativo de Registro de Proyectos(CRM)
	IF app_selected = 207 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	folio
		IF trim(str_data[3])<>'' THEN
			cadena_where:= cadena_where ||' AND proy.folio ilike '''||str_data[3]||'''';
		end if;
		
		--str_data[4]	proyecto
		IF trim(str_data[4])<>'%%' THEN
			cadena_where:= cadena_where ||' AND proy.titulo ilike '''||str_data[4]||'''';
		end if;
		
		--str_data[5]	agente
		IF str_data[5]::integer <= 0 THEN
			--Busca si el usuario tiene rol de ADMINISTRADOR
			SELECT count(gral_usr_id) FROM gral_usr_rol WHERE gral_usr_id=id_user AND gral_rol_id=1 INTO exis;
			
			IF exis=0 THEN
				--si el usuario no tiene rol de ADMINISTRADOR, entonces hay que filtrar solo registros del agente
				--en otro caso NO HAY filtro, se debe mostrar todos los registros de visitas
				SELECT gral_usr.gral_empleados_id FROM gral_usr WHERE gral_usr.id=id_user INTO id_agente;
				
				cadena_where:=cadena_where||' AND proy.gral_empleado_id='||id_agente;
			END IF;
		ELSE
			cadena_where:=cadena_where ||' AND proy.gral_empleado_id='||str_data[5];
		END IF;

		
		--str_data[6]	fecha_inicial
		--str_data[7]	fecha_final
		--Busqueda por fecha
		IF trim(str_data[6])<>'' THEN
			IF str_data[7] = '' THEN
				f_final:=str_data[6];
			ELSE
				f_final:=str_data[7];
			END IF;
			cadena_where:=' AND to_char(proy.momento_creacion, ''yyyymmdd'')::integer between (to_char('''||str_data[6]||'''::timestamp with time zone,''yyyymmdd'')::integer) and (to_char('''||f_final||'''::timestamp with time zone,''yyyymmdd'')::integer)';
		END IF;

		--str_data[8]	cliente
		IF trim(str_data[8])<>'%%' THEN
			cadena_where:= cadena_where ||' AND tbl_cliente.cliente ilike '''||str_data[8]||'''';
		end if;
		
		--str_data[9]	segmento
		IF str_data[9]::integer>0 THEN
			cadena_where:= cadena_where ||' AND proy.cxc_clie_clas1_id='||str_data[9];
		end if;
		
		--str_data[10]	mercado
		IF str_data[10]::integer>0 THEN
			cadena_where:= cadena_where ||' AND proy.cxc_clie_clas2_id='||str_data[10];
		end if;
		
		sql_query := '
		SELECT distinct proy.id 
		FROM crm_registro_proyecto as proy 
		left join (
		    select crm_contactos.id as contacto_id,cxc_clie.razon_social as cliente from crm_contactos join crm_contacto_cli on crm_contacto_cli.crm_contactos_id=crm_contactos.id join cxc_clie on cxc_clie.id=crm_contacto_cli.cxc_clie_id where crm_contactos.tipo_contacto=1 
		    union 
		    select crm_contactos.id as contacto_id,crm_prospectos.razon_social as cliente from crm_contactos join crm_contacto_pro on crm_contacto_pro.crm_contactos_id=crm_contactos.id join crm_prospectos on crm_prospectos.id=crm_contacto_pro.crm_prospectos_id where crm_contactos.tipo_contacto=2 
		) as tbl_cliente on tbl_cliente.contacto_id=proy.crm_contacto_id 
		WHERE proy.borrado_logico=false and proy.gral_emp_id='||emp_id||' '||cadena_where;
	END IF;
	--Termina buscador Aplicativo de Registro de Proyectos(CRM)


	--Buscador Catalogo de Seguimientos de Visitas(CRM)
	IF app_selected=208 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		
		--str_data[3]	titulo
		IF trim(str_data[3]) <> '%%' THEN
			cadena_where:=cadena_where||'AND titulo ilike '''||str_data[3]||'''';
		END IF;
		
		sql_query :='SELECT DISTINCT id FROM crm_tipos_seguimiento_visita WHERE gral_emp_id='||emp_id||' and borrado_logico=false '||cadena_where;
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;
	--Termina buscador Catalogo de Seguimientos de Visitas(CRM)



	--Buscador Cat√°logo de M√©todos de Pago(FAC)
	IF app_selected=209 THEN
		--str_data[1]	app_selected
		--str_data[2]	id_usuario
		--str_data[3]	clave
		--str_data[4]	titulo

		--str_data[3]	clave
		IF trim(str_data[3]) <> '%%' THEN
			cadena_where:=cadena_where||' AND clave_sat ilike '''||str_data[3]||'''';
		END IF;
		
		--str_data[4]	titulo
		IF trim(str_data[4]) <> '%%' THEN
			cadena_where:=cadena_where||' AND titulo ilike '''||str_data[4]||'''';
		END IF;
		
		sql_query :='SELECT DISTINCT id FROM fac_metodos_pago WHERE gral_emp_id='||emp_id||' and borrado_logico=false '||cadena_where;
		
		--RAISE EXCEPTION '%' ,sql_query;
	END IF;
	--Termina buscador Cat√°logo de M√©todos de Pago(FAC)























	

	
	--RAISE EXCEPTION '%',sql_query;
	
	FOR fila IN EXECUTE (sql_query) LOOP
		total_items := 1 + total_items;
		RETURN NEXT fila;
	END LOOP;
	
	IF total_items = 0 THEN
		fila.id:= -1; -- return current row of SELECT
		RETURN NEXT fila;
	END IF;
	
END; 
$$;


--
-- Name: inv_actualiza_existencia_producto_anio(integer, boolean, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_actualiza_existencia_producto_anio(tipo_calculo integer, incluye_reservados boolean, id_prod integer, id_user integer, id_almacen integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE
	/*
	Este procedimiento es para obtener la existencia de un producto. Tiene dos modalidades:
	tipo_calculo=1 : Obtiene existencia de un producto del almacen de la sucursal donde esta logueado el usuario
	tipo_calculo=2 : Obtiene existencia de un producto en todos los alacenes de la Empresa
	*/
	cadena_sql text = '';
	subquery text = '';
	fila_almacenes record;
	id_almacenes character varying := '';
	primer_registro smallint=0;
	ano_actual integer;
	mes_actual integer;
	emp_id integer;
	suc_id integer;
	incrementa int:=1;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	existencia double precision;
	descontar_reservados_transito character varying='';
BEGIN	
	ano_actual := 2012;
	mes_actual := 12;
	--SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	--SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id
  	FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	--WHERE gral_usr_suc.gral_usr_id=id_user
	INTO emp_id, suc_id;
	
	

	--tipo_calculo 1=Busqueda de Existencia por un almacen en especifico
	IF tipo_calculo = 1 THEN
		id_almacenes:=id_almacen;
	END IF;
	
	--tipo_calculo 2=Busqueda de Existencia en Todos los almacenes de la Empresa
	IF tipo_calculo = 2 THEN
		--query para obtener todos los alacenes de la empresa
		cadena_sql:='SELECT distinct inv_suc_alm.almacen_id FROM gral_suc JOIN inv_suc_alm ON inv_suc_alm.sucursal_id=gral_suc.id 
				WHERE gral_suc.empresa_id='||emp_id||' ORDER BY inv_suc_alm.almacen_id;';
		
		primer_registro:=0;--variable para saber si es el primer almacen en la cadena
		FOR fila_almacenes IN EXECUTE(cadena_sql) LOOP
			if primer_registro=0 then
				id_almacenes:=id_almacenes||'';
			else
				id_almacenes:=id_almacenes||',';
			end if;
			id_almacenes:=id_almacenes||fila_almacenes.almacen_id;
			primer_registro:=1;
		END LOOP;
	END IF;
	
	
	
	--Si el id del almacen es null, le asignamos un cero para que no genere error al ejecutar el query
	IF id_almacenes IS NULL OR id_almacenes='' THEN 
		id_almacenes:='0';
	END IF;
	
	--descuenta reservados y transito en el calculo de las existencias
	IF incluye_reservados=FALSE THEN 
		descontar_reservados_transito :=' - transito - reservado ';
	END IF;
	
	
	--reiniciar variable
	cadena_sql:='';
	
	--Crear formula para calcular la existencia actual del producto
	cadena_sql:= 'SELECT (exi_inicial '||descontar_reservados_transito||' ';
	WHILE incrementa <= mes_actual LOOP
		cadena_sql:=cadena_sql ||' + entradas_'||incrementa||' - salidas_'||incrementa;
		incrementa:= incrementa + 1;
	END LOOP;
	cadena_sql:= cadena_sql||') AS exi FROM inv_exi WHERE inv_prod_id='||id_prod||' AND ano='||ano_actual||' AND inv_alm_id IN ('||id_almacenes||')';
	
	
	--obtiene existencia del producto
	subquery := 'SELECT sum(exi) as exi FROM ('||cadena_sql||') AS sbt;';
	
	
	--RAISE EXCEPTION '%',subquery;
	
	EXECUTE subquery INTO existencia;
	
	IF existencia IS NULL OR existencia<=0 THEN 
		existencia:=0;
	END IF;
	
	existencia := round((existencia)::numeric,4)::double precision;
	
	RETURN existencia;
	
END;

$$;


--
-- Name: inv_actualiza_repite_costo_promedio(integer, double precision, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_actualiza_repite_costo_promedio(id_prod integer, costo_promedio double precision, espacio_tiempo_ejecucion timestamp with time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

DECLARE
	/*
	Este procedimiento asgina el Costo Promedio de un producto en el mes actual.
	Despues repite el mismo Costo Promedio para los meses  posteriores hasta Diciembre
	*/
	cadena_sql text = '';
	ano_actual integer;
	mes_actual integer;
	incrementa int:=1;
BEGIN	
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;

	incrementa := mes_actual + 1;
	
	--Crear cadena sql para actualizar guardar el costo promedio
	cadena_sql:= 'UPDATE inv_prod_cost_prom SET costo_promedio_'||mes_actual||'='||costo_promedio;
	WHILE incrementa <= 12 LOOP
		cadena_sql:=cadena_sql ||', costo_promedio_'||incrementa||'='||costo_promedio;
		incrementa:= incrementa + 1;
	END LOOP;
	cadena_sql:= cadena_sql||' WHERE inv_prod_id='||id_prod||' AND ano='||ano_actual||';';
	
	
	--RAISE EXCEPTION '%',subquery;
	
	EXECUTE cadena_sql;
	
	
	RETURN 'true';
	
END;

$$;


--
-- Name: inv_adm_movimientos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_adm_movimientos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$


-- #### Premisas de ejecucion de este procedimiento almacenado:
-- * Cuando se genera un Traspaso se genera una SALIDA en el almacen origen 
-- y una ENTRADA en el almacen destino
-- * Cuando se realiza un ajuste se generara ya sea una salida (Si la cantidad de existencia disminuye) 
-- o una ENTRADA (Si la cantidad de existencia aumenta)... sobre el almacen.
-- * El campo existencia de la tabla de existencias de inventario se actualizara cada que se actualice
-- la tabla de movimientos de inventario

DECLARE
	app_selected integer;
	command_selected text;
	usuario_ejecutor integer;
	emp_id integer;
	suc_id integer;
	str_data text[];
	str_filas text[];
	total_filas integer;--total de elementos de arreglo
	iter_y integer;--contador de filas o posiciones del arreglo (iterador eje y del arreglo iterado)
	
	valor_retorno character varying := ''; 
	ultimo_id integer;
	ultimo_id_proceso integer;
	ultimo_id_cxp_facturas integer; 
	ultimo_id2 integer:=0;
	ultimo_id3 integer:=0;
	
	espacio_tiempo_ejecucion timestamp with time zone := now();
	identificador_nuevo_movimiento integer;
	identificador_nuevo_movimiento_entrada integer;
	tipo_movimiento_id integer:=0;
	tipo_de_documento integer:=0;
	
	exis integer = 0; 
	ano_actual integer;
	mes_actual integer;
	
	sql_insert character varying;
	sql_update character varying;
	sql_select text := '';
	sql_select2 character varying:='';
	cadena_where character varying:='';
	valores_campos character varying:='';
	fila record;
	fila2 record;
	fila3 record;
	fila4 record;
	com_param record;
	inv_pre_param record;
	incrementa int:=1;
	costo_prom_actualizado character varying;
	
	--Variables  para entrada de mercancias
	nombre_consecutivo character varying := '';
	ultimo_consecutivo_entrada character varying;
	folio_entrada character varying;
	ultimo_consecutivo_lote character varying;
	num_lote character varying;
	fcaducidad date;
	valor_impuesto double precision := 0.0;
	importe double precision := 0.0;
	subtotal_entrada double precision := 0.0;
	impuesto_partida double precision := 0.0;

	importe_ieps_partida double precision = 0;
	suma_ieps double precision = 0;
	
	suma_impuesto double precision := 0.0;
	total_entrada double precision := 0.0;
	tasa_retencion_ double precision := 0.0;
	total_retencion double precision := 0.0;
	valor_iva double precision := 0.0;
	precio_unitario  double precision := 0.0;
	precio_unitario_mn  double precision := 0.0;
	id_dias_credito integer:=0;
	numero_dias_credito integer:=0;
	fecha_de_vencimiento timestamp with time zone;
	tip_cam double precision:=0.0;
	id_proceso integer:=0;
	nuevo_costo_promedio double precision:=0.0;
	equiv_presentacion double precision:=0.0;
	suma_cant_surtido_oc double precision:=0.0;
	cant_partida_oc double precision:=0.0;
	
	--Cancelacion de entrada
	entrada record;
	factura_detalle record;
	proveedor_entrada_id integer;
	folio_factura_entrada character varying;
	
	--variables subensamble
	folio_subensamble bigint;
	estado_orden smallint;
	formulacion record;
	orden_detalle record;
	cantidad_producto_elemento double precision := 0.0;
	id_almacen integer:=0;
	cantidad_produccion_  double precision := 0.0;
	cant_exi_actual double precision := 0.0;
	suma_costo_elemento double precision := 0.0;
	costo_promedio_actual double precision := 0.0;
	suma_costo_actual double precision := 0.0;
	
	--Variables para generar consecutivos
	id_tipo_consecutivo integer:=0;
	prefijo_consecutivo character varying := '';
	nuevo_consecutivo bigint:=0;
	nuevo_folio character varying := '';
	
	--variables  para la orden de entrada
	doc_com record;--esta variable es para almacenar datos del documento de Compra, que puede ser una factura o Remision
	detalle record;
	ultimo_id_inv_oent integer=0;
	id_orden_entrada integer=0;
	estatus_orden integer=0;
	diferencia_lote double precision;
	nuevo_lote character varying = '';
	ano_actual_2_digitos character varying = '';
	
	--Veriable para Orden de Salida
	id_lote integer = 0;
	cant_sal_anterior double precision=0;
	
	--Ajustes de inventario
	folio_ajuste character varying = '';
	tipo_ajuste boolean=false;
	id_alm_origen integer=0;
	id_alm_destino integer=0;
	tipo_costo_movimiento integer = 0;
	grupo_movimiento integer = 0;
	tipo_doc integer=0;--almacena el tipo de documento
	
	--Traspasos
	noDecUnidad integer=0;--numero de decimales permitidos para la unidad
	exisActualPres double precision=0;--existencia actual de la presentacion
	equivalenciaPres double precision=0; --equivalencia de la presentacion en la unidad del producto
	cantPres double precision=0; --Cantidad que se esta Intentando traspasar
	cantPresAsignado double precision=0;
	
	folio1 character varying = '';
	folio2 character varying = '';
	lote_proveedor character varying = '';
	lote_cad date;
	lote_ped character varying = '';
	fecha_produccion date;
	numero_dias_caducidad integer;
	fecha_movimiento timestamp with time zone;
	
	--conversion de costos a Lista de Precios
	tc_usd double precision=0;
	tc_eur double precision=0;

	--Variable que indica si se incluye el Modulo de Produccion
	incluyeModuloProduccion boolean = false;
	
	--Variable que indica si se debe controlar las existencias por presentaciones
	controlExisPres boolean = false;

	match_cadena boolean:=false;
	
	--Id de la unidad de medida del producto
	idUnidadMedida integer:=0;
	--Densidad del producto
	densidadProd double precision:=0;
	--Nombre de la unidad de medida del producto
	nombreUnidadMedida character varying:='';
	--Id de la unidad de Medida de la Venta
	idUnidadMedidaVenta integer:=0;
	--Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantUnidadVenta double precision:=0;
	--Cantidad de la existencia convertida a la unidad de venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantExisUnidadVenta double precision:=0;
BEGIN
	
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- aplicativo que manda a llamar este procedimiento almacenado
	app_selected := str_data[1]::integer;
	
	--Comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	--Usuario que utiliza el aplicativo
	usuario_ejecutor := str_data[3]::integer;
	
	/*
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	INTO emp_id, suc_id;
	*/
	
	--obtiene empresa_id, sucursal_id y sucursal_id
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id,inv_suc_alm.almacen_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id=usuario_ejecutor
	INTO emp_id, suc_id, id_almacen;
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--Obtiene parametros de la empresa 
	SELECT incluye_produccion, control_exis_pres FROM gral_emp WHERE id=emp_id INTO incluyeModuloProduccion, controlExisPres;
	
	--Obtiene parametros de Compras
	SELECT * FROM com_par WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id INTO com_param;

	--Obtiene los parametros de para listas de precios
	SELECT * FROM inv_pre_par WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id INTO inv_pre_param;
	
	-- Entrada de mercancias
	IF app_selected = 9 THEN
		/*
		str_data[4] 	id_entrada
		str_data[5] 	id_proveedor
		str_data[6] 	factura
		str_data[7] 	expedicion
		str_data[8] 	numeroguia
		str_data[9] 	ordencompra
		str_data[10] 	moneda
		str_data[11] 	tc
		str_data[12] 	observaciones
		str_data[13] 	fletera_id
		str_data[14] 	flete
		str_data[15] 	almacen_destino
		str_data[16] 	tipo_documento
		str_data[17] 	check_lab
		*/
		
		IF command_selected = 'new' THEN
			
			id_tipo_consecutivo:=16;--Folio de Entrada de Mercancia
			tipo_movimiento_id:=1;--Entrada por Compra de Mercancia
			
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			folio_entrada := prefijo_consecutivo || nuevo_consecutivo::character varying;


			--Obtener dato del proveedor
			select proveedortipo_id from cxp_prov where id=str_data[5]::integer limit 1 into fila4;
			
			if fila4.proveedortipo_id is null then fila4.proveedortipo_id:=0; end if;
			
			SELECT DISTINCT valor::double precision/100 AS valor FROM erp_parametros_generales WHERE variable = 'tasa_retencion_fletes' LIMIT 1 INTO tasa_retencion_;

			if fila4.proveedortipo_id<>2 then 
				total_retencion := str_data[14]::double precision * tasa_retencion_;
			end if;
			
			IF str_data[10]::integer=1 THEN 
				tip_cam:=1;
			ELSE
				tip_cam:=str_data[11]::double precision;
			END IF;
			
			
			--crea registro en tabla com_proceso y retorna el id del registro creado. El flujo del proceso es 3=Orden de Entrada
			INSERT INTO  com_proceso(com_proceso_flujo_id,gral_emp_id,gral_suc_id)VALUES(3, emp_id, suc_id) RETURNING id into ultimo_id_proceso;
			
			
			--crear registro en tabla com_fac(Orden de Entrada)
			INSERT INTO com_fac(no_entrada,proveedor_id,factura,factura_fecha_expedicion,numero_guia,orden_de_compra,moneda_id,tipo_de_cambio,momento_creacion,observaciones,fletera_id,flete,inv_alm_id,empresa_id,sucursal_id,id_usuario_creacion, tipo_documento, retencion, tasa_ret, com_proceso_id, lab_destino)
			VALUES(folio_entrada, str_data[5]::integer, str_data[6], str_data[7]::date, str_data[8], str_data[9], str_data[10]::integer, tip_cam, espacio_tiempo_ejecucion, str_data[12], str_data[13]::integer, str_data[14]::double precision, str_data[15]::integer, emp_id, suc_id,usuario_ejecutor, str_data[16]::integer, total_retencion, tasa_retencion_, ultimo_id_proceso, str_data[17]::boolean)
			RETURNING id INTO ultimo_id;
			
			
			
			--genera registro del movimiento
			INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id,gral_app_id, referencia, fecha_mov, inv_mov_tipo_id) 
			VALUES(str_data[12],espacio_tiempo_ejecucion,usuario_ejecutor,app_selected, str_data[6], str_data[7]::timestamp with time zone, tipo_movimiento_id ) 
			RETURNING id INTO identificador_nuevo_movimiento;
			
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--no_partida 	str_filas[1]
				--cantidad	str_filas[2]
				--costo		str_filas[3]
				--id_prod_grid	str_filas[4]
				--impuesto	str_filas[5]
				--valor_imp	str_filas[6]
				--id_pres	str_filas[7]
				--eliminado	str_filas[8]
				--id_ieps	str_filas[9]
				--tasa_eps	str_filas[10]
				--iddetoc	str_filas[11]
				
				--costo y canidad no son vacias, se agrega el registro
				IF str_filas[8]::integer != 0 THEN
					--inicializamos valor_impuesto para cada producto del grid
					valor_impuesto:=0.0;
					noDecUnidad:=0;
					
					--Buscar el numero de decimales de la unidad del producto
					SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=str_filas[4]::integer 
					INTO noDecUnidad;

					IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;

					--Redondear la Cantidad de la entrada
					str_filas[2] := round(str_filas[2]::numeric,noDecUnidad)::character varying;
					
					IF trim(str_filas[3])<>'' THEN
						precio_unitario:=str_filas[3]::double precision;
					ELSE
						precio_unitario:=0.0;
					END IF;
					
					--Aqui se convierte el costo unitario a pesos, esto es para el calculo del costo promedio
					precio_unitario_mn := precio_unitario * tip_cam;
					
					IF str_filas[10]::double precision>0 THEN 
						str_filas[10]:=str_filas[10]::double precision/100;
					END IF;
					
					--Aqui pasa  cuando la entrada es por Factura
					INSERT INTO com_fac_detalle(
						no_partida,--str_filas[1]::integer,
						cantidad,--str_filas[2]::double precision,
						costo_unitario,--precio_unitario,
						producto_id,--str_filas[4]::integer,
						tipo_de_impuesto_sobre_partida,--str_filas[5]::integer,
						valor_imp,----str_filas[6]::double precision,
						presentacion_id,--str_filas[7]::integer,
						com_fac_id,--ultimo_id
						gral_ieps_id,--str_filas[9]::integer,
						valor_ieps--str_filas[10]::double precision
					)VALUES(str_filas[1]::integer, str_filas[2]::double precision, precio_unitario, str_filas[4]::integer, str_filas[5]::integer, str_filas[6]::double precision, str_filas[7]::integer, ultimo_id,str_filas[9]::integer, str_filas[10]::double precision )
					RETURNING id INTO ultimo_id2;
					
					--Verificar si el id del detalle de la orden de compra es mayor que cero
					IF str_filas[11]::integer>0 THEN 
						select com_orden_compra_id, cantidad from com_orden_compra_detalle where id=str_filas[11]::integer into ultimo_id3, cant_partida_oc;
						
						if ultimo_id3 is null then ultimo_id3:=0; end if;
						
						IF ultimo_id3>0 THEN 
							--Crear registro en la tabla com_fac_oc, donde esta la relacion de partidas surtidas de la orden de compra con la factura de compra
							INSERT INTO com_fac_oc(com_oc_id, com_oc_det_id, com_fac_det_id) VALUES(ultimo_id3, str_filas[11]::integer, ultimo_id2);
						END IF;
						
						--Obtener suma de cantidad surtida para la partida actual de la Orden de Compra
						select sum(com_fac_detalle.cantidad) as cant_surtido from com_fac_oc join com_fac_detalle on com_fac_detalle.id=com_fac_oc.com_fac_det_id where com_fac_oc.com_oc_det_id=str_filas[11]::integer 
						into suma_cant_surtido_oc;
						
						if suma_cant_surtido_oc is null then suma_cant_surtido_oc:=0; end if;
						
						suma_cant_surtido_oc:=round(suma_cant_surtido_oc::numeric,noDecUnidad)::double precision;
						
						IF (round((cant_partida_oc::double precision - suma_cant_surtido_oc::double precision)::numeric,noDecUnidad)::double precision)<0.0001 THEN 
							--Actualizar cantidad surtida de la partida de la Orden de Compra
							UPDATE com_orden_compra_detalle SET cant_surtido=suma_cant_surtido_oc, surtir=false, estatus=2 WHERE id=str_filas[11]::integer;
						ELSE
							IF suma_cant_surtido_oc>0 THEN 
								--Actualizar cantidad surtida de la partida de la Orden de Compra
								UPDATE com_orden_compra_detalle SET cant_surtido=suma_cant_surtido_oc, estatus=1 WHERE id=str_filas[11]::integer;
							END IF;
						END IF;
						
						--Actualizar estatus de la Orden de compra
						IF (SELECT count(id) FROM com_orden_compra_detalle WHERE com_orden_compra_id=ultimo_id3 AND surtir=true AND estatus IN(0,1))>0 THEN 
							--3=Surtido Parcial
							UPDATE com_orden_compra SET status=3 WHERE id=ultimo_id3;
						ELSE 
							--4=Surtido Completo
							UPDATE com_orden_compra SET status=4 WHERE id=ultimo_id3;
						END IF;
					END IF;
					
					--Busca el valor del impuesto
					SELECT count(id) FROM gral_imptos WHERE borrado_logico=FALSE AND id=str_filas[5]::integer INTO exis;
					IF exis > 0 THEN
						SELECT iva_1 FROM gral_imptos WHERE borrado_logico=FALSE AND id=str_filas[5]::integer INTO valor_impuesto;
					END IF;
					
					--Calcular y Redondear el importe de la partida
					importe := round((str_filas[2]::double precision * str_filas[3]::double precision)::numeric,4)::double precision;
					
					--Calcular y redondear el IEPS de la partida
					importe_ieps_partida := round((importe::double precision * str_filas[10]::double precision)::numeric,4)::double precision;
					
					--Calcula el IVA de la Partida
					impuesto_partida := (importe::double precision + importe_ieps_partida::double precision) * valor_impuesto;
					
					
					--Acumular montos
					subtotal_entrada := subtotal_entrada + importe::double precision;
					suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
					suma_impuesto := suma_impuesto + impuesto_partida::double precision;
					
					
					--llamada a procedimiento que calcula el Nuevo Costo Promedio
					--el costo unitario que se le pasa debe ser en pesos(precio_unitario_mn)
					select * from inv_calculo_costo_promedio_producto(str_filas[4]::integer,str_filas[2]::double precision, precio_unitario_mn, espacio_tiempo_ejecucion, usuario_ejecutor) 
					INTO nuevo_costo_promedio;
					
					
					--genera registro en detalles del movimiento
					INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id, costo, inv_prod_presentacion_id)
					VALUES(str_filas[4]::integer, 0, str_data[15]::integer, str_filas[2]::double precision, identificador_nuevo_movimiento, nuevo_costo_promedio, str_filas[7]::integer);
					
					--reiniciamos el valor de la variable exis a cero
					exis:=0;
					
					sql_select := '';
					--query para verificar existencia del producto en el almacen y en el a√±o actual
					sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||str_filas[4]||' AND inv_alm_id = '||str_data[15]||' AND ano = '||ano_actual;
					--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
					EXECUTE sql_select INTO exis;
					
					IF exis >0 THEN
						sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||str_filas[2]||'::double precision), costo_ultimo_'||mes_actual||'='||precio_unitario||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
						WHERE inv_alm_id='||str_data[15]||' AND inv_prod_id='||str_filas[4]||' AND ano='||ano_actual||';';
						EXECUTE sql_update;
					ELSE
						sql_insert:='INSERT INTO inv_exi (inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial, costo_ultimo_'||mes_actual||') '||
						'VALUES('||str_filas[4]||','||str_data[15]||','||ano_actual||','||str_filas[2]||','''|| espacio_tiempo_ejecucion ||''',0,'||precio_unitario||' );';
						EXECUTE sql_insert;
					END IF;
					
					--llamada al procedimiento para actualizar costo promedio
					SELECT * FROM inv_actualiza_repite_costo_promedio(str_filas[4]::integer, nuevo_costo_promedio, espacio_tiempo_ejecucion) INTO costo_prom_actualizado;
					
					--reiniciamos el valor de la variable exis a cero
					exis:=0;
					
					
					
					--RAISE EXCEPTION '%','com_param.mon_prod_costo_precio='||com_param.mon_prod_costo_precio;
					
					
					/********INICIA CONVERSION DE COSTO A LA MONEDA DEFINIDA EN EL PRODUCTO*************/
					--Verificar si hay que cambiar el costo a la moneda definida en el catalogo de productos
					IF com_param.mon_prod_costo_precio THEN 
						
						--Obtener datos del producto
						select gral_mon_id, 0::double precision as tc from inv_prod where id=str_filas[4]::integer limit 1 into fila3;

						if fila3.gral_mon_id is null then 
							--Si no tiene moneda, asignar pesos por default
							fila3.gral_mon_id:=1;
						else
							if fila3.gral_mon_id=0 then 
								--Si no tiene moneda, asignar pesos por default
								fila3.gral_mon_id:=1;
							end if;
						end if;

						--RAISE EXCEPTION '%','gral_mon_id='||fila3.gral_mon_id||'    moneda_vista='||str_data[10];
						
						--Convertir a la moneda del producto
						if fila3.gral_mon_id<>str_data[10]::integer then 
							if fila3.gral_mon_id=1 then 
								--Si el tipo de cambio es menor o igual a 1, entonces hay que buscar el tipo de cambio
								if str_data[11]::double precision<=1 then 
									SELECT valor::character varying FROM erp_monedavers WHERE momento_creacion<=espacio_tiempo_ejecucion AND moneda_id=str_data[10]::integer ORDER BY momento_creacion DESC LIMIT 1 into fila3.tc;
									
									if fila3.tc is null then 
										str_data[11]:='0';
									else
										--Asignar tipo de cambio de la moneda del producto
										str_data[11]:=fila3.tc::character varying;
									end if;
								end if;
								
								
								--Convertir a MN
								--str_filas[3]:= (str_filas[3]::double precision * str_data[11]::double precision)::character varying;
								precio_unitario:=(str_filas[3]::double precision * str_data[11]::double precision);
								
								--Asignar tipo de cambio 1
								str_data[11]:='1';
								
								--Asignar moneda del producto
								str_data[10]:=fila3.gral_mon_id::character varying;
							else 
								--Si el tipo de cambio es menor o igual a 1, entonces hay que buscar el tipo de cambio
								if str_data[11]::double precision<=1 then 
									SELECT valor::character varying FROM erp_monedavers WHERE momento_creacion<=espacio_tiempo_ejecucion AND moneda_id=fila3.gral_mon_id ORDER BY momento_creacion DESC LIMIT 1 into fila3.tc;
									
									if fila3.tc is null then 
										str_data[11]:='0';
									else
										--Asignar tipo de cambio de la moneda del producto
										str_data[11]:=fila3.tc::character varying;
									end if;
								end if;
								
								--RAISE EXCEPTION '%','tc_vista='||str_data[11]||'    precio='||str_filas[3];
								
								--Asignar la moneda del producto
								str_data[10]:=fila3.gral_mon_id::character varying;
								
								--Convertir de MN a otra moneda
								--str_filas[3]:= (str_filas[3]::double precision / str_data[11]::double precision)::character varying;
								precio_unitario:=(str_filas[3]::double precision / str_data[11]::double precision);
							end if;
						end if;
					end if;
					/********TERMINA CONVERSION DE COSTO A LA MONEDA DEFINIDA EN EL PRODUCTO*************/


					--RAISE EXCEPTION '%','tc_vista='||str_data[11]||'    precio='||str_filas[3];


					
					--Query si ya existe un producto con fecha mas reciente que la que se esta dando de alta
					SELECT count(com_fac.id)::integer FROM com_fac JOIN com_fac_detalle ON com_fac_detalle.com_fac_id=com_fac.id
					WHERE com_fac.factura_fecha_expedicion > str_data[7]::date AND com_fac_detalle.producto_id=str_filas[4]::integer INTO exis;
					
					IF exis <= 0 THEN 
						--aqui debe entrar si NO existe una fecha mayor para este producto
						--debemos actualizar y repetir el costo para todos los meses
						incrementa := 0;--inicializar valor
						
						--toma el mes de la fecha de la factura
						incrementa := EXTRACT(MONTH FROM str_data[7]::timestamp with time zone)::integer  + 1;
						
						--aqui se crea la cadena para actualizar y repetir los valores del mes actual hasta el mes 12
						sql_update := 'UPDATE inv_prod_cost_prom SET costo_ultimo_'||EXTRACT(MONTH FROM str_data[7]::timestamp with time zone)::integer||'='||precio_unitario||', tipo_cambio_'||EXTRACT(MONTH FROM str_data[7]::timestamp with time zone)::integer||'='||tip_cam||', gral_mon_id_'||EXTRACT(MONTH FROM str_data[7]::timestamp with time zone)::integer||'='||str_data[10]::integer||', actualizacion_'||EXTRACT(MONTH FROM str_data[7]::timestamp with time zone)::integer||'='''||str_data[7]::timestamp with time zone||''', factura_ultima_'||EXTRACT(MONTH FROM str_data[7]::timestamp with time zone)::integer||'='''||str_data[6]||''', oc_ultima_'||EXTRACT(MONTH FROM str_data[7]::timestamp with time zone)::integer||'='''||str_data[9]||'''';
						WHILE incrementa <= 12 LOOP
							sql_update:=sql_update ||', costo_ultimo_'||incrementa||'='||precio_unitario||', tipo_cambio_'||incrementa||'='||tip_cam||', gral_mon_id_'||incrementa||'='||str_data[10]::integer||', actualizacion_'||incrementa||'='''||str_data[7]::timestamp with time zone||''', factura_ultima_'||incrementa||'='''||str_data[6]||''', oc_ultima_'||incrementa||'='''||str_data[9]||''''; 
							incrementa:= incrementa + 1;
						END LOOP;
						sql_update:= sql_update||' WHERE inv_prod_id='||str_filas[4]::integer||' AND ano='||ano_actual||';';
						
						--RAISE EXCEPTION '%',sql_update;
						EXECUTE sql_update;
					END IF;
					
					
					
					
					/****************************************************************************************************************************
					Aqui comienza el calculo y actualizacion de LISTAS DE PRECIOS(INV_PRE)
					*****************************************************************************************************************************/
					--Inicializar en cero
					exis:=0;
					
					IF inv_pre_param.id IS NOT NULL THEN 
						--RAISE EXCEPTION '%','SI HAY PARAMETROS '||emp_id;
						
						--Verificar si debe hacer el calculo automatico de listas de precios
						IF inv_pre_param.calculo_automatico THEN 
							
							sql_select := '
							SELECT 
								sbt.prod_id,
								sbt.pres_id,
								sbt.moneda_id,
								--(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + (sbt.costo * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
								(case when '||str_data[17]||'=true then 
									(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic)/(1 - sbt.pmin) ELSE 0 END)
								else
									(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END)
								end) AS precio_minimo,
								0::double precision AS precio_calculado1,0::double precision AS precio_calculado2, 0::double precision AS precio_calculado3, 0::double precision AS precio_calculado4, 0::double precision AS precio_calculado5, 0::double precision AS precio_calculado6, 0::double precision AS precio_calculado7, 0::double precision AS precio_calculado8, 0::double precision AS precio_calculado9, 0::double precision AS precio_calculado10
							FROM (
								SELECT 
									inv_prod.id AS  prod_id,
									inv_prod_pres_x_prod.presentacion_id AS pres_id,
									(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
									(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
									(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1  ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||'=1 THEN 1 ELSE inv_prod_cost_prom.tipo_cambio_'||mes_actual||' END) END)  AS tc,
									(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
									(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic, 
									(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
									(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
									(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
								FROM inv_prod 
								JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
								JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
								LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
								LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
								WHERE inv_prod.borrado_logico=false 
								AND inv_prod.empresa_id='||emp_id ||' AND inv_prod_cost_prom.ano='||ano_actual||' AND inv_prod.id='||str_filas[4]::integer||' AND inv_prod_pres_x_prod.presentacion_id='||str_filas[7]||' 
							) AS sbt LIMIT 1;';

							/*
							if str_data[17]::boolean then 
								RAISE EXCEPTION '%','sql_select: '||sql_select;
							else
								RAISE EXCEPTION '%','LAB: false';
							end if;
							*/
							
							
							
							FOR fila IN EXECUTE (sql_select) LOOP
								IF fila.precio_minimo > 0 THEN 
									/*
									--Aqu√≠ se calculan los valores para las listas de precios
									fila.precio_calculado1 := (CASE WHEN inv_pre_param.margen_l1=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l1/100)::double precision ) END);
									fila.precio_calculado2 := (CASE WHEN inv_pre_param.margen_l2=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l2/100)::double precision ) END);
									fila.precio_calculado3 := (CASE WHEN inv_pre_param.margen_l3=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l3/100)::double precision ) END);
									fila.precio_calculado4 := (CASE WHEN inv_pre_param.margen_l4=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l4/100)::double precision ) END);
									fila.precio_calculado5 := (CASE WHEN inv_pre_param.margen_l5=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l5/100)::double precision ) END);
									fila.precio_calculado6 := (CASE WHEN inv_pre_param.margen_l6=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l6/100)::double precision ) END);
									fila.precio_calculado7 := (CASE WHEN inv_pre_param.margen_l7=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l7/100)::double precision ) END);
									fila.precio_calculado8 := (CASE WHEN inv_pre_param.margen_l8=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l8/100)::double precision ) END);
									fila.precio_calculado9 := (CASE WHEN inv_pre_param.margen_l9=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l9/100)::double precision ) END);
									fila.precio_calculado10 := (CASE WHEN inv_pre_param.margen_l10=0 THEN 0 ELSE fila.precio_minimo / (1 - (inv_pre_param.margen_l10/100)::double precision ) END);
									*/
									
									--Buscar el producto y la presentacion actual el la tabla INV_PRE
									SELECT count(id) FROM inv_pre WHERE gral_emp_id=emp_id AND borrado_logico=FALSE AND inv_prod_id=fila.prod_id AND inv_prod_presentacion_id=fila.pres_id 
									INTO exis;
									
									IF exis > 0 THEN 
										--Aqui no hace nada
									ELSE 
										--Crea registro por cada presentacion en la tabla de precios 
										INSERT INTO inv_pre (inv_prod_id, inv_prod_presentacion_id, momento_creacion,borrado_logico,precio_1, precio_2, precio_3, precio_4, precio_5, precio_6, precio_7, precio_8, precio_9, precio_10, gral_mon_id_pre1, gral_mon_id_pre2, gral_mon_id_pre3, gral_mon_id_pre4, gral_mon_id_pre5, gral_mon_id_pre6, gral_mon_id_pre7, gral_mon_id_pre8, gral_mon_id_pre9, gral_mon_id_pre10, descuento_1,descuento_2,descuento_3,descuento_4,descuento_5,descuento_6,descuento_7,descuento_8,descuento_9,descuento_10,default_precio_1,default_precio_2,default_precio_3,default_precio_4,default_precio_5,default_precio_6,default_precio_7,default_precio_8,default_precio_9,default_precio_10,operacion_precio_1,operacion_precio_2,operacion_precio_3,operacion_precio_4,operacion_precio_5,operacion_precio_6,operacion_precio_7,operacion_precio_8,operacion_precio_9,operacion_precio_10,calculo_precio_1,calculo_precio_2,calculo_precio_3,calculo_precio_4,calculo_precio_5,calculo_precio_6,calculo_precio_7,calculo_precio_8,calculo_precio_9,calculo_precio_10,redondeo_precio_1,redondeo_precio_2,redondeo_precio_3,redondeo_precio_4,redondeo_precio_5,redondeo_precio_6,redondeo_precio_7,redondeo_precio_8,redondeo_precio_9,redondeo_precio_10) 
										VALUES(fila.prod_id, fila.pres_id, espacio_tiempo_ejecucion, false, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, 0,0,0,0,0,0,0,0,0,0 ,0,0,0,0,0,0,0,0,0,0,  1,1,1,1,1,1,1,1,1,1 ,1,1,1,1,1,1,1,1,1,1,  0,0,0,0,0,0,0,0,0,0);
										
										/*
										--si el producto con la presentacion no tiene registro en la tabla INV_PRE, hay que Crear el Registro
										sql_insert := 'INSERT INTO inv_pre( inv_prod_id, inv_prod_presentacion_id, gral_emp_id, momento_creacion, gral_usr_id_creacion, borrado_logico, precio_1, precio_2, precio_3, precio_4, precio_5, precio_6, precio_7, precio_8, precio_9, precio_10, gral_mon_id_pre1,gral_mon_id_pre2,gral_mon_id_pre3,gral_mon_id_pre4,gral_mon_id_pre5,gral_mon_id_pre6,gral_mon_id_pre7,gral_mon_id_pre8,gral_mon_id_pre9,gral_mon_id_pre10)
										VALUES('||fila.prod_id||', '||fila.pres_id||', '||emp_id||', '''||espacio_tiempo_ejecucion||'''::timestamp with time zone,'||usuario_ejecutor||',false,'||fila.precio_calculado1||' ,'||fila.precio_calculado2||' ,'||fila.precio_calculado3||' ,'||fila.precio_calculado4||' ,'||fila.precio_calculado5||' ,'||fila.precio_calculado6||' ,'||fila.precio_calculado7||' ,'||fila.precio_calculado8||' ,'||fila.precio_calculado9||' ,'||fila.precio_calculado10||', '||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||');';
										--EXECUTE sql_insert;
										*/
									END IF;
									
									
									--Inicializar
									sql_update := '';
									
									--Si el Producto con la Presentacion, ya existe en la Tabla INV_PRE, hay que actualizarla
									--Buscar parametros del producto en la tabla de precios(inv_pre)
									select * from inv_pre WHERE gral_emp_id=emp_id AND borrado_logico=FALSE AND inv_prod_id=fila.prod_id AND inv_prod_presentacion_id=fila.pres_id 
									into fila2;
									
									--calculo_precio_1(Forma de calculo) 	1=Automatico (En l√≠nea)
									--operacion_precio_1(Operacion para el calculo) 	1=Porcentaje (%)
									if fila2.id is not null then 
										if fila2.calculo_precio_1=1 then 
											if fila2.operacion_precio_1=1 then 
												fila.precio_calculado1 := (CASE WHEN fila2.default_precio_1=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_1/100)::double precision ) END);
												sql_update := sql_update|| ', precio_1='||fila.precio_calculado1||', gral_mon_id_pre1='||fila.moneda_id;
											end if;
										end if;
										
										if fila2.calculo_precio_2=1 then 
											if fila2.operacion_precio_2=1 then 
												fila.precio_calculado2 := (CASE WHEN fila2.default_precio_2=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_2/100)::double precision ) END);
												sql_update := sql_update|| ', precio_2='||fila.precio_calculado2||', gral_mon_id_pre2='||fila.moneda_id;
											end if;
										end if;
										
										if fila2.calculo_precio_3=1 then 
											if fila2.operacion_precio_3=1 then 
												fila.precio_calculado3 := (CASE WHEN fila2.default_precio_3=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_3/100)::double precision ) END);
												sql_update := sql_update|| ', precio_3='||fila.precio_calculado3||', gral_mon_id_pre3='||fila.moneda_id;
											end if;
										end if;
										
										if fila2.calculo_precio_4=1 then 
											if fila2.operacion_precio_4=1 then 
												fila.precio_calculado4 := (CASE WHEN fila2.default_precio_4=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_4/100)::double precision ) END);
												sql_update := sql_update|| ', precio_4='||fila.precio_calculado4||', gral_mon_id_pre4='||fila.moneda_id;
											end if;
										end if;
										
										if fila2.calculo_precio_5=1 then 
											if fila2.operacion_precio_5=1 then 
												fila.precio_calculado5 := (CASE WHEN fila2.default_precio_5=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_5/100)::double precision ) END);
												sql_update := sql_update|| ', precio_5='||fila.precio_calculado5||', gral_mon_id_pre5='||fila.moneda_id;
											end if;
										end if;
										
										if fila2.calculo_precio_6=1 then 
											if fila2.operacion_precio_6=1 then 
												fila.precio_calculado6 := (CASE WHEN fila2.default_precio_6=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_6/100)::double precision ) END);
												sql_update := sql_update|| ', precio_6='||fila.precio_calculado6||', gral_mon_id_pre6='||fila.moneda_id;
											end if;
										end if;
										
										if fila2.calculo_precio_7=1 then 
											if fila2.operacion_precio_7=1 then 
												fila.precio_calculado7 := (CASE WHEN fila2.default_precio_7=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_7/100)::double precision ) END);
												sql_update := sql_update|| ', precio_7='||fila.precio_calculado7||', gral_mon_id_pre7='||fila.moneda_id;
											end if;
										end if;
										
										if fila2.calculo_precio_8=1 then 
											if fila2.operacion_precio_8=1 then 
												fila.precio_calculado8 := (CASE WHEN fila2.default_precio_8=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_8/100)::double precision ) END);
												sql_update := sql_update|| ', precio_8='||fila.precio_calculado8||', gral_mon_id_pre8='||fila.moneda_id;
											end if;
										end if;
										
										if fila2.calculo_precio_9=1 then 
											if fila2.operacion_precio_9=1 then 
												fila.precio_calculado9 := (CASE WHEN fila2.default_precio_9=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_9/100)::double precision ) END);
												sql_update := sql_update|| ', precio_9='||fila.precio_calculado9||', gral_mon_id_pre9='||fila.moneda_id;
											end if;
										end if;
										
										if fila2.calculo_precio_10=1 then 
											if fila2.operacion_precio_10=1 then 
												fila.precio_calculado10 := (CASE WHEN fila2.default_precio_10=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_10/100)::double precision ) END);
												sql_update := sql_update|| ', precio_10='||fila.precio_calculado10||', gral_mon_id_pre10='||fila.moneda_id;
											end if;
										end if;
									end if;
									
									if trim(sql_update)<>'' then 
										
										sql_update := 'UPDATE inv_pre SET momento_actualizacion='''||espacio_tiempo_ejecucion||'''::timestamp with time zone, gral_usr_id_actualizacion='||usuario_ejecutor||' '||sql_update||' ';
										sql_update := sql_update||' WHERE gral_emp_id='||emp_id||' AND inv_prod_id='||fila.prod_id||' AND inv_prod_presentacion_id='||fila.pres_id||';';
										
										--RAISE EXCEPTION '%',sql_update;
										EXECUTE sql_update;
									end if;
									
									/*
									sql_update := 'UPDATE inv_pre SET precio_1='||fila.precio_calculado1||' ,precio_2='||fila.precio_calculado2||' ,precio_3='||fila.precio_calculado3||' ,precio_4='||fila.precio_calculado4||' ,precio_5='||fila.precio_calculado5||' ,precio_6='||fila.precio_calculado6||' ,precio_7='||fila.precio_calculado7||' ,precio_8='||fila.precio_calculado8||' ,precio_9='||fila.precio_calculado9||' ,precio_10='||fila.precio_calculado10;
									sql_update := sql_update||',gral_mon_id_pre1='||fila.moneda_id||',gral_mon_id_pre2='||fila.moneda_id||',gral_mon_id_pre3='||fila.moneda_id||',gral_mon_id_pre4='||fila.moneda_id||',gral_mon_id_pre5='||fila.moneda_id||',gral_mon_id_pre6='||fila.moneda_id||',gral_mon_id_pre7='||fila.moneda_id||',gral_mon_id_pre8='||fila.moneda_id||',gral_mon_id_pre9='||fila.moneda_id||',gral_mon_id_pre10='||fila.moneda_id;
									sql_update := sql_update||' ,momento_actualizacion='''||espacio_tiempo_ejecucion||'''::timestamp with time zone, gral_usr_id_actualizacion='||usuario_ejecutor||''; 
									sql_update := sql_update||' WHERE gral_emp_id='||emp_id||' AND inv_prod_id='||fila.prod_id||' AND inv_prod_presentacion_id='||fila.pres_id||';';
									*/
								END IF;
							END LOOP;
						END IF;
					END IF;
					
					
					
					/****************************************************************************************************************************
					Aqui comienza a crear registro para EXISTENCIA EN PRESENTACIONES(inv_exi_pres)
					*****************************************************************************************************************************/
					--revisar si la configuracion incluye control de Existencias por Presentacion
					IF controlExisPres=TRUE THEN 
						--inicializar valores para las variables
						sql_select := '';
						exis:=0;
						sql_update := '';
						sql_insert := '';
						cantPres:=0;
						
						--Obtener la equivalencia de la Presentacion en la Unidad de Medida definida para conversion
						SELECT (CASE WHEN cantidad IS NULL THEN 0 ELSE cantidad END) FROM inv_prod_presentaciones WHERE id=str_filas[7]::integer
						INTO equivalenciaPres;
						
						--Convertir la Cantidad de Unidades a su equivalencia en Cantidad de Presentaciones
						cantPres := round(str_filas[2]::numeric, noDecUnidad)::double precision / equivalenciaPres::double precision;
						
						--Redondear la Cantidad de la Presentacion
						cantPres := round(cantPres::numeric,noDecUnidad)::double precision;
						
						--Query para verificar existencia del producto en el almacen y en el a√±o actual y presentacion
						sql_select := 'SELECT count(id) FROM inv_exi_pres WHERE inv_prod_id='||str_filas[4]||' AND inv_prod_presentacion_id='||str_filas[7]||' AND inv_alm_id='||str_data[15]||';';
						--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
						EXECUTE sql_select INTO exis;
						
						IF exis >0 THEN
							sql_update := 'UPDATE inv_exi_pres SET entradas=(entradas::double precision + '||cantPres||'::double precision), momento_actualizacion='''||espacio_tiempo_ejecucion||''', gral_usr_id_actualizacion='||usuario_ejecutor||' 
							WHERE inv_alm_id='||str_data[15]||'::integer AND inv_prod_id='||str_filas[4]||'::integer AND inv_prod_presentacion_id='||str_filas[7]||'::integer;';
							EXECUTE sql_update;
						ELSE
							sql_insert:='INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
							VALUES('||str_data[15]||','||str_filas[4]||','||str_filas[7]||','||cantPres||'::double precision,'''|| espacio_tiempo_ejecucion ||''','||usuario_ejecutor||' );';
							EXECUTE sql_insert;
						END IF;
					END IF;
					
					/********************************************
					Termina creacion de registro en inv_exi_pres
					*****************************************************************************************************************************/
					
				END IF;	
			END LOOP;
			
			SELECT iva_1 FROM gral_imptos WHERE id = 1 INTO valor_iva;
			
			
			
			if fila4.proveedortipo_id<>2 then 
				suma_impuesto := suma_impuesto + (str_data[14]::double precision * valor_iva);
			else
				suma_impuesto := suma_impuesto + str_data[14]::double precision;
			end if;
			
			--sumar flete al subtotal
			subtotal_entrada := subtotal_entrada + str_data[14]::double precision;
			
			--Calculo del total
			total_entrada := subtotal_entrada::double precision + suma_ieps::double precision + suma_impuesto::double precision - total_retencion;
			
			--actualiza erp_prealmacen_entradas para guardar totales
			UPDATE com_fac SET subtotal=round((subtotal_entrada)::numeric,2)::double precision, monto_ieps=round((suma_ieps)::numeric,2)::double precision, iva=round((suma_impuesto)::numeric,2)::double precision, total=round((total_entrada)::numeric,2)::double precision, tasa_iva=valor_iva 
			WHERE id=ultimo_id;
			
			--Genera registro en Cuentas por Pagar(cxp_facturas) cuando la entrada es por Factura
			IF str_data[16]::integer = 1 THEN
				sql_select:='';
				
				--obtiene id y numero de dias de credito de acuerdo al proveedor seleccionado
				SELECT cxp_prov.dias_credito_id, cxp_prov_credias.dias FROM cxp_prov JOIN cxp_prov_credias ON cxp_prov_credias.id=cxp_prov.dias_credito_id
				WHERE cxp_prov.id=str_data[5]::integer INTO id_dias_credito, numero_dias_credito;
				
				--Calcula fecha de vencimiento de acuerdo a los dias de credito, a partir de la fecha de la factura
				SELECT (to_char(str_data[7]::timestamp with time zone,'yyyy-mm-dd')::DATE + numero_dias_credito)::timestamp with time zone AS fecha_vencimiento INTO fecha_de_vencimiento;
				
				--Crea registro en tabla cxp_facturas
				INSERT INTO cxp_facturas(cxc_prov_id,serie_folio,fecha_factura,monto_total,moneda_id,tipo_cambio,saldo_factura,id_usuario_creacion,empresa_id,sucursal_id, momento_creacion, subtotal, iva, flete, retencion,numero_guia,orden_compra,observaciones,fletera_id,tipo_factura_proveedor, dias_credito_id, fecha_vencimiento, monto_ieps)
				VALUES(	str_data[5]::integer,str_data[6],str_data[7]::timestamp with time zone,round((total_entrada)::numeric,2)::double precision,str_data[10]::integer,tip_cam, round((total_entrada)::numeric,2)::double precision, usuario_ejecutor,emp_id, suc_id, espacio_tiempo_ejecucion, round((subtotal_entrada)::numeric,2)::double precision,round((suma_impuesto)::numeric,2)::double precision, str_data[14]::double precision, total_retencion,str_data[8],str_data[9],str_data[12],str_data[13]::integer, 1, id_dias_credito, fecha_de_vencimiento, round((suma_ieps)::numeric,2)::double precision)
				RETURNING id INTO ultimo_id_cxp_facturas;
				
				--Busca productos  y cantidades de la entrada para generar registros en cxp_facturas_detalles
				sql_select:='
				SELECT com_fac_detalle.cantidad,
					com_fac_detalle.costo_unitario,
					inv_prod.sku AS codigo,
					inv_prod.descripcion,
					inv_prod_unidades.titulo AS unidad_medida,
					inv_prod_presentaciones.titulo AS presentacion,
					com_fac_detalle.tipo_de_impuesto_sobre_partida AS tipo_impuesto,
					com_fac_detalle.valor_imp,
					com_fac_detalle.gral_ieps_id,
					com_fac_detalle.valor_ieps 
				FROM com_fac_detalle 
				LEFT JOIN inv_prod ON inv_prod.id=com_fac_detalle.producto_id
				LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=com_fac_detalle.presentacion_id
				WHERE com_fac_detalle.com_fac_id='||ultimo_id;
				
				FOR factura_detalle IN EXECUTE(sql_select) LOOP
					--genera registros en cxp-facturas_detalle
					INSERT INTO cxp_facturas_detalle (cxp_facturas_id,codigo_producto,descripcion,unidad_medida,presentacion,cantidad,costo_unitario,gral_imp_id,valor_imp, gral_ieps_id, valor_ieps)
					VALUES (ultimo_id_cxp_facturas,factura_detalle.codigo,factura_detalle.descripcion,factura_detalle.unidad_medida,factura_detalle.presentacion,factura_detalle.cantidad,factura_detalle.costo_unitario,factura_detalle.tipo_impuesto,factura_detalle.valor_imp, factura_detalle.gral_ieps_id, factura_detalle.valor_ieps);
				END LOOP;
				
			END IF;
			
			
			
			
			/****************************************************************************************************************************
			AQUI COMIENZA A GENERAR EL REGISTRO PARA LA ORDEN DE ENTRADA
			*****************************************************************************************************************************/
			
			--extraer datos de la tabla com_fac para insertarlos a la tabla inv_oent
			SELECT * FROM com_fac WHERE id=ultimo_id INTO doc_com;
			
			
			id_tipo_consecutivo:=17;--Folio Orden de Entrada
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO inv_oent
			(
				folio,--nuevo_folio,
				estatus,--0,
				com_proceso_id,--doc_com.com_proceso_id,
				inv_mov_tipo_id,--tipo_movimiento_id,
				tipo_documento,--doc_com.tipo_documento,
				folio_documento,--doc_com.factura,
				fecha_exp,--doc_com.factura_fecha_expedicion,
				gral_app_id,--app_selected,
				cxp_prov_id,--doc_com.proveedor_id,
				cxc_clie_id,--0,
				inv_alm_id,--doc_com.inv_alm_id,
				monto_flete,--doc_com.flete,
				subtotal,--doc_com.subtotal,
				monto_iva,--doc_com.iva,
				monto_retencion,--doc_com.retencion,
				monto_total,--doc_com.total,
				tasa_iva,--doc_com.tasa_iva,
				tasa_retencion,--doc_com.tasa_ret,
				numero_guia,--doc_com.numero_guia,
				orden_de_compra,--doc_com.orden_de_compra
				moneda_id,--doc_com.moneda_id,
				tipo_de_cambio,--doc_com.tipo_de_cambio,
				observaciones,--doc_com.observaciones,
				tipo_mov_oc_id,--0,
				referencia_oc,--'',
				momento_creacion,--espacio_tiempo_ejecucion
				gral_usr_id_creacion,--usuario_ejecutor
				gral_emp_id,--emp_id
				gral_suc_id, --suc_id,
				monto_ieps--doc_com.monto_ieps
			)
			VALUES(
				nuevo_folio,
				0,
				doc_com.com_proceso_id,
				tipo_movimiento_id,
				doc_com.tipo_documento,
				doc_com.factura,
				doc_com.factura_fecha_expedicion,
				app_selected,
				doc_com.proveedor_id,
				0,
				doc_com.inv_alm_id,
				doc_com.flete,
				doc_com.subtotal,
				doc_com.iva,
				doc_com.retencion,
				doc_com.total,
				doc_com.tasa_iva,
				doc_com.tasa_ret,
				doc_com.numero_guia,
				doc_com.orden_de_compra,
				doc_com.moneda_id,
				doc_com.tipo_de_cambio,
				doc_com.observaciones,
				0,
				'',
				espacio_tiempo_ejecucion,
				usuario_ejecutor,
				emp_id,
				suc_id,
				doc_com.monto_ieps
			) RETURNING id INTO ultimo_id_inv_oent;
			
			
			
			--Extraer datos de la tabla com_fac_detalle
			sql_select:='SELECT 
				com_fac_detalle.cantidad,
				com_fac_detalle.costo_unitario,
				com_fac_detalle.producto_id,
				com_fac_detalle.presentacion_id,
				com_fac_detalle.tipo_de_impuesto_sobre_partida,
				com_fac_detalle.valor_imp,
				com_fac_detalle.gral_ieps_id,
				com_fac_detalle.valor_ieps 
			FROM com_fac_detalle
			JOIN inv_prod ON inv_prod.id=com_fac_detalle.producto_id
			WHERE com_fac_detalle.com_fac_id='||ultimo_id||'
			AND inv_prod.tipo_de_producto_id in (1,2,5,6,7,8);';
			
			FOR detalle IN EXECUTE (sql_select) LOOP
				--crea registros para tabla fac_rems_detalles
				INSERT INTO inv_oent_detalle
				(
					inv_oent_id,--ultimo_id_inv_oent,
					cantidad,--detalle.cantidad,
					costo_unitario,--detalle.costo_unitario,
					inv_prod_id,--detalle.producto_id,
					inv_prod_presentacion_id,--detalle.presentacion_id,
					gral_imp_id,--detalle.tipo_de_impuesto_sobre_partida,
					valor_imp,--detalle.valor_imp
					gral_ieps_id,--detalle.gral_ieps_id,
					valor_ieps--detalle.valor_ieps
				)VALUES(
					ultimo_id_inv_oent,
					detalle.cantidad,
					detalle.costo_unitario,
					detalle.producto_id,
					detalle.presentacion_id,
					detalle.tipo_de_impuesto_sobre_partida,
					detalle.valor_imp,
					detalle.gral_ieps_id,
					detalle.valor_ieps
				);
				
			END LOOP;
			
			valor_retorno := '1';
		END IF;
		
		
		
		IF command_selected = 'cancelacion' THEN
			--usuario_ejecutor
			--str_data[4]	id_entrada
			--str_data[5]	motivo_cancelacion;
			--RAISE EXCEPTION '%' ,'Si existe: '||exis;
			
			--obtenemos el id del proceso
			SELECT com_proceso_id FROM com_fac WHERE id=str_data[4]::integer INTO id_proceso;
			
			
			SELECT sum(inicial - (inicial + entradas - salidas)) AS diferencia 
			FROM inv_oent
			JOIN inv_oent_detalle ON inv_oent_detalle.inv_oent_id=inv_oent.id
			JOIN inv_lote ON inv_lote.inv_oent_detalle_id=inv_oent_detalle.id
			WHERE inv_oent.com_proceso_id=id_proceso INTO diferencia_lote;
			
			--Si la diferencia es mayor que cero, entonces no se puede cancelar porque ya se vendio mercancia de alguno de los lotes
			IF diferencia_lote > 0 THEN 
				--no se puede  cancelar
				valor_retorno := 'false';
			ELSE
				--cancela la entrada en la tabla erp_prealmacen_entradas
				UPDATE com_fac SET cancelacion=TRUE, motivo_cancelacion=str_data[5], momento_cancelacion=espacio_tiempo_ejecucion
				WHERE id=str_data[4]::integer
				RETURNING proveedor_id, factura INTO proveedor_entrada_id,folio_factura_entrada;
				--RAISE EXCEPTION '%' ,'str_data[4]: '||str_data[4];
				
				--cancela la factura en cuentas por pagar si es que existe
				UPDATE cxp_facturas SET cancelacion=TRUE, momento_cancelacion=espacio_tiempo_ejecucion, id_usuario_cancelacion=usuario_ejecutor
				WHERE cxc_prov_id=proveedor_entrada_id AND serie_folio=folio_factura_entrada AND empresa_id=emp_id;
				
				--genera registro del movimiento
				tipo_movimiento_id:=9;--SALIDA POR CANCELACION DE ENTRADA
				INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id, gral_app_id, inv_mov_tipo_id) 
				VALUES(str_data[5],espacio_tiempo_ejecucion,usuario_ejecutor,app_selected, tipo_movimiento_id) 
				RETURNING id INTO identificador_nuevo_movimiento;
				
				--busca productos  y cantidades de la entrada para generar movimientos y descontar de existencias
				sql_select:='SELECT com_fac.inv_alm_id,
						com_fac_detalle.producto_id,
						com_fac_detalle.cantidad,
						com_fac_detalle.presentacion_id,
						(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres 
					FROM com_fac 
					JOIN com_fac_detalle ON com_fac_detalle.com_fac_id=com_fac.id
					LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=com_fac_detalle.presentacion_id 
					WHERE  com_fac.id='||str_data[4]::integer;
				
				FOR entrada IN EXECUTE(sql_select) LOOP
					costo_promedio_actual:=0;
					
					--Buscar el numero de decimales de la unidad del producto
					SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=entrada.producto_id::integer 
					INTO noDecUnidad;
					
					IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
					
					--Redondear la Cantidad de la entrada
					entrada.cantidad := round(entrada.cantidad::numeric,noDecUnidad)::double precision;
					
					--Obtener el costo promedio actual del mes actual del producto elemento
					SELECT * FROM inv_obtiene_costo_promedio_actual(entrada.producto_id, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
					
					--genera registro en detalles del movimiento
					INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id, costo, inv_prod_presentacion_id)
					VALUES(entrada.producto_id, entrada.inv_alm_id,0, entrada.cantidad, identificador_nuevo_movimiento, costo_promedio_actual, entrada.presentacion_id);
					
					--query para descontar producto de existencias
					sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||entrada.cantidad||'::double precision),momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
					WHERE inv_alm_id='||entrada.inv_alm_id||'::integer AND inv_prod_id='||entrada.producto_id||'::integer AND ano='||ano_actual;
					EXECUTE sql_update;
					
					
					----------------------------------------------------------------------------------------
					--***** INICIA DESCONTAR EXISTENCIA DE PRESENTACIONES ******************************
					--revisar si la configuracion incluye control de Existencias por Presentacion
					IF controlExisPres=TRUE THEN 
						cantPres:=0;
						
						--Convertir la Cantidad de Unidades a su equivalencia en Cantidad de Presentaciones
						cantPres := entrada.cantidad::double precision / entrada.equiv_pres::double precision;
						
						--redondear la Cantidad de la Presentacion
						cantPres := round(cantPres::numeric,noDecUnidad)::double precision;
						
						--Descontar existencia de las presentaciones
						UPDATE inv_exi_pres SET salidas=(salidas::double precision + cantPres::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
						WHERE inv_alm_id=entrada.inv_alm_id AND inv_prod_id=entrada.producto_id AND inv_prod_presentacion_id=entrada.presentacion_id;
					END IF;
					--termina descontar existencia de presentaciones
					---------------------------------------------------------------------------------------------------------------------
					
				END LOOP;
				
				
				--cancelacion de la orden de entrada
				UPDATE inv_oent SET cancelacion=TRUE, momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_baja=usuario_ejecutor 
				WHERE com_proceso_id=id_proceso
				RETURNING id INTO id_orden_entrada;
				
				IF id_orden_entrada IS NOT NULL THEN 
					sql_select:='SELECT id FROM inv_oent_detalle WHERE inv_oent_id='||id_orden_entrada;
					FOR detalle IN EXECUTE( sql_select ) LOOP
						--elimina registros de lotes de la entrada
						DELETE FROM inv_lote WHERE inv_oent_detalle_id=detalle.id;
					END LOOP;
				END IF;
				
				valor_retorno := 'true';
			END IF;
			
		END IF;
		
	END IF;--Termina Entrada de Mercancias




























	
	
	
	-- orden presubensamble
	IF app_selected = 55 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	id
		--str_data[5]	folio
		--str_data[6]	observaciones
		--str_data[7]	select_almacen
		
		IF command_selected = 'new' THEN
			
			id_tipo_consecutivo:=31;--Folio produccion de Sub-Ensamble
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			folio_subensamble := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO inv_proceso(proceso_flujo_id, empresa_id) values(1, emp_id) RETURNING id INTO ultimo_id_proceso;
			
			INSERT INTO inv_ord_subensamble(folio, comentarios, proceso_id, gral_emp_id, gral_suc_id, momento_creacion, gral_usr_id_creacion, estatus, inv_alm_id) 
			VALUES(folio_subensamble, str_data[6], ultimo_id_proceso, emp_id, suc_id, espacio_tiempo_ejecucion, usuario_ejecutor,0, str_data[7]::integer) 
			RETURNING id INTO ultimo_id;

			--Obtener el tipo de cambio actual para dolar y euro
			SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=2 ORDER BY momento_creacion DESC LIMIT 1 into tc_usd;
			SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=3 ORDER BY momento_creacion DESC LIMIT 1 into tc_eur;

			if tc_usd is null then tc_usd:=0; end if;
			if tc_eur is null then tc_eur:=0; end if;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1] no_partida
				--str_filas[2] cantidad
				--str_filas[3] id_prod_grid
				--str_filas[4] eliminado
				--str_filas[5] select_pres
				--str_filas[6] densidad
				
				IF str_filas[4]::integer = 1 THEN
					--Obtener el id de la unidad de medida KILO porque las cantidades son en kilos
					select inv_prod_unidades.id as unidad_id from inv_prod_unidades where inv_prod_unidades.titulo ilike '%KILO%' limit 1 into fila2;
					if fila2.unidad_id is null then fila2.unidad_id:=0; end if;
					
					--Obtener la densidad del producto formulado
					select densidad from inv_prod where id=str_filas[3]::integer limit 1 into fila3;
					if fila3.densidad is null then fila3.densidad:=0; end if;

					--Verificar si el parametro densidad trae valor, se trae valor, se toma ese valor para guardar
					if trim(str_filas[6])<>'' then 
						if str_filas[6]::double precision>0 then 
							fila3.densidad:=str_filas[6]::double precision;

							update inv_prod set densidad=str_filas[6]::double precision where id=str_filas[3]::integer;
						end if;
					end if;
					
					INSERT INTO inv_ord_subensamble_detalle(cantidad,inv_prod_id_subensamble,inv_ord_subensamble_id, inv_prod_presentacion_id, inv_prod_unidad_id, densidad) 
					VALUES(str_filas[2]::double precision,str_filas[3]::integer, ultimo_id, str_filas[5]::integer, fila2.unidad_id, fila3.densidad)
					returning id into ultimo_id2;
					
					--Buscar componentes de la formula
					sql_select:='
					SELECT inv_kit.producto_elemento_id, 
						inv_kit.cantidad, 
						inv_prod.inv_prod_presentacion_id as pres_def_id, 
						inv_prod.densidad,
						(CASE   WHEN EXTRACT(MONTH FROM now())::integer=1 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_1 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_1=2 THEN inv_prod_cost_prom.costo_ultimo_1 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_1=3 THEN inv_prod_cost_prom.costo_ultimo_1 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_1 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=2 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_2 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_2=2 THEN inv_prod_cost_prom.costo_ultimo_2 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_2=3 THEN inv_prod_cost_prom.costo_ultimo_2 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_2 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=3 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_3 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_3=2 THEN inv_prod_cost_prom.costo_ultimo_3 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_3=3 THEN inv_prod_cost_prom.costo_ultimo_3 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_3 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=4 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_4 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_4=2 THEN inv_prod_cost_prom.costo_ultimo_4 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_4=3 THEN inv_prod_cost_prom.costo_ultimo_4 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_4 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=5 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_5 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_5=2 THEN inv_prod_cost_prom.costo_ultimo_5 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_5=3 THEN inv_prod_cost_prom.costo_ultimo_5 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_5 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=6 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_6 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_6=2 THEN inv_prod_cost_prom.costo_ultimo_6 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_6=3 THEN inv_prod_cost_prom.costo_ultimo_6 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_6 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=7 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_7 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_7=2 THEN inv_prod_cost_prom.costo_ultimo_7 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_7=3 THEN inv_prod_cost_prom.costo_ultimo_7 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_7 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=8 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_8 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_8=2 THEN inv_prod_cost_prom.costo_ultimo_8 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_8=3 THEN inv_prod_cost_prom.costo_ultimo_8 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_8 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=9 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_9 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_9=2 THEN inv_prod_cost_prom.costo_ultimo_9 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_9=3 THEN inv_prod_cost_prom.costo_ultimo_9 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_9 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=10 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_10 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_10=2 THEN inv_prod_cost_prom.costo_ultimo_10 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_10=3 THEN inv_prod_cost_prom.costo_ultimo_10 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_10 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=11 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_11 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_11=2 THEN inv_prod_cost_prom.costo_ultimo_11 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_11=3 THEN inv_prod_cost_prom.costo_ultimo_11 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_11 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=12 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_12 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_12=2 THEN inv_prod_cost_prom.costo_ultimo_12 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_12=3 THEN inv_prod_cost_prom.costo_ultimo_12 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_12 end) END) 
						ELSE 0 END) as costo_unitario_mn, 
						(case when inv_prod_unidades.titulo is null then '''' else inv_prod_unidades.titulo end) as unidad 
					from inv_kit 
					join inv_prod on inv_prod.id=inv_kit.producto_elemento_id 
					join inv_prod_unidades on inv_prod_unidades.id=inv_prod.unidad_id  
					left join inv_prod_cost_prom on (inv_prod_cost_prom.inv_prod_id=inv_kit.producto_elemento_id and inv_prod_cost_prom.ano=EXTRACT(YEAR FROM now())::integer)
					where inv_kit.producto_kit_id='||str_filas[3]::integer;
					
					FOR detalle IN EXECUTE(sql_select ) LOOP
					
						EXECUTE 'select '''||detalle.unidad||''' ~* ''KILO*'';' INTO match_cadena;
						
						IF match_cadena=false THEN
							--Convertir costo unitario a kilo
							detalle.costo_unitario_mn:=detalle.costo_unitario_mn * detalle.densidad::double precision;
						END IF;
						
						--Guardar historico de la formula utilizada
						insert into inv_ord_subensamble_detalle_formula(inv_ord_subensamble_id, inv_ord_subensamble_detalle_id,inv_prod_id,inv_prod_presentacion_id,densidad,cantidad_kg, costo_unitario_kg)
						values(ultimo_id, ultimo_id2,detalle.producto_elemento_id,detalle.pres_def_id,detalle.densidad,detalle.cantidad, detalle.costo_unitario_mn);
					END LOOP;
				END IF;
			END LOOP;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE inv_ord_subensamble SET comentarios=str_data[6],momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualizacion=usuario_ejecutor
			WHERE id=str_data[4]::integer;


			--Obtener el tipo de cambio actual para dolar y euro
			SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=2 ORDER BY momento_creacion DESC LIMIT 1 into tc_usd;
			SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=3 ORDER BY momento_creacion DESC LIMIT 1 into tc_eur;

			if tc_usd is null then tc_usd:=0; end if;
			if tc_eur is null then tc_eur:=0; end if;
			
			delete from inv_ord_subensamble_detalle where inv_ord_subensamble_id=str_data[4]::integer;
			delete from inv_ord_subensamble_detalle_formula where inv_ord_subensamble_id=str_data[4]::integer;
			
			--RAISE EXCEPTION '%' ,'No existe: '||str_data[4]::integer;
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				
				IF str_filas[4]::integer = 1 THEN
					--Obtener el id de la unidad de medida KILO porque las cantidades son en kilos
					select inv_prod_unidades.id as unidad_id from inv_prod_unidades where inv_prod_unidades.titulo ilike '%KILO%' limit 1 into fila2;
					if fila2.unidad_id is null then fila2.unidad_id:=0; end if;
					
					--Obtener la densidad del producto formulado
					select densidad from inv_prod where id=str_filas[3]::integer limit 1 into fila3;
					if fila3.densidad is null then fila3.densidad:=0; end if;

					--Verificar si el parametro densidad trae valor, se trae valor, se toma ese valor para guardar
					if trim(str_filas[6])<>'' then 
						if str_filas[6]::double precision>0 then 
							fila3.densidad:=str_filas[6]::double precision;

							update inv_prod set densidad=str_filas[6]::double precision where id=str_filas[3]::integer;
						end if;
					end if;
					
					INSERT INTO inv_ord_subensamble_detalle(cantidad,inv_prod_id_subensamble,inv_ord_subensamble_id, inv_prod_presentacion_id, inv_prod_unidad_id, densidad) 
					VALUES(str_filas[2]::double precision,str_filas[3]::integer, str_data[4]::integer, str_filas[5]::integer, fila2.unidad_id, fila3.densidad)
					returning id into ultimo_id2;
					
					--Buscar componentes de la formula
					sql_select:='
					SELECT inv_kit.producto_elemento_id, 
						inv_kit.cantidad, 
						inv_prod.inv_prod_presentacion_id as pres_def_id, 
						inv_prod.densidad,
						(CASE   WHEN EXTRACT(MONTH FROM now())::integer=1 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_1 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_1=2 THEN inv_prod_cost_prom.costo_ultimo_1 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_1=3 THEN inv_prod_cost_prom.costo_ultimo_1 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_1 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=2 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_2 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_2=2 THEN inv_prod_cost_prom.costo_ultimo_2 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_2=3 THEN inv_prod_cost_prom.costo_ultimo_2 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_2 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=3 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_3 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_3=2 THEN inv_prod_cost_prom.costo_ultimo_3 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_3=3 THEN inv_prod_cost_prom.costo_ultimo_3 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_3 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=4 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_4 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_4=2 THEN inv_prod_cost_prom.costo_ultimo_4 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_4=3 THEN inv_prod_cost_prom.costo_ultimo_4 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_4 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=5 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_5 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_5=2 THEN inv_prod_cost_prom.costo_ultimo_5 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_5=3 THEN inv_prod_cost_prom.costo_ultimo_5 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_5 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=6 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_6 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_6=2 THEN inv_prod_cost_prom.costo_ultimo_6 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_6=3 THEN inv_prod_cost_prom.costo_ultimo_6 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_6 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=7 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_7 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_7=2 THEN inv_prod_cost_prom.costo_ultimo_7 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_7=3 THEN inv_prod_cost_prom.costo_ultimo_7 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_7 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=8 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_8 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_8=2 THEN inv_prod_cost_prom.costo_ultimo_8 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_8=3 THEN inv_prod_cost_prom.costo_ultimo_8 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_8 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=9 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_9 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_9=2 THEN inv_prod_cost_prom.costo_ultimo_9 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_9=3 THEN inv_prod_cost_prom.costo_ultimo_9 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_9 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=10 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_10 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_10=2 THEN inv_prod_cost_prom.costo_ultimo_10 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_10=3 THEN inv_prod_cost_prom.costo_ultimo_10 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_10 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=11 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_11 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_11=2 THEN inv_prod_cost_prom.costo_ultimo_11 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_11=3 THEN inv_prod_cost_prom.costo_ultimo_11 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_11 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=12 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_12 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_12=2 THEN inv_prod_cost_prom.costo_ultimo_12 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_12=3 THEN inv_prod_cost_prom.costo_ultimo_12 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_12 end) END) 
						ELSE 0 END) as costo_unitario_mn, 
						(case when inv_prod_unidades.titulo is null then '''' else inv_prod_unidades.titulo end) as unidad 
					from inv_kit 
					join inv_prod on inv_prod.id=inv_kit.producto_elemento_id 
					join inv_prod_unidades on inv_prod_unidades.id=inv_prod.unidad_id  
					left join inv_prod_cost_prom on (inv_prod_cost_prom.inv_prod_id=inv_kit.producto_elemento_id and inv_prod_cost_prom.ano=EXTRACT(YEAR FROM now())::integer)
					where inv_kit.producto_kit_id='||str_filas[3]::integer;
					
					FOR detalle IN EXECUTE(sql_select ) LOOP
					
						EXECUTE 'select '''||detalle.unidad||''' ~* ''KILO*'';' INTO match_cadena;
						
						IF match_cadena=false THEN
							--Convertir costo unitario a kilo
							detalle.costo_unitario_mn:=detalle.costo_unitario_mn * detalle.densidad::double precision;
						END IF;
								
						--Guardar historico de la formula utilizada
						insert into inv_ord_subensamble_detalle_formula(inv_ord_subensamble_id, inv_ord_subensamble_detalle_id,inv_prod_id,inv_prod_presentacion_id,densidad,cantidad_kg, costo_unitario_kg)
						values(str_data[4]::integer, ultimo_id2,detalle.producto_elemento_id,detalle.pres_def_id,detalle.densidad,detalle.cantidad, detalle.costo_unitario_mn);
					END LOOP;
				END IF;
			END LOOP;
			
			valor_retorno := '1';
		END IF;
		
		
		IF command_selected = 'confirm' THEN
			UPDATE inv_ord_subensamble SET comentarios=str_data[6],momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualizacion=usuario_ejecutor
			WHERE id=str_data[4]::integer
			RETURNING proceso_id INTO ultimo_id_proceso;
			
			--actualiza en flujo del proceso
			UPDATE inv_proceso SET proceso_flujo_id=2 WHERE id=ultimo_id_proceso;


			--Obtener el tipo de cambio actual para dolar y euro
			SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=2 ORDER BY momento_creacion DESC LIMIT 1 into tc_usd;
			SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=3 ORDER BY momento_creacion DESC LIMIT 1 into tc_eur;

			if tc_usd is null then tc_usd:=0; end if;
			if tc_eur is null then tc_eur:=0; end if;
			
			delete from inv_ord_subensamble_detalle where inv_ord_subensamble_id=str_data[4]::integer;
			delete from inv_ord_subensamble_detalle_formula where inv_ord_subensamble_id=str_data[4]::integer;
			
			--RAISE EXCEPTION '%' ,'No existe: '||str_data[4]::integer;
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				
				IF str_filas[4]::integer = 1 THEN
					--Obtener el id de la unidad de medida KILO porque las cantidades son en kilos
					select inv_prod_unidades.id as unidad_id from inv_prod_unidades where inv_prod_unidades.titulo ilike '%KILO%' limit 1 into fila2;
					if fila2.unidad_id is null then fila2.unidad_id:=0; end if;
					
					--Obtener la densidad del producto formulado
					select densidad from inv_prod where id=str_filas[3]::integer limit 1 into fila3;
					if fila3.densidad is null then fila3.densidad:=0; end if;

					--Verificar si el parametro densidad trae valor, se trae valor, se toma ese valor para guardar
					if trim(str_filas[6])<>'' then 
						if str_filas[6]::double precision>0 then 
							fila3.densidad:=str_filas[6]::double precision;

							update inv_prod set densidad=str_filas[6]::double precision where id=str_filas[3]::integer;
						end if;
					end if;
					
					INSERT INTO inv_ord_subensamble_detalle(cantidad,inv_prod_id_subensamble,inv_ord_subensamble_id, inv_prod_presentacion_id, inv_prod_unidad_id, densidad) 
					VALUES(str_filas[2]::double precision,str_filas[3]::integer, str_data[4]::integer, str_filas[5]::integer, fila2.unidad_id, fila3.densidad)
					returning id into ultimo_id2;
					
					--Buscar componentes de la formula
					sql_select:='
					SELECT inv_kit.producto_elemento_id, 
						inv_kit.cantidad, 
						inv_prod.inv_prod_presentacion_id as pres_def_id, 
						inv_prod.densidad,
						(CASE   WHEN EXTRACT(MONTH FROM now())::integer=1 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_1 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_1=2 THEN inv_prod_cost_prom.costo_ultimo_1 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_1=3 THEN inv_prod_cost_prom.costo_ultimo_1 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_1 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=2 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_2 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_2=2 THEN inv_prod_cost_prom.costo_ultimo_2 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_2=3 THEN inv_prod_cost_prom.costo_ultimo_2 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_2 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=3 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_3 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_3=2 THEN inv_prod_cost_prom.costo_ultimo_3 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_3=3 THEN inv_prod_cost_prom.costo_ultimo_3 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_3 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=4 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_4 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_4=2 THEN inv_prod_cost_prom.costo_ultimo_4 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_4=3 THEN inv_prod_cost_prom.costo_ultimo_4 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_4 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=5 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_5 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_5=2 THEN inv_prod_cost_prom.costo_ultimo_5 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_5=3 THEN inv_prod_cost_prom.costo_ultimo_5 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_5 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=6 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_6 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_6=2 THEN inv_prod_cost_prom.costo_ultimo_6 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_6=3 THEN inv_prod_cost_prom.costo_ultimo_6 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_6 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=7 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_7 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_7=2 THEN inv_prod_cost_prom.costo_ultimo_7 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_7=3 THEN inv_prod_cost_prom.costo_ultimo_7 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_7 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=8 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_8 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_8=2 THEN inv_prod_cost_prom.costo_ultimo_8 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_8=3 THEN inv_prod_cost_prom.costo_ultimo_8 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_8 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=9 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_9 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_9=2 THEN inv_prod_cost_prom.costo_ultimo_9 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_9=3 THEN inv_prod_cost_prom.costo_ultimo_9 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_9 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=10 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_10 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_10=2 THEN inv_prod_cost_prom.costo_ultimo_10 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_10=3 THEN inv_prod_cost_prom.costo_ultimo_10 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_10 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=11 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_11 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_11=2 THEN inv_prod_cost_prom.costo_ultimo_11 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_11=3 THEN inv_prod_cost_prom.costo_ultimo_11 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_11 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=12 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_12 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_12=2 THEN inv_prod_cost_prom.costo_ultimo_12 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_12=3 THEN inv_prod_cost_prom.costo_ultimo_12 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_12 end) END) 
						ELSE 0 END) as costo_unitario_mn, 
						(case when inv_prod_unidades.titulo is null then '''' else inv_prod_unidades.titulo end) as unidad 
					from inv_kit 
					join inv_prod on inv_prod.id=inv_kit.producto_elemento_id 
					join inv_prod_unidades on inv_prod_unidades.id=inv_prod.unidad_id  
					left join inv_prod_cost_prom on (inv_prod_cost_prom.inv_prod_id=inv_kit.producto_elemento_id and inv_prod_cost_prom.ano=EXTRACT(YEAR FROM now())::integer)
					where inv_kit.producto_kit_id='||str_filas[3]::integer;
					
					FOR detalle IN EXECUTE(sql_select ) LOOP
					
						EXECUTE 'select '''||detalle.unidad||''' ~* ''KILO*'';' INTO match_cadena;
						
						IF match_cadena=false THEN
							--Convertir costo unitario a kilo
							detalle.costo_unitario_mn:=detalle.costo_unitario_mn * detalle.densidad::double precision;
						END IF;
								
						--Guardar historico de la formula utilizada
						insert into inv_ord_subensamble_detalle_formula(inv_ord_subensamble_id, inv_ord_subensamble_detalle_id,inv_prod_id,inv_prod_presentacion_id,densidad,cantidad_kg, costo_unitario_kg)
						values(str_data[4]::integer, ultimo_id2,detalle.producto_elemento_id,detalle.pres_def_id,detalle.densidad,detalle.cantidad, detalle.costo_unitario_mn);
					END LOOP;
				END IF;
			END LOOP;
			valor_retorno := '1';
		END IF;
		
		--0=Sin estatus
		--1=Enterado
		--2=En Proceso
		--3=Terminado
		--4=Cancelado
		
		IF command_selected = 'cancela_orden' THEN
			SELECT estatus FROM inv_ord_subensamble WHERE id=str_data[4]::integer INTO estado_orden;
			IF estado_orden < 2 THEN
				UPDATE inv_ord_subensamble SET estatus=4,momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualizacion=usuario_ejecutor
				WHERE id=str_data[4]::integer;
				valor_retorno:='La Orden de Producci&oacute;n se ha Cancelado.';
			END IF;
			
			IF estado_orden = 2 THEN
				valor_retorno:='La Orden de Producci&oacute;n No se puede Cancelar porque ya se encuentra en Proceso.';
			END IF;
			
			IF estado_orden = 3 THEN
				valor_retorno:='La Orden No se puede Cancelar porque la Producci&oacute;n ya est&aacute; Terminado.';
			END IF;
		END IF;
	END IF;--Termina orden presubensamble
	
	
	
	
	
	
	-- Orden subensamble
	IF app_selected = 58 THEN
		IF command_selected = 'edit' THEN
			--RAISE EXCEPTION '%' ,'No existe: '||str_data[7]::integer;
			UPDATE inv_ord_subensamble SET estatus=str_data[7]::integer,comentarios=str_data[6],momento_actualizacion=espacio_tiempo_ejecucion,gral_usr_id_actualizacion=usuario_ejecutor
			WHERE id=str_data[4]::integer
			RETURNING estatus, inv_alm_id, folio INTO estado_orden, id_almacen, nuevo_folio;
			
			--RAISE EXCEPTION '%' ,'estado_orden: '||estado_orden;
			--Si el estatus es 3=listo, se descuenta de las existencias en  inventario
			IF estado_orden = 3 THEN 
			
				--Obtener el tipo de cambio actual para dolar y euro
				SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=2 ORDER BY momento_creacion DESC LIMIT 1 into tc_usd;
				SELECT valor AS tipo_cambio FROM erp_monedavers WHERE momento_creacion<=now() AND moneda_id=3 ORDER BY momento_creacion DESC LIMIT 1 into tc_eur;

				if tc_usd is null then tc_usd:=0; end if;
				if tc_eur is null then tc_eur:=0; end if;
			
				sql_select:='';
				sql_select:='
				SELECT 
					subensam_det.id,
					subensam_det.inv_prod_id_subensamble, 
					subensam_det.cantidad,
					subensam_det.densidad,
					subensam_det.inv_prod_presentacion_id AS pres_id,
					(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv,
					(CASE WHEN inv_prod_unidades.decimales IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec,
					inv_prod_unidades.titulo AS unidad_subensamble, 
					0::double precision as costo_subensamble,
					0::double precision as costo_unitario_subensamble 
				FROM inv_ord_subensamble_detalle AS subensam_det
				JOIN inv_prod ON inv_prod.id=subensam_det.inv_prod_id_subensamble 
				LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=subensam_det.inv_prod_presentacion_id 
				WHERE subensam_det.inv_ord_subensamble_id='||str_data[4]::integer;
				
				FOR orden_detalle IN EXECUTE(sql_select) LOOP
					--Folio Orden de Salida
					id_tipo_consecutivo:=21;
					
					--Produccion de Subensamble
					tipo_de_documento := 6;
					
					nuevo_costo_promedio:=0;
					costo_promedio_actual:=0;
					cant_exi_actual:=0;
					
					--Redondear la cantidad
					orden_detalle.cantidad := round(orden_detalle.cantidad::numeric,orden_detalle.no_dec)::double precision;
					
					--AQUI SE GENERA EL MOVIMIENTO DE SALIDA DEL INVETARIO DE PRODUCTOS COMPONENTES
					-- el aplicativo de Produccion de subensamble es el numero 58
					tipo_movimiento_id:=11;--Salida por produccion
					INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id, gral_app_id,inv_mov_tipo_id, fecha_mov, referencia) 
					VALUES(str_data[6],espacio_tiempo_ejecucion,usuario_ejecutor,app_selected, tipo_movimiento_id, espacio_tiempo_ejecucion, nuevo_folio) 
					RETURNING id INTO identificador_nuevo_movimiento;
					

					
					/*
					--INICIA HEADER DE LA ORDEN DE SALIDA(inv_osal)-------------------------------
					--aqui entra para tomar el consecutivo del folio  la sucursal actual
					UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
					WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
					--suc_id_consecutivo
					
					--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
					nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
					
					--genera registro en tabla inv_osal(Orden de Salida)
					INSERT INTO inv_osal(
						folio, --nuevo_folio,
						estatus, --0
						erp_proceso_id, --0,
						inv_mov_tipo_id, --tipo_movimiento_id,
						tipo_documento, --tipo_de_documento,
						folio_documento, 
						fecha_exp, 
						gral_app_id, 
						cxc_clie_id, 
						inv_alm_id, 
						subtotal, 
						monto_iva, 
						monto_retencion, 
						monto_total, 
						folio_pedido, 
						orden_compra, 
						moneda_id, 
						tipo_cambio, 
						momento_creacion, 
						gral_usr_id_creacion, 
						gral_emp_id, 
						gral_suc_id 
					)
					VALUES(nuevo_folio,0,prefactura_fila.proceso_id,tipo_movimiento_id,tipo_de_documento,serie_folio_fac,espacio_tiempo_ejecucion,app_selected,prefactura_fila.cliente_id,id_almacen, prefactura_fila.fac_subtotal, prefactura_fila.fac_impuesto, prefactura_fila.fac_monto_retencion, prefactura_fila.fac_total, prefactura_fila.folio_pedido,prefactura_fila.orden_compra,prefactura_fila.moneda_id,tipo_cam,espacio_tiempo_ejecucion,usuario_ejecutor, emp_id, suc_id)
					RETURNING id INTO id_osal;


					--TERMINA HEADER DE LA ORDEN DE SALIDA(inv_osal)-------------------------------
					*/



					
					
					--::::::::::Aqui Inicia calculo costo promedio:::::::::::::::::::::::::::::::::::::::::::::::::::
					--Sacamos la existencia actual del producto subensamble
					--El tipo de busqueda es 1=Busqueda en el almacen que se le esta pasando como parametro
					--El valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
					SELECT inv_calculo_existencia_producto AS cant_exi FROM inv_calculo_existencia_producto(1, false, orden_detalle.inv_prod_id_subensamble, usuario_ejecutor, id_almacen) INTO cant_exi_actual;
					
					IF cant_exi_actual IS NULL THEN cant_exi_actual:=0; END IF;
					
					--Redondear la Cantidad de la existencia actual
					cant_exi_actual := round(cant_exi_actual::numeric,orden_detalle.no_dec)::double precision;
					
					--Obtener el costo promedio actual del mes actual del producto
					SELECT * FROM inv_obtiene_costo_promedio_actual(orden_detalle.inv_prod_id_subensamble, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
					
					--Calcular el costo promedio de la existencia actual del producto subensamble
					suma_costo_actual := cant_exi_actual * costo_promedio_actual::double precision;
					--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::.
					
					--Redondear la Cantidad de la de la Produccion
					orden_detalle.cantidad := round(orden_detalle.cantidad::numeric,orden_detalle.no_dec)::double precision;
					
					cantidad_produccion_ := orden_detalle.cantidad;
					
					--Este query es para obtener los productos componentes del producto formulado.
					sql_select:='';
					/*
					sql_select:='
					SELECT DISTINCT inv_prod.sku,
						inv_kit.producto_kit_id,
						inv_kit.producto_elemento_id, 
						inv_kit.cantidad,
						(inv_kit.cantidad*'||cantidad_produccion_||') AS cantidad_total_producto_elemento,
						inv_prod.inv_prod_presentacion_id AS id_pres_def, 
						(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv_pres_def,
						(CASE WHEN inv_prod_unidades.decimales IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec_comp
					FROM inv_prod 
					JOIN inv_kit ON inv_kit.producto_elemento_id=inv_prod.id
					LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					LEFT JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod.inv_prod_presentacion_id 
					WHERE inv_kit.producto_kit_id='||orden_detalle.inv_prod_id_subensamble;
					*/
					
					sql_select:='
					select 
						sbt.id_det_formula,
						sbt.producto_elemento_id, 
						sbt.sku,  
						sbt.utitulo,
						sbt.no_dec_comp,
						sbt.cant_equiv_pres_def,
						sbt.id_pres_def, 
						sbt.densidad_mp,
						sbt.cant_mp_kg, 
						(case when sbt.utitulo ilike ''KILO%'' THEN sbt.cant_total_elemento_kg ELSE sbt.cant_total_elemento_kg / sbt.densidad_mp::double precision END) AS cantidad_total_producto_elemento,
						(CASE   WHEN EXTRACT(MONTH FROM now())::integer=1 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_1 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_1=2 THEN inv_prod_cost_prom.costo_ultimo_1 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_1=3 THEN inv_prod_cost_prom.costo_ultimo_1 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_1 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=2 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_2 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_2=2 THEN inv_prod_cost_prom.costo_ultimo_2 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_2=3 THEN inv_prod_cost_prom.costo_ultimo_2 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_2 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=3 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_3 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_3=2 THEN inv_prod_cost_prom.costo_ultimo_3 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_3=3 THEN inv_prod_cost_prom.costo_ultimo_3 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_3 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=4 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_4 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_4=2 THEN inv_prod_cost_prom.costo_ultimo_4 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_4=3 THEN inv_prod_cost_prom.costo_ultimo_4 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_4 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=5 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_5 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_5=2 THEN inv_prod_cost_prom.costo_ultimo_5 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_5=3 THEN inv_prod_cost_prom.costo_ultimo_5 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_5 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=6 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_6 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_6=2 THEN inv_prod_cost_prom.costo_ultimo_6 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_6=3 THEN inv_prod_cost_prom.costo_ultimo_6 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_6 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=7 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_7 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_7=2 THEN inv_prod_cost_prom.costo_ultimo_7 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_7=3 THEN inv_prod_cost_prom.costo_ultimo_7 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_7 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=8 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_8 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_8=2 THEN inv_prod_cost_prom.costo_ultimo_8 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_8=3 THEN inv_prod_cost_prom.costo_ultimo_8 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_8 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=9 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_9 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_9=2 THEN inv_prod_cost_prom.costo_ultimo_9 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_9=3 THEN inv_prod_cost_prom.costo_ultimo_9 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_9 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=10 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_10 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_10=2 THEN inv_prod_cost_prom.costo_ultimo_10 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_10=3 THEN inv_prod_cost_prom.costo_ultimo_10 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_10 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=11 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_11 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_11=2 THEN inv_prod_cost_prom.costo_ultimo_11 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_11=3 THEN inv_prod_cost_prom.costo_ultimo_11 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_11 end) END)
							WHEN EXTRACT(MONTH FROM now())::integer=12 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_12 IS NULL THEN 0 ELSE (case when inv_prod_cost_prom.gral_mon_id_12=2 THEN inv_prod_cost_prom.costo_ultimo_12 * '||tc_usd||'::double precision when inv_prod_cost_prom.gral_mon_id_12=3 THEN inv_prod_cost_prom.costo_ultimo_12 * '||tc_eur||'::double precision else inv_prod_cost_prom.costo_ultimo_12 end) END) 
						ELSE 0 END) as costo_unitario_mn  
					from (
						SELECT  
							iosd_formula.id as id_det_formula,
							inv_prod.id as producto_elemento_id, 
							inv_prod.sku,  
							inv_prod_unidades.titulo AS utitulo, 
							(CASE WHEN inv_prod_unidades.decimales IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec_comp,
							(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 0 ELSE inv_prod_presentaciones.cantidad END) AS cant_equiv_pres_def,
							iosd_formula.inv_prod_presentacion_id AS id_pres_def, 
							iosd_formula.densidad as densidad_mp,
							iosd_formula.cantidad_kg as cant_mp_kg,
							(iosd_formula.cantidad_kg * '||cantidad_produccion_||') AS cant_total_elemento_kg 
						FROM inv_ord_subensamble_detalle_formula as iosd_formula 
						join inv_prod on inv_prod.id=iosd_formula.inv_prod_id 
						left join inv_prod_presentaciones on inv_prod_presentaciones.id=iosd_formula.inv_prod_presentacion_id 
						join inv_prod_unidades on inv_prod_unidades.id=inv_prod.unidad_id 
						where iosd_formula.inv_ord_subensamble_detalle_id='||orden_detalle.id ||' 
					) as sbt 
					left join inv_prod_cost_prom on (inv_prod_cost_prom.inv_prod_id=sbt.producto_elemento_id and inv_prod_cost_prom.ano=EXTRACT(YEAR FROM now())::integer);';
					
					--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
					
					FOR formulacion IN EXECUTE(sql_select) LOOP
						
						EXECUTE 'select '''||formulacion.utitulo||''' ~* ''KILO*'';' INTO match_cadena;
						
						IF match_cadena=false THEN
							--Convertir costo unitario a kilo
							formulacion.costo_unitario_mn := formulacion.costo_unitario_mn * formulacion.densidad_mp::double precision;
						END IF;
						
						orden_detalle.costo_subensamble := orden_detalle.costo_subensamble + (formulacion.costo_unitario_mn * cantidad_produccion_::double precision);
						
						
						--Actualizar costo unitario de la formula para conservar el historico
						update inv_ord_subensamble_detalle_formula set costo_unitario_kg=formulacion.costo_unitario_mn where id=formulacion.id_det_formula;
						
						
						--Redondear la cantidad del producto componente
						formulacion.cantidad_total_producto_elemento := round(formulacion.cantidad_total_producto_elemento::numeric,formulacion.no_dec_comp)::double precision;
						
						--calcula la cantidad de acuerdo al porcentaje
						--cantidad_porcentaje := prefactura_detalle.cantidad * formulacion.porcentaje;
						cantidad_producto_elemento :=  formulacion.cantidad_total_producto_elemento;
						
						--::Costo promedio del Producto elemento:::::::::::::::::::
						--Obtener el costo promedio actual del mes actual del producto elemento
						SELECT * FROM inv_obtiene_costo_promedio_actual(formulacion.producto_elemento_id, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
						
						--Suma del costo de la existencia de cada componente de la formula
						suma_costo_elemento := suma_costo_elemento::double precision + (cantidad_producto_elemento::double precision * costo_promedio_actual::double precision);
						--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
						
						--Genera registro en detalles del movimiento
						INSERT INTO inv_mov_detalle(producto_id,alm_origen_id,alm_destino_id,cantidad,inv_mov_id, costo, inv_prod_presentacion_id)
						VALUES(formulacion.producto_elemento_id,id_almacen,0,cantidad_producto_elemento,identificador_nuevo_movimiento, costo_promedio_actual, formulacion.id_pres_def);
						
						--query para descontar producto de existencias
						sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||'::double precision + '||cantidad_producto_elemento||'::double precision),momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
						WHERE inv_alm_id='||id_almacen||'::integer AND inv_prod_id='||formulacion.producto_elemento_id||'::integer AND ano='||ano_actual;
						EXECUTE sql_update;
						

						/*
						----------------------------------------------------------------------------------------
						--***** CREAR ORDEN DE SALIDA ******************************
						--aqui entra para crear registro en INV_OSAL
						id_tipo_consecutivo:=21; --Folio Orden de Salida
						
						--aqui entra para tomar el consecutivo del folio  la sucursal actual
						UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
						WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
						
						--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
						nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
				




						
						--***** TERMINA CREAR ORDEN DE SALIDA ******************************
						----------------------------------------------------------------------------------------
						*/


						
						
						----------------------------------------------------------------------------------------
						--***** INICIA DESCONTAR EXISTENCIA DE PRESENTACIONES ******************************
						--revisar si la configuracion incluye control de Existencias por Presentacion
						IF controlExisPres=TRUE THEN 
							cantPres:=0;
							
							IF formulacion.cant_equiv_pres_def IS NULL THEN formulacion.cant_equiv_pres_def:=0; END IF;
							
							--Convertir la Cantidad de Unidades a su equivalencia en Cantidad de Presentaciones
							cantPres := round(cantidad_producto_elemento::numeric, formulacion.no_dec_comp)::double precision / formulacion.cant_equiv_pres_def::double precision;
							
							--redondear la Cantidad de la Presentacion
							cantPres := round(cantPres::numeric,formulacion.no_dec_comp)::double precision;
							
							--Descontar existencia de las presentaciones
							UPDATE inv_exi_pres SET salidas=(salidas::double precision + cantPres::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
							WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=formulacion.producto_elemento_id::integer AND inv_prod_presentacion_id=formulacion.id_pres_def::integer;
						END IF;
						--Termina descontar existencia de presentaciones
						---------------------------------------------------------------------------------------------------------------------
						
					END LOOP;
					
					EXECUTE 'select '''||orden_detalle.unidad_subensamble||''' ~* ''KILO*'';' INTO match_cadena;
					
					IF match_cadena=false THEN
						--Convertir costo del subensamble a litro
						orden_detalle.costo_subensamble := orden_detalle.costo_subensamble / orden_detalle.densidad::double precision;
					END IF;

					--Este es el costo unitario del subensamble
					orden_detalle.costo_unitario_subensamble := orden_detalle.costo_subensamble / orden_detalle.cantidad::double precision;


					
					--calcular el nuevo costo promedio
					IF suma_costo_actual <=0 THEN
						--Si el costo promedio actual es cero, solo se calcula el costo promedio de lo que esta entrando
						nuevo_costo_promedio := suma_costo_elemento / cantidad_produccion_;
					ELSE
						nuevo_costo_promedio:=(suma_costo_actual::double precision + suma_costo_elemento::double precision)/(cant_exi_actual::double precision + cantidad_produccion_::double precision);
					END IF;
					
					IF nuevo_costo_promedio IS NULL OR nuevo_costo_promedio<=0 THEN 
						nuevo_costo_promedio:=0;
					END IF;
					
					nuevo_costo_promedio := round((nuevo_costo_promedio)::numeric,2)::double precision;
					
					--llamada al procedimiento que actualiza el costo promedio					
					--SELECT * FROM inv_actualiza_repite_costo_promedio(orden_detalle.inv_prod_id_subensamble, nuevo_costo_promedio, espacio_tiempo_ejecucion) INTO costo_prom_actualizado;
					--::::::::aqui termina calculo del costo promedio::::::::::::::::::::::::

					
					
					incrementa := mes_actual + 1;
					--Crear cadena sql para actualizar guardar el costo promedio y Costo Ultimo
					sql_update:= 'UPDATE inv_prod_cost_prom SET costo_promedio_'||mes_actual||'='||nuevo_costo_promedio||', costo_ultimo_'||mes_actual||'='||orden_detalle.costo_unitario_subensamble||', gral_mon_id_'||mes_actual||'=1, tipo_cambio_'||mes_actual||'=1';
					WHILE incrementa <= 12 LOOP
						sql_update:=sql_update ||', costo_promedio_'||incrementa||'='||nuevo_costo_promedio||', costo_ultimo_'||incrementa||'='||orden_detalle.costo_unitario_subensamble||', gral_mon_id_'||incrementa||'=1, tipo_cambio_'||incrementa||'=1';
						incrementa:= incrementa + 1;
					END LOOP;
					sql_update:= sql_update||' WHERE inv_prod_id='||orden_detalle.inv_prod_id_subensamble||' AND ano='||ano_actual||';';
					
					--RAISE EXCEPTION '%' ,'sql_update: '||sql_update;
					
					--Actualizar registro
					EXECUTE sql_update;

					--RAISE EXCEPTION '%' ,'orden_detalle.costo_subensamble: '||orden_detalle.costo_subensamble;
					
					--Actualizar la orden de produccion del subensamble
					update inv_ord_subensamble_detalle set costo=orden_detalle.costo_subensamble where id=orden_detalle.id;

					
					--AQUI SE GENERA EL MOVIMIENTO DE ENTRADA PARA EL PRODUCTO SUBENSAMBLE
					identificador_nuevo_movimiento:=0;
					tipo_movimiento_id:=10;--¬∑Entrada por produccion de subensamble
					INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id, gral_app_id,inv_mov_tipo_id) 
					VALUES(str_data[6],espacio_tiempo_ejecucion,usuario_ejecutor,app_selected, tipo_movimiento_id) 
					RETURNING id INTO identificador_nuevo_movimiento;
					
					--genera registro en detalles del movimiento, movimiento de entrada para el producto subensamble
					INSERT INTO inv_mov_detalle(producto_id,alm_origen_id,alm_destino_id,cantidad,inv_mov_id, costo, inv_prod_presentacion_id)
					VALUES(orden_detalle.inv_prod_id_subensamble,id_almacen,id_almacen,orden_detalle.cantidad,identificador_nuevo_movimiento, nuevo_costo_promedio, orden_detalle.pres_id);
					
					
					--AQUI COMIENZA LA ASIGNACION DE EXISTENCIA AL PRODUCTO SUBENSAMBLE
					--reiniciamos el valor de la variable exis a cero
					exis:=0;
					
					--query para verificar existencia del producto en el almacen y en el a√±o actual
					sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||orden_detalle.inv_prod_id_subensamble||' AND inv_alm_id = '||id_almacen||' AND ano = '||ano_actual;
					--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
					EXECUTE sql_select INTO exis;
					
					IF exis >0 THEN
						sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||orden_detalle.cantidad||'::double precision),momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
						WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||orden_detalle.inv_prod_id_subensamble||' AND ano='||ano_actual;
						EXECUTE sql_update;
					ELSE
						sql_insert:='INSERT INTO inv_exi (inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial) '||
						'VALUES('||orden_detalle.inv_prod_id_subensamble||','||id_almacen||','||ano_actual||','||orden_detalle.cantidad||','''|| espacio_tiempo_ejecucion ||''',0)';
						EXECUTE sql_insert;
					END IF;
					
					
					
					/****************************************************************************************************************************
					Aqui comienza a sumar entradas en presentaciones(inv_exi_pres)
					*****************************************************************************************************************************/
					IF controlExisPres=true THEN
						--aqui entra si la configuracion indica que se debe controlar existencias por presentaciones
						
						exis:=0;
						cantPresAsignado:=0;
						
						IF orden_detalle.cant_equiv IS NULL THEN orden_detalle.cant_equiv:=0; END IF;
						
						--Convertir la cantidad en su equivalente a presentaciones
						cantPresAsignado := orden_detalle.cantidad::double precision / orden_detalle.cant_equiv::double precision;
						
						--redondear la Cantidad de Presentacion Asignado para el Ajuste
						cantPresAsignado := round(cantPresAsignado::numeric,orden_detalle.no_dec)::double precision;
						
						--buscar Registro de la Presentacion en el Almacen
						SELECT count(id) AS exis FROM inv_exi_pres WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=orden_detalle.inv_prod_id_subensamble::integer AND inv_prod_presentacion_id=orden_detalle.pres_id::integer 
						INTO exis;
						
						IF exis > 0 THEN
							--Sumar Entradas de presentaciones en inv_exi_pres
							UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantPresAsignado::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
							WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=orden_detalle.inv_prod_id_subensamble::integer AND inv_prod_presentacion_id=orden_detalle.pres_id::integer;
						ELSE
							--aqui entra para CREAR registro en inv_exi_pres
							INSERT INTO inv_exi_pres(inv_alm_id, inv_prod_id, inv_prod_presentacion_id,entradas, momento_creacion, gral_usr_id_creacion) 
							VALUES(id_almacen, orden_detalle.inv_prod_id_subensamble,orden_detalle.pres_id, cantPresAsignado,espacio_tiempo_ejecucion,usuario_ejecutor);
						END IF;
					END IF;
					/********************************************
					Termina la suma de entradas en Presentaciones
					*****************************************************************************************************************************/

					
				END LOOP;
				
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'actualiza_estatus' THEN
			--RAISE EXCEPTION '%' ,'No existe: '||str_data[7]::integer;
			UPDATE inv_ord_subensamble SET estatus=str_data[5]::integer,momento_actualizacion=now(),gral_usr_id_actualizacion=usuario_ejecutor
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
	END IF;--Termina orden subensamble
	
	
	
	
	
	
	
	
	--Aplicativo Orden de Entrada
	IF app_selected = 87 THEN
		
		IF command_selected = 'edit' THEN
			/*
			str_data[4] 	id_oent
			str_data[5] 	observaciones
			*/
			
			UPDATE inv_oent SET observaciones=str_data[5], momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer 
			RETURNING inv_mov_tipo_id, fecha_exp INTO tipo_movimiento_id, fecha_produccion;
			
			
			--obtener el estatus de la Orden de Entrada
			SELECT estatus FROM inv_oent WHERE id=str_data[4]::integer INTO estatus_orden;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	eliminado[i]
					--str_filas[2]	tipo_registro[i]
					--str_filas[3]	id_detalle[i]
					--str_filas[4]	id_almacen[i]
					--str_filas[5]	id_prod_grid[i]
					--str_filas[6]	cantidad_fac[i]
					--str_filas[7]	cantidad_rec[i]
					--str_filas[8]	lote_prov[i]
					--str_filas[9]	pedimento[i]
					--str_filas[10]	caducidad[i]
					--str_filas[11]	no_tr[i]
					--str_filas[12]	req_lote[i]
					--str_filas[13]	oent_detalle_id
					--str_filas[14]	lote_int
					
					--SELECT requiere_pedimento,requiere_numero_lote FROM  inv_prod WHERE id=str_filas[5]::integer INTO req_pedimento, req_lote;
					
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='PED' THEN
						UPDATE inv_oent_detalle SET cantidad_rec=str_filas[7]::double precision WHERE id=str_filas[3]::integer;
					ELSE
					
						--tipo_movimiento_id: 10=ENTRADA PRODUCCION
						IF tipo_movimiento_id=10 THEN
							--Verificar si se incluye el modulo de produccion
							IF incluyeModuloProduccion THEN 
								--Si la orden de entrada viene de produccion, se debe calcular la fecha de caducidad
								SELECT dias_caducidad FROM pro_procesos WHERE inv_prod_id=str_filas[5]::integer AND borrado_logico=FALSE order by id desc limit 1 
								INTO numero_dias_caducidad;

								IF numero_dias_caducidad IS NULL THEN numero_dias_caducidad:=0; END IF;
								
								str_filas[10]:= (fecha_produccion::DATE + numero_dias_caducidad)::character varying;
							END IF;
						END IF;

						
						--si la fecha de caducidad no viene vacia toma el valor
						IF trim(str_filas[10])<>'' THEN
							fcaducidad = str_filas[10];
						ELSE
							fcaducidad = '2999-12-31';
						END IF;
						
						
						--aqui entra para crear o actualizar un LOTE
						IF str_filas[3]::integer > 0 THEN 
							--actualizar registro de lote
							UPDATE inv_lote SET lote_prov=str_filas[8], inicial=str_filas[7]::double precision, pedimento=str_filas[9], caducidad=fcaducidad WHERE id=str_filas[3]::integer;
						ELSE
							
							
							--tipo_movimiento_id
							
							--SELECT ajuste, grupo FROM inv_mov_tipos WHERE id=tipo_movimiento_id INTO tipo_ajuste, grupo_movimiento;
							
							--grupo:0=Entradas
							--IF grupo_movimiento=0 AND tipo_ajuste=TRUE THEN
								--entra aqui cuando es una entrada por ajuste
								--solo se debe actualizar el lote ya existente
								--UPDATE inv_lote
								
							--ELSE
								nuevo_lote := '';
								--tipo_movimiento_id: 10=ENTRADA PRODUCCION
								IF tipo_movimiento_id=10 THEN
									select lote from pro_orden_prod where folio=(select folio_documento from inv_oent where id=str_data[4]::integer) 
									INTO nuevo_lote;
									
									IF nuevo_lote = '' OR nuevo_lote is null THEN
										id_tipo_consecutivo:=25;--Consecutivo Numero de Lote
										
										--aqui entra para tomar el consecutivo del folio  la sucursal actual
										UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
										WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
										
										--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
										--folio_entrada := prefijo_consecutivo || nuevo_consecutivo::character varying;
										
										--convertir a hexadecimal el nuevo consecutivo
										nuevo_lote=to_hex(nuevo_consecutivo);
										
										--extraer los dos digitos del a√±o
										SELECT to_char(espacio_tiempo_ejecucion,'yy') INTO ano_actual_2_digitos;
										 
										--agregar ceros a la izquierda para acompletar 6 caracteres con lpad y convertir a mayusculas con upper
										nuevo_lote := upper(lpad(nuevo_lote, 6, '0'));
										
										--agregar a√±o y mes al consecutivo del lote para acompletar 10 caractares
										nuevo_lote := ano_actual_2_digitos || mes_actual || nuevo_lote;
										
									END IF;
								ELSE
									id_tipo_consecutivo:=25;--Consecutivo Numero de Lote
									
									--aqui entra para tomar el consecutivo del folio  la sucursal actual
									UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
									WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
									
									--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
									--folio_entrada := prefijo_consecutivo || nuevo_consecutivo::character varying;
									
									--convertir a hexadecimal el nuevo consecutivo
									nuevo_lote=to_hex(nuevo_consecutivo);
									
									--agregar ceros a la izquierda para acompletar 10 caracteres con lpad y convertir a mayusculas con upper
									nuevo_lote := upper(lpad(nuevo_lote, 10, '0'));
								END IF;
								
								--crear nuevo registro de lote
								INSERT INTO inv_lote(inv_oent_detalle_id,inv_prod_id,inv_alm_id,lote_int,lote_prov,inicial, pedimento, caducidad, momento_creacion)
								VALUES(str_filas[13]::integer,str_filas[5]::integer,str_filas[4]::integer,nuevo_lote,str_filas[8],str_filas[7]::double precision, str_filas[9], fcaducidad, espacio_tiempo_ejecucion);
							--END IF;--termina generacion de Lotes nuevos
							
						END IF;
						
					END IF;
				ELSE
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='LOT' THEN
						--eliminar el registro del lote
						DELETE FROM inv_lote WHERE id=str_filas[3]::integer;
					END IF;
					
				END IF;
				
			END LOOP;
			
			IF estatus_orden=0 THEN 
				--aqui se actualiza el estado de la orden de entrada
				UPDATE inv_oent SET estatus=1 WHERE id=str_data[4]::integer;
			END IF;
			
		END IF;--termina accion edit
		/*
		IF command_selected = 'cancelar' THEN
			UPDATE inv_oent SET cancelacion=TRUE, momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_baja=usuario_ejecutor WHERE id=str_data[4]::integer;
		END IF;
		*/
		valor_retorno := '1';
	END IF;--termina Aplicativo Ordenes de Entrada	
	
	
	
	
	
	
	
	--Aplicativo Orden de Salida
	IF app_selected = 94 THEN
		--str_data[4]	id_osal
		--str_data[5]	observaciones
		--str_data[6]	accion
		
		IF command_selected = 'edit' THEN
			UPDATE inv_osal SET observaciones=str_data[5], momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor WHERE id=str_data[4]::integer;
			
			--obtener el estatus de la Orden de Salida
			SELECT estatus FROM inv_osal WHERE id=str_data[4]::integer INTO estatus_orden;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	eliminado[i]
					--str_filas[2]	tipo_registro[i]
					--str_filas[3]	id_detalle_lot[i]
					--str_filas[4]	id_detalle_os[i]
					--str_filas[5]	id_almacen[i]
					--str_filas[6]	id_prod_grid[i]
					--str_filas[7]	lote_interno[i]
					--str_filas[8]	cantidad_fac[i]
					--str_filas[9]	cant_sur[i]
					--str_filas[10]	no_tr[i]
					
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='PAR' THEN
						--aqui entra porque es una partida
						UPDATE inv_osal_detalle SET cantidad_sur=str_filas[9]::double precision WHERE id=str_filas[4]::integer;
						
						--Inicializar variables
						idUnidadMedida=0;
						nombreUnidadMedida:='';
						densidadProd:=0;
						noDecUnidad:=0;
						idUnidadMedidaVenta:=0;
						cantUnidadVenta:=0;
						
						--Obtener el tipo de producto y el numero de Decimales Permitidos
						SELECT inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
						FROM inv_prod 
						LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
						WHERE inv_prod.id=str_filas[6]::integer 
						INTO idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
						
						--Obtener la unidad de Medida del producto de esta partida(unidad de medida de la venta)
						SELECT inv_prod_unidad_id FROM inv_osal_detalle WHERE id=str_filas[4]::integer INTO idUnidadMedidaVenta;
						
					ELSE
						--Tomar y redondear la cantidad en la Unidad de la Venta
						cantUnidadVenta:=round(str_filas[9]::numeric,noDecUnidad)::double precision;
						
						--Aqui entra para crear o actualizar un LOTE
						IF str_filas[3]::integer > 0 THEN 
							--Obtner el id del lote para actualizar
							SELECT inv_lote_id, cantidad_sal FROM inv_lote_detalle WHERE id=str_filas[3]::integer INTO id_lote, cant_sal_anterior;
							
							--Si es NULL o es menor que cero, asignar cero
							IF cant_sal_anterior IS NULL OR cant_sal_anterior < 0 THEN cant_sal_anterior:=0; END IF;
							
							--Verificar que la unidad de Medida de venta no sea null y sea mayor que cero
							IF idUnidadMedidaVenta IS NOT NULL AND idUnidadMedidaVenta>0 THEN 
								--Verificar  si la Unidad de Venta es diferente a la Unidad del Producto
								IF idUnidadMedida<>idUnidadMedidaVenta THEN
									IF densidadProd IS NULL OR densidadProd=0 THEN
										densidadProd:=1;
									END IF;
									
									EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
									IF match_cadena=true THEN
										--Convertir a Kilos(Convertir a la Unidad de Medida del producto)
										cant_sal_anterior := cant_sal_anterior::double precision * densidadProd;
										str_filas[9] := str_filas[9]::double precision * densidadProd;
									ELSE
										EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
										IF match_cadena=true THEN
											--Convertir a Litros(Convertir a la Unidad de Medida del producto)
											cant_sal_anterior := cant_sal_anterior::double precision / densidadProd;
											str_filas[9] := str_filas[9]::double precision / densidadProd;
										END IF;
									END IF;
								END IF;
							END IF;
							
							cant_sal_anterior := round(cant_sal_anterior::numeric,noDecUnidad)::double precision;
							str_filas[9] := round(str_filas[9]::numeric,noDecUnidad)::double precision;
							
							--Si la cantidad salida enterior es DIFERENTE a la que estamos pasando, entonces hacemos los cambios necesarios, de otra manera no se hace nada
							IF cant_sal_anterior <> str_filas[9]::double precision THEN
								--RAISE EXCEPTION '%' ,'cant_sal_anterior: '||cant_sal_anterior||'    Nuevo: '||str_filas[9]::double precision;
								
								--Se resta la cantidad que se habia reservado para regresar la existencia al lote
								UPDATE inv_lote SET reservado=(reservado - cant_sal_anterior) WHERE id=id_lote;
								
								--Reservar la nueva cantidad
								UPDATE inv_lote SET reservado=(reservado + str_filas[9]::double precision) WHERE id=id_lote;
								
								--Se registra la nueva cantidad que se le dara salida, la cantidad es en la unidad de la Venta
								UPDATE inv_lote_detalle SET cantidad_sal=cantUnidadVenta::double precision WHERE id=str_filas[3]::integer;
							END IF;
						ELSE
							--Obtener el id del nuevo lote que se le dara salida
							SELECT id FROM inv_lote WHERE lote_int=str_filas[7] AND inv_prod_id=str_filas[6]::integer AND inv_alm_id=str_filas[5]::integer
							INTO id_lote;
							
							--Verificar que la unidad de Medida de venta no sea null y sea mayor que cero
							IF idUnidadMedidaVenta IS NOT NULL AND idUnidadMedidaVenta>0 THEN 							
								--Verificar  si la Unidad de Venta es diferente a la Unidad del Producto
								IF idUnidadMedida<>idUnidadMedidaVenta THEN
									--Si la densidad es null o cero, le asignamos 1 por default, esto evita problemas con divisiones entre cero
									IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
									
									EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
									IF match_cadena=true THEN
										--Convertir a Kilos(Convertir a la Unidad de Medida del producto)
										str_filas[9] := str_filas[9]::double precision * densidadProd;
									ELSE
										EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
										IF match_cadena=true THEN
											--Convertir a Litros(Convertir a la Unidad de Medida del producto)
											str_filas[9] := str_filas[9]::double precision / densidadProd;
										END IF;
									END IF;
								END IF;
							END IF;
							
							str_filas[9] := round(str_filas[9]::numeric,noDecUnidad)::double precision;
							
							--Reservar la cantidad que se le dara salida
							UPDATE inv_lote SET reservado=(reservado + str_filas[9]::double precision) WHERE id=id_lote;
							
							--Crear registro en inv_lote_detalle para registrar la cantidad que se le dara salida
							INSERT INTO inv_lote_detalle(inv_lote_id,inv_osal_detalle_id,cantidad_sal)
							VALUES(id_lote, str_filas[4]::integer, cantUnidadVenta::double precision);
						END IF;
					END IF;
				ELSE
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='LOT' THEN
						
						--RAISE EXCEPTION '%' ,'str_filas[3]: '||str_filas[3]||'    str_filas[4]: '||str_filas[4];
						--RAISE EXCEPTION '%' ,'idUnidadMedida: '||idUnidadMedida||'    idUnidadMedidaVenta: '||idUnidadMedidaVenta;
						--RAISE EXCEPTION '%' ,'nombreUnidadMedida: '||nombreUnidadMedida||'    densidadProd: '||densidadProd;
						
						--obtner el id del lote eliminado del grid y la cantidad que se le dio salida
						SELECT inv_lote_id, cantidad_sal FROM inv_lote_detalle WHERE id=str_filas[3]::integer INTO id_lote, cant_sal_anterior;
						
						--Si es NULL o es menor que cero, asignar cero
						IF cant_sal_anterior IS NULL OR cant_sal_anterior < 0 THEN 
							cant_sal_anterior:=0;
						END IF;
						
						--Si cant_sal_anterior es mayor que cero
						IF cant_sal_anterior > 0 THEN
							--Verificar que la unidad de Medida de venta no sea null y sea mayor que cero
							IF idUnidadMedidaVenta IS NOT NULL AND idUnidadMedidaVenta>0 THEN 
								--Verificar  si la Unidad de Venta es diferente a la Unidad del Producto
								IF idUnidadMedida<>idUnidadMedidaVenta THEN
									IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
									
									EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
									IF match_cadena=true THEN
										--Convertir a Kilos(Convertir a la Unidad de Medida del producto)
										cant_sal_anterior := cant_sal_anterior::double precision * densidadProd;
									ELSE
										EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
										IF match_cadena=true THEN
											--Convertir a Litros(Convertir a la Unidad de Medida del producto)
											cant_sal_anterior := cant_sal_anterior::double precision / densidadProd;
										END IF;
									END IF;
								END IF;
							END IF;
						END IF;
						
						cant_sal_anterior := round(cant_sal_anterior::numeric,noDecUnidad)::double precision;
						
						--se resta la cantidad que se le dio salida para regresar la existencia al lote
						UPDATE inv_lote SET reservado=(reservado - cant_sal_anterior::double precision) WHERE id=id_lote;
						
						--Eliminar el registro del inv_lote_detalle
						DELETE FROM inv_lote_detalle WHERE id=str_filas[3]::integer;
					END IF;
				END IF;
			END LOOP;
			
			IF estatus_orden=0 THEN 
				--Aqui se actualiza el estado de la orden de salida
				UPDATE inv_osal SET estatus=1 WHERE id=str_data[4]::integer;
			END IF;
			
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
			--Si la accion es  confirmar, se le da salida del lote
			IF str_data[6]='confirmar' THEN
				--aqui se actualiza el estado a 2=Confirmado
				UPDATE inv_osal SET estatus=2, momento_confirmacion=espacio_tiempo_ejecucion  WHERE id=str_data[4]::integer;
				
				--obtenemos el id de los Lotes y las cantidades a dar Salida
				sql_select:='';
				sql_select:='
				SELECT 
					inv_lote_detalle.inv_lote_id,
					inv_lote_detalle.cantidad_sal,
					(CASE WHEN inv_osal_detalle.inv_prod_unidad_id IS NULL THEN 0 ELSE inv_osal_detalle.inv_prod_unidad_id END) AS id_uni_venta,
					inv_osal_detalle.inv_prod_id 
				FROM inv_osal_detalle 
				JOIN inv_lote_detalle ON inv_lote_detalle.inv_osal_detalle_id=inv_osal_detalle.id 
				WHERE inv_osal_detalle.inv_osal_id='||str_data[4]::integer;
				
				--aqui comienza a dar salida del lote
				FOR detalle IN EXECUTE(sql_select) LOOP
					--Inicializar variables
					idUnidadMedida=0;
					nombreUnidadMedida:='';
					densidadProd:=0;
					noDecUnidad:=0;
					idUnidadMedidaVenta:=0;
					cantUnidadVenta:=0;
					
					--Obtener el tipo de producto y el numero de Decimales Permitidos
					SELECT inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
					FROM inv_prod 
					LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=detalle.inv_prod_id 
					INTO idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;

					--Unidad de Medida de la Venta del producto
					idUnidadMedidaVenta:=detalle.id_uni_venta;
					
					--Verificar que la unidad de Medida de venta sea mayor que cero
					IF idUnidadMedidaVenta>0 THEN 							
						--Verificar  si la Unidad de Venta es diferente a la Unidad del Producto
						IF idUnidadMedida<>idUnidadMedidaVenta THEN
							--Si la densidad es null o cero, le asignamos 1 por default, esto evita problemas con divisiones entre cero
							IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
							
							EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
							IF match_cadena=true THEN
								--Convertir a Kilos(Convertir a la Unidad de Medida del producto)
								detalle.cantidad_sal := detalle.cantidad_sal::double precision * densidadProd;
							ELSE
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
								IF match_cadena=true THEN
									--Convertir a Litros(Convertir a la Unidad de Medida del producto)
									detalle.cantidad_sal := detalle.cantidad_sal::double precision / densidadProd;
								END IF;
							END IF;
						END IF;
					END IF;
					
					detalle.cantidad_sal := round(detalle.cantidad_sal::numeric,noDecUnidad)::double precision;
					
					--Se resta la cantidad que se habia reservado y le da salida
					UPDATE inv_lote SET reservado=(reservado - detalle.cantidad_sal::double precision), salidas=(salidas + detalle.cantidad_sal::double precision)
					WHERE id=detalle.inv_lote_id;
				END LOOP;
				
			END IF;
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		END IF;--termina accion edit
		
		valor_retorno := '1';
	END IF;--termina Aplicativo Ordenes de Salida
	
	
	
	
	--Aplicativo Ajustes de Inventario
	IF app_selected = 95 THEN
		--str_data[4]	identificador
		--str_data[5]	select_tipo_mov
		--str_data[6]	observaciones
		--str_data[7]	select_almacen
		
		IF command_selected = 'new' THEN
			
			tipo_movimiento_id := str_data[5]::integer;
			id_tipo_consecutivo:=22;--Folio Ajuste de Inventario
			tipo_doc:=3;--Tipo documento Ajuste
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del Ajuste
			folio_ajuste := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--genera registro del movimiento
			INSERT INTO inv_mov(referencia,inv_mov_tipo_id,fecha_mov,observacion,momento_creacion,gral_usr_id,gral_app_id ) 
			VALUES(folio_ajuste,tipo_movimiento_id,espacio_tiempo_ejecucion,str_data[6],espacio_tiempo_ejecucion,usuario_ejecutor,app_selected) 
			RETURNING id INTO identificador_nuevo_movimiento;
			
			--obtener el tipo de costo y grupo del Movimiento seleccionado
			SELECT tipo_costo, grupo FROM inv_mov_tipos WHERE id=str_data[5]::integer INTO tipo_costo_movimiento, grupo_movimiento;
			
			--grupo:0=Entradas, grupo:2=Salidas
			IF grupo_movimiento=0 THEN
				--aqui entra para crear registro en INV_OENT
				id_tipo_consecutivo:=17;--Folio Orden de Entrada
				
				--aqui entra para tomar el consecutivo del folio  la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
				
				
				INSERT INTO inv_oent(
					folio,--nuevo_folio,
					estatus,--0,
					com_proceso_id,--0,
					inv_mov_tipo_id,--tipo_movimiento_id,
					tipo_documento,--tipo_doc,
					folio_documento,--folio_ajuste,
					fecha_exp,--espacio_tiempo_ejecucion,
					gral_app_id,--app_selected,
					cxp_prov_id,--0,
					cxc_clie_id,--0,
					inv_alm_id,--str_data[7]::integer,
					numero_guia,--'',
					orden_de_compra,--''
					moneda_id,--1,
					tipo_de_cambio,--1,
					observaciones,--str_data[6],
					momento_creacion,--espacio_tiempo_ejecucion
					gral_usr_id_creacion,--usuario_ejecutor
					gral_emp_id--emp_id
				)
				VALUES(nuevo_folio,0,0,tipo_movimiento_id,tipo_doc,folio_ajuste,espacio_tiempo_ejecucion,app_selected,0,0,str_data[7]::integer,'','',1,1,str_data[6],espacio_tiempo_ejecucion,usuario_ejecutor,emp_id) 
				RETURNING id INTO ultimo_id;
				
			ELSE 
				--aqui entra para crear registro en INV_OSAL
				id_tipo_consecutivo:=21; --Folio Orden de Salida
				
				--aqui entra para tomar el consecutivo del folio  la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
				
				--genera registro en tabla inv_osal(Orden de Salida)
				INSERT INTO inv_osal(
					folio,--nuevo_folio,
					estatus,--0,
					erp_proceso_id,--0,
					inv_mov_tipo_id,--tipo_movimiento_id,
					tipo_documento,--tipo_doc,
					folio_documento,--folio_ajuste,
					fecha_exp,--espacio_tiempo_ejecucion,
					gral_app_id,--app_selected,
					cxc_clie_id,--0,
					inv_alm_id,--str_data[7]::integer,
					orden_compra,--'',
					moneda_id,--1,
					tipo_cambio,--1,
					momento_creacion,--espacio_tiempo_ejecucion,
					gral_usr_id_creacion,--usuario_ejecutor
					gral_emp_id,--emp_id
					gral_suc_id--suc_id
				)
				VALUES(nuevo_folio,0,0,tipo_movimiento_id,tipo_doc,folio_ajuste,espacio_tiempo_ejecucion,app_selected,0,str_data[7]::integer,'',1,1,espacio_tiempo_ejecucion,usuario_ejecutor,emp_id,suc_id)
				RETURNING id INTO ultimo_id;
			END IF;
			
			
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	idproducto[i]
				--str_filas[2]	id_almacen[i]
				--str_filas[3]	cant_ajuste[i]
				--str_filas[4]	costo_ajuste[i]
				--str_filas[5]	no_tr[i]
				--str_filas[6]	select_pres
				
				--grupo:0=Entradas, grupo:2=Salidas
				IF grupo_movimiento=0 THEN
					id_alm_origen:=0;
					id_alm_destino:=str_filas[2]::integer;
				ELSE 
					id_alm_origen:=str_filas[2]::integer;
					id_alm_destino:=0;
				END IF;
				
				--0=Alimentado, 1=Promedio
				IF tipo_costo_movimiento=0 THEN
					--aqui entra cuando el costo es ALIMENTADO, se toma el costo que viene desde la vista
					precio_unitario:=str_filas[4]::double precision;
				ELSE 
					--aqui entra cuando el costo es PROMEDIO, toma  el costo promedio actual del producto
					SELECT * FROM inv_obtiene_costo_promedio_actual(str_filas[1]::integer, espacio_tiempo_ejecucion) INTO precio_unitario;
				END IF;
				
				--se toma el costo unitario y se asigna  a la variable para calcular el costo promedio, este costo unitario se toma por default que viene en M.N.
				precio_unitario_mn:= precio_unitario::double precision;
				
				--genera registro en detalles del movimiento
				INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad,costo, inv_prod_presentacion_id)
				VALUES(identificador_nuevo_movimiento,id_alm_origen,id_alm_destino,str_filas[1]::integer,str_filas[3]::double precision, precio_unitario, str_filas[6]::integer);
				
				
				--buscar el numero de decimales de la unidad del producto
				SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				WHERE inv_prod.id=str_filas[1]::integer 
				INTO noDecUnidad;
				
				IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
				
				--inicializar valor a cero
				equivalenciaPres:=0;
				
				--buscar la equivalencia de la Presentacion del Producto
				SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_filas[6]::integer 
				INTO equivalenciaPres;
				
				IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
				
				--redondear la cantidad de unidades a Ajustar
				str_filas[3] := round(str_filas[3]::numeric,noDecUnidad)::character varying;
				
				--convertir la Suma de Unidades en su equivalencia a la Presentacion
				cantPresAsignado := str_filas[3]::double precision / equivalenciaPres::double precision;
				
				--redondear la Cantidad de Presentacion Asignado para el Ajuste
				cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision;
				
				
				--grupo:0=Entradas, grupo:2=Salidas
				IF grupo_movimiento=0 THEN 
					--RAISE EXCEPTION '%' ,'grupo_movimiento: '||grupo_movimiento||'          tipo_costo_movimiento: '||tipo_costo_movimiento;
					--aqui entra para registrar ENTTRADAS en inv_exi
					sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||'::double precision + '||str_filas[3]||'::double precision), costo_ultimo_'||mes_actual||'='||precio_unitario||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
					WHERE inv_alm_id='||str_filas[2]||'::integer AND inv_prod_id='||str_filas[1]||'::integer AND ano='||ano_actual||'::integer;';
					EXECUTE sql_update;
					IF FOUND THEN
						--RAISE EXCEPTION '%','FOUND'||FOUND;
					ELSE
						RAISE EXCEPTION '%','NOT FOUND:'||FOUND||'   No se pudo actualizar inv_exi';
					END IF;
					
					
					IF controlExisPres=true THEN
						--aqui entra si la configuracion indica que se debe controlar existencias por presentaciones
						
						--buscar Registro de la Presentacion en el Almacen
						SELECT count(id) AS exis FROM inv_exi_pres 
						WHERE inv_alm_id=str_filas[2]::integer AND inv_prod_id=str_filas[1]::integer AND inv_prod_presentacion_id=str_filas[6]::integer 
						INTO exis;
						
						IF exis > 0 THEN
							--Sumar Entradas de presentaciones en inv_exi_pres
							UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantPresAsignado::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
							WHERE inv_alm_id = str_filas[2]::integer AND inv_prod_id = str_filas[1]::integer AND inv_prod_presentacion_id=str_filas[6]::integer;
						ELSE
							--aqui entra para CREAR registro en inv_exi_pres
							INSERT INTO inv_exi_pres(inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
							VALUES(str_filas[2]::integer, str_filas[1]::integer, str_filas[6]::integer, cantPresAsignado::double precision, espacio_tiempo_ejecucion, usuario_ejecutor);
						END IF;
					END IF;
					
					--tipo_costo:0=Alimentado
					IF tipo_costo_movimiento=0 THEN
						--llamada a procedimiento que calcula el Nuevo Costo Promedio
						--el costo unitario que se le pasa debe ser en pesos(precio_unitario_mn)
						select * from inv_calculo_costo_promedio_producto(str_filas[1]::integer,str_filas[3]::double precision, precio_unitario_mn, espacio_tiempo_ejecucion, usuario_ejecutor) 
						INTO nuevo_costo_promedio;
						
						--llamada al procedimiento para actualizar costo promedio
						SELECT * FROM inv_actualiza_repite_costo_promedio(str_filas[1]::integer, nuevo_costo_promedio, espacio_tiempo_ejecucion) INTO costo_prom_actualizado;
					END IF;
					
					
					--genera registro en INV_OENT_DETALLE(Ordenes de Entrada)
					INSERT INTO inv_oent_detalle(
						inv_oent_id,--ultimo_id,
						inv_prod_id,--str_filas[1]::integer,
						inv_prod_presentacion_id,--str_filas[6]::integer,
						cantidad,--str_filas[3]::double precision,
						costo_unitario,--precio_unitario,
						gral_imp_id,--0,
						valor_imp--0
					)VALUES(ultimo_id, str_filas[1]::integer, str_filas[6]::integer, str_filas[3]::double precision, precio_unitario,0,0);
					
					
				ELSE
					--RAISE EXCEPTION '%' ,'grupo_movimiento: '||grupo_movimiento||'          tipo_costo_movimiento: '||tipo_costo_movimiento;
					--aqui entra para registrar SALIDAS
					--query para descontar producto de existencias
					sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||str_filas[3]||'),momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
					WHERE inv_alm_id='||str_filas[2]||' AND inv_prod_id='||str_filas[1]||' AND ano='||ano_actual;
					EXECUTE sql_update;
					IF FOUND THEN
						--RAISE EXCEPTION '%','FOUND'||FOUND;
					ELSE
						RAISE EXCEPTION '%','NOT FOUND:'||FOUND||'   No se pudo actualizar inv_exi';
					END IF;
					
					
					IF controlExisPres=true THEN
						--aqui entra si la configuracion indica que se debe controlar existencias por presentaciones
						
						--buscar Registro de la Presentacion en el Almacen
						SELECT count(id) AS exis FROM inv_exi_pres 
						WHERE inv_alm_id=str_filas[2]::integer AND inv_prod_id=str_filas[1]::integer AND inv_prod_presentacion_id=str_filas[6]::integer 
						INTO exis;

						IF exis > 0 THEN
							--Sumar Salidas de presentaciones en inv_exi_pres
							UPDATE inv_exi_pres SET salidas=(salidas::double precision + cantPresAsignado::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor  
							WHERE inv_alm_id = str_filas[2]::integer AND inv_prod_id = str_filas[1]::integer AND inv_prod_presentacion_id = str_filas[6]::integer;
						ELSE
							--aqui entra para CREAR registro en inv_exi_pres
							INSERT INTO inv_exi_pres(inv_alm_id, inv_prod_id, inv_prod_presentacion_id, salidas, momento_creacion, gral_usr_id_creacion) 
							VALUES(str_filas[2]::integer, str_filas[1]::integer, str_filas[6]::integer, cantPresAsignado::double precision, espacio_tiempo_ejecucion, usuario_ejecutor);
						END IF;
					END IF;
					
					
					--genera registro en INV_OSAL_DETALLE(Ordenes de Salida)
					INSERT INTO inv_osal_detalle(inv_osal_id,inv_prod_id,inv_prod_presentacion_id,cantidad,precio_unitario)
					VALUES(ultimo_id, str_filas[1]::integer, str_filas[6]::integer, str_filas[3]::double precision, precio_unitario);
					
				END IF;
			END LOOP;
			
		END IF;--termina accion edit
		
		valor_retorno := '1';
	END IF;--termina Aplicativo Ajustes de Inventario
	
	
	
		
	--Aplicativo Impresion de Etiquetas
	IF app_selected = 98 THEN
		IF command_selected = 'new' THEN
			id_tipo_consecutivo:=27;--Folio Impresion de Etiquetas
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO inv_etiquetas(folio,  folio_origen ,tipo_origen,borrado_logico ,momento_creacion ,gral_emp_id ,gral_suc_id ,gral_usr_id_creacion )
			VALUES (nuevo_folio, str_data[5],str_data[6]::integer,false,now(),emp_id,suc_id,usuario_ejecutor)
			RETURNING id INTO ultimo_id;
				
				
			--total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			--cont_fila:=1;
			
			IF extra_data[1] != 'sin datos' THEN

				FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
					INSERT INTO inv_etiquetas_detalle(inv_etiquetas_id ,lote_interno ,cantidad,inv_prod_id,inv_lote_id,cantidad_produccion)
					VALUES(ultimo_id,str_filas[1],str_filas[2]::integer,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::double precision);
				END LOOP;
				
			END IF;
			
			valor_retorno := '1';
		END IF;
	END IF;
	
	
	
	
	--Aplicativo Traspasos
	IF app_selected = 10 THEN
		--str_data[4]	identificador
		--str_data[5]	select_suc_origen
		--str_data[6]	select_alm_origen
		--str_data[7]	select_suc_destino
		--str_data[8]	select_alm_destino
		--str_data[9]	observaciones
		--str_data[10]	fecha_traspaso
		
		IF command_selected = 'new' THEN
			
			id_tipo_consecutivo:=29;--Folio Traspaso
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del traspaso
			folio1 := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO inv_tras(
				folio,--folio1,
				fecha_traspaso,--str_data[10]::date,
				gral_suc_id_origen,--str_data[5]::integer,
				inv_alm_id_origen,--str_data[6]::integer,
				gral_suc_id_destino,--str_data[7]::integer,
				inv_alm_id_destino,--str_data[8]::integer,
				observaciones,--str_data[9],
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_emp_id,--emp_id,
				gral_suc_id,--suc_id,
				gral_usr_id_creacion--usuario_ejecutor
			)
			VALUES (folio1, str_data[10]::date, str_data[5]::integer, str_data[6]::integer, str_data[7]::integer, str_data[8]::integer, str_data[9], espacio_tiempo_ejecucion, emp_id, suc_id, usuario_ejecutor)
			RETURNING id INTO ultimo_id;
			
			
			--********************************************************************************************************
			--GENERA REGISTRO PARA ORDEN DE TRASPASO(inv_otras)
			id_tipo_consecutivo:=30;--Folio Orden de Traspaso
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio dela Orden de Traspaso
			folio2 := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO inv_otras(folio, fecha, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion, inv_tras_id)
			VALUES (folio2, str_data[10]::date, str_data[5]::integer, str_data[6]::integer, str_data[7]::integer, str_data[8]::integer, espacio_tiempo_ejecucion, emp_id, suc_id, usuario_ejecutor, ultimo_id)
			RETURNING id INTO ultimo_id2;
			
			--********************************************************************************************************
			
			
			tipo_movimiento_id := 7;--SALIDA POR TRASPASO
			
			--genera registro del movimiento
			INSERT INTO inv_mov(
				referencia,--folio1,
				inv_mov_tipo_id,--tipo_movimiento_id,
				fecha_mov,--str_data[10]::date,
				observacion,--str_data[9],
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id,--usuario_ejecutor,
				gral_app_id --app_selected
			) 
			VALUES(folio1, tipo_movimiento_id, str_data[10]::date, str_data[9], espacio_tiempo_ejecucion, usuario_ejecutor, app_selected) 
			RETURNING id INTO identificador_nuevo_movimiento;

			
			tipo_movimiento_id := 3;--ENTRADA TRASPASO
			
			--genera registro del movimiento
			INSERT INTO inv_mov(
				referencia,--folio1,
				inv_mov_tipo_id,--tipo_movimiento_id,
				fecha_mov,--str_data[10]::date,
				observacion,--str_data[9],
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id,--usuario_ejecutor,
				gral_app_id --app_selected
			) 
			VALUES(folio1, tipo_movimiento_id, str_data[10]::date, str_data[9], espacio_tiempo_ejecucion, usuario_ejecutor, app_selected) 
			RETURNING id INTO identificador_nuevo_movimiento_entrada;
			
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	idproducto[i]
				--str_filas[2]	cant_traspaso[i]
				--str_filas[3]	no_tr[i]
				--str_filas[4]	select_pres
				
				--buscar el numero de decimales de la unidad del producto
				SELECT inv_prod_unidades.decimales FROM inv_prod JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				WHERE inv_prod.id=str_filas[1]::integer 
				INTO noDecUnidad;
				
				IF noDecUnidad IS NULL THEN noDecUnidad:=0;  END IF;
				
				--redondear la Cantidad de la Presentacion
				str_filas[2] := round(str_filas[2]::numeric,noDecUnidad)::double precision;
				
				--crear registro en detalles de traspaso
				INSERT INTO inv_tras_det(inv_tras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id)
				VALUES(ultimo_id, str_filas[1]::integer, str_filas[2]::double precision, str_filas[4]::integer);
				
				--crea registro para detalles Orden de Traspaso
				INSERT INTO inv_otras_det(inv_otras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id)
				VALUES(ultimo_id2, str_filas[1]::integer, str_filas[2]::double precision, str_filas[4]::integer);
				
				--obtener el costo promedio actual del producto
				SELECT * FROM inv_obtiene_costo_promedio_actual(str_filas[1]::integer, espacio_tiempo_ejecucion) INTO precio_unitario;
				
				--***** RESGISTRAR SALIDA *********************
				--genera registro en detalles del movimiento
				INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id)
				VALUES(identificador_nuevo_movimiento, str_data[6]::integer, str_data[8]::integer, str_filas[1]::integer, str_filas[2]::double precision, precio_unitario, str_filas[4]::integer);
				
				--query para descontar producto de existencias
				sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||str_filas[2]||'),momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
				WHERE inv_alm_id='||str_data[6]||'::integer AND inv_prod_id='||str_filas[1]||' AND ano='||ano_actual;
				EXECUTE sql_update;

				----------------------------------------------------------------------------------------
				--***** INICIA DESCONTAR EXISTENCIA DE PRESENTACIONES ******************************
				--revisar si la configuracion incluye control de Existencias por Presentacion
				IF controlExisPres=TRUE THEN 
					--inicializar valor a cero
					equivalenciaPres:=0;
					
					--buscar la equivalencia de la Presentacion Origen en la Unidad del Producto
					SELECT cantidad AS equiv_pres FROM inv_prod_presentaciones WHERE id=str_filas[4]::integer 
					INTO equivalenciaPres;
					
					IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
					
					--Convertir la Cantidad de Unidades a su equivalencia en Cantidad de Presentaciones
					cantPres := round(str_filas[2]::numeric, noDecUnidad)::double precision / equivalenciaPres::double precision;
					
					--redondear la Cantidad de la Presentacion
					cantPres := round(cantPres::numeric,noDecUnidad)::double precision;
					
					--Descontar existencia de las presentaciones
					UPDATE inv_exi_pres SET salidas=(salidas::double precision + cantPres::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
					WHERE inv_alm_id=str_data[6]::integer AND inv_prod_id=str_filas[1]::integer AND inv_prod_presentacion_id=str_filas[4]::integer;
				END IF;
				--termina descontar existencia de presentaciones
				---------------------------------------------------------------------------------------------------------------------
				
				--***** RESGISTRAR ENTRADA *********************
				--genera registro en detalles del movimiento
				INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id)
				VALUES(identificador_nuevo_movimiento_entrada, str_data[6]::integer, str_data[8]::integer, str_filas[1]::integer, str_filas[2]::double precision, precio_unitario, str_filas[4]::integer);
				
				--reiniciamos el valor de la variable exis a cero
				exis:=0;
				
				sql_select := '';
				--query para verificar existencia del producto en el almacen y en el a√±o actual
				sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||str_filas[1]||' AND inv_alm_id = '||str_data[8]||' AND ano = '||ano_actual;
				EXECUTE sql_select INTO exis;
				
				--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
				IF exis >0 THEN
					--aqui entra para ACTUALIZAR registro en inv_exi
					sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||str_filas[2]||'::double precision), costo_ultimo_'||mes_actual||'='||precio_unitario||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
					WHERE inv_alm_id='||str_data[8]||' AND inv_prod_id='||str_filas[1]||' AND ano='||ano_actual||';';
					EXECUTE sql_update;
				ELSE
					--aqui entra para CREAR registro en inv_exi
					sql_insert:='INSERT INTO inv_exi (inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial, costo_ultimo_'||mes_actual||') '||
					'VALUES('||str_filas[1]||','||str_data[8]||','||ano_actual||','||str_filas[2]||','''|| espacio_tiempo_ejecucion ||''',0,'||precio_unitario||' );';
					EXECUTE sql_insert;
				END IF;
				
				
				-------------------------------------------------------------------------------------
				--***** SUMAR EXISTENCIA DE PRESENTACIONES EN EL ALMACEN DESTINO******
				--revisar si la configuracion incluye control de Existencias por Presentacion
				IF controlExisPres=TRUE THEN 
					--inicializar a cero
					exis := 0;
					
					--buscar Registro de la Presentacion en el Almacen Destino
					SELECT count(id) AS exis FROM inv_exi_pres WHERE inv_alm_id=str_data[8]::integer AND inv_prod_id=str_filas[1]::integer AND inv_prod_presentacion_id=str_filas[4]::integer 
					INTO exis;
					
					IF exis >0 THEN
						--Sumar existencia de la presentacion
						UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantPres::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
						WHERE inv_alm_id = str_data[8]::integer AND inv_prod_id = str_filas[1]::integer AND inv_prod_presentacion_id = str_filas[4]::integer;
					ELSE
						--aqui entra para CREAR registro en inv_exi
						INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
						VALUES(str_data[8]::integer, str_filas[1]::integer, str_filas[4]::integer, cantPres::double precision, espacio_tiempo_ejecucion, usuario_ejecutor );
					END IF;
				END IF;
				--**termina actualizar existencia de Presentaciones
				-----------------------------------------------------------------------------------------
			END LOOP;
			
		END IF;--termina accion NEW
		
		valor_retorno := '1';
	END IF;--termina Aplicativo Traspasos
	
	
	
	
	--Aplicativo Ordenes de Traspaso
	IF app_selected = 105 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	select_alm_origen
		--str_data[6]	select_alm_destino
		--str_data[7]	observaciones
		--str_data[8]	fecha
		
		IF command_selected = 'edit' THEN
			UPDATE inv_otras SET fecha=str_data[8]::date, observaciones=str_data[7], estatus=1, momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer
			RETURNING id, folio INTO ultimo_id, folio1;
			
			tipo_movimiento_id := 7;--SALIDA POR TRASPASO
			INSERT INTO inv_lote_mov(id_referencia, referencia, inv_mov_tipo_id, fecha_mov, observacion, gral_usr_id, gral_app_id)
			VALUES(ultimo_id, folio1, tipo_movimiento_id, str_data[8]::timestamp with time zone, str_data[7], usuario_ejecutor, app_selected)
			RETURNING id INTO identificador_nuevo_movimiento;

			
			tipo_movimiento_id := 3;--ENTRADA TRASPASO
			INSERT INTO inv_lote_mov(id_referencia, referencia, inv_mov_tipo_id, fecha_mov, observacion, gral_usr_id, gral_app_id)
			VALUES(ultimo_id, folio1, tipo_movimiento_id, str_data[8]::timestamp with time zone, str_data[7], usuario_ejecutor, app_selected)
			RETURNING id INTO identificador_nuevo_movimiento_entrada;

			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	no_tr[i]
				--str_filas[2]	tipotr[i]
				--str_filas[3]	idPartida[i]
				--str_filas[4]	idproducto[i]
				--str_filas[5]	lote_int[i]
				--str_filas[6]	cant_traspaso[i]
				
				IF str_filas[2]='LOTE' THEN 
					--AQUI INICIA DARLE SALIDA AL LOTE DEL ALMACEN ORIGEN
					UPDATE inv_lote SET salidas=(salidas + str_filas[6]::double precision), momento_actualizacion=espacio_tiempo_ejecucion 
					WHERE lote_int=str_filas[5] AND inv_prod_id=str_filas[4]::integer AND inv_alm_id=str_data[5]::integer
					RETURNING id, lote_prov, caducidad, pedimento INTO id_lote, lote_proveedor, lote_cad, lote_ped;
					
					IF lote_proveedor IS NULL THEN 
						lote_proveedor:='';
					END IF;
					
					--movimiento detalle de la salida del lote
					INSERT INTO inv_lote_mov_det(inv_lote_mov_id, inv_alm_origen_id, inv_alm_destino_id, inv_lote_id, cantidad, referencia_det_id )
					VALUES(identificador_nuevo_movimiento, str_data[5]::integer, str_data[6]::integer, id_lote, str_filas[6]::double precision, str_filas[3]::integer);
					
					
					--AQUI INICIA DARLE ENTRADA AL LOTE EN EL ALMACEN DESTINO
					--buscar lote en el almacen destino
					SELECT count(id) FROM inv_lote WHERE trim(lote_int)=trim(str_filas[5]) AND inv_prod_id=str_filas[4]::integer AND inv_alm_id=str_data[6]::integer
					INTO exis;
					
					IF exis > 0 THEN 
						--RAISE EXCEPTION '%','LOTE: '||str_filas[5];
						
						--aqui actualiza la existencia del lote porque ya existe en el almacen destino
						UPDATE inv_lote SET entradas=(entradas + str_filas[6]::double precision), momento_actualizacion=espacio_tiempo_ejecucion 
						WHERE lote_int=str_filas[5] AND inv_prod_id=str_filas[4]::integer AND inv_alm_id=str_data[6]::integer
						RETURNING id INTO id_lote;
					ELSE
						--aqui crea un nuevo registro para el lote en el almacen destino porque aun no existe
						INSERT INTO inv_lote(inv_prod_id, inv_alm_id, lote_int, lote_prov, inicial, pedimento, caducidad, momento_creacion)
						VALUES(str_filas[4]::integer, str_data[6]::integer, trim(str_filas[5]), lote_proveedor, str_filas[6]::double precision, lote_ped, lote_cad, espacio_tiempo_ejecucion )
						RETURNING id INTO id_lote;
					END IF;
					
					--movimiento detalle de la entrada del lote
					INSERT INTO inv_lote_mov_det( inv_lote_mov_id, inv_alm_origen_id, inv_alm_destino_id, inv_lote_id, cantidad, referencia_det_id)
					VALUES(identificador_nuevo_movimiento_entrada, str_data[5]::integer, str_data[6]::integer, id_lote, str_filas[6]::double precision, str_filas[3]::integer);
				END IF;
			END LOOP;
			
		END IF;--termina accion edit
		
		valor_retorno := '1';
	END IF;--termina Aplicativo Ordenes de Traspaso
	
	
	
	--Aplicativo Control de Costos
	IF app_selected = 125 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	select_tipo_prod
		--str_data[5]	select_marca
		--str_data[6]	select_familia
		--str_data[7]	select_subfamilia
		--str_data[8]	producto
		--str_data[9]	codigo
		--str_data[10]	select_presentacion
		--str_data[11]	tipo_costo
		--str_data[12]	costo_importacion
		--str_data[13]	costo_directo
		--str_data[14]	precio_minimo
		--str_data[15]	costo_adicional
		
		IF command_selected = 'edit' THEN

			--tipo de producto
			IF str_data[4]::integer!=0 THEN
				cadena_where:=' AND inv_prod.tipo_de_producto_id='||str_data[4];
			END IF;
			
			--marca
			IF str_data[5]::integer!=0 THEN
				cadena_where:=cadena_where||' AND inv_prod.inv_mar_id='||str_data[5];
			END IF;
			
			--familia
			IF str_data[6]::integer!=0 THEN
				cadena_where:=cadena_where||' AND inv_prod.inv_prod_familia_id='||str_data[6];
			END IF;
			
			--SubFamilia
			IF str_data[7]::integer!=0 THEN
				cadena_where:=cadena_where||' AND inv_prod.subfamilia_id='||str_data[7];
			END IF;
			
			--str_data[8]	producto
			IF str_data[8]!='%%' AND str_data[8]!='' THEN
				cadena_where:=cadena_where||' AND inv_prod.descripcion ILIKE '''||str_data[8]||'''';
			END IF;

			--str_data[9]	CODIGO
			IF str_data[9]!='%%' AND str_data[9]!='' THEN
				cadena_where:=cadena_where||' AND inv_prod.sku ILIKE '''||str_data[9]||'''';
			END IF;
			
		
			--str_data[10]	select_presentacion
			IF str_data[10]::integer!=0 THEN
				cadena_where:=cadena_where||' AND inv_prod_pres_x_prod.presentacion_id='||str_data[10];
			END IF;
			
			--cadena sql para buscar los registros a actualizar
			sql_select := '
			SELECT 
				inv_prod.id AS producto_id,
				inv_prod_pres_x_prod.presentacion_id 
			FROM inv_prod
			JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
			WHERE inv_prod.borrado_logico=false 
			AND inv_prod.empresa_id='||emp_id||' '||cadena_where||' ';
			--ano_actual;
			--mes_actual;
			--RAISE EXCEPTION '%',sql_select;
			FOR fila IN EXECUTE (sql_select) LOOP
				SELECT count(id) FROM inv_prod_costos WHERE gral_emp_id=emp_id AND ano=ano_actual AND inv_prod_id=fila.producto_id  AND inv_prod_presentacion_id=fila.presentacion_id 
				INTO exis;
				
				incrementa := 0;--inicializar valor
				
				IF exis > 0 THEN
					--Aqu√≠ entra para ACTUALIZAR un registro
					incrementa := mes_actual + 1;
					
					--aqui se crea la cadena para actualizar y repetir los valores del mes actual hasta el mes 12
					sql_update := 'UPDATE inv_prod_costos SET costo_imp_'||mes_actual||'='||str_data[12]||', costo_dir_'||mes_actual||'='||str_data[13]||', precio_min_'||mes_actual||'='||str_data[14]||', costo_adic_'||mes_actual||'='||str_data[15]||', actualizacion_'||mes_actual||'='''||espacio_tiempo_ejecucion||''', usr_id_actualiza_'||mes_actual||'='||usuario_ejecutor||'';
					WHILE incrementa <= 12 LOOP
						sql_update:=sql_update ||', costo_imp_'||incrementa||'='||str_data[12]||', costo_dir_'||incrementa||'='||str_data[13]||', precio_min_'||incrementa||'='||str_data[14]||', costo_adic_'||incrementa||'='||str_data[15]||', actualizacion_'||incrementa||'='''||espacio_tiempo_ejecucion||''', usr_id_actualiza_'||incrementa||'='||usuario_ejecutor||' ';
						incrementa:= incrementa + 1;
					END LOOP;
					sql_update:= sql_update||' WHERE gral_emp_id='||emp_id||' AND ano='||ano_actual||' AND inv_prod_id='||fila.producto_id||' AND inv_prod_presentacion_id='||fila.presentacion_id||';';

					--RAISE EXCEPTION '%',sql_update;
					
					--aqui ejecutamos la cadena sql
					EXECUTE sql_update;
					
				ELSE
					--aqu√≠ entra para CREAR un nuevo registro
					incrementa := mes_actual + 1;

					--esta cadena almacen los campos a actualizar
					sql_insert := 'INSERT INTO inv_prod_costos(gral_emp_id, ano, inv_prod_id, inv_prod_presentacion_id, costo_imp_'||mes_actual||', costo_dir_'||mes_actual||', precio_min_'||mes_actual||', costo_adic_'||mes_actual||', actualizacion_'||mes_actual||', usr_id_actualiza_'||mes_actual||' ';
					
					--en esta cadena van los valores de los campos a actualizar
					valores_campos:=''||emp_id||', '||ano_actual||', '||fila.producto_id ||', '||fila.presentacion_id||', '||str_data[12]||', '||str_data[13]||', '||str_data[14]||', '||str_data[15]||', '''||espacio_tiempo_ejecucion||''','||usuario_ejecutor||'';
					
					WHILE incrementa <= 12 LOOP
						sql_insert:=sql_insert ||', costo_imp_'||incrementa||', costo_dir_'||incrementa||', precio_min_'||incrementa||', costo_adic_'||incrementa||', actualizacion_'||incrementa||', usr_id_actualiza_'||incrementa||'';
						valores_campos:=valores_campos ||', '||str_data[12]||', '||str_data[13]||', '||str_data[14]||', '||str_data[15]||', '''||espacio_tiempo_ejecucion||''','||usuario_ejecutor||' ';
						incrementa:= incrementa + 1;
					END LOOP;
					sql_insert:= sql_insert||' ) VALUES('||valores_campos||')';
					
					EXECUTE sql_insert;
					
				END IF;


				
				/****************************************************************************************************************************
				Aqui comienza el calculo y actualizacion de LISTAS DE PRECIOS(INV_PRE)
				Solo cuando el calculo sea automatico
				*****************************************************************************************************************************/
				IF inv_pre_param.id IS NOT NULL THEN 
					--RAISE EXCEPTION '%','SI HAY PARAMETROS '||emp_id;
					
					--Verificar si debe hacer el calculo automatico de listas de precios
					IF inv_pre_param.calculo_automatico THEN
						
						sql_select := '
						SELECT 
							sbt.prod_id,
							sbt.pres_id,
							sbt.moneda_id,
							--(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + (sbt.costo * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
							(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
							0::double precision AS precio_calculado1,0::double precision AS precio_calculado2, 0::double precision AS precio_calculado3, 0::double precision AS precio_calculado4, 0::double precision AS precio_calculado5, 0::double precision AS precio_calculado6, 0::double precision AS precio_calculado7, 0::double precision AS precio_calculado8, 0::double precision AS precio_calculado9, 0::double precision AS precio_calculado10
						FROM (
							SELECT 
								inv_prod.id AS  prod_id,
								inv_prod_pres_x_prod.presentacion_id AS pres_id,
								(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
								(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
								(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1  ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||'=1 THEN 1 ELSE inv_prod_cost_prom.tipo_cambio_'||mes_actual||' END) END)  AS tc,
								(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
								(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic, 
								(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
								(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
								(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
							FROM inv_prod 
							JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
							JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
							LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
							LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
							WHERE inv_prod.borrado_logico=false 
							AND inv_prod.empresa_id='||emp_id ||' AND inv_prod_cost_prom.ano='||ano_actual||' AND inv_prod.id='||fila.producto_id||' AND inv_prod_pres_x_prod.presentacion_id='||fila.presentacion_id||' 
						) AS sbt LIMIT 1;';
						
						
						FOR fila2 IN EXECUTE (sql_select) LOOP
							IF fila2.precio_minimo > 0 THEN 
								--Aqu√≠ se calculan los valores para las listas de precios
								fila2.precio_calculado1 := (CASE WHEN inv_pre_param.margen_l1=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l1/100)::double precision ) END);
								fila2.precio_calculado2 := (CASE WHEN inv_pre_param.margen_l2=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l2/100)::double precision ) END);
								fila2.precio_calculado3 := (CASE WHEN inv_pre_param.margen_l3=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l3/100)::double precision ) END);
								fila2.precio_calculado4 := (CASE WHEN inv_pre_param.margen_l4=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l4/100)::double precision ) END);
								fila2.precio_calculado5 := (CASE WHEN inv_pre_param.margen_l5=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l5/100)::double precision ) END);
								fila2.precio_calculado6 := (CASE WHEN inv_pre_param.margen_l6=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l6/100)::double precision ) END);
								fila2.precio_calculado7 := (CASE WHEN inv_pre_param.margen_l7=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l7/100)::double precision ) END);
								fila2.precio_calculado8 := (CASE WHEN inv_pre_param.margen_l8=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l8/100)::double precision ) END);
								fila2.precio_calculado9 := (CASE WHEN inv_pre_param.margen_l9=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l9/100)::double precision ) END);
								fila2.precio_calculado10 := (CASE WHEN inv_pre_param.margen_l10=0 THEN 0 ELSE fila2.precio_minimo / (1 - (inv_pre_param.margen_l10/100)::double precision ) END);
								
								--Buscar el producto y la presentacion actual el la tabla INV_PRE
								SELECT count(id) FROM inv_pre WHERE gral_emp_id=emp_id AND borrado_logico=FALSE AND inv_prod_id=fila2.prod_id AND inv_prod_presentacion_id=fila2.pres_id 
								INTO exis;
								
								IF exis > 0 THEN
									--si el Producto con la Presentacion, ya existe en la Tabla INV_PRE, hay que actualizarla
									sql_update := 'UPDATE inv_pre SET precio_1='||fila2.precio_calculado1||' ,precio_2='||fila2.precio_calculado2||' ,precio_3='||fila2.precio_calculado3||' ,precio_4='||fila2.precio_calculado4||' ,precio_5='||fila2.precio_calculado5||' ,precio_6='||fila2.precio_calculado6||' ,precio_7='||fila2.precio_calculado7||' ,precio_8='||fila2.precio_calculado8||' ,precio_9='||fila2.precio_calculado9||' ,precio_10='||fila2.precio_calculado10 ||' ,momento_actualizacion='''||espacio_tiempo_ejecucion||'''::timestamp with time zone, gral_usr_id_actualizacion='||usuario_ejecutor||''; 
									
									sql_update := sql_update||',gral_mon_id_pre1='||fila2.moneda_id||',gral_mon_id_pre2='||fila2.moneda_id||',gral_mon_id_pre3='||fila2.moneda_id||',gral_mon_id_pre4='||fila2.moneda_id||',gral_mon_id_pre5='||fila2.moneda_id||',gral_mon_id_pre6='||fila2.moneda_id||',gral_mon_id_pre7='||fila2.moneda_id||',gral_mon_id_pre8='||fila2.moneda_id||',gral_mon_id_pre9='||fila2.moneda_id||',gral_mon_id_pre10='||fila2.moneda_id;
									
									sql_update := sql_update||' WHERE gral_emp_id='||emp_id||' AND inv_prod_id='||fila2.prod_id||' AND inv_prod_presentacion_id='||fila2.pres_id||';';
									
									--RAISE EXCEPTION '%',sql_update;
									EXECUTE sql_update;
								ELSE 
									--si el producto con la presentacion no tiene registro en la tabla INV_PRE, hay que Crear el Registro
									sql_insert := 'INSERT INTO inv_pre( inv_prod_id, inv_prod_presentacion_id, gral_emp_id, momento_creacion, gral_usr_id_creacion, borrado_logico, precio_1, precio_2, precio_3, precio_4, precio_5, precio_6, precio_7, precio_8, precio_9, precio_10, gral_mon_id_pre1,gral_mon_id_pre2,gral_mon_id_pre3,gral_mon_id_pre4,gral_mon_id_pre5,gral_mon_id_pre6,gral_mon_id_pre7,gral_mon_id_pre8,gral_mon_id_pre9,gral_mon_id_pre10)
									VALUES('||fila2.prod_id||', '||fila2.pres_id||', '||emp_id||', '''||espacio_tiempo_ejecucion||'''::timestamp with time zone,'||usuario_ejecutor||',false,'||fila2.precio_calculado1||' ,'||fila2.precio_calculado2||' ,'||fila2.precio_calculado3||' ,'||fila2.precio_calculado4||' ,'||fila2.precio_calculado5||' ,'||fila2.precio_calculado6||' ,'||fila2.precio_calculado7||' ,'||fila2.precio_calculado8||' ,'||fila2.precio_calculado9||' ,'||fila2.precio_calculado10||', '||fila2.moneda_id||' ,'||fila2.moneda_id||' ,'||fila2.moneda_id||' ,'||fila2.moneda_id||' ,'||fila2.moneda_id||' ,'||fila2.moneda_id||' ,'||fila2.moneda_id||' ,'||fila2.moneda_id||' ,'||fila2.moneda_id||' ,'||fila2.moneda_id||');';
									
									EXECUTE sql_insert;
								END IF;
							END IF;
						END LOOP;
					END IF;
				END IF;
				--FINALIZA CALCULO DE PRECIOS--

				
			END LOOP;
			
		END IF;--termina accion edit
		
		valor_retorno := '1';
	END IF;--termina Control de Costos
	
	
	
	--Aplicativo Actualizador de Lista de Precios a partir de Precio Minimo
	IF app_selected = 126 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	tipo_producto
		--str_data[5]	familia
		--str_data[6]	subfamilia
		--str_data[7]	presentacion
		--str_data[8]	codigo
		--str_data[9]	producto
		--str_data[10]	aplicar_descto
		
		--str_data[11]	lista1
		--str_data[12]	lista2
		--str_data[13]	lista3
		--str_data[14]	lista4
		--str_data[15]	lista5
		--str_data[16]	lista6
		--str_data[17]	lista7
		--str_data[18]	lista8
		--str_data[19]	lista9
		--str_data[20]	lista10
		
		--str_data[21]	descto1
		--str_data[22]	descto2
		--str_data[23]	descto3
		--str_data[24]	descto4
		--str_data[25]	descto5
		--str_data[26]	descto6
		--str_data[27]	descto7
		--str_data[28]	descto8
		--str_data[29]	descto9
		--str_data[30]	descto10
		--str_data[31]	marca
		
		--select * from inv_adm_movimientos('126___update___1___35___30___25___20___15___10___5___0___0___0', array['sin datos']);
		IF command_selected = 'update' THEN
			--str_data[4]	tipo_producto
			IF str_data[4]::integer!=0 THEN
				cadena_where:=' AND inv_prod.tipo_de_producto_id='||str_data[4];
			END IF;
			
			--str_data[5]	familia
			IF str_data[5]::integer!=0 THEN
				cadena_where:=cadena_where||' AND inv_prod.inv_prod_familia_id='||str_data[5];
			END IF;
			
			--str_data[6]	subfamilia
			IF str_data[6]::integer!=0 THEN
				cadena_where:=cadena_where||' AND inv_prod.subfamilia_id='||str_data[6];
			END IF;
			
			--str_data[7]	presentacion
			IF str_data[7]::integer!=0 THEN
				cadena_where:=cadena_where||' AND inv_prod_pres_x_prod.presentacion_id='||str_data[7];
			END IF;
			
			--str_data[8]	codigo
			IF str_data[8]!='%%' AND str_data[8]!='' THEN
				cadena_where:=cadena_where||' AND inv_prod.sku ILIKE '''||str_data[8]||'''';
			END IF;

			--str_data[9]	producto
			IF str_data[9]!='%%' AND str_data[9]!='' THEN
				cadena_where:=cadena_where||' AND inv_prod.descripcion ILIKE '''||str_data[9]||'''';
			END IF;
			
			--str_data[31]	marca
			IF str_data[31]::integer!=0 THEN
				cadena_where:=cadena_where||' AND inv_prod.inv_mar_id='||str_data[31];
			END IF;
			
			
			--el precio minimo se convierte en M.N. en el query, por lo tanto el id de la moneda siempre debe ser 1.
			sql_select := '
			SELECT 
				sbt.prod_id,
				sbt.pres_id,
				sbt.moneda_id,
				sbt.tc,
				--(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + (sbt.costo * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
				(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
				0::double precision AS precio_calculado1,
				0::double precision AS precio_calculado2,
				0::double precision AS precio_calculado3,
				0::double precision AS precio_calculado4,
				0::double precision AS precio_calculado5,
				0::double precision AS precio_calculado6,
				0::double precision AS precio_calculado7,
				0::double precision AS precio_calculado8,
				0::double precision AS precio_calculado9,
				0::double precision AS precio_calculado10
			FROM (
				SELECT 
					inv_prod.id AS  prod_id,
					inv_prod_pres_x_prod.presentacion_id AS pres_id,
					(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
					(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
					(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1  ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||'=1 THEN 1 ELSE inv_prod_cost_prom.tipo_cambio_'||mes_actual||' END) END)  AS tc,
					(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
					(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic, 
					(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
					(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
					(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
				FROM inv_prod
				JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
				JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
				LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
				LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
				WHERE inv_prod.borrado_logico=false 
				AND inv_prod.empresa_id='||emp_id ||' 
				AND inv_prod_cost_prom.ano='||ano_actual||' '||cadena_where||' 
			) AS sbt;';
			
			--(CASE WHEN inv_prod_cost_prom.tipo_cambio_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.tipo_cambio_'||mes_actual||' END) AS tc,
			--RAISE EXCEPTION '%',sql_select;
			
			--obtener el tipo de cambio actual del USD
			--SELECT valor FROM erp_monedavers WHERE  momento_creacion <= now() AND moneda_id=2 ORDER BY momento_creacion DESC LIMIT 1 INTO tc_usd;
			--RAISE EXCEPTION '%','tc_usd: :'||tc_usd;
			
			--obtener el tipo de cambio actual del EUR
			--SELECT valor FROM erp_monedavers WHERE  momento_creacion <= now() AND moneda_id=3 ORDER BY momento_creacion DESC LIMIT 1 INTO tc_eur;
			
			--IF tc_usd IS NULL THEN tc_usd:=0.0; END IF;
			--IF tc_eur IS NULL THEN tc_eur:=0.0; END IF;
			
			--obtener las monedas de las listas de precios.
			--SELECT gral_mon_id_pre1 AS moneda1, gral_mon_id_pre2 AS moneda2, gral_mon_id_pre3 AS moneda3, gral_mon_id_pre4 AS moneda4, gral_mon_id_pre5 AS moneda5, gral_mon_id_pre6 AS moneda6, gral_mon_id_pre7 AS moneda7, gral_mon_id_pre8 AS moneda8, gral_mon_id_pre9 AS moneda9, gral_mon_id_pre10 AS moneda10
			--FROM inv_pre WHERE gral_emp_id=emp_id AND borrado_logico=FALSE LIMIT 1
			--INTO fila2;
			
			FOR fila IN EXECUTE (sql_select) LOOP
				
				IF fila.precio_minimo > 0 THEN 
				/*
					--aqui se hace la conversion del costo a la moneda de la lista de precio(Se llama a un procedimiento que hace la conversion)
					fila.precio_calculado1 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda1);
					fila.precio_calculado2 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda2);
					fila.precio_calculado3 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda3);
					fila.precio_calculado4 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda4);
					fila.precio_calculado5 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda5);
					fila.precio_calculado6 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda6);
					fila.precio_calculado7 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda7);
					fila.precio_calculado8 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda8);
					fila.precio_calculado9 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda9);
					fila.precio_calculado10 := conversion_costo_para_lista_precio(fila.precio_minimo, tc_usd, tc_eur, fila2.moneda10);
				*/	
					
					--Aqu√≠ se calculan los valores para las listas de precios
					fila.precio_calculado1 := (CASE WHEN str_data[11]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[11]::double precision/100)::double precision ) END);
					fila.precio_calculado2 := (CASE WHEN str_data[12]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[12]::double precision/100)::double precision ) END);
					fila.precio_calculado3 := (CASE WHEN str_data[13]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[13]::double precision/100)::double precision ) END);
					fila.precio_calculado4 := (CASE WHEN str_data[14]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[14]::double precision/100)::double precision ) END);
					fila.precio_calculado5 := (CASE WHEN str_data[15]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[15]::double precision/100)::double precision ) END);
					fila.precio_calculado6 := (CASE WHEN str_data[16]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[16]::double precision/100)::double precision ) END);
					fila.precio_calculado7 := (CASE WHEN str_data[17]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[17]::double precision/100)::double precision ) END);
					fila.precio_calculado8 := (CASE WHEN str_data[18]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[18]::double precision/100)::double precision ) END);
					fila.precio_calculado9 := (CASE WHEN str_data[19]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[19]::double precision/100)::double precision ) END);
					fila.precio_calculado10 := (CASE WHEN str_data[20]::double precision=0 THEN 0 ELSE fila.precio_minimo / (1 - (str_data[20]::double precision/100)::double precision ) END);
					
					--buscar el producto y la presentacion actual el la tabla INV_PRE
					SELECT count(id) FROM inv_pre WHERE gral_emp_id=emp_id AND borrado_logico=FALSE AND inv_prod_id=fila.prod_id AND inv_prod_presentacion_id=fila.pres_id 
					INTO exis;
					
					IF exis > 0 THEN
						--si el Producto con la Presentacion, ya existe en la Tabla INV_PRE, hay que actualizarla
						sql_update := 'UPDATE inv_pre SET precio_1='||fila.precio_calculado1||' ,precio_2='||fila.precio_calculado2||' ,precio_3='||fila.precio_calculado3||' ,precio_4='||fila.precio_calculado4||' ,precio_5='||fila.precio_calculado5||' ,precio_6='||fila.precio_calculado6||' ,precio_7='||fila.precio_calculado7||' ,precio_8='||fila.precio_calculado8||' ,precio_9='||fila.precio_calculado9||' ,precio_10='||fila.precio_calculado10 ||' ,momento_actualizacion='''||espacio_tiempo_ejecucion||'''::timestamp with time zone, gral_usr_id_actualizacion='||usuario_ejecutor||''; 
						
						IF str_data[10]::boolean = true THEN
							IF str_data[21]::double precision > 0 THEN sql_update := sql_update||',descuento_1='||str_data[21]::double precision||''; END IF;
							IF str_data[22]::double precision > 0 THEN sql_update := sql_update||',descuento_2='||str_data[22]::double precision||''; END IF;
							IF str_data[23]::double precision > 0 THEN sql_update := sql_update||',descuento_3='||str_data[23]::double precision||''; END IF;
							IF str_data[24]::double precision > 0 THEN sql_update := sql_update||',descuento_4='||str_data[24]::double precision||''; END IF;
							IF str_data[25]::double precision > 0 THEN sql_update := sql_update||',descuento_5='||str_data[25]::double precision||''; END IF;
							IF str_data[26]::double precision > 0 THEN sql_update := sql_update||',descuento_6='||str_data[26]::double precision||''; END IF;
							IF str_data[27]::double precision > 0 THEN sql_update := sql_update||',descuento_7='||str_data[27]::double precision||''; END IF;
							IF str_data[28]::double precision > 0 THEN sql_update := sql_update||',descuento_8='||str_data[28]::double precision||''; END IF;
							IF str_data[29]::double precision > 0 THEN sql_update := sql_update||',descuento_9='||str_data[29]::double precision||''; END IF;
							IF str_data[30]::double precision > 0 THEN sql_update := sql_update||',descuento_10='||str_data[30]::double precision||''; END IF;
						END IF;
						
						sql_update := sql_update||',gral_mon_id_pre1='||fila.moneda_id||',gral_mon_id_pre2='||fila.moneda_id||',gral_mon_id_pre3='||fila.moneda_id||',gral_mon_id_pre4='||fila.moneda_id||',gral_mon_id_pre5='||fila.moneda_id||',gral_mon_id_pre6='||fila.moneda_id||',gral_mon_id_pre7='||fila.moneda_id||',gral_mon_id_pre8='||fila.moneda_id||',gral_mon_id_pre9='||fila.moneda_id||',gral_mon_id_pre10='||fila.moneda_id;
						
						sql_update := sql_update||' WHERE gral_emp_id='||emp_id||' AND inv_prod_id='||fila.prod_id||' AND inv_prod_presentacion_id='||fila.pres_id||';';
						
						--RAISE EXCEPTION '%',sql_update;
						EXECUTE sql_update;
					ELSE
						--si el producto con la presentacion no tiene registro en la tabla INV_PRE, hay que Crear el Registro
						sql_insert := 'INSERT INTO inv_pre( inv_prod_id, inv_prod_presentacion_id, gral_emp_id, momento_creacion, gral_usr_id_creacion, borrado_logico, precio_1, precio_2, precio_3, precio_4, precio_5, precio_6, precio_7, precio_8, precio_9, precio_10, descuento_1,descuento_2,descuento_3,descuento_4,descuento_5,descuento_6,descuento_7,descuento_8,descuento_9,descuento_10, gral_mon_id_pre1,gral_mon_id_pre2,gral_mon_id_pre3,gral_mon_id_pre4,gral_mon_id_pre5,gral_mon_id_pre6,gral_mon_id_pre7,gral_mon_id_pre8,gral_mon_id_pre9,gral_mon_id_pre10)
						VALUES('||fila.prod_id||', '||fila.pres_id||', '||emp_id||', '''||espacio_tiempo_ejecucion||'''::timestamp with time zone,'||usuario_ejecutor||',false,'||fila.precio_calculado1||' ,'||fila.precio_calculado2||' ,'||fila.precio_calculado3||' ,'||fila.precio_calculado4||' ,'||fila.precio_calculado5||' ,'||fila.precio_calculado6||' ,'||fila.precio_calculado7||' ,'||fila.precio_calculado8||' ,'||fila.precio_calculado9||' ,'||fila.precio_calculado10||', '||str_data[21]::double precision||','||str_data[22]::double precision||','||str_data[23]::double precision||','||str_data[24]::double precision||','||str_data[25]::double precision||','||str_data[26]::double precision||','||str_data[27]::double precision||','||str_data[28]::double precision||','||str_data[29]::double precision||','||str_data[30]::double precision||','||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||' ,'||fila.moneda_id||');';
						
						EXECUTE sql_insert;
					END IF;
					
				END IF;
				
			END LOOP;

			valor_retorno := '1';
		END IF;--termina update
		
	END IF;
	--Termina Aplicativo Actualizador de Lista de Precios a partir de Precio Minimo
	
	
	
	
	--Aplicativo Orden de Devolucion
	IF app_selected = 100 THEN
		--str_data[4]	identificador
		--str_data[5]	observaciones
		--str_data[6]	accion
		
		IF command_selected = 'edit' THEN
			UPDATE inv_odev SET observaciones=str_data[5], estatus=1, momento_actualizacion=espacio_tiempo_ejecucion, momento_confirmacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor 
			WHERE id=str_data[4]::integer
			RETURNING folio, inv_mov_tipo_id, momento_confirmacion INTO folio1, tipo_movimiento_id, fecha_movimiento;
			
			INSERT INTO inv_lote_mov(
				id_referencia,--str_data[4]::integer,
				referencia,--folio1,
				inv_mov_tipo_id,--tipo_movimiento_id,
				fecha_mov,--fecha_movimiento,
				observacion,--str_data[5],
				gral_usr_id,--usuario_ejecutor,
				gral_app_id--app_selected
			)VALUES(str_data[4]::integer, folio1, tipo_movimiento_id, fecha_movimiento, str_data[5], usuario_ejecutor, app_selected) 
			RETURNING id INTO ultimo_id;
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta esta Eliminado, 0:No esta Eliminado
					--str_filas[1]	eliminado[i]
					--str_filas[2]	tipo_registro[i]
					--str_filas[3]	id_detalle[i]
					--str_filas[4]	id_almacen[i]
					--str_filas[5]	id_prod_grid[i]
					--str_filas[6]	lote_id[i]
					--str_filas[7]	lote_interno[i]
					--str_filas[8]	cant_dev[i]
					--str_filas[9]	no_tr[i]
					--str_filas[10]	id_partida[i]
					
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='LOT' THEN
						--Inicializar variables
						idUnidadMedida=0;
						nombreUnidadMedida:='';
						densidadProd:=0;
						noDecUnidad:=0;
						idUnidadMedidaVenta:=0;

						--Actualizar inv_odev_detalle
						UPDATE inv_odev_detalle SET cant_dev_lote=str_filas[8]::double precision
						WHERE id=str_filas[3]::integer
						RETURNING inv_lote_id, inv_prod_unidad_id INTO id_lote, idUnidadMedidaVenta;
						
						--Obtener la Unidad del Producto, Densidad y el numero de Decimales Permitidos
						SELECT inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec 
						FROM inv_lote
						JOIN inv_prod ON inv_prod.id=inv_lote.inv_prod_id
						LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
						WHERE inv_lote.id=id_lote 
						INTO idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;

						--Verificar que la unidad de Medida de venta no sea null y sea mayor que cero
						IF idUnidadMedidaVenta IS NOT NULL AND idUnidadMedidaVenta>0 THEN 
							--Verificar  si la Unidad de Venta es diferente a la Unidad del Producto
							IF idUnidadMedida<>idUnidadMedidaVenta THEN
								IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
								
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
								IF match_cadena=true THEN
									--Convertir a Kilos(Convertir a la Unidad de Medida del producto)
									str_filas[8] := str_filas[8]::double precision * densidadProd;
								ELSE
									EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
									IF match_cadena=true THEN
										--Convertir a Litros(Convertir a la Unidad de Medida del producto)
										str_filas[8] := str_filas[8]::double precision / densidadProd;
									END IF;
								END IF;
							END IF;
						END IF;

						--Redondear Cantidad
						str_filas[8] := round(str_filas[8]::numeric,noDecUnidad)::double precision;
						
						--Aqui entra para actualizar un LOTE
						UPDATE inv_lote SET entradas=(entradas::double precision + str_filas[8]::double precision)
						WHERE id=id_lote;
						
						--Crear registro en datalles de movimientos de Lotes
						INSERT INTO inv_lote_mov_det(inv_lote_mov_id,inv_alm_origen_id,inv_alm_destino_id,inv_lote_id,cantidad,referencia_det_id)
						VALUES(ultimo_id,0,str_filas[4]::integer,id_lote,str_filas[8]::double precision,str_filas[3]::integer);
					END IF;
				ELSE
					--str_filas[2]	tipo_registro[i]
					IF str_filas[2]='LOT' THEN
						--eliminar el registro del inv_odev_detalle
						DELETE FROM inv_odev_detalle WHERE id=str_filas[3]::integer;
					END IF;
				END IF;
			END LOOP;
			
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		END IF;--termina accion edit
		
		valor_retorno := '1';
	END IF;--termina Aplicativo Ordenes de Devolucion





	--Aplicativo Captura de Cosotos
	IF app_selected = 145 THEN
		--str_data[4]	identificador
		
		IF command_selected = 'edit' THEN
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	idreg[i]
				--str_filas[2]	idprod[i]
				--str_filas[3]	costo_ultimo[i]
				--str_filas[4]	selectMon[i]
				--str_filas[5]	tc[i]
				--str_filas[6]	notr[i]
				
				--str_filas[7]	id_pres[i]
				--str_filas[8]	igi[i]
				--str_filas[9]	gi[i]
				--str_filas[10]	ca[i]
				--str_filas[11]	margen_pmin[i]
				
				/*
				--Llamada a procedimiento que calcula el Nuevo Costo Promedio
				--El costo unitario que se le pasa debe ser en pesos(precio_unitario_mn)
				--inv_calculo_costo_promedio_producto(id_prod integer, cantidad_entrada double precision, costo_unitario_entrada double precision, espacio_tiempo_ejecucion timestamp with time zone, id_user integer)
				select * from inv_calculo_costo_promedio_producto(str_filas[4]::integer,str_filas[2]::double precision, precio_unitario_mn, espacio_tiempo_ejecucion, usuario_ejecutor) 
				INTO nuevo_costo_promedio;
				*/
				--Inicializar valor
				incrementa := 0;
				exis:=0;
				sql_insert := '';
				valores_campos:='';
				sql_update:='';
				
				

				
				/********INICIA CONVERSION DE COSTO A LA MONEDA DEFINIDA EN EL PRODUCTO*************/
				--Verificar si hay que cambiar el costo a la moneda definida en el catalogo de productos
				IF com_param.mon_prod_costo_precio THEN 
					
					--Obtener datos del producto
					select gral_mon_id, 0::double precision as tc from inv_prod where id=str_filas[2]::integer limit 1 into fila3;

					if fila3.gral_mon_id is null then 
						--Si no tiene moneda, asignar pesos por default
						fila3.gral_mon_id:=1;
					else
						if fila3.gral_mon_id=0 then 
							--Si no tiene moneda, asignar pesos por default
							fila3.gral_mon_id:=1;
						end if;
					end if;
					
					--Convertir a la moneda del producto
					if fila3.gral_mon_id<>str_filas[4]::integer then 
						if fila3.gral_mon_id=1 then 
							--Si el tipo de cambio es menor o igual a 1, entonces hay que buscar el tipo de cambio
							if str_filas[5]::double precision<=1 then 
								SELECT valor::character varying FROM erp_monedavers WHERE momento_creacion<=espacio_tiempo_ejecucion AND moneda_id=str_filas[4]::integer ORDER BY momento_creacion DESC LIMIT 1 into fila3.tc;
								
								if fila3.tc is null then 
									str_filas[5]:='0';
								else
									--Asignar tipo de cambio de la moneda del producto
									str_filas[5]:=fila3.tc::character varying;
								end if;
							end if;
							
							
							--Convertir a MN
							str_filas[3]:= (str_filas[3]::double precision * str_filas[5]::double precision)::character varying;
							
							--Asignar tipo de cambio 1
							str_filas[5]:='1';
							
							--Asignar moneda del producto
							str_filas[4]:=fila3.gral_mon_id::character varying;
						else
							--Si el tipo de cambio es menor o igual a 1, entonces hay que buscar el tipo de cambio
							if str_filas[5]::double precision<=1 then 
								SELECT valor::character varying FROM erp_monedavers WHERE momento_creacion<=espacio_tiempo_ejecucion AND moneda_id=fila3.gral_mon_id ORDER BY momento_creacion DESC LIMIT 1 into fila3.tc;
								
								if fila3.tc is null then 
									str_filas[5]:='0';
								else
									--Asignar tipo de cambio de la moneda del producto
									str_filas[5]:=fila3.tc::character varying;
								end if;
							end if;
							
							--Asignar la moneda del producto
							str_filas[4]:=fila3.gral_mon_id::character varying;
							
							--Convertir de MN a otra moneda
							str_filas[3]:= (str_filas[3]::double precision / str_filas[5]::double precision)::character varying;
						end if;
					end if;
				end if;
				/********TERMINA CONVERSION DE COSTO A LA MONEDA DEFINIDA EN EL PRODUCTO*************/
				
				
				--Buscar si ya existe un registro para el producto actual
				SELECT count(id) FROM inv_prod_cost_prom WHERE inv_prod_id=str_filas[2]::integer AND ano=ano_actual INTO exis;
				
				IF exis<=0 THEN 
					--Aqu√≠ entra para CREAR un nuevo registro
					incrementa := mes_actual + 1;
					
					--√âsta cadena almacena los campos a actualizar
					sql_insert := 'INSERT INTO inv_prod_cost_prom(inv_prod_id, ano, costo_ultimo_'||mes_actual||', tipo_cambio_'||mes_actual||', gral_mon_id_'||mes_actual||', actualizacion_'||mes_actual||' ';
					
					--En esta cadena van los valores de los campos a actualizar
					valores_campos:=''||str_filas[2]||', '||ano_actual||', '||str_filas[3]||'::double precision, '||str_filas[5]||'::double precision,'||str_filas[4]||'::integer,'''||espacio_tiempo_ejecucion||'''::timestamp with time zone';

					--Este ciclo es para repetir los valores desde el mes actual hasta el mes 12 del a√±o actual
					WHILE incrementa <= 12 LOOP
						sql_insert:=sql_insert ||', costo_ultimo_'||incrementa||', tipo_cambio_'||incrementa||', gral_mon_id_'||incrementa||', actualizacion_'||incrementa||'';
						valores_campos:=valores_campos ||', '||str_filas[3]||'::double precision, '||str_filas[5]||'::double precision,'||str_filas[4]||'::integer,'''||espacio_tiempo_ejecucion||'''::timestamp with time zone ';
						incrementa:= incrementa + 1;
					END LOOP;
					sql_insert:= sql_insert||' ) VALUES('||valores_campos||');';
					
					--RAISE EXCEPTION '%','sql_insert: '||sql_insert;
					EXECUTE sql_insert;
				ELSE
					--Aqu√≠ entra para ACTUALIZAR un registro
					incrementa := mes_actual + 1;
					
					--aqui se crea la cadena para actualizar y repetir los valores del mes actual hasta el mes 12 del a√±o actual
					sql_update := 'UPDATE inv_prod_cost_prom SET costo_ultimo_'||mes_actual||'='||str_filas[3]||'::double precision, tipo_cambio_'||mes_actual||'='||str_filas[5]||'::double precision, gral_mon_id_'||mes_actual||'='||str_filas[4]||'::integer, actualizacion_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''';
					WHILE incrementa <= 12 LOOP
						sql_update:=sql_update ||', costo_ultimo_'||incrementa||'='||str_filas[3]||'::double precision, tipo_cambio_'||incrementa||'='||str_filas[5]||'::double precision, gral_mon_id_'||incrementa||'='||str_filas[4]||'::integer, actualizacion_'||incrementa||'='''||espacio_tiempo_ejecucion||'''::timestamp with time zone ';
						incrementa:= incrementa + 1;
					END LOOP;
					sql_update:= sql_update||' WHERE ano='||ano_actual||' AND inv_prod_id='||str_filas[2]::integer||';';
					--RAISE EXCEPTION '%','sql_update: '||sql_update;
					
					--aqui ejecutamos la cadena sql
					EXECUTE sql_update;					
				END IF;
				
				
				IF com_param.captura_costo_ref THEN 
					--Aqu√≠ entra cuando tiene que actualizar valores para calculo de Costo de Referencia
					
					--inicializar valor
					incrementa := 0;
					exis:=0;
					sql_update:='';
					sql_insert:='';
					valores_campos:='';
					
					--Buscar registro en inv_prod_costos
					SELECT count(id) FROM inv_prod_costos WHERE gral_emp_id=emp_id AND ano=ano_actual AND inv_prod_id=str_filas[2]::integer AND inv_prod_presentacion_id=str_filas[7]::integer 
					INTO exis;
					
					IF exis > 0 THEN
						--Aqu√≠ entra para ACTUALIZAR un registro
						incrementa := mes_actual + 1;
						
						--aqui se crea la cadena para actualizar y repetir los valores del mes actual hasta el mes 12
						sql_update := 'UPDATE inv_prod_costos SET costo_imp_'||mes_actual||'='||str_filas[8]||', costo_dir_'||mes_actual||'='||str_filas[9]||', precio_min_'||mes_actual||'='||str_filas[11]||', costo_adic_'||mes_actual||'='||str_filas[10]||', actualizacion_'||mes_actual||'='''||espacio_tiempo_ejecucion||''', usr_id_actualiza_'||mes_actual||'='||usuario_ejecutor||'';
						WHILE incrementa <= 12 LOOP
							sql_update:=sql_update ||', costo_imp_'||incrementa||'='||str_filas[8]||', costo_dir_'||incrementa||'='||str_filas[9]||', precio_min_'||incrementa||'='||str_filas[11]||', costo_adic_'||incrementa||'='||str_filas[10]||', actualizacion_'||incrementa||'='''||espacio_tiempo_ejecucion||''', usr_id_actualiza_'||incrementa||'='||usuario_ejecutor||' ';
							incrementa:= incrementa + 1;
						END LOOP;
						sql_update:= sql_update||' WHERE gral_emp_id='||emp_id||' AND ano='||ano_actual||' AND inv_prod_id='||str_filas[2]||' AND inv_prod_presentacion_id='||str_filas[7]||';';
						--RAISE EXCEPTION '%',sql_update;
						
						--Aqui ejecutamos la cadena sql
						EXECUTE sql_update;
					ELSE
						--aqu√≠ entra para CREAR un nuevo registro
						incrementa := mes_actual + 1;
						
						--Esta cadena almacen los campos a actualizar
						sql_insert := 'INSERT INTO inv_prod_costos(gral_emp_id, ano, inv_prod_id, inv_prod_presentacion_id, costo_imp_'||mes_actual||', costo_dir_'||mes_actual||', precio_min_'||mes_actual||', costo_adic_'||mes_actual||', actualizacion_'||mes_actual||', usr_id_actualiza_'||mes_actual||' ';
						
						--En esta cadena van los valores de los campos a actualizar
						valores_campos:=''||emp_id||', '||ano_actual||', '|| str_filas[2] ||', '||str_filas[7]||', '||str_filas[8]||', '||str_filas[9]||', '||str_filas[11]||', '||str_filas[10]||', '''||espacio_tiempo_ejecucion||''','||usuario_ejecutor||'';
						
						WHILE incrementa <= 12 LOOP
							sql_insert:=sql_insert ||', costo_imp_'||incrementa||', costo_dir_'||incrementa||', precio_min_'||incrementa||', costo_adic_'||incrementa||', actualizacion_'||incrementa||', usr_id_actualiza_'||incrementa||'';
							valores_campos:=valores_campos ||', '||str_filas[8]||', '||str_filas[9]||', '||str_filas[11]||', '||str_filas[10]||', '''||espacio_tiempo_ejecucion||''','||usuario_ejecutor||' ';
							incrementa:= incrementa + 1;
						END LOOP;
						sql_insert:= sql_insert||' ) VALUES('||valores_campos||')';
						
						EXECUTE sql_insert;
					END IF;
					
					--Aqui se agrega esta condicion para tomar en cuenta la presentacion, porque el Costo Integrado Total es por presentacion
					str_filas[7]:= 'AND inv_prod_pres_x_prod.presentacion_id='||str_filas[7];
				ELSE
					--Aqui entra solo para actualizar Costo Ultimo

					--Aqui no debe llevar el filtro por presentacion.
					str_filas[7]:= '';
				END IF;
				
				
				
				
				/****************************************************************************************************************************
				Aqui comienza el calculo y actualizacion de LISTAS DE PRECIOS(INV_PRE)
				Solo cuando el calculo sea automatico
				*****************************************************************************************************************************/
				IF inv_pre_param.id IS NOT NULL THEN 
					--RAISE EXCEPTION '%','SI HAY PARAMETROS '||emp_id;
					--Inicializar en cero
					exis:=0;
					sql_select := '';
					
					--Verificar si debe hacer el calculo automatico de listas de precios
					IF inv_pre_param.calculo_automatico THEN 
						sql_select := '
						SELECT 
							sbt.prod_id,
							sbt.pres_id,
							sbt.moneda_id,
							--(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + (sbt.costo * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
							(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
							0::double precision AS precio_calculado1,0::double precision AS precio_calculado2, 0::double precision AS precio_calculado3, 0::double precision AS precio_calculado4, 0::double precision AS precio_calculado5, 0::double precision AS precio_calculado6, 0::double precision AS precio_calculado7, 0::double precision AS precio_calculado8, 0::double precision AS precio_calculado9, 0::double precision AS precio_calculado10 
						FROM (
							SELECT 
								inv_prod.id AS  prod_id,
								inv_prod_pres_x_prod.presentacion_id AS pres_id,
								(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
								(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
								(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1  ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||'=1 THEN 1 ELSE inv_prod_cost_prom.tipo_cambio_'||mes_actual||' END) END)  AS tc,
								(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
								(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic, 
								(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
								(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
								(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
							FROM inv_prod 
							JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
							JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
							LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
							LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
							WHERE inv_prod.borrado_logico=false 
							AND inv_prod.empresa_id='||emp_id ||' AND inv_prod_cost_prom.ano='||ano_actual||' AND inv_prod.id='||str_filas[2]||' '||str_filas[7]||' 
						) AS sbt LIMIT 1;';

						--RAISE EXCEPTION '%','sql_select: '||sql_select;
						
						FOR fila IN EXECUTE (sql_select) LOOP
							IF fila.precio_minimo > 0 THEN 
								--Buscar el producto y la presentacion actual el la tabla INV_PRE
								SELECT count(id) FROM inv_pre WHERE gral_emp_id=emp_id AND borrado_logico=FALSE AND inv_prod_id=fila.prod_id AND inv_prod_presentacion_id=fila.pres_id 
								INTO exis;
								
								IF exis > 0 THEN 
									--Aqui no hace nada
								ELSE 
									--Crea registro por cada presentacion en la tabla de precios 
									INSERT INTO inv_pre (inv_prod_id, inv_prod_presentacion_id, momento_creacion,borrado_logico,precio_1, precio_2, precio_3, precio_4, precio_5, precio_6, precio_7, precio_8, precio_9, precio_10, gral_mon_id_pre1, gral_mon_id_pre2, gral_mon_id_pre3, gral_mon_id_pre4, gral_mon_id_pre5, gral_mon_id_pre6, gral_mon_id_pre7, gral_mon_id_pre8, gral_mon_id_pre9, gral_mon_id_pre10, descuento_1,descuento_2,descuento_3,descuento_4,descuento_5,descuento_6,descuento_7,descuento_8,descuento_9,descuento_10,default_precio_1,default_precio_2,default_precio_3,default_precio_4,default_precio_5,default_precio_6,default_precio_7,default_precio_8,default_precio_9,default_precio_10,operacion_precio_1,operacion_precio_2,operacion_precio_3,operacion_precio_4,operacion_precio_5,operacion_precio_6,operacion_precio_7,operacion_precio_8,operacion_precio_9,operacion_precio_10,calculo_precio_1,calculo_precio_2,calculo_precio_3,calculo_precio_4,calculo_precio_5,calculo_precio_6,calculo_precio_7,calculo_precio_8,calculo_precio_9,calculo_precio_10,redondeo_precio_1,redondeo_precio_2,redondeo_precio_3,redondeo_precio_4,redondeo_precio_5,redondeo_precio_6,redondeo_precio_7,redondeo_precio_8,redondeo_precio_9,redondeo_precio_10) 
									VALUES(fila.prod_id, fila.pres_id, espacio_tiempo_ejecucion, false, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, fila.moneda_id, 0,0,0,0,0,0,0,0,0,0 ,0,0,0,0,0,0,0,0,0,0,  1,1,1,1,1,1,1,1,1,1 ,1,1,1,1,1,1,1,1,1,1,  0,0,0,0,0,0,0,0,0,0);
								END IF;
								
								
								--Inicializar
								sql_update := '';
								
								--Si el Producto con la Presentacion, ya existe en la Tabla INV_PRE, hay que actualizarla
								--Buscar parametros del producto en la tabla de precios(inv_pre)
								select * from inv_pre WHERE gral_emp_id=emp_id AND borrado_logico=FALSE AND inv_prod_id=fila.prod_id AND inv_prod_presentacion_id=fila.pres_id 
								into fila2;
								
								--calculo_precio_1(Forma de calculo) 	1=Automatico (En l√≠nea)
								--operacion_precio_1(Operacion para el calculo) 	1=Porcentaje (%)
								if fila2.id is not null then 
									if fila2.calculo_precio_1=1 then 
										if fila2.operacion_precio_1=1 then 
											fila.precio_calculado1 := (CASE WHEN fila2.default_precio_1=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_1/100)::double precision ) END);
											sql_update := sql_update|| ', precio_1='||fila.precio_calculado1||', gral_mon_id_pre1='||fila.moneda_id;
										end if;
									end if;
									
									if fila2.calculo_precio_2=1 then 
										if fila2.operacion_precio_2=1 then 
											fila.precio_calculado2 := (CASE WHEN fila2.default_precio_2=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_2/100)::double precision ) END);
											sql_update := sql_update|| ', precio_2='||fila.precio_calculado2||', gral_mon_id_pre2='||fila.moneda_id;
										end if;
									end if;
									
									if fila2.calculo_precio_3=1 then 
										if fila2.operacion_precio_3=1 then 
											fila.precio_calculado3 := (CASE WHEN fila2.default_precio_3=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_3/100)::double precision ) END);
											sql_update := sql_update|| ', precio_3='||fila.precio_calculado3||', gral_mon_id_pre3='||fila.moneda_id;
										end if;
									end if;
									
									if fila2.calculo_precio_4=1 then 
										if fila2.operacion_precio_4=1 then 
											fila.precio_calculado4 := (CASE WHEN fila2.default_precio_4=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_4/100)::double precision ) END);
											sql_update := sql_update|| ', precio_4='||fila.precio_calculado4||', gral_mon_id_pre4='||fila.moneda_id;
										end if;
									end if;
									
									if fila2.calculo_precio_5=1 then 
										if fila2.operacion_precio_5=1 then 
											fila.precio_calculado5 := (CASE WHEN fila2.default_precio_5=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_5/100)::double precision ) END);
											sql_update := sql_update|| ', precio_5='||fila.precio_calculado5||', gral_mon_id_pre5='||fila.moneda_id;
										end if;
									end if;
									
									if fila2.calculo_precio_6=1 then 
										if fila2.operacion_precio_6=1 then 
											fila.precio_calculado6 := (CASE WHEN fila2.default_precio_6=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_6/100)::double precision ) END);
											sql_update := sql_update|| ', precio_6='||fila.precio_calculado6||', gral_mon_id_pre6='||fila.moneda_id;
										end if;
									end if;
									
									if fila2.calculo_precio_7=1 then 
										if fila2.operacion_precio_7=1 then 
											fila.precio_calculado7 := (CASE WHEN fila2.default_precio_7=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_7/100)::double precision ) END);
											sql_update := sql_update|| ', precio_7='||fila.precio_calculado7||', gral_mon_id_pre7='||fila.moneda_id;
										end if;
									end if;
									
									if fila2.calculo_precio_8=1 then 
										if fila2.operacion_precio_8=1 then 
											fila.precio_calculado8 := (CASE WHEN fila2.default_precio_8=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_8/100)::double precision ) END);
											sql_update := sql_update|| ', precio_8='||fila.precio_calculado8||', gral_mon_id_pre8='||fila.moneda_id;
										end if;
									end if;
									
									if fila2.calculo_precio_9=1 then 
										if fila2.operacion_precio_9=1 then 
											fila.precio_calculado9 := (CASE WHEN fila2.default_precio_9=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_9/100)::double precision ) END);
											sql_update := sql_update|| ', precio_9='||fila.precio_calculado9||', gral_mon_id_pre9='||fila.moneda_id;
										end if;
									end if;
									
									if fila2.calculo_precio_10=1 then 
										if fila2.operacion_precio_10=1 then 
											fila.precio_calculado10 := (CASE WHEN fila2.default_precio_10=0 THEN fila.precio_minimo ELSE fila.precio_minimo / (1 - (fila2.default_precio_10/100)::double precision ) END);
											sql_update := sql_update|| ', precio_10='||fila.precio_calculado10||', gral_mon_id_pre10='||fila.moneda_id;
										end if;
									end if;
								end if;
								
								if trim(sql_update)<>'' then 
									
									sql_update := 'UPDATE inv_pre SET momento_actualizacion='''||espacio_tiempo_ejecucion||'''::timestamp with time zone, gral_usr_id_actualizacion='||usuario_ejecutor||' '||sql_update||' ';
									sql_update := sql_update||' WHERE gral_emp_id='||emp_id||' AND inv_prod_id='||fila.prod_id||' AND inv_prod_presentacion_id='||fila.pres_id||';';
									
									--RAISE EXCEPTION '%',sql_update;
									EXECUTE sql_update;
								end if;
								
							END IF;
						END LOOP;
						
					END IF;
				END IF;
				--FINALIZA CALCULO DE PRECIOS--
				
				
				
			END LOOP;
			
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		END IF;--termina accion edit
		
		valor_retorno := '1';
	END IF;
	--Termina Aplicativo Captura de Costos




	--Aplicativo Aplicativo Ordenes de Salida con Impresion de Etiqueta
	IF app_selected = 200 THEN
		--str_data[4]	identificador
		--str_data[5]	observaciones
		
		IF command_selected = 'edit' THEN 

			if (select count(id) from inv_fac where fac_doc_id=str_data[4]::integer)>0 then 
				update inv_fac set observaciones=str_data[5], momento_actualiza=espacio_tiempo_ejecucion,gral_usr_id_actualiza=usuario_ejecutor where fac_doc_id=str_data[4]::integer 
				RETURNING id INTO ultimo_id;
			else 
				insert into inv_fac(fac_doc_id,observaciones,momento_crea,gral_usr_id_crea,gral_suc_id)values(str_data[4]::integer,str_data[5],espacio_tiempo_ejecucion,usuario_ejecutor,suc_id) 
				RETURNING id INTO ultimo_id;
			end if;
			
			
			FOR iter_y IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
				SELECT INTO str_filas string_to_array(extra_data[iter_y],'___');
				--str_filas[1]	iddet[i]
				--str_filas[2]	idprod[i]
				--str_filas[3]	idpres[i]
				--str_filas[4]	oc[i]
				--str_filas[5]	lote[i]
				--str_filas[6]	fcaducidad[i]
				--str_filas[7]	cantidad[i]
				--str_filas[8]	codigo2[i]
				--str_filas[9]	seleccionado[i]
				
				if (select count(id) from inv_fac_etiqueta where fac_doc_det_id=str_filas[1]::integer and inv_prod_id=str_filas[2]::integer and inv_prod_pres_id=str_filas[3]::integer) > 0 then 
					if trim(str_filas[6])='' then 
						--Aqui no actualiza fecha porque viene vacio
						update inv_fac_etiqueta set orden_compra=str_filas[4],lote=str_filas[5],cantidad=str_filas[7]::double precision, codigo2=str_filas[8],imprimir=str_filas[9]::boolean where fac_doc_det_id=str_filas[1]::integer and inv_prod_id=str_filas[2]::integer and inv_prod_pres_id=str_filas[3]::integer;
					else 
						update inv_fac_etiqueta set orden_compra=str_filas[4],lote=str_filas[5],caducidad=str_filas[6]::date,cantidad=str_filas[7]::double precision, codigo2=str_filas[8],imprimir=str_filas[9]::boolean where fac_doc_det_id=str_filas[1]::integer and inv_prod_id=str_filas[2]::integer and inv_prod_pres_id=str_filas[3]::integer;
					end if;
				else
					if trim(str_filas[6])='' then 
						--Aqui no actualiza fecha porque viene vacio
						insert into inv_fac_etiqueta(inv_fac_id,fac_doc_det_id,inv_prod_id,inv_prod_pres_id,orden_compra,lote,cantidad,codigo2,imprimir) 
						values(ultimo_id,str_filas[1]::integer,str_filas[2]::integer,str_filas[3]::integer,str_filas[4],str_filas[5],str_filas[7]::double precision,str_filas[8],str_filas[9]::boolean);
					else 
						insert into inv_fac_etiqueta(inv_fac_id,fac_doc_det_id,inv_prod_id,inv_prod_pres_id,orden_compra,lote,caducidad,cantidad,codigo2,imprimir) 
						values(ultimo_id,str_filas[1]::integer,str_filas[2]::integer,str_filas[3]::integer,str_filas[4],str_filas[5],str_filas[6]::date,str_filas[7]::double precision,str_filas[8],str_filas[9]::boolean);
					end if;
				end if;
			END LOOP;
			
			--:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		END IF;--termina accion edit
		
		valor_retorno := '1';
	END IF;
	--Termina Aplicativo Ordenes de Salida con Impresion de Etiqueta






	
	
	
	
	RETURN valor_retorno; 

END;$$;


--
-- Name: inv_calculo_costo_promedio_producto(integer, double precision, double precision, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_calculo_costo_promedio_producto(id_prod integer, cantidad_entrada double precision, costo_unitario_entrada double precision, espacio_tiempo_ejecucion timestamp with time zone, id_user integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE
	sql_select character varying = '';
	cant_exi_actual double precision=0.0;
	costo_promedio_actual double precision=0.0;
	
	suma_costo_actual double precision=0.0;
	suma_costo_entrada double precision=0.0;
	
	nuevo_costo_promedio double precision=0.0;
BEGIN	
	
	--sacamos la existencia actual del producto
	--el tipo de busqueda es 2=Busqueda de Existencia en todos  los almacenes de la empresa
	--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
	SELECT inv_calculo_existencia_producto AS cant_exi FROM inv_calculo_existencia_producto(2,false, id_prod, id_user, 0) INTO cant_exi_actual;
	
	--sacar el costo promedio actual del mes actual del producto
	SELECT * FROM inv_obtiene_costo_promedio_actual(id_prod, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
	
	--RAISE EXCEPTION '%',sql_select;
	
	--suma el costo total de la existencia actual
	suma_costo_actual := cant_exi_actual * costo_promedio_actual;
	
	--suma el costo total de lo nuevo que esta entrando al almacen
	suma_costo_entrada:= cantidad_entrada * costo_unitario_entrada;
	
	--calcular el nuevo costo promedio
	IF costo_promedio_actual <=0 THEN
		--si el costo promedio actual es cero, solo se calcula el costo promedio de lo que esta entrando
		nuevo_costo_promedio := suma_costo_entrada / cantidad_entrada;
	ELSE
		nuevo_costo_promedio := (suma_costo_actual + suma_costo_entrada) / (cant_exi_actual + cantidad_entrada);
	END IF;
	--RAISE EXCEPTION '%',cadena_sql;
	
	IF nuevo_costo_promedio IS NULL OR nuevo_costo_promedio<=0 THEN 
		nuevo_costo_promedio:=0;
	END IF;
	
	nuevo_costo_promedio := round((nuevo_costo_promedio)::numeric,2)::double precision;
	
	RETURN nuevo_costo_promedio;
	
END;

$$;


--
-- Name: inv_calculo_existencia_producto_retorna_negativos(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_calculo_existencia_producto_retorna_negativos(id_prod integer, id_user integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE
	cadena_sql text = '';
	ano_actual integer;
	mes_actual integer;
	id_almacen integer;
	incrementa int:=1;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	existencia double precision;
BEGIN	
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--obtener id de almacen de la sucursal
  	SELECT inv_suc_alm.almacen_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id = id_user
	INTO id_almacen;

	--Si el id del almacen es null, le asignamos un cero para que no genere error al ejecutar el query
	IF id_almacen IS NULL THEN 
		id_almacen:=0;
	END IF;
	
	
	cadena_sql:= 'SELECT exi_inicial ';
	WHILE incrementa <= mes_actual LOOP
		cadena_sql:=cadena_sql ||' + entradas_'||incrementa||' - salidas_'||incrementa;
		incrementa:= incrementa + 1;
	END LOOP;
	cadena_sql:= cadena_sql||' FROM inv_exi WHERE inv_prod_id='||id_prod||' AND ano='||ano_actual||' AND inv_alm_id='||id_almacen;
	
	--RAISE EXCEPTION '%',cadena_sql;
	
	EXECUTE cadena_sql INTO existencia;
	
	IF existencia IS NULL THEN 
		existencia:=0;
	END IF;
	
	RETURN existencia;
	
END;

$$;


--
-- Name: inv_carga_inventario_fisico(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_carga_inventario_fisico(user_id integer, id_empresa integer, id_sucursal integer, tipo integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	fila record;
	cadena_sql character varying;
	cadena_sql2 character varying;
	--variables para generar consecutivos
	id_tipo_consecutivo integer=0;
	tipo_movimiento_id integer=0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
	nuevo_lote character varying = '';
	emp_id integer:=0;
	suc_id integer:=0;
	app_id integer:=0;
	ultimo_id integer:=0;
	precio_unitario_mn double precision:=0;
	id_alm_origen integer:=0;
	id_alm_destino integer:=0;
	presentacion_id integer:=0;
	exis integer:=0;
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	emp_id := id_empresa;
	suc_id := id_sucursal;
	--Aplicativo de carga de inventario fisico
	app_id:=178;
	
	id_tipo_consecutivo:=25;--Consecutivo Numero de Lote
	tipo_movimiento_id := 0;
	id_alm_origen := 0;
	id_alm_destino := 0;
	presentacion_id := 0;

	--"4";"ENTRADA AJUSTE"
	--"8";"SALIDA AJUSTE"
	
	--ACTUALIZA TABLA INV_EXI
	IF tipo=1 THEN 
		--obtiene lista de todos los prooductos
		cadena_sql:='
		SELECT 
			(CASE WHEN inv_exi.id IS NULL THEN 0 ELSE inv_exi.id END) AS id_reg,
			(CASE WHEN inv_exi.id IS NULL THEN 0 ELSE (inv_exi.exi_inicial + inv_exi.entradas_1 + inv_exi.entradas_2 + inv_exi.entradas_3 + inv_exi.entradas_4 + inv_exi.entradas_5 + inv_exi.entradas_6 + inv_exi.entradas_7 + inv_exi.entradas_8 + inv_exi.entradas_9 + inv_exi.entradas_10 + inv_exi.entradas_11 + inv_exi.entradas_12 - inv_exi.salidas_1 - inv_exi.salidas_2 - inv_exi.salidas_3 - inv_exi.salidas_4 - inv_exi.salidas_5 - inv_exi.salidas_6 - inv_exi.salidas_7 - inv_exi.salidas_8 - inv_exi.salidas_9 - inv_exi.salidas_10 - inv_exi.salidas_11 - inv_exi.salidas_12) END) AS exi_actual,
			inv_exi_tmp.prod_id, 
			inv_exi_tmp.alm_id, 
			inv_exi_tmp.exi,
			0::double precision AS diferencia  
		FROM inv_exi_tmp 
		LEFT JOIN inv_exi ON (inv_exi.inv_prod_id=inv_exi_tmp.prod_id AND inv_exi.inv_alm_id=inv_exi_tmp.alm_id AND inv_exi.ano=EXTRACT(YEAR FROM inv_exi_tmp.fecha))
		WHERE inv_exi_tmp.emp_id='||emp_id||' 
		AND inv_exi_tmp.estatus=false 
		AND EXTRACT(YEAR FROM inv_exi_tmp.fecha)='||ano_actual;
		
		FOR fila IN EXECUTE(cadena_sql) LOOP
			IF fila.exi IS NOT NULL and fila.exi::character varying<>'' THEN 
				IF fila.alm_id IS NOT NULL and fila.alm_id>0 THEN 
					cadena_sql2:='';
					tipo_movimiento_id := 0;
					id_alm_origen := 0;
					id_alm_destino := 0;
					presentacion_id := 0;
					
					IF fila.id_reg > 0 THEN 
						IF fila.exi > fila.exi_actual THEN
							--Sumar ENTRADAS
							--Tipo de Movimiento ENTRADA AJUSTE
							tipo_movimiento_id := 4;
							
							fila.diferencia:= fila.exi - fila.exi_actual::double precision;
							cadena_sql2:='UPDATE inv_exi SET entradas_'||mes_actual||'=entradas_'||mes_actual||' + '||fila.diferencia||'::double precision WHERE id='||fila.id_reg;
							
						ELSE
							--Sumar SALIDAS
							IF fila.exi < fila.exi_actual THEN
								--Tipo de Movimiento SALIDA AJUSTE
								tipo_movimiento_id := 8;
								fila.diferencia:= fila.exi_actual - fila.exi::double precision;
								cadena_sql2:='UPDATE inv_exi SET salidas_'||mes_actual||'=salidas_'||mes_actual||' + '||fila.diferencia||'::double precision WHERE id='||fila.id_reg;
							END IF;
						END IF;
					ELSE
						--Tipo de Movimiento ENTRADA AJUSTE
						tipo_movimiento_id := 4;
						fila.diferencia:=fila.exi;
						cadena_sql2:='INSERT INTO inv_exi (inv_prod_id, inv_alm_id, ano, entradas_'||mes_actual||') VALUES ('||fila.prod_id||','||fila.alm_id||','||ano_actual||','||fila.diferencia||');';
					END IF;
					
					IF cadena_sql2<>'' THEN 
						EXECUTE cadena_sql2;

						IF tipo_movimiento_id>0 THEN 
							--aqui entra para tomar el consecutivo del folio  la sucursal actual
							UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
							WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
							
							--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del Ajuste
							nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
							
							--Genera registro del movimiento
							INSERT INTO inv_mov(referencia,inv_mov_tipo_id,fecha_mov,observacion,momento_creacion,gral_usr_id,gral_app_id ) 
							VALUES(nuevo_folio,tipo_movimiento_id,espacio_tiempo_ejecucion,'ENTRADA GENERADA POR LA CARGA MASIVA DE INVENTARIO FISICO',espacio_tiempo_ejecucion,user_id,app_id) 
							RETURNING id INTO ultimo_id;
							
							--se toma el costo unitario y se asigna  a la variable para calcular el costo promedio, este costo unitario se toma por default que viene en M.N.
							precio_unitario_mn:= 0;

							IF tipo_movimiento_id=4 THEN 
								id_alm_destino := fila.alm_id;
							END IF;

							IF tipo_movimiento_id=8 THEN 
								id_alm_origen := fila.alm_id;
							END IF;
							
							--Genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad,costo, inv_prod_presentacion_id)
							VALUES(ultimo_id,id_alm_origen,id_alm_destino,fila.prod_id, fila.diferencia, precio_unitario_mn, presentacion_id);
						END IF;
						
					END IF;
				END IF;
			END IF;
		END LOOP;

	END IF;
	--TERMINA ACTUALIZACION DE TABLA INV_EXI

	
	--ACTUALIZA TABLA INV_LOTE
	IF tipo=2 THEN 
		cadena_sql:='
		SELECT 
			inv_lote_tmp.prod_id, 
			inv_lote_tmp.alm_id, 
			inv_lote_tmp.lote_int, 
			inv_lote_tmp.lote_prov,
			inv_lote_tmp.exi,
			0::double precision AS diferencia,
			0::integer as id_reg,
			0::double precision as exi_actual 
		FROM inv_lote_tmp 
		WHERE inv_lote_tmp.emp_id='||emp_id||' 
		AND inv_lote_tmp.estatus=false 
		AND EXTRACT(YEAR FROM inv_lote_tmp.fecha)='||ano_actual;

		--RAISE EXCEPTION '%',cadena_sql;




		FOR fila IN EXECUTE(cadena_sql) LOOP
			IF fila.exi IS NOT NULL and fila.exi::character varying<>'' THEN 
				IF fila.alm_id IS NOT NULL and fila.alm_id>0 THEN 
					cadena_sql2:='';
					tipo_movimiento_id := 0;
					id_alm_origen := 0;
					id_alm_destino := 0;
					presentacion_id := 0;
					exis:=0;
					fila.exi_actual:=0;

					
					SELECT count(id) FROM inv_lote 
					WHERE inv_lote.inv_prod_id=fila.prod_id AND inv_lote.inv_alm_id=fila.alm_id AND trim(inv_lote.lote_int)=trim(fila.lote_int)
					INTO exis;

					IF exis >0 THEN
						SELECT (inv_lote.inicial - inv_lote.salidas + inv_lote.entradas) AS existencia FROM inv_lote 
						WHERE inv_lote.inv_prod_id=fila.prod_id AND inv_lote.inv_alm_id=fila.alm_id AND trim(inv_lote.lote_int)=trim(fila.lote_int) 
						INTO fila.exi_actual;
						
						IF fila.exi > fila.exi_actual THEN
							--Sumar ENTRADAS
							--Tipo de Movimiento ENTRADA AJUSTE
							tipo_movimiento_id := 4;
							
							fila.diferencia:= fila.exi - fila.exi_actual::double precision;
							cadena_sql2:='UPDATE inv_lote SET entradas=entradas + '||fila.diferencia||'::double precision, lote_prov='''||fila.lote_prov||'''  WHERE inv_lote.inv_prod_id='||fila.prod_id||' AND inv_lote.inv_alm_id='||fila.alm_id||' AND trim(inv_lote.lote_int)=trim('''||fila.lote_int||''')';
						ELSE
							--Sumar SALIDAS
							IF fila.exi < fila.exi_actual THEN
								--Tipo de Movimiento SALIDA AJUSTE
								tipo_movimiento_id := 8;
								fila.diferencia:= fila.exi_actual - fila.exi::double precision;
								cadena_sql2:='UPDATE inv_lote SET salidas=salidas + '||fila.diferencia||'::double precision, lote_prov='''||fila.lote_prov||''' WHERE inv_lote.inv_prod_id='||fila.prod_id||' AND inv_lote.inv_alm_id='||fila.alm_id||' AND trim(inv_lote.lote_int)=trim('''||fila.lote_int||''')';
							END IF;
						END IF;
					ELSE
						IF fila.exi > 0 THEN
							--Tipo de Movimiento ENTRADA AJUSTE
							tipo_movimiento_id := 4;
							fila.diferencia:=fila.exi;
							
							IF trim(fila.lote_int)='' THEN 
								--Aqui se genera Nuevo Lote
								--RAISE EXCEPTION '%',fila2.lote_interno;
								--aqui entra para tomar el consecutivo del folio  la sucursal actual
								UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
								WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
								
								--convertir a hexadecimal el nuevo consecutivo
								nuevo_lote=to_hex(nuevo_consecutivo);
								
								--agregar ceros a la izquierda para acompletar 10 caracteres con lpad y convertir a mayusculas con upper
								nuevo_lote := upper(lpad(nuevo_lote, 10, '0'));
								
								fila.lote_int:=nuevo_lote;
							END IF;
							
							cadena_sql2:='INSERT INTO inv_lote (inv_prod_id, inv_alm_id, lote_int, lote_prov, inicial, momento_creacion,  momento_actualizacion, caducidad,reservado) 
							VALUES ('||fila.prod_id||','||fila.alm_id||','''||fila.lote_int||''','''||fila.lote_prov||''','||fila.diferencia||',now(), now(),''2999-12-31'',0);';

							--RAISE EXCEPTION '%',cadena_sql2;
						END IF;
					END IF;
					
					IF cadena_sql2<>'' THEN 
						EXECUTE cadena_sql2;
					END IF;

					
				END IF;
			END IF;
		END LOOP;





		
	END IF;
	--TERMINA ACTUALIZACION DE TABLA INV_LOTE

	
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: inv_existencia_producto(integer, integer, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_existencia_producto(id_almacen integer, id_prod integer, fecha_inicial character varying, id_user integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE
	/*
	Este procedimiento es para obtener la existencia de un producto. Tiene dos modalidades:
	tipo_calculo=1 : Obtiene existencia de un producto del almacen de la sucursal donde esta logueado el usuario
	tipo_calculo=2 : Obtiene existencia de un producto en todos los alacenes de la Empresa
	*/
	cadena_sql text = '';
	subquery text = '';
	fila_almacenes record;
	id_almacenes character varying := '';
	primer_registro smallint=0;
	ano integer;
	mes integer;
	emp_id integer;
	incrementa int:=1;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	existencia double precision;
BEGIN	
	
	SELECT EXTRACT(YEAR FROM  fecha_inicial::timestamp with time zone ) INTO ano;
	SELECT EXTRACT(MONTH FROM fecha_inicial::timestamp with time zone) INTO mes;
	--RAISE EXCEPTION '%','A√±o:'||ano||'mes:'||mes;
	--RAISE EXCEPTION '%','id_almacen: '||id_almacen;
	
	--obtener id de almacen de la sucursal
  	--SELECT gral_suc.empresa_id, inv_suc_alm.almacen_id FROM gral_usr_suc 
	--JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	--JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	--WHERE gral_usr_suc.gral_usr_id = id_user
	--INTO emp_id, id_almacen;

	--tipo_calculo 1=Busqueda de Existencia por un almacen en especifico
	--IF tipo_calculo = 1 THEN
	--	id_almacenes:=id_almacen;
	--END IF;
	
	--tipo_calculo 2=Busqueda de Existencia en Todos los almacenes de la Empresa
	--RAISE EXCEPTION '%',id_almacen;
	IF id_almacen != 0 THEN
		id_almacenes = id_almacen;
	END IF;
	
	IF id_almacen = 0 THEN
		--query para obtener todos los alacenes de la empresa
		cadena_sql:='SELECT distinct inv_suc_alm.almacen_id FROM gral_suc JOIN inv_suc_alm ON inv_suc_alm.sucursal_id=gral_suc.id 
				WHERE gral_suc.empresa_id='||emp_id||' ORDER BY inv_suc_alm.almacen_id;';
		
		primer_registro:=0;--variable para saber si es el primer almacen en la cadena
		FOR fila_almacenes IN EXECUTE(cadena_sql) LOOP
			if primer_registro=0 then
				id_almacenes:=id_almacenes||'';
			else
				id_almacenes:=id_almacenes||',';
			end if;
			id_almacenes:=id_almacenes||fila_almacenes.almacen_id;
			primer_registro:=1;
		END LOOP;
	END IF;
	
	
	
	--Si el id del almacen es null, le asignamos un cero para que no genere error al ejecutar el query
	IF id_almacenes IS NULL OR id_almacenes='' THEN 
		id_almacenes:='0';
	END IF;
	
	--reiniciar variable
	cadena_sql:='';
	
	--Crear formula para calcular la existencia actual del producto
	cadena_sql:= 'SELECT (exi_inicial - transito - reservado ';
	IF mes = 1 THEN
		--WHILE incrementa <= mes LOOP
		  --    cadena_sql:=cadena_sql ||' + entradas_'||incrementa||' - salidas_'||incrementa;
		    --  incrementa:= incrementa + 1;
		--END LOOP;
	ELSE
		WHILE incrementa <= mes-1 LOOP
		      cadena_sql:=cadena_sql ||' + entradas_'||incrementa||' - salidas_'||incrementa;
		      incrementa:= incrementa + 1;
		END LOOP;
	END IF;
	cadena_sql:= cadena_sql||') AS exi FROM inv_exi WHERE inv_prod_id='||id_prod||' AND ano='||ano||' AND inv_alm_id IN ('||id_almacenes||')';
	
	
	--obtiene existencia del producto
	subquery := 'SELECT sum(exi) as exi FROM ('||cadena_sql||') AS sbt;';
	
	
	--RAISE EXCEPTION '%',cadena_sql;
	
	EXECUTE subquery INTO existencia;
	
	IF existencia IS NULL OR existencia<=0 THEN 
		existencia:=0;
	END IF;

	/* EJECUTANDO EL PROCEDIMIENTO.
	   select * from inv_existencia_producto (3,233,'2013-03-21', 1)as exitencia_inicial
	   
	*/
	
	RETURN existencia;
	
END;

$$;


--
-- Name: inv_iniciar_anio(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_iniciar_anio(id_empresa integer, nuevo_anio integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	/***
	Este procedimiento es para inicar el a√±o, debe ejecutarse el 1 de enero de vada a√±o para que los datos esten disponibles para el nuevo a√±o.
	Las tablas que se afectan son:
	inv_exi(Tabla de existencias)
	inv_prod_cost_prom(Tabla de costos promedio y costo ultimo de compra por unidad)
	inv_prod_costos(Tabla de costos adicionales como: impuestos de y gastos de importacion, costo de envase o cualquier costo adicional y margen para calcular el precio minimo de venta)
	**/
	valor_retorno character varying = 'false';
	fila record;
	fila2 record;
	fila3 record;
	
	cadena_sql text;
	cadena_sql2 text;
	cadena_sql3 text;
	
BEGIN
	--Llamada al procedimiento
	--select * from inv_iniciar_anio(4, 2014);
	
	--Cadena sql para tomar los datos del a√±o anterior
	cadena_sql:='
	SELECT 
		inv_prod_cost_prom.inv_prod_id,
		inv_prod_cost_prom.costo_promedio_12 AS costo_promedio,
		inv_prod_cost_prom.costo_ultimo_12 AS costo_ultimo,
		inv_prod_cost_prom.tipo_cambio_12 AS tc,
		inv_prod_cost_prom.gral_mon_id_12 AS id_mon,
		inv_prod_cost_prom.actualizacion_12 AS actualizacion,
		inv_prod_cost_prom.factura_ultima_12 AS factura,
		inv_prod_cost_prom.oc_ultima_12 AS oc  
	FROM inv_prod_cost_prom 
	JOIN inv_prod ON inv_prod.id=inv_prod_cost_prom.inv_prod_id
	WHERE inv_prod_cost_prom.ano='||(nuevo_anio::integer-1)||' 
	AND inv_prod.empresa_id='||id_empresa||' 
	AND inv_prod.borrado_logico=false';
	--RAISE EXCEPTION '%','cadena_sql: '||cadena_sql;
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		--Crea los registros en la tabla inv_prod_cost_prom para el nuevo a√±o
		INSERT INTO inv_prod_cost_prom(inv_prod_id, ano, costo_promedio_1, costo_promedio_2, costo_promedio_3, costo_promedio_4, costo_promedio_5, costo_promedio_6, costo_promedio_7, costo_promedio_8, costo_promedio_9, costo_promedio_10, costo_promedio_11, costo_promedio_12, costo_ultimo_1, costo_ultimo_2, costo_ultimo_3, costo_ultimo_4, costo_ultimo_5, costo_ultimo_6, costo_ultimo_7, costo_ultimo_8, costo_ultimo_9, costo_ultimo_10, costo_ultimo_11, costo_ultimo_12, tipo_cambio_1, tipo_cambio_2, tipo_cambio_3, tipo_cambio_4, tipo_cambio_5, tipo_cambio_6, tipo_cambio_7, tipo_cambio_8, tipo_cambio_9, tipo_cambio_10, tipo_cambio_11, tipo_cambio_12, gral_mon_id_1, gral_mon_id_2, gral_mon_id_3, gral_mon_id_4, gral_mon_id_5, gral_mon_id_6, gral_mon_id_7, gral_mon_id_8, gral_mon_id_9, gral_mon_id_10, gral_mon_id_11, gral_mon_id_12, actualizacion_1, actualizacion_2, actualizacion_3, actualizacion_4, actualizacion_5, actualizacion_6, actualizacion_7, actualizacion_8, actualizacion_9, actualizacion_10, actualizacion_11, actualizacion_12, factura_ultima_1, factura_ultima_2, factura_ultima_3, factura_ultima_4, factura_ultima_5, factura_ultima_6, factura_ultima_7, factura_ultima_8, factura_ultima_9, factura_ultima_10, factura_ultima_11, factura_ultima_12, oc_ultima_1, oc_ultima_2, oc_ultima_3, oc_ultima_4, oc_ultima_5, oc_ultima_6, oc_ultima_7, oc_ultima_8, oc_ultima_9, oc_ultima_10, oc_ultima_11, oc_ultima_12 )
		VALUES(fila.inv_prod_id, nuevo_anio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_promedio, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.costo_ultimo, fila.tc, fila.tc, fila.tc, fila.tc, fila.tc, fila.tc, fila.tc, fila.tc, fila.tc, fila.tc, fila.tc, fila.tc, fila.id_mon, fila.id_mon, fila.id_mon, fila.id_mon, fila.id_mon, fila.id_mon, fila.id_mon, fila.id_mon, fila.id_mon, fila.id_mon, fila.id_mon, fila.id_mon, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.actualizacion, fila.factura, fila.factura, fila.factura, fila.factura, fila.factura, fila.factura, fila.factura, fila.factura, fila.factura, fila.factura, fila.factura, fila.factura, fila.oc, fila.oc, fila.oc, fila.oc, fila.oc, fila.oc, fila.oc, fila.oc, fila.oc, fila.oc, fila.oc, fila.oc);
	END LOOP;
	



	
	--Obtener datos para el Costo Referencia (CIT)
	cadena_sql2:='
	SELECT 
		inv_prod_costos.gral_emp_id,
		inv_prod_costos.inv_prod_id,
		inv_prod_costos.inv_prod_presentacion_id,
		inv_prod_costos.costo_imp_12 AS igi, 
		inv_prod_costos.costo_dir_12 AS gi, 
		inv_prod_costos.precio_min_12 AS pmin, 
		inv_prod_costos.actualizacion_12 AS actualizacion, 
		inv_prod_costos.usr_id_actualiza_12 AS id_user,
		inv_prod_costos.costo_adic_12 AS costo_adic
	FROM inv_prod_costos 
	JOIN inv_prod ON inv_prod.id=inv_prod_costos.inv_prod_id 
	JOIN inv_prod_presentaciones ON (inv_prod_presentaciones.id=inv_prod_costos.inv_prod_presentacion_id and inv_prod_presentaciones.borrado_logico=false)
	WHERE inv_prod_costos.ano='||(nuevo_anio::integer-1)||'  
	AND inv_prod_costos.gral_emp_id='||id_empresa||' 
	AND inv_prod.borrado_logico=false;';

	--RAISE EXCEPTION '%','cadena_sql2: '||cadena_sql2;
	
	FOR fila2 IN EXECUTE(cadena_sql2) LOOP
		--Crea los registros en la tabla inv_prod_costos para el nuevo a√±o
		INSERT INTO inv_prod_costos(gral_emp_id, ano, inv_prod_id, inv_prod_presentacion_id, costo_imp_1, costo_imp_2, costo_imp_3, costo_imp_4, costo_imp_5, costo_imp_6, costo_imp_7, costo_imp_8, costo_imp_9, costo_imp_10, costo_imp_11, costo_imp_12, costo_dir_1, costo_dir_2, costo_dir_3, costo_dir_4, costo_dir_5, costo_dir_6, costo_dir_7, costo_dir_8, costo_dir_9, costo_dir_10, costo_dir_11, costo_dir_12, precio_min_1, precio_min_2, precio_min_3, precio_min_4, precio_min_5, precio_min_6, precio_min_7, precio_min_8, precio_min_9, precio_min_10, precio_min_11, precio_min_12, actualizacion_1, actualizacion_2, actualizacion_3, actualizacion_4, actualizacion_5, actualizacion_6, actualizacion_7, actualizacion_8, actualizacion_9, actualizacion_10, actualizacion_11, actualizacion_12, usr_id_actualiza_1, usr_id_actualiza_2, usr_id_actualiza_3, usr_id_actualiza_4, usr_id_actualiza_5, usr_id_actualiza_6, usr_id_actualiza_7, usr_id_actualiza_8, usr_id_actualiza_9, usr_id_actualiza_10, usr_id_actualiza_11, usr_id_actualiza_12, costo_adic_1, costo_adic_2, costo_adic_3, costo_adic_4, costo_adic_5, costo_adic_6, costo_adic_7, costo_adic_8, costo_adic_9, costo_adic_10, costo_adic_11, costo_adic_12)
		VALUES(fila2.gral_emp_id, nuevo_anio, fila2.inv_prod_id, fila2.inv_prod_presentacion_id, fila2.igi, fila2.igi, fila2.igi, fila2.igi, fila2.igi, fila2.igi, fila2.igi, fila2.igi, fila2.igi, fila2.igi, fila2.igi, fila2.igi, fila2.gi, fila2.gi, fila2.gi, fila2.gi, fila2.gi, fila2.gi, fila2.gi, fila2.gi, fila2.gi, fila2.gi, fila2.gi, fila2.gi, fila2.pmin, fila2.pmin, fila2.pmin, fila2.pmin, fila2.pmin, fila2.pmin, fila2.pmin, fila2.pmin, fila2.pmin, fila2.pmin, fila2.pmin, fila2.pmin, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.actualizacion, fila2.id_user, fila2.id_user, fila2.id_user, fila2.id_user, fila2.id_user, fila2.id_user, fila2.id_user, fila2.id_user, fila2.id_user, fila2.id_user, fila2.id_user, fila2.id_user, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic, fila2.costo_adic);
	END LOOP;




	
	--Obtener existencia actual de cada producto
	cadena_sql3:='
	SELECT 
		inv_exi.inv_prod_id,
		inv_exi.inv_alm_id,
		inv_exi.ano,
		(exi_inicial + entradas_1 + entradas_2 + entradas_3 + entradas_4 + entradas_5 + entradas_6 + entradas_7 + entradas_8 + entradas_9 + entradas_10 + entradas_11 + entradas_12 - salidas_1 - salidas_2 - salidas_3 - salidas_4 - salidas_5 - salidas_6 - salidas_7 - salidas_8 - salidas_9 - salidas_10 - salidas_11 - salidas_12 ) AS exi,
		inv_exi.transito,
		inv_exi.reservado,
		costo_ultimo_12 AS costo_ultimo 
	FROM inv_exi
	JOIN inv_prod ON inv_prod.id=inv_exi.inv_prod_id
	WHERE inv_exi.ano='||(nuevo_anio::integer-1)||' 
	AND inv_prod.empresa_id='||id_empresa||' 
	AND inv_prod.borrado_logico=false;';
	--RAISE EXCEPTION '%','cadena_sql3: '||cadena_sql3;
	
	FOR fila3 IN EXECUTE(cadena_sql3) LOOP
		--Crea los registros en la tabla inv_exi para el nuevo a√±o.
		--La existencia del a√±o anterior se carga en el campo exi_inicial
		INSERT INTO inv_exi(ano,inv_prod_id, inv_alm_id, exi_inicial, transito, reservado, entradas_1, entradas_2, entradas_3, entradas_4, entradas_5, entradas_6, entradas_7, entradas_8, entradas_9, entradas_10, entradas_11, entradas_12, salidas_1, salidas_2, salidas_3, salidas_4, salidas_5, salidas_6, salidas_7, salidas_8, salidas_9, salidas_10, salidas_11, salidas_12,costo_ultimo_1, costo_ultimo_2, costo_ultimo_3, costo_ultimo_4, costo_ultimo_5, costo_ultimo_6, costo_ultimo_7, costo_ultimo_8, costo_ultimo_9, costo_ultimo_10, costo_ultimo_11, costo_ultimo_12 )
		VALUES(nuevo_anio,fila3.inv_prod_id, fila3.inv_alm_id, fila3.exi, fila3.transito, fila3.reservado, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo, fila3.costo_ultimo);
	END LOOP;

	

	--Retorna un TRUE, si todo salio bien
	valor_retorno:='true';
	return valor_retorno;
END	
	
$$;


--
-- Name: inv_obtiene_costo_promedio_actual(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_obtiene_costo_promedio_actual(id_prod integer, espacio_tiempo_ejecucion timestamp with time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE
	ano_actual integer;
	mes_actual integer;
	sql_select character varying = '';
	costo_promedio_actual double precision=0.0;
	
BEGIN	
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--sacar el costo promedio actual del mes actual
	sql_select := 'SELECT costo_promedio_'||mes_actual||' FROM inv_prod_cost_prom WHERE inv_prod_id='||id_prod||'::integer AND ano='||ano_actual||';';
	EXECUTE sql_select INTO costo_promedio_actual;
	
	--RAISE EXCEPTION '%',cadena_sql;
	
	IF costo_promedio_actual IS NULL OR costo_promedio_actual<=0 THEN 
		costo_promedio_actual:=0;
	END IF;
	
	RETURN costo_promedio_actual;
	
END;

$$;


--
-- Name: inv_reporte(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_reporte(campos_data character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE
	app_selected integer;
	command_selected character varying;
	usuario_ejecutor integer;
	emp_id integer;
	suc_id integer;
	str_data text[];
	exis integer=0;
	
	cadena_sql text = '';
	cadena_sql2 character varying='';
	cadena_where text = '';
	cadena_where2 character varying = '';
	cadena_campos text = '';
	ano_actual integer;
	mes_actual integer;
	id_almacen integer;
	incrementa int:=1;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	existencia double precision;
	fila record;
	equivalenciaPres double precision=0;
BEGIN	
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	app_selected:=str_data[1]::integer;--app_selected
	usuario_ejecutor:=str_data[2]::integer;--id_usuario
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	INTO emp_id, suc_id;
	
	
	--Busqueda de Productos para Aplicativo Control de Costos
	IF app_selected = 125 THEN
		--str_data[3]	tipo_prod
		--str_data[4]	mar
		--str_data[5]	fam
		--str_data[6]	subfam
		--str_data[7]	producto
		--str_data[8]	pres
		--str_data[9]	tipo_costo;
		--str_data[10]	tipo_busqueda;--false=Solo Busqueda de datos, true=Simulacion(Calculo de costos de acuerdo a parametros)
		--str_data[11]	importacion
		--str_data[12]	directo
		--str_data[13]	pminimo
		--str_data[14]	tipo_cambio
		--str_data[15]	codigo
		--str_data[16]	a√±o
		--str_data[17]	mes
		--str_data[18]	costo_adic
		
		IF str_data[16]::integer > 0 THEN
			ano_actual:=str_data[16]::integer;
		END IF;
		
		IF str_data[17]::integer > 0 THEN
			mes_actual:=str_data[17]::integer;
		END IF;
		
		--tipo de producto
		IF str_data[3]::integer!=0 THEN
			cadena_where:=' AND inv_prod.tipo_de_producto_id='||str_data[3];
		END IF;
		
		--marca
		IF str_data[4]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.inv_mar_id='||str_data[4];
		END IF;
		
		--familia
		IF str_data[5]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.inv_prod_familia_id='||str_data[5];
		END IF;
		
		--SubFamilia
		IF str_data[6]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.subfamilia_id='||str_data[6];
		END IF;
		
		--str_data[7]	producto
		IF str_data[7]!='%%' AND str_data[7]!='' THEN
			cadena_where:=cadena_where||' AND inv_prod.descripcion ILIKE '''||str_data[7]||'''';
		END IF;

		--str_data[15]	codigo
		IF str_data[15]!='%%' AND str_data[15]!='' THEN
			cadena_where:=cadena_where||' AND inv_prod.sku ILIKE '''||str_data[15]||'''';
		END IF;
		
		--str_data[8]	pres
		IF str_data[8]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod_presentaciones.id='||str_data[8];
		END IF;
		
		--str_data[9]	tipo_costo
		IF str_data[9]::integer=1 THEN
			cadena_campos:=' inv_prod_cost_prom.costo_ultimo_'||mes_actual||' AS costo,
					inv_prod_cost_prom.tipo_cambio_'||mes_actual||' AS tipo_cambio,
					inv_prod_cost_prom.gral_mon_id_'||mes_actual||'::integer AS moneda_id, ';
			
			--el la moneda del Precio Minimo siempre sera en pesos
			--cadena_campos:=cadena_campos||'1::integer AS moneda_pm_id, ';
			
			
			IF str_data[10]='false' THEN 
				--si no es simulacion, el calculo se hace con la moneda de la factura
				cadena_campos:=cadena_campos||'inv_prod_cost_prom.gral_mon_id_'||mes_actual||'::integer AS moneda_pm_id, ';
			ELSE
				--si √©s simulacion, el calculo se hace en M.N.
				cadena_campos:=cadena_campos||'1::integer AS moneda_pm_id, ';
			END IF;	
			
		ELSE
			cadena_campos:=' inv_prod_cost_prom.costo_promedio_'||mes_actual||' AS costo,
					1::double precision AS tipo_cambio,
					1::integer AS moneda_id, 
					1::integer AS moneda_pm_id, ';
		END IF;
		
		cadena_sql:= '
		SELECT
			sbt.producto_id,
			sbt.codigo,
			sbt.descripcion,
			sbt.unidad,
			sbt.presentacion_id,
			sbt.presentacion,
			sbt.orden_compra,
			sbt.factura_prov,
			(CASE WHEN gral_mon.descripcion_abr IS NULL THEN '''' ELSE gral_mon.descripcion_abr END ) AS moneda, 
			sbt.costo_adic,
			sbt.costo,
			sbt.tipo_cambio,
			sbt.moneda_id, 
			sbt.costo_importacion, 
			sbt.costo_directo, 
			sbt.costo_referencia, 
			sbt.precio_minimo,
			(CASE WHEN tbl_mon2.descripcion_abr IS NULL THEN '''' ELSE tbl_mon2.descripcion_abr END ) AS moneda_pm
			--sbt.tipo_prod_id
		FROM (
			SELECT 
				inv_prod.id AS producto_id,
				inv_prod.sku AS codigo,
				inv_prod.descripcion,
				inv_prod.tipo_de_producto_id AS tipo_prod_id,
				inv_prod_unidades.titulo AS unidad,
				inv_prod_presentaciones.id AS presentacion_id, 
				inv_prod_presentaciones.titulo AS presentacion,
				(CASE WHEN inv_prod_cost_prom.oc_ultima_'||mes_actual||' IS NULL THEN '''' ELSE inv_prod_cost_prom.oc_ultima_'||mes_actual||' END ) AS orden_compra, 
				(CASE WHEN inv_prod_cost_prom.factura_ultima_'||mes_actual||' IS NULL THEN '''' ELSE inv_prod_cost_prom.factura_ultima_'||mes_actual||' END) AS factura_prov,  
				(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE costo_adic_'||mes_actual||'::double precision END ) AS costo_adic,  
				'||cadena_campos||' 
				(CASE WHEN costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (costo_imp_'||mes_actual||'/100)::double precision END ) AS costo_importacion,  
				(CASE WHEN costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (costo_dir_'||mes_actual||'/100)::double precision END ) AS costo_directo, 
				(CASE WHEN precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (precio_min_'||mes_actual||'/100)::double precision END ) AS precio_minimo,
				0::double precision AS costo_referencia, 
				''''::character varying AS moneda_pm 
			FROM inv_prod
			JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
			JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
			JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
			LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
			LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_presentaciones.id AND inv_prod_costos.ano='||ano_actual||') 
			WHERE inv_prod.borrado_logico=false 
			AND inv_prod.empresa_id='||emp_id||' 
			AND inv_prod_cost_prom.ano='||ano_actual||' '||cadena_where||' 
		) AS sbt 
		LEFT JOIN gral_mon ON gral_mon.id=sbt.moneda_id
		LEFT JOIN gral_mon AS tbl_mon2 ON tbl_mon2.id=sbt.moneda_pm_id;';
		
		--RAISE EXCEPTION '%',cadena_sql;
		FOR fila IN EXECUTE (cadena_sql) LOOP

			/*
			1;"Prod. Terminado"
			2;"Prod. Intermedio"
			3;"Kit"
			4;"Servicios"
			5;"Refacciones"
			6;"Accesorios"
			7;"Materia Prima"
			8;"Prod. en Desarrollo"
			*/
			/*
			IF fila.tipo_prod_id=1 OR fila.tipo_prod_id=2 OR fila.tipo_prod_id=8 OR fila.tipo_prod_id=3 THEN 
				--aqui entra a buscar costos
				
				
				
				IF fila.tipo_prod_id=3 THEN 
					
				END IF;
			END IF;
			*/
			
			--str_data[10]	tipo_busqueda
			--aqui se revisa el tipo de Busqueda
			--si es false, entonces solo hay que buscar los costos y hacer calculos con porcentajes guardados
			IF str_data[10]='false' THEN 
				SELECT count(id) FROM inv_prod_costos WHERE gral_emp_id=emp_id AND ano=ano_actual AND inv_prod_id=fila.producto_id AND inv_prod_presentacion_id=fila.presentacion_id 
				INTO exis;
				
				IF exis > 0 THEN

					--fila.moneda_id trae la moneda en la que viene el costo ultimo
					IF fila.moneda_id=1 THEN 
						--SI fila.moneda_id=1, entonces utilizaremos tipo de cambio=1, esto hara que la trasformacion a pesos quede igual
						fila.tipo_cambio:= 1.0000;
					END IF;
					
					--convertir el costo en M.N.
					--fila.costo:= fila.costo * fila.tipo_cambio;
					
					--calcula costo Importacion de acuerdo al porcentaje de costo Importacion
					fila.costo_importacion:= fila.costo * fila.costo_importacion;
					
					--calcula costo directo de acuerdo al porcentaje de costo directo
					--fila.costo_directo:= fila.costo * fila.costo_directo;
					fila.costo_directo:= (fila.costo + fila.costo_importacion) * fila.costo_directo;
					
					--calcular costo de referencia
					fila.costo_referencia:= fila.costo + fila.costo_importacion + fila.costo_directo + fila.costo_adic;
					
					--calcula el precio Minimo de Venta 
					--fila.precio_minimo:= fila.costo_referencia + (fila.costo_referencia * fila.precio_minimo);
					IF fila.precio_minimo=0 THEN 
						fila.precio_minimo:= fila.costo_referencia;
					ELSE
						fila.precio_minimo:= fila.costo_referencia / (1 - fila.precio_minimo);
					END IF;
				END IF;
			ELSE
				--si es true, quiere decir que es SIMULACION
				--entonces hay que hacer calculo con porcentajes que vienen como parametros desde la vista
				--fila.moneda_id trae la moneda en la que viene el costo ultimo
				IF fila.moneda_id=1 THEN 
					--SI fila.moneda_id=1, entonces utilizaremos tipo de cambio=1, esto hara que la trasformacion a pesos quede igual
					fila.tipo_cambio:= 1.0000;
				ELSE
					--SI fila.moneda_id != 1, entonces tomamos el tipo de cambio que viene de la vista para transformar el costo ultimo a pesos
					fila.tipo_cambio:= str_data[14]::double precision;
				END IF;

				--Tomar el valor de Costo Adicional que viene de la vista
				fila.costo_adic := str_data[18]::double precision;
				
				--Convertir el costo en M.N.
				fila.costo:= fila.costo * fila.tipo_cambio;
				--fila.costo_adic:= fila.costo_adic * fila.tipo_cambio;
				
				
				--calcula costo Importacion de acuerdo al porcentaje de costo Importacion del parametro
				fila.costo_importacion:= fila.costo * (str_data[11]::double precision/100)::double precision;
				
				--calcula costo directo de acuerdo al porcentaje de costo directo del parametro
				--fila.costo_directo:= fila.costo * (str_data[12]::double precision/100)::double precision;
				fila.costo_directo:= (fila.costo + fila.costo_importacion) * (str_data[12]::double precision/100)::double precision;
				
				--calcular costo de referencia
				fila.costo_referencia:= fila.costo + fila.costo_importacion + fila.costo_directo + fila.costo_adic;
				
				--calcula el precio Minimo de Venta de acuerdo al porcentaje  del parametro
				--fila.precio_minimo:= fila.costo_referencia + (fila.costo_referencia * (str_data[13]::double precision/100)::double precision);
				fila.precio_minimo:= fila.costo_referencia / (1 - (str_data[13]::double precision/100)::double precision)::double precision;
			END IF;

			/*
			--Obtener la equivalencia de la Presentacion en la Unidad de Medida definida
			SELECT (CASE WHEN cantidad IS NULL THEN 1 WHEN cantidad=0 THEN 1 ELSE cantidad END) FROM inv_prod_presentaciones 
			WHERE id=fila.presentacion_id::integer
			INTO equivalenciaPres;

			IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;

			--Calcular el precio minimo de acuerdo a la Presentacion
			fila.precio_minimo := fila.precio_minimo::double precision * equivalenciaPres::double precision;
			*/
			
			RETURN NEXT fila;
		END LOOP;
		
	END IF;
	--Termina buscador para Aplicativo Control de Costos
	
	
	
	
	
	--Actualizador lista de Precios a partir de Precio Minimo
	IF app_selected = 126 THEN
		command_selected = str_data[3];
		--str_data[4]	tipo_producto
		--str_data[5]	marca
		--str_data[6]	familia
		--str_data[7]	subfamilia
		--str_data[8]	codigo
		--str_data[9]	producto
		--str_data[10]	presentacion;
		
		--tipo de producto
		IF str_data[4]::integer!=0 THEN
			cadena_where:=' AND inv_prod.tipo_de_producto_id='||str_data[4];
		END IF;
		
		--marca
		IF str_data[5]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.inv_mar_id='||str_data[5];
		END IF;
		
		--familia
		IF str_data[6]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.inv_prod_familia_id='||str_data[6];
		END IF;
		
		--SubFamilia
		IF str_data[7]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod.subfamilia_id='||str_data[7];
		END IF;
		
		--str_data[8]	codigo
		IF str_data[8]!='%%' AND str_data[8]!='' THEN
			cadena_where:=cadena_where||' AND inv_prod.sku ILIKE '''||str_data[8]||'''';
		END IF;
		
		--str_data[9]	producto
		IF str_data[9]!='%%' AND str_data[9]!='' THEN
			cadena_where:=cadena_where||' AND inv_prod.descripcion ILIKE '''||str_data[9]||'''';
		END IF;
		
		--str_data[10]	pres
		IF str_data[10]::integer!=0 THEN
			cadena_where:=cadena_where||' AND inv_prod_pres_x_prod.presentacion_id='||str_data[10];
		END IF;
		
		--BUSQUEDA PARA EL PAGINADO
		IF command_selected='paginado' THEN 
			
			cadena_sql:= '
				SELECT 
					sbt.prod_id,
					sbt.codigo,
					sbt.descripcion,
					sbt.unidad,
					sbt.pres_id,
					sbt.presentacion,
					sbt.moneda_id,
					(CASE WHEN gral_mon.descripcion_abr IS NULL THEN '''' ELSE gral_mon.descripcion_abr END ) AS moneda, 
					sbt.tc,
					--(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + (sbt.costo * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo 
					(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo 
				FROM (
					SELECT 
						inv_prod.id AS  prod_id,
						inv_prod.sku AS codigo,
						inv_prod.descripcion,
						inv_prod_unidades.titulo AS unidad,
						inv_prod_pres_x_prod.presentacion_id AS pres_id,
						inv_prod_presentaciones.titulo AS presentacion,
						(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
						(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
						(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1  ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||'=1 THEN 1 ELSE inv_prod_cost_prom.tipo_cambio_'||mes_actual||' END) END)  AS tc,
						(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
						(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic,  
						(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
						(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
						(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
					FROM inv_prod
					JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
					JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
					LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
					LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
					WHERE inv_prod.borrado_logico=false 
					AND inv_prod.empresa_id='||emp_id||' 
					AND inv_prod_cost_prom.ano='||ano_actual||' '||cadena_where||' 
				) AS sbt
				LEFT JOIN gral_mon ON gral_mon.id=sbt.moneda_id;';
				
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP
				RETURN NEXT fila;
			END LOOP;
		END IF;
		--termina BUSQUEDA PARA EL PAGINADO---------
		
		
		
		
		--BUSQUEDA PARA EL REPORTE(PDF)-------------
		IF command_selected='reporte' THEN 
			
			cadena_sql:= '
				SELECT 
					sbt.codigo,
					sbt.descripcion,
					sbt.unidad,
					sbt.presentacion,
					(CASE WHEN gral_mon.descripcion_abr IS NULL THEN '''' ELSE gral_mon.descripcion_abr END ) AS moneda, 
					--(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + (sbt.costo * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
					(CASE WHEN sbt.costo > 0 THEN (sbt.costo + sbt.costo_adic + (sbt.costo * sbt.igi) + ((sbt.costo + (sbt.costo * sbt.igi)) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
					--(CASE WHEN sbt.costo > 0 THEN ((sbt.costo * sbt.tc) + ((sbt.costo * sbt.tc) * sbt.igi) + ((sbt.costo * sbt.tc) * sbt.gi))/(1 - sbt.pmin) ELSE 0 END) AS precio_minimo,
					inv_pre.precio_1,
					inv_pre.precio_2,
					inv_pre.precio_3,
					inv_pre.precio_4,
					inv_pre.precio_5,
					inv_pre.precio_6,
					inv_pre.precio_7,
					inv_pre.precio_8,
					inv_pre.precio_9,
					inv_pre.precio_10,
					tblmon1.simbolo AS mon1,
					tblmon2.simbolo AS mon2,
					tblmon3.simbolo AS mon3,
					tblmon4.simbolo AS mon4,
					tblmon5.simbolo AS mon5,
					tblmon6.simbolo AS mon6,
					tblmon7.simbolo AS mon7,
					tblmon8.simbolo AS mon8,
					tblmon9.simbolo AS mon9,
					tblmon10.simbolo AS mon10
				FROM ( 
					SELECT 
						inv_prod.id AS  prod_id,
						inv_prod.sku AS codigo,
						inv_prod.descripcion,
						inv_prod_unidades.titulo_abr AS unidad,
						inv_prod_pres_x_prod.presentacion_id AS pres_id,
						inv_prod_presentaciones.titulo AS presentacion,
						(CASE WHEN inv_prod_presentaciones.cantidad IS NULL THEN 1 ELSE inv_prod_presentaciones.cantidad END) AS equiv_pres,
						(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END) AS costo,
						(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1  ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||'=1 THEN 1 ELSE inv_prod_cost_prom.tipo_cambio_'||mes_actual||' END) END)  AS tc,
						(CASE WHEN inv_prod_cost_prom.gral_mon_id_'||mes_actual||' IS NULL THEN 1 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END) AS moneda_id,
						--1::integer AS moneda_id,
						(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||'::double precision END ) AS costo_adic, 
						(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_imp_'||mes_actual||'/100)::double precision END ) AS igi,  
						(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.costo_dir_'||mes_actual||'/100)::double precision END ) AS gi, 
						(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE (inv_prod_costos.precio_min_'||mes_actual||'/100)::double precision END ) AS pmin
					FROM inv_prod 
					JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
					JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
					LEFT JOIN inv_prod_cost_prom ON inv_prod_cost_prom.inv_prod_id=inv_prod.id
					LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
					WHERE inv_prod.borrado_logico=false 
					AND inv_prod.empresa_id='||emp_id||' 
					AND inv_prod_cost_prom.ano='||ano_actual||' '||cadena_where||' 
				) AS sbt 
				JOIN inv_pre ON (inv_pre.inv_prod_id=sbt.prod_id AND inv_pre.inv_prod_presentacion_id=sbt.pres_id )
				LEFT JOIN gral_mon ON gral_mon.id=sbt.moneda_id 
				LEFT JOIN gral_mon AS tblmon1 ON tblmon1.id=inv_pre.gral_mon_id_pre1
				LEFT JOIN gral_mon AS tblmon2 ON tblmon2.id=inv_pre.gral_mon_id_pre2
				LEFT JOIN gral_mon AS tblmon3 ON tblmon3.id=inv_pre.gral_mon_id_pre3
				LEFT JOIN gral_mon AS tblmon4 ON tblmon4.id=inv_pre.gral_mon_id_pre4
				LEFT JOIN gral_mon AS tblmon5 ON tblmon5.id=inv_pre.gral_mon_id_pre5
				LEFT JOIN gral_mon AS tblmon6 ON tblmon6.id=inv_pre.gral_mon_id_pre6
				LEFT JOIN gral_mon AS tblmon7 ON tblmon7.id=inv_pre.gral_mon_id_pre7
				LEFT JOIN gral_mon AS tblmon8 ON tblmon8.id=inv_pre.gral_mon_id_pre8
				LEFT JOIN gral_mon AS tblmon9 ON tblmon9.id=inv_pre.gral_mon_id_pre9
				LEFT JOIN gral_mon AS tblmon10 ON tblmon10.id=inv_pre.gral_mon_id_pre10;';
			
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP
				RETURN NEXT fila;
			END LOOP;
		END IF;
		--TERMINA BUSQUEDA PARA EL REPORTE(PDF)
		
	END IF;
	--Termina buscador Actualizador lista de Precios a partir de Precio Minimo
	
	
	
	
	--Reporte de Existencias en Inventario
	IF app_selected = 133 THEN
		command_selected = str_data[3];
		--str_data[4]	almacen
		--str_data[5]	codigo
		--str_data[6]	descripcion
		--str_data[7]	tipo_reporte
		--str_data[8]	tipo_costo
		--str_data[9]	tipo_prod
		
		--BUSQUEDA PARA EL REPORTE-------------
		IF command_selected='reporte' THEN 
			--cadena_sql:= '
			
			--tipo general
			IF str_data[7]::integer=1 THEN
				cadena_where:='';
			END IF;
			
			--tipo solo con existencias
			IF str_data[7]::integer=2 THEN
				cadena_where:=' WHERE existencia > 0';
			END IF;
			
			--tipo solo sin existencias
			IF str_data[7]::integer=3 THEN
				cadena_where:=' WHERE existencia <=0';
			END IF;
			
			--tipo solo valor m√≠nimo
			IF str_data[7]::integer=4 THEN
				cadena_where:=' WHERE existencia <= valor_minimo';
			END IF;
			
			--tipo solo valor m√°ximo
			IF str_data[7]::integer=5 THEN
				cadena_where:=' WHERE existencia >= valor_maximo';
			END IF;

			--tipo solo punto de reorden
			IF str_data[7]::integer=6 THEN
				cadena_where:=' WHERE existencia <= punto_reorden';
			END IF;

			--Tipo de producto
			IF str_data[9]::integer > 0 THEN
				cadena_where2 :=' AND inv_prod.tipo_de_producto_id='||str_data[9]||' ';
			END IF;
			
			cadena_sql:= '
			SELECT 
				sbt.id,
				valor_minimo,
				valor_maximo,
				punto_reorden,
				almacen,
				familia,
				grupo,
				linea,
				codigo_producto,
				titulo,
				unidad,
				existencia,
				costo_unitario,
				(existencia * costo_unitario) AS costo_total,
				(CASE WHEN gral_mon.id IS NULL THEN 0 ELSE gral_mon.id END) AS moneda_id,
				(CASE WHEN gral_mon.simbolo IS NULL THEN '''' ELSE gral_mon.descripcion_abr END) AS simbolo_moneda
			FROM (
				SELECT  inv_prod.id,
					inv_prod.valor_minimo,
					inv_prod.valor_maximo,
					inv_prod.punto_reorden,
					inv_alm.titulo AS almacen,
					''''::character varying AS familia,
					''''::character varying AS grupo,
					(CASE WHEN inv_prod_lineas.titulo IS NULL THEN '''' ELSE inv_prod_lineas.titulo END) AS linea,
					inv_prod.sku AS codigo_producto,
					inv_prod.descripcion AS titulo,
					inv_prod_unidades.titulo AS unidad,
					(inv_exi.exi_inicial - inv_exi.transito -inv_exi.reservado ';
					
					WHILE incrementa <= mes_actual LOOP
						cadena_sql:=cadena_sql ||' + inv_exi.entradas_'||incrementa||' - inv_exi.salidas_'||incrementa;
						incrementa:= incrementa + 1;
					END LOOP;
					
					cadena_sql:= cadena_sql||'
					) AS existencia,
					(CASE WHEN 1='||str_data[8]||' THEN
						(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_ultimo_'||mes_actual||' END)
					ELSE
						(CASE WHEN inv_prod_cost_prom.costo_promedio_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.costo_promedio_'||mes_actual||' END)
					END) AS costo_unitario,
					(CASE WHEN 1='||str_data[8]||' THEN
						(CASE WHEN inv_prod_cost_prom.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_cost_prom.gral_mon_id_'||mes_actual||' END)
					ELSE
						(CASE WHEN inv_prod_cost_prom.costo_promedio_'||mes_actual||' IS NULL THEN 0 ELSE 1 END)
					END) AS moneda_id
				FROM inv_exi 
				JOIN inv_alm ON inv_alm.id=inv_exi.inv_alm_id
				JOIN inv_prod ON (inv_prod.id=inv_exi.inv_prod_id and inv_prod.borrado_logico=false) 
				JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				LEFT JOIN inv_prod_cost_prom ON (inv_prod_cost_prom.inv_prod_id=inv_prod.id AND inv_prod_cost_prom.ano='||ano_actual||' )
				LEFT JOIN gral_mon ON gral_mon.id=inv_prod_cost_prom.gral_mon_id_'||mes_actual||'
				LEFT JOIN inv_prod_lineas ON inv_prod_lineas.id=inv_prod.inv_prod_linea_id
				WHERE inv_exi.ano='||ano_actual||' 
				AND inv_exi.inv_alm_id='||str_data[4]||' '||cadena_where2||' 
				AND inv_prod.sku ILIKE '''||str_data[5]||''' 
				AND inv_prod.descripcion ILIKE '''||str_data[6]||'''
			) AS sbt 
			LEFT JOIN gral_mon ON gral_mon.id=sbt.moneda_id
			'||cadena_where ||';';
			
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP
				RETURN NEXT fila;
			END LOOP;
			
		END IF;
		--TERMINA BUSQUEDA PARA EL REPORTE
		
	END IF;--termina Reporte de Existencias en Inventario
	
	
	--Reporte de Existencias por Presentaciones
	IF app_selected = 139 THEN
		command_selected = str_data[3];
		--str_data[4]	tipo
		--str_data[5]	almacen
		--str_data[6]	codigo
		--str_data[7]	descripcion
		--str_data[8]	presentacion
		
		--tipo solo con existencias
		IF str_data[4]::integer=2 THEN
			cadena_where:=' WHERE exis_pres > 0';
		END IF;
		
		--tipo solo sin existencias
		IF str_data[4]::integer=3 THEN
			cadena_where:=' WHERE exis_pres <=0';
		END IF;
		
		--tipo solo sin existencias
		IF str_data[8]::integer !=0 THEN
			IF cadena_where='' THEN 
				cadena_where = ' WHERE idpres='||str_data[8];
			ELSE
				cadena_where:= cadena_where ||' AND idpres='||str_data[8];
			END IF;
			
		END IF;
		
		--BUSQUEDA PARA EL REPORTE-------------
		IF command_selected='reporte' THEN 
			cadena_sql:= '
			SELECT 
				codigo,
				descripcion,
				unidad,
				no_dec,
				idpres,
				presentacion,
				round(exis_pres::numeric,no_dec)::double precision AS exis_pres,
				round((exis_pres::double precision * eqiv::double precision)::numeric,no_dec)::double precision AS exis_uni
			FROM (
				SELECT 
					inv_prod.sku AS codigo,
					inv_prod.descripcion,
					inv_prod_unidades.titulo AS unidad,
					inv_prod_unidades.decimales AS no_dec,
					inv_prod_presentaciones.id AS idpres,
					inv_prod_presentaciones.titulo AS presentacion,
					inv_prod_presentaciones.cantidad AS eqiv,
					(inv_exi_pres.inicial::double precision + inv_exi_pres.entradas::double precision - inv_exi_pres.salidas::double precision - inv_exi_pres.reservado::double precision) AS exis_pres 
				FROM inv_exi_pres
				JOIN inv_prod ON inv_prod.id=inv_exi_pres.inv_prod_id
				JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
				JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_exi_pres.inv_prod_presentacion_id
				WHERE inv_prod.borrado_logico=FALSE 
				AND inv_exi_pres.inv_alm_id='||str_data[5]||' 
				AND inv_prod.tipo_de_producto_id!=3 
				AND inv_prod.tipo_de_producto_id!=4  
				AND inv_prod.sku ILIKE '''||str_data[6]||''' 
				AND inv_prod.descripcion ILIKE '''||str_data[7]||'''
			) AS sbt '||cadena_where ||';';
			
			--RAISE EXCEPTION '%',cadena_sql;
			FOR fila IN EXECUTE (cadena_sql) LOOP
				RETURN NEXT fila;
			END LOOP;
			
		END IF;--termina command reporte
	END IF;
	--termina Reporte de Existencias por Presentaciones




	--Lista de productos para Carga de Inventario Fisico
	IF app_selected = 178 THEN
		
		cadena_where:='';

		--linea
		IF str_data[5]::integer <> 0 THEN 
			cadena_where:= cadena_where||' AND inv_prod_lineas.id='||str_data[5];
		END IF;
		--marca
		IF str_data[6]::integer <> 0 THEN 
			cadena_where:= cadena_where||' AND inv_mar.id='||str_data[6];
		END IF;
		--tipo de producto
		IF str_data[7]::integer <> 0 THEN 
			cadena_where:= cadena_where||' AND inv_prod_tipos.id='||str_data[7];
		END IF;
		--familia
		IF str_data[8]::integer <> 0 THEN 
			cadena_where:= cadena_where||' AND familia.id='||str_data[8];
		END IF;
		
		--subfamilia
		IF str_data[9]::integer <> 0 THEN 
			cadena_where:= cadena_where||' AND subfam.id='||str_data[9];
		END IF;
		
		--Formato de Reporte de INVENTARIO
		IF str_data[10]::integer = 1 THEN 
			
			--almacen
			IF str_data[4]::integer <> 0 THEN 
				cadena_where:= cadena_where||' AND inv_exi.inv_alm_id='||str_data[4];
			END IF;
			
			cadena_sql:= '
			SELECT  inv_prod.id AS id_prod,
				inv_prod.sku AS codigo_producto,
				inv_prod.descripcion AS descripcion_producto,
				inv_prod_unidades.titulo AS unidad,
				(CASE WHEN inv_prod_tipos.titulo IS NULL THEN '''' ELSE inv_prod_tipos.titulo END) AS tipo_producto,
				inv_alm.id AS id_almacen,
				inv_alm.titulo AS almacen,
				(CASE WHEN familia.titulo IS NULL THEN '''' ELSE familia.titulo END) AS familia,
				(CASE WHEN subfam.titulo IS NULL THEN '''' ELSE subfam.titulo END) AS subfamilia,
				(CASE WHEN inv_prod_lineas.titulo IS NULL THEN '''' ELSE inv_prod_lineas.titulo END) AS linea,
				(CASE WHEN inv_mar.titulo IS NULL THEN '''' ELSE inv_mar.titulo END) AS marca,
				(inv_exi.exi_inicial ';
				WHILE incrementa <= mes_actual LOOP
					cadena_sql:=cadena_sql ||' + inv_exi.entradas_'||incrementa||' - inv_exi.salidas_'||incrementa;
					incrementa:= incrementa + 1;
				END LOOP;
				cadena_sql:= cadena_sql||' 
				) AS existencia 
			FROM inv_prod 
			LEFT JOIN inv_exi ON inv_exi.inv_prod_id=inv_prod.id 
			LEFT JOIN inv_alm ON inv_alm.id=inv_exi.inv_alm_id
			JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
			LEFT JOIN inv_prod_tipos ON inv_prod_tipos.id=inv_prod.tipo_de_producto_id 
			LEFT JOIN inv_prod_lineas ON inv_prod_lineas.id=inv_prod.inv_prod_linea_id
			LEFT JOIN inv_mar ON inv_mar.id=inv_prod.inv_mar_id
			LEFT JOIN inv_prod_familias AS familia ON familia.id=inv_prod.inv_prod_familia_id 
			LEFT JOIN inv_prod_familias AS subfam ON subfam.id=inv_prod.subfamilia_id 
			WHERE inv_prod.borrado_logico=FALSE 
			AND inv_prod.empresa_id='||str_data[3]||'  
			AND inv_exi.ano='||ano_actual||' '||cadena_where||' 
			AND inv_prod.tipo_de_producto_id!=3 
			AND inv_prod.tipo_de_producto_id!=4 ';
		END IF;


		--Formato de Reporte de LOTES
		IF str_data[10]::integer = 2 THEN 
			
			--almacen
			IF str_data[4]::integer <> 0 THEN 
				cadena_where:= cadena_where||' AND inv_lote.inv_alm_id='||str_data[4];
			END IF;
			
			cadena_sql:= '
			SELECT  
				inv_prod.id AS id_prod,
				inv_prod.sku AS codigo_producto,
				inv_prod.descripcion AS descripcion_producto,
				(CASE WHEN inv_prod_unidades.titulo IS NULL THEN '''' ELSE inv_prod_unidades.titulo END) AS unidad,
				inv_alm.id AS id_almacen,
				inv_alm.titulo AS almacen,
				(CASE WHEN inv_lote.id IS NULL THEN '''' ELSE inv_lote.lote_int END) AS lote_interno,
				(CASE WHEN inv_lote.id IS NULL THEN '''' ELSE inv_lote.lote_prov END) AS lote_proveedor,
				(CASE WHEN inv_lote.id IS NULL THEN 0 ELSE (inv_lote.inicial - inv_lote.salidas + inv_lote.entradas - inv_lote.reservado) END) AS existencia,
				(CASE WHEN inv_prod_tipos.titulo IS NULL THEN '''' ELSE inv_prod_tipos.titulo END) AS tipo_producto,
				(CASE WHEN familia.titulo IS NULL THEN '''' ELSE familia.titulo END) AS familia,
				(CASE WHEN subfam.titulo IS NULL THEN '''' ELSE subfam.titulo END) AS subfamilia,
				(CASE WHEN inv_prod_lineas.titulo IS NULL THEN '''' ELSE inv_prod_lineas.titulo END) AS linea,
				(CASE WHEN inv_mar.titulo IS NULL THEN '''' ELSE inv_mar.titulo END) AS marca
			FROM inv_prod 
			LEFT JOIN inv_lote ON (inv_lote.inv_prod_id=inv_prod.id and (inv_lote.inicial - inv_lote.salidas + inv_lote.entradas)>0)
			LEFT JOIN inv_alm ON inv_alm.id=inv_lote.inv_alm_id
			LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
			LEFT JOIN inv_prod_tipos ON inv_prod_tipos.id=inv_prod.tipo_de_producto_id 
			LEFT JOIN inv_prod_lineas ON inv_prod_lineas.id=inv_prod.inv_prod_linea_id
			LEFT JOIN inv_mar ON inv_mar.id=inv_prod.inv_mar_id
			LEFT JOIN inv_prod_familias AS familia ON familia.id=inv_prod.inv_prod_familia_id 
			LEFT JOIN inv_prod_familias AS subfam ON subfam.id=inv_prod.subfamilia_id 
			WHERE inv_prod.borrado_logico=FALSE 
			AND inv_prod.tipo_de_producto_id!=3 
			AND inv_prod.tipo_de_producto_id!=4
			AND inv_prod.empresa_id='||str_data[3]||' '||cadena_where||';';
			
		END IF;
		

		--RAISE EXCEPTION '%',cadena_sql;
		FOR fila IN EXECUTE (cadena_sql) LOOP
			RETURN NEXT fila;
		END LOOP;

		
	END IF;


	


	
	--Lista de productos para carga de Costos y Precios
	IF app_selected = 1001 THEN
		--app_selected+"___"+id_usuario+"___"+id_empresa+"___"+linea+"___"+marca+"___"+tipo+"___"+familia+"___"+subfamilia+"___"+tipo_reporte;
		--	1		  2		  3		  4	     5	         6	      7		    8		    9
		
		cadena_where:='';
		
		--linea
		IF str_data[4]::integer <> 0 THEN 
			cadena_where:= cadena_where||' and inv_prod.inv_prod_linea_id='||str_data[4];
		END IF;
		
		--marca
		IF str_data[5]::integer <> 0 THEN 
			cadena_where:= cadena_where||' and inv_mar.id='||str_data[5];
		END IF;
		
		--tipo de producto
		IF str_data[6]::integer <> 0 THEN 
			cadena_where:= cadena_where||' and inv_prod.tipo_de_producto_id='||str_data[6];
		END IF;
		
		--familia
		IF str_data[7]::integer <> 0 THEN 
			cadena_where:= cadena_where||' and familia.id='||str_data[7];
		END IF;
		
		--subfamilia
		IF str_data[8]::integer <> 0 THEN 
			cadena_where:= cadena_where||' and subfam.id='||str_data[8];
		END IF;
		

		--Tipo de Reporte para Carga y Actualizacion de Costos y precios
		IF str_data[9]::integer = 1 THEN 
			cadena_sql:= '
			SELECT DISTINCT 
				inv_prod.id AS no_prod,
				inv_prod.sku AS codigo,
				inv_prod.descripcion AS nombre_producto,
				(CASE WHEN inv_mar.titulo IS NULL THEN '''' ELSE inv_mar.titulo END) AS marca,
				(CASE WHEN familia.titulo IS NULL THEN '''' ELSE familia.titulo END) AS familia,
				(CASE WHEN subfam.titulo IS NULL THEN '''' ELSE subfam.titulo END) AS subfamilia,
				inv_prod_pres_x_prod.presentacion_id as no_pres,
				inv_prod_presentaciones.titulo as presentacion,
				(CASE WHEN tbl_costos.gral_mon_id_'||mes_actual||' IS NULL THEN 0 ELSE tbl_costos.gral_mon_id_'||mes_actual||' END) AS  no_mon,
				(CASE WHEN tbl_costos.gral_mon_id_'||mes_actual||' IS NULL THEN '''' ELSE gral_mon.descripcion_abr END ) AS mon,
				(CASE WHEN tbl_costos.tipo_cambio_'||mes_actual||' IS NULL THEN 0 ELSE tbl_costos.tipo_cambio_'||mes_actual||' END) AS tc,
				(CASE WHEN tbl_costos.costo_ultimo_'||mes_actual||' IS NULL THEN 0 ELSE tbl_costos.costo_ultimo_'||mes_actual||' END) AS costo_ultimo,
				(CASE WHEN inv_prod_costos.costo_imp_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_'||mes_actual||' END ) AS porcentaje_igi,  
				0::character varying AS igi,
				(CASE WHEN inv_prod_costos.costo_dir_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_'||mes_actual||' END ) AS porcentaje_gi, 
				0::character varying AS gi,
				(CASE WHEN inv_prod_costos.costo_adic_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.costo_adic_'||mes_actual||' END ) AS costo_adic, 
				0::character varying AS cit,
				(CASE WHEN inv_prod_costos.precio_min_'||mes_actual||' IS NULL THEN 0 ELSE inv_prod_costos.precio_min_'||mes_actual||' END ) AS margen_pmin,
				0::character varying AS pmin,
				(case when inv_pre.default_precio_1 is null then 0 else inv_pre.default_precio_1 end) as margen_l1,
				0::character varying AS lista1,
				(case when inv_pre.default_precio_2 is null then 0 else inv_pre.default_precio_2 end) as margen_l2,
				0::character varying AS lista2,
				(case when inv_pre.default_precio_3 is null then 0 else inv_pre.default_precio_3 end) as margen_l3,
				0::character varying AS lista3,
				(case when inv_pre.default_precio_4 is null then 0 else inv_pre.default_precio_4 end) as margen_l4,
				0::character varying AS lista4,
				(case when inv_pre.default_precio_5 is null then 0 else inv_pre.default_precio_5 end) as margen_l5,
				0::character varying AS lista5,
				(case when inv_pre.default_precio_6 is null then 0 else inv_pre.default_precio_6 end) as margen_l6,
				0::character varying AS lista6,
				(case when inv_pre.default_precio_7 is null then 0 else inv_pre.default_precio_7 end) as margen_l7,
				0::character varying AS lista7,
				(case when inv_pre.default_precio_8 is null then 0 else inv_pre.default_precio_8 end) as margen_l8,
				0::character varying AS lista8,
				(case when inv_pre.default_precio_9 is null then 0 else inv_pre.default_precio_9 end) as margen_l9,
				0::character varying AS lista9,
				(case when inv_pre.default_precio_10 is null then 0 else inv_pre.default_precio_10 end) as margen_l10,
				0::character varying AS lista10 
			FROM inv_prod
			JOIN inv_prod_pres_x_prod ON inv_prod_pres_x_prod.producto_id=inv_prod.id
			JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id=inv_prod_pres_x_prod.presentacion_id
			LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=inv_prod.id AND inv_prod_costos.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id AND inv_prod_costos.ano='||ano_actual||')
			left join inv_prod_cost_prom AS tbl_costos ON (tbl_costos.inv_prod_id=inv_prod.id AND tbl_costos.ano='||ano_actual||' AND tbl_costos.costo_ultimo_'||mes_actual||'>0)
			LEFT JOIN inv_prod_familias AS familia ON familia.id=inv_prod.inv_prod_familia_id 
			LEFT JOIN inv_prod_familias AS subfam ON subfam.id=inv_prod.subfamilia_id 
			LEFT JOIN inv_mar ON inv_mar.id=inv_prod.inv_mar_id 
			LEFT JOIN gral_mon ON gral_mon.id=tbl_costos.gral_mon_id_'||mes_actual||' 
			left join inv_pre on (inv_pre.inv_prod_id=inv_prod.id and inv_pre.inv_prod_presentacion_id=inv_prod_pres_x_prod.presentacion_id)
			WHERE inv_prod.borrado_logico=FALSE AND inv_prod_presentaciones.borrado_logico=FALSE 
			AND inv_prod.empresa_id='||emp_id||' '||cadena_where||' ORDER BY inv_prod.sku;';
			
		END IF;

		
		--RAISE EXCEPTION '%',cadena_sql;
		FOR fila IN EXECUTE (cadena_sql) LOOP
			RETURN NEXT fila;
		END LOOP;

		
	END IF;




	
END;

$$;


--
-- Name: inv_reporte_existencias(integer, integer, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_reporte_existencias(id_user integer, id_alm integer, codigo_producto character varying, descripcion character varying, tipo_reporte integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE
	cadena_sql text = '';
	cadena_where text = '';
	ano_actual integer;
	mes_actual integer;
	id_almacen integer;
	incrementa int:=1;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	existencia double precision;
	fila record;
BEGIN	
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--tipo general
	IF tipo_reporte=1 THEN
		cadena_where:='';
	END IF;
	
	--tipo solo con existencias
	IF tipo_reporte=2 THEN
		cadena_where:=' WHERE existencia > 0';
	END IF;
	
	--tipo solo sin existencias
	IF tipo_reporte=3 THEN
		cadena_where:=' WHERE existencia <=0';
	END IF;

	--tipo solo valor m√≠nimo
	IF tipo_reporte=4 THEN
		cadena_where:=' WHERE existencia <= valor_minimo';
	END IF;

	--tipo solo valor m√°ximo
	IF tipo_reporte=5 THEN
		cadena_where:=' WHERE existencia >= valor_maximo';
	END IF;

	--tipo solo punto de reorden
	IF tipo_reporte=6 THEN
		cadena_where:=' WHERE existencia <= punto_reorden';
	END IF;
	
	cadena_sql:= '
	SELECT 
		id,
		valor_minimo,
		valor_maximo,
		punto_reorden,
		almacen,
		familia,
		grupo,
		linea,
		codigo_producto,
		titulo,
		unidad,
		existencia,
		costo_unitario,
		(existencia * costo_unitario) AS costo_total
	FROM (
		SELECT  inv_prod.id,
			inv_prod.valor_minimo,
			inv_prod.valor_maximo,
			inv_prod.punto_reorden,
			inv_alm.titulo AS almacen,
			''''::character varying AS familia,
			''''::character varying AS grupo,
			(CASE WHEN inv_prod_lineas.titulo IS NULL THEN '''' ELSE inv_prod_lineas.titulo END) AS linea,
			inv_prod.sku AS codigo_producto,
			inv_prod.descripcion AS titulo,
			inv_prod_unidades.titulo AS unidad,
			(inv_exi.exi_inicial - inv_exi.transito -inv_exi.reservado ';
			
			WHILE incrementa <= mes_actual LOOP
				cadena_sql:=cadena_sql ||' + inv_exi.entradas_'||incrementa||' - inv_exi.salidas_'||incrementa;
				incrementa:= incrementa + 1;
			END LOOP;
			
			cadena_sql:= cadena_sql||'
			) AS existencia,
			costo_ultimo_'||mes_actual||' AS costo_unitario
		FROM inv_exi 
		JOIN inv_alm ON inv_alm.id=inv_exi.inv_alm_id
		JOIN inv_prod ON inv_prod.id=inv_exi.inv_prod_id
		JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
		LEFT JOIN inv_prod_lineas ON inv_prod_lineas.id=inv_prod.inv_prod_linea_id
		WHERE inv_exi.ano='||ano_actual||' 
		AND inv_exi.inv_alm_id='||id_alm||' 
		AND inv_prod.tipo_de_producto_id!=3 
		AND inv_prod.tipo_de_producto_id!=4  
		AND inv_prod.sku ILIKE '''||codigo_producto||''' 
		AND inv_prod.descripcion ILIKE '''||descripcion||'''
	) AS sbt '||cadena_where ||';';
	
	--RAISE EXCEPTION '%',cadena_sql;
	
	FOR fila IN EXECUTE (cadena_sql) LOOP
		RETURN NEXT fila;
	END LOOP;
	
END;

$$;


--
-- Name: inv_reporte_movimientos(integer, integer, integer, text, text, integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.inv_reporte_movimientos(tipo_movimiento_id integer, id_almacen integer, empresa_id integer, fecha_inicial text, fecha_final text, id_usuario integer, sku character varying, descripcion character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE
	cadena_sql text = '';
	movimientos text = '';
	cadena_where character varying = '';
	cadena_where_almacen_origen character varying = '';
	cadena_where_almacen_destino character varying = '';
	
	fila           record;
	registros      record;
	fila_almacenes record;
	returnrecord   record;
	
	id_almacenes character varying:='';
	existencia_actual double precision;
	
	primer_registro smallint;
	
BEGIN	
	
   BEGIN 
    	CREATE TEMPORARY TABLE tmprecord (
		codigo character varying,
		descripcion character varying,
		unidad character varying,
		existecia double precision,
		referencia character varying,
		tipo_movimiento character varying,
		fecha_movimiento character varying,
		sucursal character varying,
		almacen character varying,
		cantidad double precision,
		existencia_actual double precision,
		costo double precision
	);
        EXCEPTION WHEN OTHERS THEN
    	TRUNCATE TABLE tmprecord; -- TRUNCATE if the table already exists within the session.
    END;	

		/*RAISE EXCEPTION '%','tipo de movimiento'|| tipo_movimiento_id|| 
					    ' id_almacen'|| id_almacen||
					   '  empresa_id'|| empresa_id||
					'  fecha_inicial'|| fecha_inicial||
					  '  fecha_final'|| fecha_final||
					   '  id_usuario'|| id_usuario ||
					          '  sku'||sku  ||
					  '  descripcion'||descripcion;*/
		IF id_almacen = 0 THEN
			--query para obtener todos los alacenes de la empresa
			cadena_sql:='SELECT distinct inv_suc_alm.almacen_id FROM gral_suc JOIN inv_suc_alm ON inv_suc_alm.sucursal_id=gral_suc.id WHERE gral_suc.empresa_id='||empresa_id||' ORDER BY inv_suc_alm.almacen_id;';

			--RAISE EXCEPTION '%','Si llega aqui: sql-almacenes: '||cadena_sql;
			primer_registro:=0;--variable para saber si es el primer almacen en la cadena
			FOR fila_almacenes IN EXECUTE(cadena_sql) LOOP
				if primer_registro=0 then
					id_almacenes:=id_almacenes||'';
				else
					id_almacenes:=id_almacenes||',';
				end if;
				id_almacenes:=id_almacenes||fila_almacenes.almacen_id;
				primer_registro:=1;
			END LOOP;
		END IF;
		
		IF id_almacen <> 0 THEN
			cadena_where:=cadena_where|| ' AND inv_exi.inv_alm_id='||id_almacen||'';
		ELSE
			cadena_where:=cadena_where|| ' AND inv_exi.inv_alm_id IN ('||id_almacenes||')';
		END IF;
		
		IF trim(sku) <> '' THEN
			cadena_where:=cadena_where|| ' AND inv_prod.sku ilike '''||sku||'''';
		END IF;
		IF trim(descripcion) <> '' THEN
			cadena_where:=cadena_where|| ' AND inv_prod.descripcion ilike '''||descripcion||'''';
		END IF;

		--RAISE EXCEPTION '%','id_almacen:'||id_almacen||'    sku:'||sku||'    descripcion:'||descripcion;
		
		--la fecha final en este cuery es la seri la fecha de movimiento 
		cadena_sql:='
		select 
			inv_prod.id, 
			inv_prod.sku,
			inv_prod.descripcion, 
			inv_exi.inv_alm_id,
			(select * from inv_existencia_producto (inv_exi.inv_alm_id, inv_prod.id,'''||fecha_inicial||''' , '||id_usuario||')) as existencia_inicial
		from inv_prod
		join inv_exi on inv_exi.inv_prod_id=inv_prod.id
		WHERE borrado_logico=false  
		'||cadena_where||'
		and inv_exi.ano=EXTRACT(YEAR FROM  '''||fecha_inicial||'''::timestamp with time zone)';

	--RAISE EXCEPTION '%','Segundo Query: primer query: '||cadena_sql;

	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		cadena_where ='';
		IF id_almacen!=0 THEN
			cadena_where_almacen_origen:= cadena_where_almacen_origen||'AND alm_origen.id='||id_almacen||'  ';
			cadena_where_almacen_destino:=cadena_where_almacen_destino||'AND alm_destino.id='||id_almacen||'  ';
		END IF;
		IF id_almacen=0 THEN
			cadena_where_almacen_origen:= cadena_where_almacen_origen||'AND alm_origen.id IN ('||id_almacenes||') ';
			cadena_where_almacen_destino:=cadena_where_almacen_destino||'AND alm_destino.id IN ('||id_almacenes||') ';
		END IF;
		IF tipo_movimiento_id!=0 THEN
			cadena_where:=cadena_where||'AND inv_mov_tipos.id='||tipo_movimiento_id||  '';
		END IF;
		
		existencia_actual :=0;
		
		  movimientos:='
		  SELECT * FROM (
			SELECT 
				inv_prod.id, 
				inv_prod.sku AS codigo,  
				inv_prod.descripcion,
				inv_prod_unidades.titulo as unidad,
				
				inv_mov.referencia, 
				inv_mov_tipos.id AS id_tipo_movimiento,  
				inv_mov_tipos.titulo AS tipo_movimiento,
				inv_mov_tipos.grupo, 
				to_char(inv_mov.fecha_mov,''yyyy-mm-dd'') AS fecha_movimiento,   
				inv_mov.fecha_mov,
				gral_emp.id AS id_empresa,   
				gral_emp.titulo AS nombre_empresa,   
				gral_suc.id AS id_sucursal,   
				gral_suc.titulo AS nombre_sucursal,
				(CASE WHEN inv_mov_tipos.grupo=0 THEN inv_mov_detalle.alm_destino_id 
					WHEN inv_mov_tipos.grupo=2 THEN inv_mov_detalle.alm_origen_id 
					WHEN inv_mov_tipos.grupo=3 THEN inv_mov_detalle.alm_origen_id 
				ELSE 0 END) AS id_almacen,
				(CASE WHEN inv_mov_tipos.grupo=0 THEN alm_destino.titulo
					WHEN inv_mov_tipos.grupo=2 THEN alm_origen.titulo 
					WHEN inv_mov_tipos.grupo=3 THEN alm_origen.titulo 
				ELSE '''' END) AS nombre_almacen,
				inv_mov_detalle.cantidad,   
				inv_mov_detalle.alm_destino_id ,   
				inv_mov_detalle.alm_origen_id,   
				inv_mov_detalle.costo
			FROM inv_mov_detalle  
			JOIN inv_mov  ON inv_mov.id = inv_mov_detalle.inv_mov_id   
			JOIN inv_mov_tipos  ON inv_mov_tipos.id = inv_mov.inv_mov_tipo_id  
			JOIN inv_prod ON  inv_prod.id = inv_mov_detalle.producto_id  
			JOIN inv_prod_unidades ON  inv_prod_unidades.id = inv_prod.unidad_id  
			
			JOIN gral_emp ON gral_emp.id = inv_prod.empresa_id  
			JOIN gral_suc ON gral_suc.id  = inv_prod.sucursal_id  
			LEFT JOIN inv_alm AS alm_origen ON (alm_origen.id=inv_mov_detalle.alm_origen_id  '||cadena_where_almacen_origen|| ')
			LEFT JOIN inv_alm AS alm_destino  ON (alm_destino.id=inv_mov_detalle.alm_destino_id '||cadena_where_almacen_destino||')
			WHERE inv_prod.empresa_id='||empresa_id||' 
			AND inv_prod.borrado_logico=false
			AND inv_prod.id='||fila.id||'  
			'||cadena_where||  ' 
			AND (to_char(inv_mov.fecha_mov,''yyyymmdd'')::integer BETWEEN to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymmdd'')::integer AND to_char('''||fecha_final||'''::timestamp with time zone,''yyyymmdd'')::integer)  
		) as sbt
		WHERE sbt.nombre_almacen!=''''
		ORDER BY codigo asc, fecha_mov asc;';
		
		--RAISE EXCEPTION '%','Segundo Query: sql movimientos: '||movimientos;
		existencia_actual:=fila.existencia_inicial; --400
		
		FOR registros IN EXECUTE(movimientos) LOOP
			IF registros.grupo = 0 THEN ---- 0=Entradas, 1=Existencia Inicial, 2=Salidas, 3=Traspasos
				existencia_actual:= existencia_actual  + registros.cantidad;
				insert into tmprecord values(registros.codigo, registros.descripcion, registros.unidad, fila.existencia_inicial, registros.referencia, registros.tipo_movimiento, registros.fecha_movimiento, registros.nombre_sucursal,registros.nombre_almacen,registros.cantidad,existencia_actual,registros.costo);
			END IF;
			
			IF registros.grupo = 2 THEN ---- 0=Entradas, 1=Existencia Inicial, 2=Salidas, 3=Traspasos
				existencia_actual:=existencia_actual  - registros.cantidad;
				insert into tmprecord values(registros.codigo, registros.descripcion, registros.unidad, fila.existencia_inicial, registros.referencia, registros.tipo_movimiento, registros.fecha_movimiento, registros.nombre_sucursal,registros.nombre_almacen,registros.cantidad,existencia_actual,registros.costo);
			END IF;
			
			IF registros.grupo = 3 THEN ---- 0=Entradas, 1=Existencia Inicial, 2=Salidas, 3=Traspasos
				existencia_actual:=existencia_actual - registros.cantidad ; 
				insert into tmprecord values(registros.codigo, registros.descripcion, registros.unidad, fila.existencia_inicial, registros.referencia, registros.tipo_movimiento, registros.fecha_movimiento, registros.nombre_sucursal,registros.nombre_almacen,registros.cantidad,existencia_actual,registros.costo);
			END IF;
		END LOOP;
		
	END LOOP;

	
	
	--recorriendo la tabla temporal y retornando sus filas
	FOR returnrecord IN SELECT * FROM tmprecord LOOP
		RETURN NEXT returnrecord;
	END LOOP;

	--return fila;
END;

/*
                      inv_Reporte_movimientos(tipo_movimiento_id,id_almacen,empresa_id,fecha_inicial,fecha_final,id_usuario,sku , descripcion  )
	select * from inv_Reporte_movimientos(0,3 ,1,'2013-01-01', '2013-02-01' ,1,'PKA12','ACTICIDE OF 25 M'  )
	as foo(
		codigo character varying,
		descripcion character varying,
		existecia double precision,
		referencia character varying,
		tipo_movimiento character varying,
		fecha_movimiento character varying,
		sucursal character varying,
		almacen character varying,
		cantidad double precision,
		existencia_actual double precision,
		costo double precision
	);

	--funcion para saber cuanta cantidad existe o existia de un determinado producto
	select * from existencia_producto(id_Almacen,id_producto, fecha, id_deusuario)as existencia_inicial;
	select * from existencia_producto(3 , 345,2013-03-21 , 1) as existencia_inicial;
*/

$$;


--
-- Name: kemikal_asigna_costo_ultimo_en_tabla_inv_prod_cost_prom(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.kemikal_asigna_costo_ultimo_en_tabla_inv_prod_cost_prom(id_empresa integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	fila record;
	fila_pres record;
	cadena_sql text;
	sql_update text='';
	sql_insert text='';
	valores_campos text='';

	id_moneda smallint = 0;
	tc double precision =0.0;
	costo double precision =0.0;
	factura_compra character varying;
	orden_compra character varying;
	facha_factura date;
	
	exis integer=0;
	incrementa integer=0;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	usuario_ejecutor integer=0;
	presentacion_id integer=0;
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	usuario_ejecutor:=1; 
	
	--obtiene lista de todos los prooductos
	cadena_sql:='select 
			inv_prod.id AS id_prod,
			(CASE WHEN costos_kemikal.costo  IS NULL THEN 0 ELSE costos_kemikal.costo END) AS costo,
			(CASE WHEN costos_kemikal.moneda_id IS NULL THEN 0 ELSE costos_kemikal.moneda_id END ) as moneda_id,
			(CASE WHEN costos_kemikal.tc is null then 0 else costos_kemikal.tc::double precision END) as tcam,
			(CASE WHEN costos_kemikal.factura IS NULL THEN '''' ELSE costos_kemikal.factura END) AS factura,
			(CASE WHEN costos_kemikal.oc IS NULL THEN '''' ELSE costos_kemikal.oc END) AS ocom
		from inv_prod
		LEFT JOIN costos_kemikal ON costos_kemikal.codigo=inv_prod.sku
		WHERE inv_prod.empresa_id='||id_empresa||'  AND inv_prod.borrado_logico=FALSE ORDER BY inv_prod.id;';
	
	--RAISE EXCEPTION '%',cadena_sql;
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		
		IF fila.costo >0 THEN
			tc:=fila.tcam;
			factura_compra:=fila.factura;
			orden_compra:=fila.ocom;
			--presentacion_id:=3;
			
			incrementa := 0;--inicializar valor
			
			--toma el mes de la fecha de la factura
			incrementa := mes_actual + 1;

			--RAISE EXCEPTION '%',fila.id_prod;
			
			--aqui se crea la cadena para actualizar y repetir los valores del mes actual hasta el mes 12
			sql_update := 'UPDATE inv_prod_cost_prom SET 
					costo_ultimo_'||mes_actual||'='||fila.costo||', 
					tipo_cambio_'||mes_actual||'='||tc||', 
					gral_mon_id_'||mes_actual||'='||fila.moneda_id||', 
					actualizacion_'||mes_actual||'='''||espacio_tiempo_ejecucion||''', 
					factura_ultima_'||mes_actual||'='''||factura_compra||''', 
					oc_ultima_'||mes_actual||'='''||orden_compra||'''';
			WHILE incrementa <= 12 LOOP
				sql_update:=sql_update ||', costo_ultimo_'||incrementa||'='||fila.costo||'
							  , tipo_cambio_'||incrementa||'='||tc||'
							  , gral_mon_id_'||incrementa||'='||fila.moneda_id||'
							  , actualizacion_'||incrementa||'='''||espacio_tiempo_ejecucion||'''
							  , factura_ultima_'||incrementa||'='''||factura_compra||'''
							  , oc_ultima_'||incrementa||'='''||orden_compra||''''; 
				incrementa:= incrementa + 1;
			END LOOP;
			sql_update:= sql_update||' WHERE inv_prod_id='||fila.id_prod||' AND ano='||ano_actual||';';
			
			--RAISE EXCEPTION '%',sql_update;
			
			
			EXECUTE sql_update;
		END IF;
		
		/*
		--:::::::::::::ACTUALIZAR INV_PROD_COSTOS :::::::::::::::::::::::::::
		SELECT count(id) FROM inv_prod_costos WHERE gral_emp_id=id_empresa AND ano=ano_actual AND inv_prod_id=fila.id_prod
		INTO exis;
		
		incrementa := 0;--inicializar valor
		
		IF exis > 0 THEN
			--Aqu√≠ entra para ACTUALIZAR un registro
			incrementa := mes_actual + 1;
			
			--aqui se crea la cadena para actualizar y repetir los valores del mes actual hasta el mes 12
			sql_update := 'UPDATE inv_prod_costos SET costo_imp_'||mes_actual||'='||fila.ci||', costo_dir_'||mes_actual||'='||fila.cd||', precio_min_'||mes_actual||'='||fila.pmin||', actualizacion_'||mes_actual||'='''||espacio_tiempo_ejecucion||''', usr_id_actualiza_'||mes_actual||'='||usuario_ejecutor||'';
			WHILE incrementa <= 12 LOOP
				sql_update:=sql_update ||', costo_imp_'||incrementa||'='||fila.ci||', costo_dir_'||incrementa||'='||fila.cd||', precio_min_'||incrementa||'='||fila.pmin||', actualizacion_'||incrementa||'='''||espacio_tiempo_ejecucion||''', usr_id_actualiza_'||incrementa||'='||usuario_ejecutor||' ';
				incrementa:= incrementa + 1;
			END LOOP;
			sql_update:= sql_update||' WHERE gral_emp_id='||id_empresa||' AND ano='||ano_actual||' AND inv_prod_id='||fila.id_prod||';';

			--RAISE EXCEPTION '%',sql_update;
			
			--aqui ejecutamos la cadena sql
			EXECUTE sql_update;
			
		ELSE
			--aqu√≠ entra para CREAR un nuevo registro
			incrementa := mes_actual + 1;

			--esta cadena almacen los campos a actualizar
			sql_insert := 'INSERT INTO inv_prod_costos(gral_emp_id, ano, inv_prod_id, inv_prod_presentacion_id, costo_imp_'||mes_actual||', costo_dir_'||mes_actual||', precio_min_'||mes_actual||', actualizacion_'||mes_actual||', usr_id_actualiza_'||mes_actual||' ';

			--en esta cadena van los valores de los campos a actualizar
			valores_campos:=''||id_empresa||', '||ano_actual||', '||fila.id_prod ||', '||presentacion_id||', '||fila.ci||', '||fila.cd||', '||fila.pmin||', '''||espacio_tiempo_ejecucion||''','||usuario_ejecutor||'';
			
			WHILE incrementa <= 12 LOOP
				sql_insert:=sql_insert ||', costo_imp_'||incrementa||', costo_dir_'||incrementa||', precio_min_'||incrementa||', actualizacion_'||incrementa||', usr_id_actualiza_'||incrementa||'';
				valores_campos:=valores_campos ||', '||fila.ci||', '||fila.cd||', '||fila.pmin||', '''||espacio_tiempo_ejecucion||''','||usuario_ejecutor||' ';
				incrementa:= incrementa + 1;
			END LOOP;
			sql_insert:= sql_insert||' ) VALUES('||valores_campos||')';
			
			EXECUTE sql_insert;
			
		END IF;
		*/



		
		
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: log_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE


--Estas  variables se utilizan en la mayoria de los catalogos
str_data text[];
str_filas text[];
str_filas2 text[];
str_filas3 text[];
total_filas integer;--total de elementos de arreglo
cont_fila integer;--contador de filas o posiciones del arreglo
app_selected integer;
command_selected text;
espacio_tiempo_ejecucion timestamp with time zone := now();
ano_actual integer;
mes_actual integer;
valor_retorno character varying:='';
usuario_id integer:=0;
emp_id integer:=0;
suc_id integer:=0;
ultimo_id integer:=0;
ultimo_id2 integer:=0;
ultimo_id3 integer:=0;
fila record;
fila2 record;
fila3 record;
fila4 record;
fila5 record;
tipo_movimiento_id integer:=0;

id_tipo_consecutivo integer=0;
prefijo_consecutivo character varying = '';
nuevo_consecutivo bigint=0;
nuevo_folio character varying = '';

exis integer:=0;
cadena_sql character varying = '';
sql_select character varying = '';
registro integer:=0;
cantidad1 double precision:=0;
cantidad2 double precision:=0;

BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	--aplicativo seleccionado
	app_selected := str_data[1]::integer;
	
	command_selected := str_data[2];--new, edit
	
	-- usuario que utiliza el aplicativo
	usuario_id := str_data[3]::integer;
	
	--obtiene empresa_id y sucursal_id
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id;
	
	valor_retorno:='0';
	
	-- Aplicativo asignacion de rutas
	IF app_selected = 72 THEN
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		
		--str_data[1]  app_selected
		--str_data[2]  command_selected
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  chofer_id
		--str_data[6]  unidad_id
		--str_data[7]  confirmar
		
                IF command_selected = 'new' THEN
			id_tipo_consecutivo:=12;--Folio de Asignacion de Rutas
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO log_rutas(folio,log_chofer_id,log_vehiculo_id,momento_creacion,gral_emp_id,gral_suc_id,gral_usr_id_creacion) 
			VALUES (nuevo_folio,str_data[5]::integer,str_data[6]::integer,espacio_tiempo_ejecucion,emp_id,suc_id,usuario_id)
			RETURNING id INTO ultimo_id;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--aqui se vuelven a crear los registros
					IF str_filas[1]='FAC_DOCS' THEN
						INSERT INTO log_rutas_detalle (log_ruta_id,fac_docs_id,inv_prod_id,envase ) 
						VALUES (ultimo_id,str_filas[2]::integer, str_filas[3]::integer, str_filas[4] );
						
						--Actualiza estatus de partida de a enviado=true
						UPDATE fac_docs_detalles set enviado=true WHERE fac_doc_id=str_filas[2]::integer and  inv_prod_id=str_filas[3]::integer;
						
					END IF;
					
					
					
					IF str_filas[1]='RC' THEN
						IF str_filas[8]::integer != 0 THEN 
							INSERT INTO log_rutas_detalle_cobro(log_ruta_id,cxc_fac_rev_cob_detalle_id ) VALUES (ultimo_id,str_filas[5]::integer );
							--actualiza campo enviado en erp_h_facturas
							UPDATE erp_h_facturas SET enviado=TRUE WHERE id=(SELECT erp_h_facturas_id FROM cxc_fac_rev_cob_detalle WHERE id=str_filas[5]::integer);
						END IF;
					END IF;
					
					valor_retorno := '1';
					
				END LOOP;
			END IF;
		END IF;
                
                IF command_selected = 'edit' THEN
			
			IF str_data[7]='confirmar' THEN
				UPDATE log_rutas SET confirmado=TRUE, momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id WHERE id=str_data[4]::integer;
			END IF;
			
                        total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	tipo
					--str_filas[2]	fac_docs_id
					--str_filas[3]	inv_prod_id
					--str_filas[4]	envase
					--str_filas[5]	fac_rev_cobro
					--str_filas[6]	seleccionado
					--str_filas[7]	id_detalle
					--str_filas[8]	eliminado
					
					IF str_filas[1]='FAC_DOCS' THEN
						--si es nuevo se crea el registro
						IF str_filas[7]='0' THEN
							INSERT INTO log_rutas_detalle (log_ruta_id,fac_docs_id,inv_prod_id,envase ) VALUES (str_data[4]::integer,str_filas[2]::integer, str_filas[3]::integer, str_filas[4] );
						END IF;

						IF  str_filas[6] ='1' THEN
							UPDATE fac_docs_detalles set enviado=true where fac_doc_id=str_filas[2]::integer AND inv_prod_id=str_filas[3]::integer;
						ELSE
							UPDATE fac_docs_detalles set enviado=false where fac_doc_id=str_filas[2]::integer AND inv_prod_id=str_filas[3]::integer;
						END IF;
					END IF;
					
					
					
					IF str_filas[1]='RC' THEN
						IF str_filas[8]::integer<>0 THEN --aqui entra si el registor no esta eliminado
							--si es nuevo se crea el registro
							IF str_filas[7]='0' THEN
								INSERT INTO log_rutas_detalle_cobro(log_ruta_id,cxc_fac_rev_cob_detalle_id ) VALUES (str_data[4]::integer,str_filas[5]::integer );
							END IF;
							
							--actualiza campo enviado en erp_h_facturas
							IF  str_filas[6] ='1' THEN
								UPDATE erp_h_facturas SET enviado=TRUE WHERE id=(SELECT erp_h_facturas_id FROM cxc_fac_rev_cob_detalle WHERE id=str_filas[5]::integer);
							ELSE
								UPDATE erp_h_facturas SET enviado=FALSE WHERE id=(SELECT erp_h_facturas_id FROM cxc_fac_rev_cob_detalle WHERE id=str_filas[5]::integer);
							END IF;
						ELSE 
							--aqui entra si el registro se elimino de la vista
							IF str_filas[7] !='0' THEN--Diferente de 0(cero) significa que no es un registro nuevo por lo tanto hay que eliminar
								DELETE FROM log_rutas_detalle_cobro WHERE cxc_fac_rev_cob_detalle_id=str_filas[5]::integer;
								UPDATE erp_h_facturas SET enviado=FALSE WHERE id=(SELECT erp_h_facturas_id FROM cxc_fac_rev_cob_detalle WHERE id=str_filas[5]::integer);
							END IF;
						
						END IF;
					END IF;
					
					
					valor_retorno := '1';
					
				END LOOP;
			END IF;
			
                END IF;
		
                IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','esttooooo::'||str_data[4];
			DELETE  FROM  log_rutas WHERE  id=str_data[4]::integer;
			DELETE  FROM  log_rutas_detalle WHERE log_ruta_id = str_data[4]::integer;
			DELETE  FROM  log_rutas_detalle_cobro WHERE log_ruta_id = str_data[4]::integer;
			
                        valor_retorno := '1';
                END IF;
                
	END IF;--termina Catalogo de rutas


	
	-- Catalogo de Operadores
	IF app_selected = 154 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         nombre
			--str_data[6]         apellido_paterno
			--str_data[7]         apellido_materno  
			--str_data[8]         select_transportista
			
			id_tipo_consecutivo:=47;--Folio de Operadores
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			INSERT INTO log_choferes (clave,nombre,apellido_paterno,apellido_materno, cxp_prov_id, gral_emp_id,gral_suc_id,borrado_logico,momento_creacion,id_usuario_creacion ) 
			VALUES (nuevo_folio,str_data[5],str_data[6],str_data[7], str_data[8]::integer, emp_id,suc_id,false,now(),usuario_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE log_choferes SET nombre=str_data[5],apellido_paterno=str_data[6],apellido_materno=str_data[7], cxp_prov_id=str_data[8]::integer, momento_actualizacion=now(),id_usuario_actualizacion=usuario_id
			WHERE log_choferes.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE log_choferes SET momento_baja=now(), id_usuario_baja=usuario_id, borrado_logico=true WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--termina Catalogo de Operadores



	--Aplicativo Administrador de Viajes(LOG)
	IF app_selected = 181 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected 
		--str_data[3]  id_usuario
		--str_data[4]  identificador
		--str_data[5]  fecha
		--str_data[6]  hora
		--str_data[7]  sucursal
		--str_data[8]  id_vehiculo
		--str_data[9]  observaciones
		--str_data[10]  adicionales
		--str_data[11]  id_ruta
		--str_data[12]  id_almacen_salida
		--str_data[13]  suma_precio_venta
		--str_data[14]  tipo_distribucion
		
		IF command_selected = 'new' THEN
			--Folio Administrador de Viajes(LOG)
			id_tipo_consecutivo:=52;
			
			--Aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--Obtener datos del Vehiculo(Unidad)
			SELECT placa, numero_economico, log_chofer_id, log_vehiculo_clase_id, log_vehiculo_tipo_id FROM log_vehiculos WHERE id=str_data[8]::integer LIMIT 1 INTO fila;
			
			--Buscar costo de la ruta
			select (case when costo is null then 0 else costo end) as costo from log_ruta_tipo_unidad where log_ruta_id=str_data[11]::integer and log_vehiculo_tipo_id=fila.log_vehiculo_tipo_id limit 1 into fila5;
			
			if fila5.costo is null then fila5.costo:=0; end if;
			
			INSERT INTO log_viaje(
				gral_emp_id, --emp_id,
				gral_suc_id, --str_data[7]::integer,
				folio, --nuevo_folio,
				fecha, --str_data[5]::date, 
				hora, --str_data[6]::time with time zone,
				log_vehiculo_id, --str_data[8]::integer,
				no_economico, --fila.numero_economico,
				placas, --fila.placa,
				log_vehiculo_clase_id, --fila.log_vehiculo_clase_id,
				log_chofer_id, --fila.log_chofer_id,
				observaciones, --str_data[9]::text,
				log_ruta_id, --str_data[11]::integer,
				inv_alm_id, --str_data[12]::integer,
				total_precio, --str_data[13]::double precision,
				log_tipo_distribucion_id, --str_data[14]::integer
				costo_ruta, --fila5.costo, 
				log_vehiculo_tipo_id, --fila.log_vehiculo_tipo_id,
				log_status_id, --0,
				borrado_logico, --false,
				momento_crea, --espacio_tiempo_ejecucion,
				gral_usr_id_crea --usuario_id 
			)
			VALUES (emp_id, str_data[7]::integer, nuevo_folio, str_data[5]::date, str_data[6]::time with time zone, str_data[8]::integer, fila.numero_economico, fila.placa, fila.log_vehiculo_clase_id, fila.log_chofer_id, str_data[9]::text, str_data[11]::integer, str_data[12]::integer, str_data[13]::double precision, str_data[14]::integer, fila5.costo, fila.log_vehiculo_tipo_id, 0, false, espacio_tiempo_ejecucion, usuario_id )
			RETURNING id INTO ultimo_id;
			
			cont_fila:=1;
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	iddet
					--str_filas[3]	idcga
					--str_filas[4]	idped
					--str_filas[5]	iddest
					--str_filas[6]	idmun
					--str_filas[7]	selec
					--str_filas[8]	selec_chk_firma
					--str_filas[9]	selec_chk_sello
					--str_filas[10]	selec_chk_efectivo
					--str_filas[11]	selec_chk_cheque
					--str_filas[12]	tarifa_clase_id
					--str_filas[13]	tarifa_tipo_id
					--str_filas[14]	precio
					--str_filas[15]	cant_tar
					--str_filas[16]	cant_car
					
					IF str_filas[7]::integer=1 THEN 
						--Obtener id del cliente
						select log_doc.cxc_clie_id from log_doc join log_doc_carga on log_doc_carga.log_doc_id=log_doc.id where log_doc_carga.id=str_filas[3]::integer LIMIT 1 INTO fila2;
						
						INSERT INTO log_viaje_det(
							log_viaje_id, --ultimo_id,
							cxc_clie_id, --fila2.cxc_clie_id,
							log_doc_carga_id, --str_filas[3]::integer,
							log_doc_ped_id, --str_filas[4]::integer,
							gral_mun_id, --str_filas[6]::integer,
							solicitar_firma, --str_filas[8]::boolean,
							solicitar_sello, --str_filas[9]::boolean,
							solicitar_efectivo, --str_filas[10]::boolean,
							solicitar_cheque, --str_filas[11]::boolean,
							log_tarifa_clase_id, --str_filas[12]::integer,
							log_tarifa_tipo_id, --str_filas[13]::integer,
							precio_tarifa_venta, --str_filas[14]::double precision,
							cant_tar, --str_filas[15]::double precision,
							cant_car, --str_filas[16]::double precision,
							log_status_id--0 Nuevo
						)
						VALUES(ultimo_id, fila2.cxc_clie_id, str_filas[3]::integer, str_filas[4]::integer, str_filas[6]::integer, str_filas[8]::boolean, str_filas[9]::boolean, str_filas[10]::boolean, str_filas[11]::boolean, str_filas[12]::integer, str_filas[13]::integer, str_filas[14]::double precision, str_filas[15]::double precision,str_filas[16]::double precision,0);
					END IF;
				END LOOP;
			END IF;
			
			
			
			--Crear registros para servicios adicionales
			IF trim(str_data[10])<>'' THEN
				--Validar Servicios Adicionales
				
				--Convertir en arreglo la cadena de Adicionales
				SELECT INTO str_filas2 string_to_array(str_data[10],'|');
				
				cont_fila=1;
				FOR cont_fila IN array_lower(str_filas2,1) .. array_upper(str_filas2,1) LOOP
					SELECT INTO str_filas3 string_to_array(str_filas2[cont_fila],'&&');
					--str_filas3[1]	idreg
					--str_filas3[2]	del
					--str_filas3[3]	noTr
					--str_filas3[4]	idprod
					--str_filas3[5]	precio
					--str_filas3[6]	id_pedido
					if str_filas3[2]::integer=1 then
						select id, unidad_id, inv_prod_presentacion_id as pres_id from inv_prod where id=str_filas3[4]::integer limit 1 into fila3;
						
						insert into log_viaje_serv_adic(log_viaje_id,inv_prod_id,inv_prod_unidad_id,inv_prod_pres_id,precio, log_doc_ped_id)
						values(ultimo_id,str_filas3[4]::integer,fila3.unidad_id,fila3.pres_id,str_filas3[5]::double precision, str_filas3[6]::integer);
					end if;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;


		
		IF command_selected = 'edit' THEN 
			
			--Obtener datos del Vehiculo(Unidad)
			SELECT placa, numero_economico, log_chofer_id, log_vehiculo_clase_id, log_vehiculo_tipo_id FROM log_vehiculos WHERE id=str_data[8]::integer LIMIT 1 INTO fila;

			--Buscar costo de la ruta
			select (case when costo is null then 0 else costo end) as costo from log_ruta_tipo_unidad where log_ruta_id=str_data[11]::integer and log_vehiculo_tipo_id=fila.log_vehiculo_tipo_id limit 1 into fila5;

			if fila5.costo is null then fila5.costo:=0; end if;
			
			UPDATE log_viaje SET gral_suc_id=str_data[7]::integer,fecha=str_data[5]::date, hora=str_data[6]::time with time zone,log_vehiculo_id=str_data[8]::integer,no_economico=fila.numero_economico,placas=fila.placa,log_vehiculo_clase_id=fila.log_vehiculo_clase_id,log_chofer_id=fila.log_chofer_id,observaciones=str_data[9]::text,log_ruta_id=str_data[11]::integer, total_precio=str_data[13]::double precision, log_tipo_distribucion_id=str_data[14]::integer, costo_ruta=fila5.costo, log_vehiculo_tipo_id=fila.log_vehiculo_tipo_id, momento_actualiza=espacio_tiempo_ejecucion,gral_usr_id_actualiza=usuario_id 
			WHERE id=str_data[4]::integer;
			
			cont_fila:=1;
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	iddet
					--str_filas[3]	idcga
					--str_filas[4]	idped
					--str_filas[5]	iddest
					--str_filas[6]	idmun
					--str_filas[7]	selec
					--str_filas[8]	selec_chk_firma
					--str_filas[9]	selec_chk_sello
					--str_filas[10]	selec_chk_efectivo
					--str_filas[11]	selec_chk_cheque
					--str_filas[12]	tarifa_clase_id
					--str_filas[13]	tarifa_tipo_id
					--str_filas[14]	precio
					
					IF str_filas[7]::integer>=1 THEN 
						--No ha sido eliminado
						
						--Obtener id del cliente
						select log_doc.cxc_clie_id from log_doc join log_doc_carga on log_doc_carga.log_doc_id=log_doc.id where log_doc_carga.id=str_filas[3]::integer LIMIT 1 INTO fila2;
						

						IF str_filas[2]::integer > 0 THEN 
							--Actualizar registro existente
							UPDATE log_viaje_det SET cxc_clie_id=fila2.cxc_clie_id, solicitar_firma=str_filas[8]::boolean, solicitar_sello=str_filas[9]::boolean, solicitar_efectivo=str_filas[10]::boolean, solicitar_cheque=str_filas[11]::boolean, log_tarifa_clase_id=str_filas[12]::integer, log_tarifa_tipo_id=str_filas[13]::integer, precio_tarifa_venta=str_filas[14]::double precision, cant_tar=str_filas[15]::double precision,cant_car=str_filas[16]::double precision,log_status_id=0 
							WHERE id=str_filas[2]::integer;
						ELSE
							--Crear nuevo registro
							INSERT INTO log_viaje_det(
								log_viaje_id, --str_data[4]::integer,
								cxc_clie_id, --fila2.cxc_clie_id,
								log_doc_carga_id, --str_filas[3]::integer,
								log_doc_ped_id, --str_filas[4]::integer,
								gral_mun_id, --str_filas[6]::integer,
								solicitar_firma, --str_filas[8]::boolean,
								solicitar_sello, --str_filas[9]::boolean,
								solicitar_efectivo, --str_filas[10]::boolean,
								solicitar_cheque, --str_filas[11]::boolean,
								log_tarifa_clase_id, --str_filas[12]::integer,
								log_tarifa_tipo_id, --str_filas[13]::integer,
								precio_tarifa_venta, --str_filas[14]::double precision,
								cant_tar, --str_filas[15]::double precision,
								cant_car, --str_filas[16]::double precision,
								log_status_id--0
							)
							VALUES(str_data[4]::integer,fila2.cxc_clie_id,str_filas[3]::integer,str_filas[4]::integer,str_filas[6]::integer,str_filas[8]::boolean,str_filas[9]::boolean,str_filas[10]::boolean,str_filas[11]::boolean, str_filas[12]::integer, str_filas[13]::integer, str_filas[14]::double precision,str_filas[15]::double precision,str_filas[16]::double precision,0);
						END IF;
					ELSE 
						--Fue eliminado
						DELETE FROM log_viaje_det WHERE id=str_filas[2]::integer;
					END IF;
				END LOOP;
			END IF;
			
			
			--Crear registros para servicios adicionales
			IF trim(str_data[10])<>'' THEN
				--Validar Servicios Adicionales
				
				--Convertir en arreglo la cadena de Adicionales
				SELECT INTO str_filas2 string_to_array(str_data[10],'|');
				
				cont_fila=1;
				FOR cont_fila IN array_lower(str_filas2,1) .. array_upper(str_filas2,1) LOOP
					SELECT INTO str_filas3 string_to_array(str_filas2[cont_fila],'&&');
					--str_filas3[1]	idreg
					--str_filas3[2]	del
					--str_filas3[3]	noTr
					--str_filas3[4]	idprod
					--str_filas3[5]	precio
					--str_filas3[6] id_pedido
					if str_filas3[2]::integer=1 then
						if str_filas3[1]::integer>0 then 
							update log_viaje_serv_adic set precio=str_filas3[5]::double precision where id=str_filas3[1]::integer;
						else 
							--Obtener datos del producto
							select id, unidad_id, inv_prod_presentacion_id as pres_id from inv_prod where id=str_filas3[4]::integer limit 1 into fila3;
							
							insert into log_viaje_serv_adic(log_viaje_id,inv_prod_id,inv_prod_unidad_id,inv_prod_pres_id,precio, log_doc_ped_id)
							values(str_data[4]::integer,str_filas3[4]::integer,fila3.unidad_id,fila3.pres_id,str_filas3[5]::double precision, str_filas3[6]::integer);
						end if;
					else
						delete from log_viaje_serv_adic where id=str_filas3[1]::integer;
					end if;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		
		
		IF command_selected = 'confirm' THEN 
			--inv_alm_id, --str_data[12]::integer,
			
			--Obtener datos del Vehiculo(Unidad)
			SELECT placa, numero_economico, log_chofer_id, log_vehiculo_clase_id, log_vehiculo_tipo_id FROM log_vehiculos WHERE id=str_data[8]::integer LIMIT 1 INTO fila;

			--Buscar costo de la ruta
			select (case when costo is null then 0 else costo end) as costo from log_ruta_tipo_unidad where log_ruta_id=str_data[11]::integer and log_vehiculo_tipo_id=fila.log_vehiculo_tipo_id limit 1 into fila5;

			if fila5.costo is null then fila5.costo:=0; end if;
			
			--Status 1=Confirmado
			UPDATE log_viaje SET gral_suc_id=str_data[7]::integer, fecha=str_data[5]::date, hora=str_data[6]::time with time zone, log_vehiculo_id=str_data[8]::integer, no_economico=fila.numero_economico, placas=fila.placa, log_vehiculo_clase_id=fila.log_vehiculo_clase_id, log_chofer_id=fila.log_chofer_id, observaciones=str_data[9]::text, log_ruta_id=str_data[11]::integer, total_precio=str_data[13]::double precision, log_tipo_distribucion_id=str_data[14]::integer, costo_ruta=fila5.costo, log_vehiculo_tipo_id=fila.log_vehiculo_tipo_id, log_status_id=2, momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
			WHERE id=str_data[4]::integer 
			RETURNING folio into nuevo_folio;
			
			--En el campo nuevo_folio, asignamos el folio del Viaje
			
			/*Crear registro header para la salida*/
			
			--SALIDA POR ENVIO A VIAJE
			tipo_movimiento_id:=20003;
			
			--Genera nuevo registro HEADER del MOVIMIENTO DE SALIDA
			INSERT INTO inv_mov(referencia, inv_mov_tipo_id, fecha_mov, observacion, momento_creacion, gral_usr_id, gral_app_id ) 
			VALUES(nuevo_folio,tipo_movimiento_id,espacio_tiempo_ejecucion,'SALIDA POR ENVIO A VIAJE',espacio_tiempo_ejecucion,usuario_id, app_selected) 
			RETURNING id INTO ultimo_id;
			
			/*Termina registro header para la salida*/			
			
			cont_fila:=1;
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	iddet
					--str_filas[3]	idcga
					--str_filas[4]	idped
					--str_filas[5]	iddest
					--str_filas[6]	idmun
					--str_filas[7]	selec
					--str_filas[8]	selec_chk_firma
					--str_filas[9]	selec_chk_sello
					--str_filas[10]	selec_chk_efectivo
					--str_filas[11]	selec_chk_cheque
					--str_filas[12]	tarifa_clase_id
					--str_filas[13]	tarifa_tipo_id
					--str_filas[14]	precio
					
					IF str_filas[7]::integer>=1 THEN 
						--No ha sido eliminado
						
						--Obtener id del cliente
						select log_doc.cxc_clie_id from log_doc join log_doc_carga on log_doc_carga.log_doc_id=log_doc.id where log_doc_carga.id=str_filas[3]::integer LIMIT 1 INTO fila2;
						
						--ESTATUS 1=ENVIADO, para log_doc_ped, log_doc_ped_det, log_viaje_det, 
						
						--Actualizar estatus
						update log_doc_ped set log_status_id=2 where id=str_filas[4]::integer;
						
						--update log_doc_ped_det set log_status_id=2 where log_doc_ped_id=str_filas[4]::integer;
						
						IF str_filas[2]::integer > 0 THEN 
							--Actualizar registro existente
							UPDATE log_viaje_det SET cxc_clie_id=fila2.cxc_clie_id, solicitar_firma=str_filas[8]::boolean, solicitar_sello=str_filas[9]::boolean, solicitar_efectivo=str_filas[10]::boolean, solicitar_cheque=str_filas[11]::boolean, log_tarifa_clase_id=str_filas[12]::integer, log_tarifa_tipo_id=str_filas[13]::integer, precio_tarifa_venta=str_filas[14]::double precision, cant_tar=str_filas[15]::double precision, cant_car=str_filas[16]::double precision, log_status_id=2 
							WHERE id=str_filas[2]::integer;
						ELSE
							--Crear nuevo registro
							INSERT INTO log_viaje_det(
								log_viaje_id, --str_data[4]::integer,
								cxc_clie_id, --fila2.cxc_clie_id,
								log_doc_carga_id, --str_filas[3]::integer,
								log_doc_ped_id, --str_filas[4]::integer,
								gral_mun_id, --str_filas[6]::integer,
								solicitar_firma, --str_filas[8]::boolean,
								solicitar_sello, --str_filas[9]::boolean,
								solicitar_efectivo, --str_filas[10]::boolean,
								solicitar_cheque, --str_filas[11]::boolean,
								log_tarifa_clase_id, --str_filas[12]::integer,
								log_tarifa_tipo_id, --str_filas[13]::integer,
								precio_tarifa_venta, --str_filas[14]::double precision,
								cant_tar, --str_filas[15]::double precision,
								cant_car, --str_filas[16]::double precision,
								log_status_id--2=Enviado
							)
							VALUES(str_data[4]::integer, fila2.cxc_clie_id, str_filas[3]::integer, str_filas[4]::integer, str_filas[6]::integer, str_filas[8]::boolean, str_filas[9]::boolean, str_filas[10]::boolean,str_filas[11]::boolean, str_filas[12]::integer, str_filas[13]::integer, str_filas[14]::double precision,str_filas[15]::double precision,str_filas[16]::double precision,2)
							RETURNING id::character varying INTO str_filas[2];
						END IF;
						
						
						/*** REGISTRAR SALIDA DEL ALMACEN *****/
						sql_select:='
						SELECT 
							log_doc_ped_det.id as id_det, 
							(case when inv_prod.id is null then 0 else inv_prod.id end) as id_prod,
							log_doc_ped_det.cantidad,
							log_doc_ped_det.inv_prod_unidad_id as um_id,
							inv_prod.inv_prod_presentacion_id as pres_def_id,
							log_doc_ped_det.log_status_id as estatus,
							0::double precision as precio_mn,
							0::integer as alm_orig_id,
							0::integer as alm_dest_id 
						FROM log_doc_ped_det 
						JOIN inv_prod on inv_prod.id=log_doc_ped_det.inv_prod_id 
						WHERE log_doc_ped_det.log_doc_ped_id='||str_filas[4]||' ORDER BY log_doc_ped_det.id';
						
						for fila4 in execute (sql_select) loop 
							--Este es el almacen de salida
							fila4.alm_orig_id:=str_data[12]::integer;							
							
							--Genera registro en detalles del MOVIMIENTO DE SALIDA
							INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad,costo, inv_prod_presentacion_id)
							VALUES(ultimo_id, fila4.alm_orig_id, fila4.alm_dest_id, fila4.id_prod, fila4.cantidad, fila4.precio_mn, fila4.pres_def_id);
							
							--Descontar existencias
							cadena_sql := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||fila4.cantidad||'::double precision),momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
							WHERE inv_alm_id='||fila4.alm_orig_id||'::integer AND inv_prod_id='||fila4.id_prod||'::integer AND ano='||ano_actual;
							
							--RAISE EXCEPTION '%','cadena_sql: '||cadena_sql;
							
							EXECUTE cadena_sql;
							
							--Actualizar registro del detalle del pedido para indicar que el producto fue enviado al viaje
							--update log_doc_ped_det set estatus=2, log_status_id=2 where id=fila4.id_det;
							update log_doc_ped_det set log_status_id=2 where id=fila4.id_det;
						end loop;
						
						--RAISE EXCEPTION '%','ultimo_id2: '||ultimo_id2;
						
						/*** TERMINA REGISTRO DE SALIDA DEL ALMACEN *****/
						
						
						/*
						0;"NUEVO"
						1;"ENV-PARCIAL"
						2;"ENVIADO "
						3;"EVIDENCIA"
						4;"LIQUIDACION"
						5;"PAGADO"
						*/
						--Revisar estatus de productos del pedido
						--Si no quedan productos con estatus=0, entonces hay que cambiar el estatus del Pedido
						if (select count(id) from log_doc_ped_det where log_status_id<=0 and log_doc_ped_id=str_filas[4]::integer)<=0 then 
							--Actualizar el estatus del pedido si ya no queda productos para enviar a viaje
							--update log_doc_ped set estatus=1, log_status_id=1 where id=str_filas[4]::integer;
							update log_doc_ped set log_status_id=2 where id=str_filas[4]::integer;
							
							--update log_viaje_det set log_status_id=1, status=1 where id=str_filas[2]::integer;
						end if;


						--RAISE EXCEPTION '%','ID_CARGA: '||str_filas[3];
						--select count(id) from log_doc_ped where log_status_id<4 and log_doc_carga_id=2;--3
						--select count(id) from log_doc_ped where log_status_id<3 and log_doc_carga_id=2;
						--select count(id) from log_doc_ped where log_status_id<2 and log_doc_carga_id=2;
						--select count(id) from log_doc_ped where log_status_id<1 and log_doc_carga_id=2;

						select 	sum(estatus0) as estatus0, sum(estatus1) as estatus1, sum(estatus2) as estatus2, sum(estatus3) as estatus3, sum(estatus4) as estatus4, 0::integer as estatus 
						from(
							select log_doc_carga_id, (case when log_status_id=0 then 1 else 0 end) as estatus0, (case when log_status_id=1 then 1 else 0 end) as estatus1, (case when log_status_id=2 then 1 else 0 end) as estatus2, (case when log_status_id=3 then 1 else 0 end) as estatus3, (case when log_status_id=4 then 1 else 0 end) as estatus4 from log_doc_ped
						) as sbt where log_doc_carga_id=str_filas[3]::integer
						into fila;

						if fila.estatus1>0 and fila.estatus2=0 and fila.estatus3=0 and fila.estatus4=0 then
							fila.estatus:=1;
						end if;

						if fila.estatus1=0 and fila.estatus2>0 and fila.estatus3=0 and fila.estatus4=0 then
							fila.estatus:=2;
						end if;

						if fila.estatus1=0 and fila.estatus2=0 and fila.estatus3>0 and fila.estatus4=0 then
							fila.estatus:=3;
						end if;

						if fila.estatus1=0 and fila.estatus2=0 and fila.estatus3=0 and fila.estatus4>0 then
							fila.estatus:=4;
						end if;

						if fila.estatus1>0 and fila.estatus2>0 and fila.estatus3=0 and fila.estatus4>0 then
							fila.estatus:=1;
						end if;
						
						if fila.estatus0>0 and fila.estatus1=0 and fila.estatus2>0 and fila.estatus3=0 and fila.estatus4>0 then
							fila.estatus:=1;
						end if;
						
						update log_doc_carga set log_status_id=fila.estatus where id=str_filas[3]::integer;
					ELSE 
						--Fue eliminado
						DELETE FROM log_viaje_det WHERE id=str_filas[2]::integer;
					END IF;
				END LOOP;		
			END IF;

			--Crear registros para servicios adicionales
			IF trim(str_data[10])<>'' THEN
				--Validar Servicios Adicionales
				
				--Convertir en arreglo la cadena de Adicionales
				SELECT INTO str_filas2 string_to_array(str_data[10],'|');
				
				cont_fila=1;
				FOR cont_fila IN array_lower(str_filas2,1) .. array_upper(str_filas2,1) LOOP
					SELECT INTO str_filas3 string_to_array(str_filas2[cont_fila],'&&');
					--str_filas3[1]	idreg
					--str_filas3[2]	del
					--str_filas3[3]	noTr
					--str_filas3[4]	idprod
					--str_filas3[5]	precio
					--str_filas3[6] id_pedido
					if str_filas3[2]::integer=1 then
						if str_filas3[1]::integer>0 then 
							update log_viaje_serv_adic set precio=str_filas3[5]::double precision where id=str_filas3[1]::integer;
						else 
							--Obtener datos del producto
							select id, unidad_id, inv_prod_presentacion_id as pres_id from inv_prod where id=str_filas3[4]::integer limit 1 into fila3;
							
							insert into log_viaje_serv_adic(log_viaje_id,inv_prod_id,inv_prod_unidad_id,inv_prod_pres_id,precio, log_doc_ped_id)
							values(str_data[4]::integer,str_filas3[4]::integer,fila3.unidad_id,fila3.pres_id,str_filas3[5]::double precision, str_filas3[6]::integer);
						end if;
					else
						delete from log_viaje_serv_adic where id=str_filas3[1]::integer;
					end if;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;

		


		IF command_selected = 'guardar_rechazos' THEN
			--str_data[4]  id_det_viaje
			--str_data[5]  select_almacen_destino
			--str_data[6]  almacen_origen
			
			--Obtener datos
			select log_viaje.folio, log_viaje_det.cxc_clie_id, log_viaje_det.log_doc_ped_id, 0::integer as ultimo_id_log_doc, log_doc_carga.no_carga, log_doc_carga.fecha_entrega, 0::integer as ultimo_id_log_doc_carga, log_doc_ped.no_pedido, log_doc_ped.no_entrega, log_doc_ped.cxc_dest_id, log_doc_ped.gral_mun_id, 0::integer as ultimo_id_log_doc_ped 
			from log_viaje_det 
			join log_viaje on log_viaje.id=log_viaje_det.log_viaje_id 
			join log_doc_carga on log_doc_carga.id=log_viaje_det.log_doc_carga_id 
			join log_doc_ped on log_doc_ped.id=log_viaje_det.log_doc_ped_id 
			where log_viaje_det.id=str_data[4]::integer limit 1 
			into fila;
			
			
			/******INICIA EL REGISTRO DEL DOCUMENTO PARA DEJAR REGISTRO DISPONIBLE PARA UN VIAJE****/
			--Entrada por Compra de Mercancia
			tipo_movimiento_id:=1;
			
			--Folio carga de documento(LOG)
			id_tipo_consecutivo:=51;
			
			--Aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del Ajuste
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--Tipo 1=Carga automatica desde un excel
			--Tipo 2=Carga desde el Aplicativo de Registro de Cargas
			--Tipo 3=Creado desde el registro de un rechazo
			
			--Crear registro en la tabla global de DOCUMENTOS
			INSERT INTO log_doc(folio, gral_emp_id, gral_suc_id, inv_alm_id, cxc_clie_id, fecha_carga, tipo, borrado_logico, momento_creacion, gral_usr_id_crea, observaciones)
			VALUES(nuevo_folio, emp_id, suc_id, str_data[5]::integer, fila.cxc_clie_id, espacio_tiempo_ejecucion, 3, false, espacio_tiempo_ejecucion, usuario_id, 'CARGA GENERADA AL REGISTRAR RECHAZO DEL VIAJE FOLIO='||fila.folio||' NO_CARGA='||fila.no_carga||' NO_PEDIDO='||fila.no_pedido)
			RETURNING id INTO fila.ultimo_id_log_doc;
			
			/******TERMINA REGISTRO DEL DOCUMENTO****/
			
			

			/******INICIA EL REGISTRO DE LA CARGA****/
			--Folio Registro de Cargas(LOG)
			id_tipo_consecutivo:=54;
			
			--Aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--Crear registro en la tabla de CARGAS
			INSERT INTO log_doc_carga(folio, log_doc_id, no_carga, fecha_entrega, puesto_exp, observaciones, log_status_id)
			VALUES(nuevo_folio, fila.ultimo_id_log_doc, fila.no_carga, fila.fecha_entrega, '', 'CARGA GENERADA AL REGISTRAR RECHAZO DEL VIAJE FOLIO='||fila.folio||' NO_CARGA='||fila.no_carga||' NO_PEDIDO='||fila.no_pedido, 0)
			RETURNING id INTO fila.ultimo_id_log_doc_carga;
			
			/******TERMINA REGISTRO DE LA CARGA****/
			
			
			/******INICIA EL REGISTRO DEL PEDIDO****/
			--Crear registro en la tabla de PEDIDOS
			INSERT INTO log_doc_ped(log_doc_carga_id, no_pedido, no_entrega, cxc_dest_id, gral_mun_id, log_status_id)
			VALUES(fila.ultimo_id_log_doc_carga, fila.no_pedido, fila.no_entrega, fila.cxc_dest_id, fila.gral_mun_id, 0)
			RETURNING id INTO fila.ultimo_id_log_doc_ped;
			
			--Buscar las facturas del pedido al que corresponde el rechazo
			FOR fila2 IN EXECUTE('select id, no_facura, total_factura from log_doc_ped_fac where log_doc_ped_id='||fila.log_doc_ped_id||' ORDER BY id') LOOP
				INSERT INTO log_doc_ped_fac(log_doc_ped_id, no_facura, total_factura)VALUES(fila.ultimo_id_log_doc_ped, fila2.no_facura, fila2.total_factura);
			END LOOP;
			/******TERMINA REGISTRO DE PEDIDO****/
			
			/*
			FOR fila2 IN EXECUTE('SELECT distinct inv_suc_alm.almacen_id FROM gral_suc JOIN inv_suc_alm ON inv_suc_alm.sucursal_id=gral_suc.id WHERE gral_suc.empresa_id='||fila.emp_id||' ORDER BY inv_suc_alm.almacen_id') LOOP
				INSERT INTO inv_exi(inv_prod_id, inv_alm_id, ano, exi_inicial, transito) VALUES(fila.prod_id, fila2.almacen_id, ano_actual, 0, 0);
			END LOOP;
			*/
			
			
			
			cont_fila:=1;
			IF extra_data[1]<>'sin datos' THEN
				
				--Agregar movimiento de entrada al almacen de rechazos
				
				--Entrada por RECHAZO
				tipo_movimiento_id:=20001;
				
				--Genera registro header del MOVIMIENTO
				INSERT INTO inv_mov(referencia,inv_mov_tipo_id,fecha_mov,observacion,momento_creacion,gral_usr_id,gral_app_id ) 
				VALUES(fila.folio,tipo_movimiento_id,espacio_tiempo_ejecucion,'ENTRADA POR REGISTRO DE RECHAZO DEL DESTINATARIO',espacio_tiempo_ejecucion,usuario_id, app_selected) 
				RETURNING id INTO ultimo_id;
				
				
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	noTr
					--str_filas[2]	id_det_ped
					--str_filas[3]	cant_uni_dev
					--str_filas[4]	select_tipo_rechazo
					--str_filas[5]	precio_unitario_mn
					--str_filas[6]	id_prod
					--str_filas[7]	cargo_rechazo
					
					--Crear registro de la devolucion
					insert into log_doc_ped_det_dev(log_doc_ped_det_id, log_viaje_det_id, tipo, log_tipo_rechazo_id, cantidad, cargo)
					values(str_filas[2]::integer, str_data[4]::integer, 1, str_filas[4]::integer, str_filas[3]::double precision, str_filas[7]::double precision);
					
					/****CREAR DETALLE DE PEDIDO(log_doc_ped_det)*******/
					select * from log_doc_ped_det where id=str_filas[2]::integer limit 1 into fila3;
					
					--Crear nuevo registro
					INSERT INTO log_doc_ped_det(
						log_doc_ped_id, --fila.ultimo_id_log_doc_ped, 
						pos, --fila3.pos, 
						inv_prod_id, --fila3.inv_prod_id,
						inv_prod_unidad_id, --fila3.inv_prod_unidad_id,
						inv_prod_pres_id, --fila3.inv_prod_pres_id,
						cantidad, --str_filas[3]::double precision,
						peso, --((fila3.peso / fila3.cantidad::double precision) * str_filas[3]::double precision),
						volumen, --((fila3.volumen / fila3.cantidad::double precision) * str_filas[3]::double precision)
						log_status_id --0
					)
					VALUES(fila.ultimo_id_log_doc_ped, fila3.pos, fila3.inv_prod_id, fila3.inv_prod_unidad_id, fila3.inv_prod_pres_id, str_filas[3]::double precision, ((fila3.peso / fila3.cantidad::double precision) * str_filas[3]::double precision), ((fila3.volumen / fila3.cantidad::double precision) * str_filas[3]::double precision), 0);
					/****TERMINA CREAR DETALLE DE PEDIDO(log_doc_ped_det)*******/
					

					
					--Buscar presentacion default del producto
					select id as id_prod, inv_prod_presentacion_id as pres_def_id from inv_prod where id=str_filas[6]::integer limit 1 into fila2;
					
					/****INICIA DETALLE DEL MOVIMIENTO(inv_mov_detalle)*******/
					
					--Genera registro en detalles del MOVIMIENTO ENTRADA
					INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id)
					VALUES(ultimo_id,str_data[6]::integer, str_data[5]::integer,str_filas[6]::integer, str_filas[3]::double precision, str_filas[5]::double precision, fila2.pres_def_id);
					
					/****TERMINA DETALLE DEL MOVIMIENTO(inv_mov_detalle)*******/
					


					/****INICIA REGISTRAR EXISTENCIA EN ALMACEN(inv_exi)*******/
					--Cargar INV_EXI
					exis:=0;
					cadena_sql:='';
					
					--Buscar registro del producto en el almacen y en el a√±o actual
					SELECT count(id) FROM inv_exi WHERE inv_prod_id=fila2.id_prod AND inv_alm_id=str_data[5]::integer AND ano=ano_actual INTO exis;
					
					IF exis > 0 THEN 
						cadena_sql:='UPDATE inv_exi SET entradas_'||mes_actual||'=entradas_'||mes_actual||' + '||str_filas[3]||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
						WHERE inv_prod_id='||fila2.id_prod||' AND inv_alm_id='||str_data[5]||' AND ano='||ano_actual;
					ELSE
						cadena_sql:='INSERT INTO inv_exi(inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial, costo_ultimo_'||mes_actual||') '||
						'VALUES('||fila2.id_prod||','||str_data[5]||','||ano_actual||','||str_filas[3]||','''|| espacio_tiempo_ejecucion ||''',0,0 );';
					END IF;
					
					if cadena_sql<>'' then 
						--Si la cadena no esta vacia hay que ejecutar la actualizacion o insercion
						execute cadena_sql;
					end if;
					/****TERMINA REGISTRAR EXISTENCIA EN ALMACEN(inv_exi)*******/
					
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;


		--RAISE EXCEPTION '%','command_selected: '||command_selected;
		
		IF command_selected = 'cancel' THEN
			UPDATE log_viaje SET log_status_id=6, momento_baja=now(), gral_usr_id_baja=usuario_id, borrado_logico=true WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Aplicativo Administrador de Viajes(LOG)
	

	

	-- Catalogo de Vehiculo Marca
	IF app_selected = 182 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO log_vehiculo_marca (titulo,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
	
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE log_vehiculo_marca SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualiza=usuario_id
			WHERE log_vehiculo_marca.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE log_vehiculo_marca SET momento_baja=now(), borrado_logico=true, gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--termina Catalogo de Vehiculo Marca


	-- Catalogo de Vehiculo Tipo Rodada
	IF app_selected = 183 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO log_vehiculo_tipo_rodada (titulo,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
	
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE log_vehiculo_tipo_rodada SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualiza=usuario_id
			WHERE log_vehiculo_tipo_rodada.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE log_vehiculo_tipo_rodada SET momento_baja=now(), borrado_logico=true, gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--termina Catalogo de Vehiculo Tipo Rodada

	
	-- Catalogo de Vehiculo Tipo Caja
	IF app_selected = 184 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO log_vehiculo_tipo_caja (titulo,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
	
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE log_vehiculo_tipo_caja SET titulo=str_data[5],momento_actualizacion=now(),gral_usr_id_actualiza=usuario_id
			WHERE log_vehiculo_tipo_caja.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE log_vehiculo_tipo_caja SET momento_baja=now(), borrado_logico=true, gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--termina Catalogo de Vehiculo Tipo Caja



	
	-- Catalogo de Servicios Adicionales(LOG)
	IF app_selected = 185 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			
			cont_fila:=1;
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	idreg
					--str_filas[2]	idprod
					--str_filas[3]	elim
					IF str_filas[3]::integer=1 THEN 
						INSERT INTO log_serv_adic(inv_prod_id)VALUES(str_filas[2]::integer);
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			cont_fila:=1;
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	idreg
					--str_filas[2]	idprod
					--str_filas[3]	elim
					IF str_filas[3]::integer=1 THEN 
						if str_filas[1]::integer > 0 then  
							update log_serv_adic set inv_prod_id=str_filas[2]::integer where id=str_filas[1]::integer;
						else
							INSERT INTO log_serv_adic(inv_prod_id)VALUES(str_filas[2]::integer);
						end if;
					ELSE
						delete from log_serv_adic where id=str_filas[1]::integer;
					END IF;
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			delete from log_serv_adic where id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--Termina Catalogo de Servicios Adicionales(LOG)





	-- Catalogo de Vehiculo Tipos de Unidades
	IF app_selected = 187 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			--str_data[6]         volumeninicio
			--str_data[7]         volumenfin
			--str_data[8]         kginicio
			--str_data[9]         kgfin
			--str_data[10]         carton_ini
			--str_data[11]         carton_fin
			--str_data[12]         tarima_ini
			--str_data[13]         tarima_fin
			
			INSERT INTO log_vehiculo_tipo (titulo,volumen_inicio,volumen_fin,kg_inicio,kg_fin, carton_inicio, carton_fin, tarima_inicio, tarima_fin, borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],str_data[6]::double precision,str_data[7]::double precision,str_data[8]::double precision,str_data[9]::double precision,str_data[10]::double precision, str_data[11]::double precision, str_data[12]::double precision, str_data[13]::double precision, false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE log_vehiculo_tipo SET titulo=str_data[5],volumen_inicio=str_data[6]::double precision,volumen_fin=str_data[7]::double precision,kg_inicio=str_data[8]::double precision,kg_fin=str_data[9]::double precision, carton_inicio=str_data[10]::double precision, carton_fin=str_data[11]::double precision, tarima_inicio=str_data[12]::double precision, tarima_fin=str_data[13]::double precision, momento_actualizacion=now(),gral_usr_id_actualiza=usuario_id
			WHERE log_vehiculo_tipo.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE log_vehiculo_tipo SET momento_baja=now(), borrado_logico=true, gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--termina Catalogo de Vehiculo Tipos de Unidades



        --Aplicativo de Registro de Cargas(LOG)
        IF app_selected=188 THEN
		--str_data[1]	app_selected
		--str_data[2]	command_selected
		--str_data[3]	id_usuario
		--str_data[4]	identificador
		--str_data[5]	no_carga
		--str_data[6]	fecha_entrega
		--str_data[7]	select_almacen
		--str_data[8]	id_cliente
		--str_data[9]	observaciones
		--str_data[10]	tipo_carga
		
		IF command_selected = 'new' THEN
			
			/******INICIA EL REGISTRO DEL DOCUMENTO****/
			
			--Entrada por Compra de Mercancia
			tipo_movimiento_id:=1;
			
			--Folio carga de documento(LOG)
			id_tipo_consecutivo:=51;
			
			--Aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del Ajuste
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

			
			--Tipo 1=Carga automatica desde un excel
			--Tipo 2=Carga desde el Aplicativo de Registro de Cargas
			--Tipo 3=Creado desde el registro de un rechazo
			
			--Crear registro en la tabla global de DOCUMENTOS
			INSERT INTO log_doc(
				folio, --nuevo_folio,
				gral_emp_id, --emp_id, 
				gral_suc_id, --suc_id, 
				inv_alm_id, --str_data[7]::integer,
				cxc_clie_id, --str_data[8]::integer,
				fecha_carga, --espacio_tiempo_ejecucion,
				tipo, --2,
				borrado_logico, --false,
				momento_creacion, --espacio_tiempo_ejecucion,
				gral_usr_id_crea --usuario_id 
			)
			VALUES(nuevo_folio, emp_id, suc_id, str_data[7]::integer, str_data[8]::integer, espacio_tiempo_ejecucion, 2, false, espacio_tiempo_ejecucion, usuario_id )
			RETURNING id INTO ultimo_id;
			
			
			/******INICIA EL REGISTRO DE LA CARGA****/
			--Folio Registro de Cargas(LOG)
			id_tipo_consecutivo:=54;
			
			--Aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--Crear registro en la tabla de CARGAS
			INSERT INTO log_doc_carga(folio, log_doc_id, no_carga, fecha_entrega, puesto_exp, observaciones, afecta_inv, log_status_id)
			VALUES(nuevo_folio, ultimo_id, str_data[5], str_data[6]::date, '', str_data[9],str_data[10]::boolean, 0)
			RETURNING id INTO ultimo_id2;

			
			IF extra_data[1]<>'sin datos' THEN
				ultimo_id3:=0;
				cont_fila:=1;
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	tipoTr
					--str_filas[3]	noTr
					--str_filas[4]	iddet
					--str_filas[5]	iddest
					--str_filas[6]	no_pedido
					--str_filas[7]	no_fac
					--str_filas[8]	idpedfac
					--str_filas[9]	total_fac
					--str_filas[10]	clase_tarifa
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then
						if trim(str_filas[2])='PAR' then
							--Obtener dato del destinatario
							SELECT gral_mun_id FROM cxc_destinatarios WHERE id=str_filas[5]::integer LIMIT 1 INTO fila;
							
							if fila.gral_mun_id is null then fila.gral_mun_id:=0; end if;
							
							exis:=0;
						
							select count(id) from log_tarifa_clie where cxc_clie_id=str_data[8]::integer into exis;
							
							if exis is null then exis:=0; end if;
							
							if exis>0 then 
								if str_filas[10]::integer > 0 then 
									select log_tarifa_tipo_id from log_tarifa_clie where log_tarifa_clase_id=str_filas[10]::integer and cxc_clie_id=str_data[8]::integer limit 1 into fila2;

									if fila2.log_tarifa_tipo_id is null then fila2.log_tarifa_tipo_id:=0; end if;
									
									--Crear registro en la tabla de PEDIDOS
									INSERT INTO log_doc_ped(log_doc_carga_id, no_pedido, no_entrega, cxc_dest_id, gral_mun_id, log_tarifa_clase_id, log_tarifa_tipo_id, log_status_id)
									VALUES(ultimo_id2, str_filas[6], '', str_filas[5]::integer, fila.gral_mun_id, str_filas[10]::integer, fila2.log_tarifa_tipo_id, 0)
									RETURNING id INTO ultimo_id3;
								else
									--Crear registro en la tabla de PEDIDOS
									INSERT INTO log_doc_ped(log_doc_carga_id, no_pedido, no_entrega, cxc_dest_id, gral_mun_id, log_tarifa_clase_id, log_status_id)
									VALUES(ultimo_id2, str_filas[6], '', str_filas[5]::integer, fila.gral_mun_id, str_filas[10]::integer, 0)
									RETURNING id INTO ultimo_id3;
								end if; 
							else 
								--Crear registro en la tabla de PEDIDOS
								INSERT INTO log_doc_ped(log_doc_carga_id, no_pedido, no_entrega, cxc_dest_id, gral_mun_id, log_tarifa_clase_id, log_status_id)
								VALUES(ultimo_id2, str_filas[6], '', str_filas[5]::integer, fila.gral_mun_id, str_filas[10]::integer, 0)
								RETURNING id INTO ultimo_id3;
							end if;
							
							if trim(str_filas[7])<>'' then 
								--Guadar numero de factura
								INSERT INTO log_doc_ped_fac(log_doc_ped_id, no_facura, total_factura)VALUES(ultimo_id3, str_filas[7], str_filas[9]::double precision);
							end if;
						else
							if trim(str_filas[7])<>'' then 
								--Guadar numero de factura
								INSERT INTO log_doc_ped_fac(log_doc_ped_id, no_facura, total_factura)VALUES(ultimo_id3, str_filas[7], str_filas[9]::double precision);
							end if;
						end if;
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN 
			
			--Obtener el id del documento a partir del id de la carga
			select log_doc_id from log_doc_carga where id=str_data[4]::integer into ultimo_id;
			
			if ultimo_id is null then ultimo_id:=0; end if;
			
			--Actualizar registro del documento
			UPDATE log_doc set inv_alm_id=str_data[7]::integer, cxc_clie_id=str_data[8]::integer, momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
			WHERE id=ultimo_id;
			
			--Actualizar registro de la Carga 
			UPDATE log_doc_carga SET no_carga=str_data[5], fecha_entrega=str_data[6]::date, observaciones=str_data[9], afecta_inv=str_data[10]::boolean  
			WHERE id=str_data[4]::integer;
			
			IF extra_data[1]<>'sin datos' THEN
				ultimo_id3:=0;
				cont_fila:=1;
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	tipoTr
					--str_filas[3]	noTr
					--str_filas[4]	iddet
					--str_filas[5]	iddest
					--str_filas[6]	no_pedido
					--str_filas[7]	no_fac
					--str_filas[8]	idpedfac
					--str_filas[9]	total_fac
					--str_filas[10]	clase_tarifa
					
					--Verificar que el registro no se haya eliminado del grid
					IF str_filas[1]::integer > 0 then 
						exis:=0;
					
						select count(id) from log_tarifa_clie where cxc_clie_id=str_data[8]::integer into exis;
						
						if exis is null then exis:=0; end if;
						
						if trim(str_filas[2])='PAR' then 
							if str_filas[4]::integer > 0 then 
								
								ultimo_id3 := str_filas[4]::integer;

								if exis>0 then 
									if str_filas[10]::integer > 0 then 
										select log_tarifa_tipo_id from log_tarifa_clie where log_tarifa_clase_id=str_filas[10]::integer and cxc_clie_id=str_data[8]::integer limit 1 into fila2;

										if fila2.log_tarifa_tipo_id is null then fila2.log_tarifa_tipo_id:=0; end if;
										
										--Actualizar registro en la tabla de PEDIDOS
										update log_doc_ped set no_pedido=str_filas[6], log_tarifa_clase_id=str_filas[10]::integer, log_tarifa_tipo_id=fila2.log_tarifa_tipo_id where id=str_filas[4]::integer;
									else
										--Actualizar registro en la tabla de PEDIDOS
										update log_doc_ped set no_pedido=str_filas[6], log_tarifa_clase_id=str_filas[10]::integer where id=str_filas[4]::integer;
									end if; 
								else 
									--Actualizar registro en la tabla de PEDIDOS
									update log_doc_ped set no_pedido=str_filas[6], log_tarifa_clase_id=str_filas[10]::integer where id=str_filas[4]::integer;
								end if;
								
								
								if str_filas[8]::integer > 0 then 
									if trim(str_filas[7])<>'' then 
										--Si factura No viene vacio, hay que actualizar
										update log_doc_ped_fac set no_facura=str_filas[7], total_factura=str_filas[9]::double precision where id=str_filas[8]::integer;
									else
										--Si factura SI viene vacio, hay que eliminar
										delete from log_doc_ped_fac where id=str_filas[8]::integer;
									end if;
								else
									if trim(str_filas[7])<>'' then 
										--Guadar numero de factura
										INSERT INTO log_doc_ped_fac(log_doc_ped_id, no_facura, total_factura)VALUES(ultimo_id3, str_filas[7], str_filas[9]::double precision);
									end if;
								end if;
							else
								--Obtener dato del destinatario
								SELECT gral_mun_id FROM cxc_destinatarios WHERE id=str_filas[5]::integer LIMIT 1 INTO fila;
								
								if fila.gral_mun_id is null then fila.gral_mun_id:=0; end if;

								if exis>0 then 
									if str_filas[10]::integer > 0 then 
										select log_tarifa_tipo_id from log_tarifa_clie where log_tarifa_clase_id=str_filas[10]::integer and cxc_clie_id=str_data[8]::integer limit 1 into fila2;

										if fila2.log_tarifa_tipo_id is null then fila2.log_tarifa_tipo_id:=0; end if;
										
										--Crear registro en la tabla de PEDIDOS
										INSERT INTO log_doc_ped(log_doc_carga_id, no_pedido, no_entrega, cxc_dest_id, gral_mun_id, log_tarifa_clase_id, log_tarifa_tipo_id, log_status_id)
										VALUES(ultimo_id2, str_filas[6], '', str_filas[5]::integer, fila.gral_mun_id, str_filas[10]::integer, fila2.log_tarifa_tipo_id,0)
										RETURNING id INTO ultimo_id3;
									else
										--Crear registro en la tabla de PEDIDOS
										INSERT INTO log_doc_ped(log_doc_carga_id, no_pedido, no_entrega, cxc_dest_id, gral_mun_id, log_tarifa_clase_id, log_status_id)
										VALUES(ultimo_id2, str_filas[6], '', str_filas[5]::integer, fila.gral_mun_id, str_filas[10]::integer,0)
										RETURNING id INTO ultimo_id3;
									end if; 
								else 
									--Crear registro en la tabla de PEDIDOS
									INSERT INTO log_doc_ped(log_doc_carga_id, no_pedido, no_entrega, cxc_dest_id, gral_mun_id, log_tarifa_clase_id, log_status_id)
									VALUES(ultimo_id2, str_filas[6], '', str_filas[5]::integer, fila.gral_mun_id, str_filas[10]::integer,0)
									RETURNING id INTO ultimo_id3;
								end if;
								

								
								if trim(str_filas[7])<>'' then 
									--Guadar numero de factura
									INSERT INTO log_doc_ped_fac(log_doc_ped_id, no_facura, total_factura)VALUES(ultimo_id3, str_filas[7], str_filas[9]::double precision);
								end if;
							end if;
						else
							if str_filas[8]::integer > 0 then 
								if trim(str_filas[7])<>'' then 
									--Si factura No viene vacio, hay que actualizar
									update log_doc_ped_fac set no_facura=str_filas[7], total_factura=str_filas[9]::double precision where id=str_filas[8]::integer;
								else
									--Si factura SI viene vacio, hay que eliminar
									delete from log_doc_ped_fac where id=str_filas[8]::integer;
								end if;
							else
								if trim(str_filas[7])<>'' then 
									--Guadar numero de factura
									INSERT INTO log_doc_ped_fac(log_doc_ped_id, no_facura, total_factura)VALUES(ultimo_id3, str_filas[7], str_filas[9]::double precision);
								end if;
							end if;
							
						end if;
					else
						--Eliminar partida
						if trim(str_filas[2])='PAR' then 
							
							/*
							Verificar si la carga no afecta inventario
							Si no afecta, entonces es necesario regresar las existencias en los registros de entradas al almacen.
							*/
							if str_data[10]::boolean=false then 
								--Obtener las partidas del pedido
								cadena_sql:='select id as id_ped_det, cantidad, inv_prod_id, inv_prod_unidad_id from log_doc_ped_det where log_doc_ped_id='||str_filas[4]||';';
								
								--RAISE EXCEPTION '%','sql_select= '||sql_select;
								FOR fila4 IN EXECUTE(cadena_sql) LOOP 
									--Redondeo de cantidad 
									fila4.cantidad := round((fila4.cantidad)::numeric,4)::double precision;
									
									--Restar salidas
									update log_entrada_sal set cantidad=(cantidad - fila4.cantidad) where inv_prod_id=fila4.inv_prod_id and inv_prod_unidad_id=fila4.inv_prod_unidad_id;

									--
									sql_select:='select id, log_entrada_det_id, cantidad from log_entrada_det_ped where log_doc_ped_det_id='||fila4.id_ped_det||';';
									
									--RAISE EXCEPTION '%','sql_select= '||sql_select;
									FOR fila5 IN EXECUTE(sql_select) LOOP 
										if fila5.cantidad > 0 then 
											update log_entrada_det set entregado=(entregado - fila5.cantidad::double precision), status=0 where id=fila5.log_entrada_det_id;
											
											--Eliminar relacion
											delete from log_entrada_det_ped where id=fila5.id;
										end if;
									END LOOP;

								END LOOP;
							end if;

							--Eliminar registros
							delete from log_doc_ped_det where log_doc_ped_id=str_filas[4]::integer;
							delete from log_doc_ped where id=str_filas[4]::integer;
							delete from log_doc_ped_fac where log_doc_ped_id=str_filas[4]::integer;
						else
							--Eliminar registro de factura
							delete from log_doc_ped_fac where id=str_filas[8]::integer;
						end if;
						
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			
			--UPDATE log_vehiculo_tipo SET momento_baja=now(), borrado_logico=true, gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;



		
		IF command_selected = 'guardar_detalle_pedido' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	id_pedido
			--str_data[5]	id_almacen
			--str_data[6]	tipo_carga

			--RAISE EXCEPTION '%','tipo_carga: '||str_data[6];

			--Verifica el tipo de carga para decidir si generar movimientos de inventario(TRUE=Si Afecta invantario al registrar cargas, FALSE=No Afecta invantario al registrar cargas)
			if str_data[6]::boolean then 
				--Generar datos en tabla header de movimientos
				
				--Entrada por REGISTRO DE CARGA
				tipo_movimiento_id:=20001;
				
				--Buscar folio de la carga
				select log_doc_carga.folio as folio_carga from log_doc_carga join log_doc_ped on log_doc_ped.log_doc_carga_id=log_doc_carga.id where log_doc_ped.id=str_data[4]::integer limit 1 into fila;
				
				if fila.folio_carga is null then fila.folio_carga:=''; end if;
				
				--Verificar si ya existe un movimiento
				exis:=0;
				cadena_sql:='';
				
				--Buscar registro del producto en el almacen y en el a√±o actual
				select count(id) from inv_mov where referencia=fila.folio_carga and inv_mov_tipo_id=tipo_movimiento_id and gral_app_id=app_selected into exis;
				
				if exis > 0 then 
					select id from inv_mov where referencia=fila.folio_carga and inv_mov_tipo_id=tipo_movimiento_id and gral_app_id=app_selected limit 1 into ultimo_id;
				else
					--Genera registro header del MOVIMIENTO
					INSERT INTO inv_mov(referencia,inv_mov_tipo_id,fecha_mov,observacion,momento_creacion,gral_usr_id,gral_app_id ) 
					VALUES(fila.folio_carga,tipo_movimiento_id,espacio_tiempo_ejecucion,'ENTRADA GENERADA POR EL APLICATIVO REGISTRO DE CARGAS',espacio_tiempo_ejecucion,usuario_id, app_selected) 
					RETURNING id INTO ultimo_id;
				end if;
			end if;
			
			
			IF extra_data[1]<>'sin datos' THEN
				cont_fila:=1;
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	elim
					--str_filas[2]	noTr
					--str_filas[3]	iddet
					--str_filas[4]	id_prod
					--str_filas[5]	id_uni
					--str_filas[6]	cant
					--str_filas[7]	peso
					--str_filas[8]	volumen
					--str_filas[9]	almacen_origen
					--str_filas[10]	almacen_destino
					--str_filas[11]	precio_unitario_mn

						
					--Verificar que el registro no se haya eliminado del grid
					if str_filas[1]::integer > 0 then 
						--Buscar el id de la presentacion default del producto.
						select inv_prod_presentacion_id as pres_def_id from inv_prod where id=str_filas[4]::integer into fila2;
						
						if fila2.pres_def_id is null then fila2.pres_def_id:=0; end if;
						
						--Redondear a 4 digitos
						str_filas[6]:=round(str_filas[6]::numeric,4)::character varying;
						
						
						if str_filas[3]::integer > 0 then 
							--Actualizar registro
							update log_doc_ped_det set inv_prod_unidad_id=str_filas[5]::integer where id=str_filas[3]::integer;
							
							if (select count(id) from inv_prod where id=str_filas[4]::integer and unidad_id=0)>0 then 
								--Asignar la unidad de medida del producto cuando no tiene asignada
								update inv_prod set unidad_id=str_filas[5]::integer where id=str_filas[4]::integer;
							end if;
						else
							--Crear nuevo registro
							INSERT INTO log_doc_ped_det(log_doc_ped_id, pos, inv_prod_id, inv_prod_unidad_id, inv_prod_pres_id, cantidad, peso, volumen, log_status_id)
							VALUES(str_data[4]::integer, '', str_filas[4]::integer, str_filas[5]::integer, fila2.pres_def_id, str_filas[6]::double precision, str_filas[7]::double precision, str_filas[8]::double precision, 0)
							returning id into ultimo_id3;

							--Asignar el id del detalle del pedido
							str_filas[3]:=ultimo_id3::character varying;
							
							--Costo unitario en cero, porque no existen costos
							str_filas[11] := '0';
							
							--Almacen Origen cero, porque es una nueva entrada
							str_filas[9] := '0';
							
							--Verifica el tipo de carga para decidir si generar movimientos de inventario
							if str_data[6]::boolean then 
								--Genera registro en detalles del MOVIMIENTO ENTRADA
								INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad,costo, inv_prod_presentacion_id)
								VALUES(ultimo_id,str_filas[9]::integer, str_filas[10]::integer,str_filas[4]::integer, str_filas[6]::double precision, str_filas[11]::double precision, fila2.pres_def_id);
								
								--Cargar INV_EXI
								exis:=0;
								cadena_sql:='';
								
								--Buscar registro del producto en el almacen y en el a√±o actual
								SELECT count(id) FROM inv_exi WHERE inv_prod_id=str_filas[4]::integer AND inv_alm_id=str_filas[10]::integer AND ano=ano_actual INTO exis;
								
								IF exis > 0 THEN 
									cadena_sql:='UPDATE inv_exi SET entradas_'||mes_actual||'=entradas_'||mes_actual||' + '||str_filas[6]||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
									WHERE inv_prod_id='||str_filas[4]||' AND inv_alm_id='||str_filas[10]||' AND ano='||ano_actual;
								ELSE
									cadena_sql:='INSERT INTO inv_exi(inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial, costo_ultimo_'||mes_actual||') '||
									'VALUES('||str_filas[4]||','||str_filas[10]||','||ano_actual||','||str_filas[6]||','''|| espacio_tiempo_ejecucion ||''',0,0 );';
								END IF;
								
								if cadena_sql<>'' then 
									--Si la cadena no esta vacia hay que ejecutar la actualizacion o insercion
									execute cadena_sql;
								end if;
							else
								--Descontar de las existencias de entradas 
								cantidad2:=0;
								cantidad2:=str_filas[6]::double precision;
								
								sql_select:='
								select 
									id as id_det,
									inv_prod_id as prod_id,
									inv_prod_unidad_id as uni_id,
									log_entrada_det.cantidad,
									(cantidad - entregado) AS exis
								from log_entrada_det where log_entrada_det.inv_prod_id='||str_filas[4]||' and inv_prod_unidad_id='||str_filas[5]||' and cantidad > entregado order by id asc;';
								
								--RAISE EXCEPTION '%','sql_select= '||sql_select;
								FOR fila IN EXECUTE(sql_select) LOOP 
									if cantidad2 > 0 then 
										if fila.exis > cantidad2 then 
											update log_entrada_det set entregado=(entregado + cantidad2) where id=fila.id_det;

											--Crear registro para relacionar la partida del pedido con la entrada de donde se esta tomando la cantidad
											insert into log_entrada_det_ped(log_doc_ped_det_id,log_entrada_det_id,cantidad) values(str_filas[3]::integer, fila.id_det, cantidad2);
  
											cantidad2:=0;
										else 
											update log_entrada_det set entregado=fila.cantidad, status=1 where id=fila.id_det;

											--Crear registro para relacionar la partida del pedido con la entrada de donde se esta tomando la cantidad
											insert into log_entrada_det_ped(log_doc_ped_det_id,log_entrada_det_id,cantidad) values(str_filas[3]::integer, fila.id_det, fila.exis);
											
											cantidad2:=cantidad2::double precision - fila.exis;
										end if;
									end if;
								END LOOP;
								
								--Buscar producto en la tabla que acumula salidas
								select count(id) from log_entrada_sal where inv_prod_id=str_filas[4]::integer and inv_prod_unidad_id=str_filas[5]::integer into exis;
								
								if exis > 0 then 
									--Sumar salidas
									update log_entrada_sal set cantidad=(cantidad + str_filas[6]::double precision) where inv_prod_id=str_filas[4]::integer and inv_prod_unidad_id=str_filas[5]::integer;
								else
									--Crear registro de salida
									insert into log_entrada_sal(inv_prod_id,inv_prod_unidad_id,cantidad) values(str_filas[4]::integer, str_filas[5]::integer, str_filas[6]::double precision);
								end if;
							end if;
						end if;
					else
						--Aqui entra cuando un registro fue elimnado de la vista
						
						if str_filas[3]::integer > 0 then 
							--Si el id del registro es mayor a cero, entra aqui
							
							--Verifica el tipo de carga para decidir si generar movimientos de inventario
							if str_data[6]::boolean then 
								
								--Obtener los datos del registro
								select log_doc_carga.folio as folio_carga, log_doc_ped_det.inv_prod_id, log_doc_ped_det.cantidad, 0::integer as pres_def_id, 0::double precision as precio_mn
								from log_doc_ped_det
								join log_doc_ped on log_doc_ped.id=log_doc_ped_det.log_doc_ped_id
								join log_doc_carga on log_doc_carga.id=log_doc_ped.log_doc_carga_id
								where log_doc_ped_det.id=str_filas[3]::integer 
								limit 1 into fila3;
								
								if registro=0 then 
									--SALIDA POR ELIMINACION
									tipo_movimiento_id:=20002;
									
									--Genera nuevo registro HEADER del MOVIMIENTO DE SALIDA
									INSERT INTO inv_mov(referencia,inv_mov_tipo_id,fecha_mov,observacion,momento_creacion,gral_usr_id,gral_app_id ) 
									VALUES(fila3.folio_carga,tipo_movimiento_id,espacio_tiempo_ejecucion,'SALIDA POR ELIMINACION DE REGISTRO DE PRODUCTO DESDE APLICATIVO DE REGISTRO DE CARGAS',espacio_tiempo_ejecucion,usuario_id, app_selected) 
									RETURNING id INTO ultimo_id2;
									
									--Aumentamos en contador de registro para permitir que solo se genere un registro de Header de movimiento por cada accion guardar
									registro := registro + 1;
								end if;
								--RAISE EXCEPTION '%','ultimo_id2: '||ultimo_id2;
								--Buscar el id de la presentacion default del producto.
								select inv_prod_presentacion_id from inv_prod where id=fila3.inv_prod_id into fila3.pres_def_id;
								
								if fila3.pres_def_id is null then fila3.pres_def_id:=0; end if;
							
								--Costo unitario en cero, porque no existen costos
								fila3.precio_mn := '0';
								
								--Almacen Origen se le asigna el valor del almacen destino porque de alli debe salir la existencia del producto
								str_filas[9] := str_filas[10];

								--El almacen destino se deja en cero, porque solamente se da de baja la existencia
								str_filas[10] := '0';
								
								--Genera registro en detalles del MOVIMIENTO DE SALIDA
								INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad,costo, inv_prod_presentacion_id)
								VALUES(ultimo_id2,str_filas[9]::integer, str_filas[10]::integer,fila3.inv_prod_id, fila3.cantidad, fila3.precio_mn, fila3.pres_def_id);
								
								
								--Descontar existencias
								cadena_sql := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||fila3.cantidad||'::double precision),momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
								WHERE inv_alm_id='||str_filas[9]||'::integer AND inv_prod_id='||fila3.inv_prod_id||'::integer AND ano='||ano_actual;
								
								--RAISE EXCEPTION '%','cadena_sql: '||cadena_sql;
								
								EXECUTE cadena_sql;
							else
								--Devolver existencia al producto que s eelimino
								select cantidad from log_doc_ped_det where id=str_filas[3]::integer into cantidad1;
								
								if cantidad1 is null then cantidad1:=0; end if;
								
								--Redondeo de cantidad
								cantidad1 := round((cantidad1)::numeric,4)::double precision;
								
								--Restar salidas
								update log_entrada_sal set cantidad=(cantidad - str_filas[6]::double precision) where inv_prod_id=str_filas[4]::integer and inv_prod_unidad_id=str_filas[5]::integer;
								
								sql_select:='select id, log_entrada_det_id, cantidad from log_entrada_det_ped where log_doc_ped_det_id='||str_filas[3]||';';
								
								--RAISE EXCEPTION '%','sql_select= '||sql_select;
								FOR fila IN EXECUTE(sql_select) LOOP 
									if fila.cantidad > 0 then 
										update log_entrada_det set entregado=(entregado - fila.cantidad::double precision), status=0 where id=fila.log_entrada_det_id;
										
										--Eliminar relacion
										delete from log_entrada_det_ped where id=fila.id;
									end if;
								END LOOP;
							end if;

								
							--Eliminar el registro
							delete from log_doc_ped_det where id=str_filas[3]::integer;
						end if;
					end if;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
	END IF;
	--termina Registro de Cargas(LOG)
	
	
	
	-- Aplicativo Tarifario de Costos
	IF app_selected = 189 THEN
		IF command_selected = 'new' THEN

			--str_data[4]	id
			--str_data clave nuevo_folio
			--str_data[5]	titulo
			--str_data[6]	select_tiporuta
			--str_data[7]	kilometros

			--Folio Tarifario
			id_tipo_consecutivo:=55;
			
			--Aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--Obtener datos del Vehiculo(Unidad)
			--SELECT placa, numero_economico, log_chofer_id, log_vehiculo_clase_id FROM log_vehiculos WHERE id=str_data[8]::integer LIMIT 1 INTO fila;
			
			INSERT INTO log_ruta(folio,titulo,log_ruta_tipo_id,km,borrado_logico,momento_crea,gral_usr_id_crea,gral_emp_id,gral_suc_id)
			VALUES (nuevo_folio, str_data[5], str_data[6]::integer, str_data[7]::double precision,false,now(),usuario_id,emp_id,suc_id)
			RETURNING id INTO ultimo_id;

			total_filas:= array_length(extra_data,1);
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	id_reg 
					--str_filas[2]	eliminado 
					--str_filas[3]	id_tipounidad
					--str_filas[4]	costo 
					--str_filas[5]	noTr
					--str_filas[6]	costo_hot_shot
					--str_filas[7]	costo_extra_reparto_local
					--str_filas[8]	costo_extra_reparto_foraneo
					--str_filas[9]	costo_estadia
					
					--crea registro en log_ruta_tipo_unidad
					INSERT INTO log_ruta_tipo_unidad(log_ruta_id,log_vehiculo_tipo_id,costo, costo_hot_shot, costo_extra_reparto_local, costo_extra_reparto_foraneo, costo_estadia) 
					VALUES(ultimo_id, str_filas[3]::integer, str_filas[4]::double precision, str_filas[6]::double precision, str_filas[7]::double precision, str_filas[8]::double precision, str_filas[9]::double precision);
					
					valor_retorno := '1';
				END LOOP;
			END IF;

			--Crear registros para Poblaciones
			IF trim(str_data[9])<>'' THEN
				--Convertir en arreglo la cadena de municipio
				SELECT INTO str_filas2 string_to_array(str_data[9],'|');
				
				cont_fila=1;
				FOR cont_fila IN array_lower(str_filas2,1) .. array_upper(str_filas2,1) LOOP
					SELECT INTO str_filas3 string_to_array(str_filas2[cont_fila],'&&');
					--str_filas3[1]	idreg
					--str_filas3[2]	eliminado
					--str_filas3[3]	noTr
					--str_filas3[4]	id_mun
					--str_filas3[5]	select_localidad
					--str_filas3[6]	select_entidad
					--str_filas3[7]	select_pais
					
					if str_filas3[2]::integer=1 then
						insert into log_ruta_mun(log_ruta_id,gral_mun_id)values(ultimo_id,str_filas3[5]::integer );
					end if;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
			
		END IF;

		IF command_selected = 'edit' THEN
			UPDATE log_ruta SET titulo=str_data[5],km=str_data[7]::double precision,momento_actualiza=now(),gral_usr_id_actualiza=usuario_id
			WHERE log_ruta.id = str_data[4]::integer;
			valor_retorno := '1';
			
			total_filas:= array_length(extra_data,1);
			cont_fila:=1;
			
			IF extra_data[1]<>'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	id_reg 
					--str_filas[2]	eliminado 
					--str_filas[3]	id_tipounidad
					--str_filas[4]	costo 
					--str_filas[5]	noTr
					--str_filas[6]	costo_hot_shot
					--str_filas[7]	costo_extra_reparto_local
					--str_filas[8]	costo_extra_reparto_foraneo
					--str_filas[9]	costo_estadia
					
					if str_filas[1]::integer>0 then
						UPDATE log_ruta_tipo_unidad SET costo=str_filas[4]::double precision, costo_hot_shot=str_filas[6]::double precision,costo_extra_reparto_local=str_filas[7]::double precision, costo_extra_reparto_foraneo=str_filas[8]::double precision, costo_estadia=str_filas[9]::double precision 
						WHERE log_ruta_tipo_unidad.id=str_filas[1]::integer;
					else 
						INSERT INTO log_ruta_tipo_unidad(log_ruta_id,log_vehiculo_tipo_id,costo, costo_hot_shot, costo_extra_reparto_local, costo_extra_reparto_foraneo, costo_estadia) 
						VALUES(str_data[4]::integer, str_filas[3]::integer, str_filas[4]::double precision, str_filas[6]::double precision, str_filas[7]::double precision, str_filas[8]::double precision, str_filas[9]::double precision);
					end if;  
					valor_retorno := '1';

				END LOOP;
			END IF;
			
			
			--Crear registros para Poblaciones
			IF trim(str_data[9])<>'' THEN
				--Convertir en arreglo la cadena de Poblaciones
				SELECT INTO str_filas2 string_to_array(str_data[9],'|');
				
				cont_fila=1;
				FOR cont_fila IN array_lower(str_filas2,1) .. array_upper(str_filas2,1) LOOP
					SELECT INTO str_filas3 string_to_array(str_filas2[cont_fila],'&&');

					--str_filas3[1]	idreg
					--str_filas3[2]	eliminado
					--str_filas3[3]	noTr
					--str_filas3[4]	id_mun
					--str_filas3[5]	select_localidad
					--str_filas3[6]	select_entidad
					--str_filas3[7]	select_pais
					
					if str_filas3[2]::integer=1 then
						if str_filas3[1]::integer>0 then 
							update log_ruta_mun set gral_mun_id=str_filas3[5]::integer where id=str_filas3[1]::integer;
						else 
							insert into log_ruta_mun(log_ruta_id,gral_mun_id)
							values(str_data[4]::integer,str_filas3[5]::integer);
						end if;
					else
						delete from log_ruta_mun where id=str_filas3[1]::integer;
					end if;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
			
		END IF;
		
		
		IF command_selected = 'delete' THEN
			UPDATE log_ruta SET momento_baja=now(),borrado_logico=true 
			WHERE log_ruta.id = str_data[4]::integer;
			DELETE  FROM  log_ruta_mun WHERE log_ruta_id = str_data[4]::integer;
			DELETE  FROM  log_ruta_tipo_unidad WHERE log_ruta_id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;-- Termina Catalogo Tarifario
	
	
	
	
	
	-- Catalogo de Tipo de Rechazo
	IF app_selected = 190 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         titulo
			INSERT INTO log_tipo_rechazo (titulo,borrado_logico,momento_creacion,gral_usr_id_crea,gral_emp_id,gral_suc_id) 
			VALUES (str_data[5],false,now(),usuario_id,emp_id,suc_id);
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE log_tipo_rechazo SET titulo=str_data[5],momento_actualiza=now(),gral_usr_id_actualiza=usuario_id
			WHERE log_tipo_rechazo.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE log_tipo_rechazo SET momento_baja=now(), borrado_logico=true, gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	--termina Catalogo de Tipo de Rechazo


	
	--Aplicativo de captura de Evidencias
	IF app_selected = 191 THEN
		
		/*	
		IF command_selected = 'liquidar_factura' THEN
			--str_data[1]   app_selected
			--str_data[2]   command_selected
			--str_data[3]   id_usuario 
			--str_data[4]   id_factura
			--str_data[5]   id_carga
			--str_data[6]   id_pedido
			--str_data[7]   id_det_viaje
			--str_data[8]   chk_firma
			--str_data[9]   chk_sello
			--str_data[10]   chk_cheque
			--str_data[11]   chk_eftvo
			--str_data[12]   no_che
			--str_data[13]   monto
			--str_data[14]   no_tr
			--str_data[15]   con_evidencia
			
			
			--0;"NUEVO"
			--1;"ENV-PARCIAL"
			--2;"ENVIADO "
			--3;"EVIDENCIA"
			--4;"LIQUIDACION"
			--5;"PAGADO"
			
			--Actualizar el registro de la factura
			update log_doc_ped_fac set firma=str_data[8]::boolean, sello=str_data[9]::boolean, cheque=str_data[10]::boolean, efectivo=str_data[11]::boolean, no_cheque=str_data[12], cantidad=str_data[13]::double precision, log_status_id=4, fecha_evidencia= now(), gral_usr_id_actualiza=usuario_id 
			where id=str_data[4]::integer;
			
			--Actualizar pedido y detalle del viaje
			if (select count(id) from log_doc_ped_fac where log_status_id<4 and log_doc_ped_id=str_data[6]::integer)<=0 then 
				--Actualizar estatus del pedido
				update log_doc_ped set log_status_id=4 where id=str_data[6]::integer;

				--Actualizar detalle del viaje
				update log_viaje_det set log_status_id=4 where id=str_data[7]::integer;
			else
				--Verificar si al menos una Factura del Pedido ya tiene captura de Evidencia
				if (select count(id) from log_doc_ped_fac where log_status_id=4 and log_doc_ped_id=str_data[6]::integer)>0 then 
					--Asignar estatus 3 para indicar que esta en captura de Evidencia
					update log_doc_ped set log_status_id=3 where id=str_data[6]::integer;
					
					--Actualizar detalle del viaje
					update log_viaje_det set log_status_id=4 where id=str_data[7]::integer;
				end if;
			end if;
			
			
			
			select 	sum(estatus0) as estatus0, sum(estatus1) as estatus1, sum(estatus2) as estatus2, sum(estatus3) as estatus3, sum(estatus4) as estatus4, 0::integer as estatus 
			from(
				select log_doc_carga_id, (case when log_status_id=0 then 1 else 0 end) as estatus0, (case when log_status_id=1 then 1 else 0 end) as estatus1, (case when log_status_id=2 then 1 else 0 end) as estatus2, (case when log_status_id=3 then 1 else 0 end) as estatus3, (case when log_status_id=4 then 1 else 0 end) as estatus4 from log_doc_ped 
			) as sbt where log_doc_carga_id=str_data[5]::integer
			into fila;

			if fila.estatus1>0 and fila.estatus2=0 and fila.estatus3=0 and fila.estatus4=0 then
				fila.estatus:=1;
			end if;

			if fila.estatus1=0 and fila.estatus2>0 and fila.estatus3=0 and fila.estatus4=0 then
				fila.estatus:=2;
			end if;

			if fila.estatus1=0 and fila.estatus2=0 and fila.estatus3>0 and fila.estatus4=0 then
				fila.estatus:=3;
			end if;

			if fila.estatus1=0 and fila.estatus2=0 and fila.estatus3=0 and fila.estatus4>0 then
				fila.estatus:=4;
			end if;

			if fila.estatus1>0 and fila.estatus2>0 and fila.estatus3=0 and fila.estatus4>0 then
				fila.estatus:=1;
			end if;
			
			if fila.estatus0>0 and fila.estatus1=0 and fila.estatus2>0 and fila.estatus3=0 and fila.estatus4>0 then
				fila.estatus:=1;
			end if;

			--Actualizar estatus de carga
			update log_doc_carga set log_status_id=fila.estatus where id=str_data[5]::integer;
			
			
			--Obtener id del Viaje
			select log_viaje_id from log_viaje_det where id=str_data[7]::integer into ultimo_id;
			
			--Verificar que el id no tenga un valor null
			if ultimo_id is null then ultimo_id:=0; end if;
			
			--Actualizar el registro Header del Viaje
			--Si no quedan partidas del viaje con estatus<4, entonces hay que cambiar el estatus de la Carga
			if (select count(id) from log_viaje_det where log_status_id<4 and log_viaje_id=ultimo_id)<=0 then 
				--Actualizar a Estatus=4 si ya no hay partidas con estatus menor a 4
				update log_viaje set log_status_id=4 where id=ultimo_id;
			else
				--Verificar si al menos un pedido ya tiene captura de Evidencia
				if (select count(id) from log_viaje_det where log_status_id=4 and log_viaje_id=ultimo_id)>0 then 
					--Asignar estatus 3 para indicar que esta en captura de Evidencia
					update log_viaje set log_status_id=3 where id=ultimo_id;
				end if;
			end if;
			
			valor_retorno := '1';
		END IF;
		*/
		
		
		
		IF command_selected = 'guardar_evidencias' THEN
			--str_data[1]   app_selected
			--str_data[2]   command_selected
			--str_data[3]   id_usuario
			--str_data[4]   identificador
			
			IF extra_data[1]<>'sin datos' THEN
				
				cont_fila:=1;
				FOR cont_fila IN array_lower(extra_data,1) .. array_upper(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	notr
					--str_filas[2]	id_factura
					--str_filas[3]	id_carga
					--str_filas[4]	id_pedido
					--str_filas[5]	id_det_viaje
					--str_filas[6]	chk_firma
					--str_filas[7]	chk_sello
					--str_filas[8]	chk_cheque
					--str_filas[9]	chk_eftvo
					--str_filas[10]	no_che
					--str_filas[11]	monto
					--str_filas[12]	fecha
					--str_filas[13]	con_evidencia
					
					--Actualizar el registro de la factura
					if trim(str_filas[12])<>'' then 
						--Actualizar CON fecha de evidencia
						update log_doc_ped_fac set firma=str_filas[6]::boolean, sello=str_filas[7]::boolean, cheque=str_filas[8]::boolean, efectivo=str_filas[9]::boolean, no_cheque=str_filas[10], cantidad=str_filas[11]::double precision, fecha_evidencia=str_filas[12]::timestamp with time zone, log_status_id=4, fecha_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
						where id=str_filas[2]::integer;
					else
						--Actualizar SIN fecha de evidencia
						update log_doc_ped_fac set firma=str_filas[6]::boolean, sello=str_filas[7]::boolean, cheque=str_filas[8]::boolean, efectivo=str_filas[9]::boolean, no_cheque=str_filas[10], cantidad=str_filas[11]::double precision, log_status_id=4, fecha_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
						where id=str_filas[2]::integer;
					end if;
										
					--Actualizar pedido y detalle del viaje
					if (select count(id) from log_doc_ped_fac where log_status_id<4 and log_doc_ped_id=str_filas[4]::integer)<=0 then 
						--Actualizar estatus del pedido
						update log_doc_ped set log_status_id=4 where id=str_filas[4]::integer;
						
						--Actualizar detalle del viaje
						update log_viaje_det set log_status_id=4 where id=str_filas[5]::integer;
					else
						--Verificar si al menos una Factura del Pedido ya tiene captura de Evidencia
						if (select count(id) from log_doc_ped_fac where log_status_id=4 and log_doc_ped_id=str_filas[4]::integer)>0 then 
							--Asignar estatus 3 para indicar que esta en captura de Evidencia
							update log_doc_ped set log_status_id=3 where id=str_filas[4]::integer;
							
							--Actualizar detalle del viaje
							update log_viaje_det set log_status_id=4 where id=str_filas[5]::integer;
						end if;
					end if;
					
					
					select 	sum(estatus0) as estatus0, sum(estatus1) as estatus1, sum(estatus2) as estatus2, sum(estatus3) as estatus3, sum(estatus4) as estatus4, 0::integer as estatus 
					from(
						select log_doc_carga_id, (case when log_status_id=0 then 1 else 0 end) as estatus0, (case when log_status_id=1 then 1 else 0 end) as estatus1, (case when log_status_id=2 then 1 else 0 end) as estatus2, (case when log_status_id=3 then 1 else 0 end) as estatus3, (case when log_status_id=4 then 1 else 0 end) as estatus4 from log_doc_ped 
					) as sbt where log_doc_carga_id=str_filas[3]::integer
					into fila;

					if fila.estatus1>0 and fila.estatus2=0 and fila.estatus3=0 and fila.estatus4=0 then
						fila.estatus:=1;
					end if;

					if fila.estatus1=0 and fila.estatus2>0 and fila.estatus3=0 and fila.estatus4=0 then
						fila.estatus:=2;
					end if;

					if fila.estatus1=0 and fila.estatus2=0 and fila.estatus3>0 and fila.estatus4=0 then
						fila.estatus:=3;
					end if;

					if fila.estatus1=0 and fila.estatus2=0 and fila.estatus3=0 and fila.estatus4>0 then
						fila.estatus:=4;
					end if;

					if fila.estatus1>0 and fila.estatus2>0 and fila.estatus3=0 and fila.estatus4>0 then
						fila.estatus:=1;
					end if;
					
					if fila.estatus0>0 and fila.estatus1=0 and fila.estatus2>0 and fila.estatus3=0 and fila.estatus4>0 then
						fila.estatus:=1;
					end if;

					--Actualizar estatus de carga
					update log_doc_carga set log_status_id=fila.estatus where id=str_filas[3]::integer;
					
					
					--Obtener id del Viaje
					select log_viaje_id from log_viaje_det where id=str_filas[5]::integer into ultimo_id;
					
					--Verificar que el id no tenga un valor null
					if ultimo_id is null then ultimo_id:=0; end if;
					
					--Actualizar el registro Header del Viaje
					--Si no quedan partidas del viaje con estatus<4, entonces hay que cambiar el estatus de la Carga
					if (select count(id) from log_viaje_det where log_status_id<4 and log_viaje_id=ultimo_id)<=0 then 
						--Actualizar a Estatus=4 si ya no hay partidas con estatus menor a 4
						update log_viaje set log_status_id=4 where id=ultimo_id;
					else
						--Verificar si al menos un pedido ya tiene captura de Evidencia
						if (select count(id) from log_viaje_det where log_status_id=4 and log_viaje_id=ultimo_id)>0 then 
							--Asignar estatus 3 para indicar que esta en captura de Evidencia
							update log_viaje set log_status_id=3 where id=ultimo_id;
						end if;
					end if;
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
	END IF;
	--Aplicativo de captura de Evidencias



	-- Aplicativo Tarifario de Venta por POBLACION
	IF app_selected = 194 THEN
		IF command_selected = 'new' THEN
			--str_data[4]   id
			--str_data[5]	id_cliente
			--str_data[6]	select_pais
			--str_data[7]	select_estado
			--str_data[8]	select_municipio
			
			insert into log_tarifario_venta(cxc_clie_id, gral_pais_id, gral_edo_id, gral_mun_id, borrado_logico, momento_creacion,gral_usr_id_crea, gral_emp_id,gral_suc_id) values (str_data[5]::integer,str_data[6]::integer,str_data[7]::integer,str_data[8]::integer,false, espacio_tiempo_ejecucion,usuario_id, emp_id,suc_id )
			returning id into ultimo_id;
			
			IF extra_data[1]<>'sin datos' THEN
				cont_fila:=1;
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	notr 
					--str_filas[2]	iddet 
					--str_filas[3]	tipo_tarifa_id
					--str_filas[4]	precio 
					--str_filas[5]	tipo_unidad_id
					
					--Crea registro en log_tarifario_venta_det
					insert into log_tarifario_venta_det(log_tarifario_venta_id,log_tarifa_tipo_id,valor, log_vehiculo_tipo_id) values(ultimo_id, str_filas[3]::integer, str_filas[4]::double precision, str_filas[5]::integer);
					
					valor_retorno := '1';
				END LOOP;
			END IF;

			valor_retorno := '1';
		END IF;
		
		
		IF command_selected = 'edit' THEN
			update log_tarifario_venta set cxc_clie_id=str_data[5]::integer, gral_pais_id=str_data[6]::integer, gral_edo_id=str_data[7]::integer, gral_mun_id=str_data[8]::integer, momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
			where id=str_data[4]::integer;
			
			IF extra_data[1]<>'sin datos' THEN
				cont_fila:=1;
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	notr 
					--str_filas[2]	iddet 
					--str_filas[3]	tipo_tarifa_id
					--str_filas[4]	precio 
					--str_filas[5]	tipo_unidad_id
					
					if str_filas[2]::integer > 0 then 
						--Aqu√≠ entra cuando es editar un registro existente
						update log_tarifario_venta_det set log_tarifa_tipo_id=str_filas[3]::integer, valor=str_filas[4]::double precision, log_vehiculo_tipo_id=str_filas[5]::integer where id=str_filas[2]::integer and log_tarifario_venta_id=str_data[4]::integer;
					else 
						--Crea registro en log_tarifario_venta_det
						insert into log_tarifario_venta_det(log_tarifario_venta_id,log_tarifa_tipo_id,valor, log_vehiculo_tipo_id) values(str_data[4]::integer, str_filas[3]::integer, str_filas[4]::double precision, str_filas[5]::integer);
					end if;
					
					valor_retorno := '1';
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		
		IF command_selected = 'delete' THEN
			UPDATE log_tarifario_venta SET momento_baja=espacio_tiempo_ejecucion, borrado_logico=true, gral_usr_id_baja=usuario_id 
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	-- Termina Catalogo Tarifario de Venta por POBLACION




	-- Aplicativo Tarifario de Venta por RANGO
	IF app_selected = 195 THEN
		IF command_selected = 'new' THEN
			--str_data[4]   id
			--str_data[5]	id_cliente
			--str_data[6]	vigencia_ini
			--str_data[7]	vigencia_fin
			--str_data[8]	select_tipo_tarifa
			
			insert into log_tarifario_venta(cxc_clie_id, gral_pais_id, gral_edo_id, gral_mun_id, borrado_logico, momento_creacion,gral_usr_id_crea, gral_emp_id,gral_suc_id) 
			values (str_data[5]::integer,0,0,0,false, espacio_tiempo_ejecucion,usuario_id, emp_id,suc_id)
			returning id into ultimo_id;
			
			insert into log_tarifario_venta_det(log_tarifario_venta_id,log_tarifa_tipo_id,valor, fecha_inicio, fecha_fin) values(ultimo_id, str_data[8]::integer, 0, str_data[6]::date, str_data[7]::date)
			returning id into ultimo_id2;
			
			IF extra_data[1]<>'sin datos' THEN
				cont_fila:=1;
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	notr 
					--str_filas[2]	iddet 
					--str_filas[3]	elim
					--str_filas[4]	titulo_rango 
					--str_filas[5]	valor1 
					--str_filas[6]	valor2 
					--str_filas[7]	precio 

					--VErificar que no venga con estatus eliminado
					if str_filas[3]::integer=1 then 
						--Crea registro en log_tarifario_venta_det_rango
						insert into log_tarifario_venta_det_rango(log_tarifario_venta_det_id, titulo, valor1,valor2, precio) values(ultimo_id2, trim(str_filas[4]), str_filas[5]::double precision, str_filas[6]::double precision, str_filas[7]::double precision);
					end if;
					
					valor_retorno := '1';
				END LOOP;
			END IF;

			valor_retorno := '1';
		END IF;
		
		
		IF command_selected = 'edit' THEN
			update log_tarifario_venta set cxc_clie_id=str_data[5]::integer, momento_actualiza=espacio_tiempo_ejecucion, gral_usr_id_actualiza=usuario_id 
			where id=str_data[4]::integer;

			update log_tarifario_venta_det set log_tarifa_tipo_id=str_data[8]::integer, fecha_inicio=str_data[6]::date, fecha_fin=str_data[7]::date 
			where log_tarifario_venta_id=str_data[4]::integer 
			returning id into ultimo_id2;
			
			IF extra_data[1]<>'sin datos' THEN
				cont_fila:=1;
				FOR cont_fila IN 1 .. array_length(extra_data,1) LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--str_filas[1]	notr 
					--str_filas[2]	iddet 
					--str_filas[3]	elim
					--str_filas[4]	titulo_rango 
					--str_filas[5]	valor1 
					--str_filas[6]	valor2 
					--str_filas[7]	precio 
					
					--VErificar que no venga con estatus eliminado
					if str_filas[3]::integer=1 then 
						if str_filas[2]::integer>0 then 
							update log_tarifario_venta_det_rango set titulo=trim(str_filas[4]), valor1=str_filas[5]::double precision, valor2=str_filas[6]::double precision, precio=str_filas[7]::double precision
							where id = str_filas[2]::integer;
						else 
							--Crea registro en log_tarifario_venta_det_rango
							insert into log_tarifario_venta_det_rango(log_tarifario_venta_det_id, titulo, valor1,valor2, precio) values(ultimo_id2, trim(str_filas[4]), str_filas[5]::double precision, str_filas[6]::double precision, str_filas[7]::double precision);
						end if;
					else
						if str_filas[2]::integer>0 then 
							delete from log_tarifario_venta_det_rango where id=str_filas[2]::integer;
						end if;
					end if;
					valor_retorno := '1';
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		
		IF command_selected = 'delete' THEN
			UPDATE log_tarifario_venta SET momento_baja=espacio_tiempo_ejecucion, borrado_logico=true, gral_usr_id_baja=usuario_id 
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;
	-- Termina Catalogo Tarifario de Venta por RANGO











	















	
	
	RETURN valor_retorno;
	
END;$$;


--
-- Name: matar_facturas_por_serie_folio(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.matar_facturas_por_serie_folio(factura character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
BEGIN
	
	
	--matar factura de fac_cfds
	UPDATE fac_cfds SET pagado=TRUE WHERE serie_folio = factura;
	
	--matar factura de erp_h_facturas
	UPDATE erp_h_facturas SET pagado=TRUE, total_pagos=monto_total, saldo_factura=0 WHERE serie_folio = factura;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;



--
-- Name: obtener_edo_cta_cxp_cierre_mes(integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.obtener_edo_cta_cxp_cierre_mes(id_empresa integer, fecha character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
	
	fila record;
	fila2 record;
	returnrecord record;
	cadena_sql character varying;
	cadena_sql2 character varying;
	incluir_registro boolean;
	suma_pagos double precision;
	
BEGIN
	
	BEGIN 
		--Crear tabla temporal
		CREATE TEMPORARY TABLE tmprecord (
			id_proveedor integer,
			proveedor character varying,
			factura character varying,
			fecha_factura character varying,
			moneda_id integer,
			moneda_abr character varying,
			moneda_simbolo character varying,
			orden_compra character varying,
			monto_total double precision,
			importe_pagado double precision,
			saldo_factura double precision
		);
		EXCEPTION WHEN OTHERS THEN
		TRUNCATE TABLE tmprecord; -- TRUNCATE if the table already exists within the session.
	END;
	
	
	/*
	Obtener listado de facturas tomando en cuenta las siguientes condiciones:
	--Que hayan sido generadas en el mes y antes del mes indicado en el parametro fecha
	--Que la fecha del ultimo pago sea mayor al mes indicado en el parametro fecha o que el campo sea null
	--Que la fecha de cancelacion sea mayor al mes indicado en el parametro fecha o que el campo sea null
	*/
	cadena_sql:='
	SELECT  
		cxp_prov.id AS id_proveedor, 
		cxp_prov.razon_social AS proveedor,
		cxp_facturas.serie_folio, 
		to_char(cxp_facturas.fecha_factura,''dd/mm/yyyy'') as fecha_factura, 
		cxp_facturas.moneda_id,
		gral_mon.descripcion_abr AS moneda_abr, 
		gral_mon.simbolo AS moneda_simbolo,
		cxp_facturas.orden_compra, 
		cxp_facturas.monto_total, 
		(cxp_facturas.total_pagos + cxp_facturas.total_notas_creditos) AS importe_pagado, 
		cxp_facturas.saldo_factura, 
		cxp_facturas.pagado,
		cxp_facturas.fecha_ultimo_pago,
		cxp_facturas.cancelacion,
		cxp_facturas.momento_cancelacion 
	FROM cxp_facturas 
	JOIN cxp_prov ON cxp_prov.id = cxp_facturas.cxc_prov_id 
	JOIN gral_mon ON gral_mon.id = cxp_facturas.moneda_id 
	WHERE cxp_facturas.empresa_id='||id_empresa||' 
	AND cxp_facturas.fecha_factura <= '''||fecha||'''::timestamp with time zone
	AND (cxp_facturas.fecha_ultimo_pago > '''||fecha||'''::timestamp with time zone OR cxp_facturas.fecha_ultimo_pago IS NULL)
	AND (cxp_facturas.momento_cancelacion > '''||fecha||'''::timestamp with time zone OR cxp_facturas.momento_cancelacion IS NULL)
	ORDER BY cxp_prov.id, cxp_facturas.moneda_id, cxp_facturas.fecha_factura;';
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		incluir_registro:=false;
		suma_pagos:=0.0;
		
		IF fila.cancelacion THEN
			--Si esta cancelado, verificar que haya sido despues de la fecha ingresada como parametro
			IF fila.momento_cancelacion > fecha::timestamp with time zone THEN
				incluir_registro:=true;
			END IF;
		ELSE
			IF fila.pagado THEN
				--Si esta pagado, verificar que haya sido despues de la fecha que se le pasa como parametro
				IF fila.fecha_ultimo_pago > fecha::timestamp with time zone THEN
					incluir_registro:=true;
				END IF;
			ELSE
				incluir_registro:=true;
			END IF;
		END IF;
		
		IF incluir_registro THEN
			--Query para obtener suma de  Pagos y Notas de Credito aplicados a la Factura
			cadena_sql2:='
			SELECT sum(sum) AS pagos FROM (
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(cxp_pagos_detalles.cantidad) FROM cxp_pagos JOIN cxp_pagos_detalles ON cxp_pagos_detalles.cxp_pago_id=cxp_pagos.id WHERE cxp_pagos_detalles.serie_folio='''||fila.serie_folio||''' AND cxp_pagos_detalles.cancelacion=FALSE AND cxp_pagos.cxp_prov_id='||fila.id_proveedor||' AND cxp_pagos.fecha_pago::timestamp with time zone > '''||fecha||'''::timestamp with time zone) AS sbt  
				UNION
				SELECT CASE WHEN sum IS NULL THEN 0 ELSE sum END FROM( SELECT sum(total) FROM cxp_nota_credito WHERE factura='''||fila.serie_folio||''' AND cancelado=FALSE AND cxp_prov_id='||fila.id_proveedor||' AND fecha_expedicion::timestamp with time zone > '''||fecha||'''::timestamp with time zone) AS sbt2
			) AS sbt3';
			
			EXECUTE cadena_sql2 INTO suma_pagos;
			
			IF suma_pagos IS NULL THEN suma_pagos:=0; END IF;

			--Calcular el importe pagado a la antes de la fecha indicada en el parametro
			fila.importe_pagado := fila.importe_pagado::double precision - suma_pagos::double precision;
			
			--Obtener el saldo de la factura
			fila.saldo_factura := fila.monto_total::double precision - fila.importe_pagado::double precision;
			
			INSERT INTO tmprecord VALUES(fila.id_proveedor, fila.proveedor, fila.serie_folio, fila.fecha_factura, fila.moneda_id, fila.moneda_abr, fila.moneda_simbolo, fila.orden_compra, fila.monto_total, fila.importe_pagado, fila.saldo_factura);
		END IF;
	END LOOP;

	
	--Recorriendo la tabla temporal y retornando sus filas
	FOR returnrecord IN SELECT * FROM tmprecord LOOP
		RETURN NEXT returnrecord;
	END LOOP;
	
	
END

$$;


--
-- Name: poc_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.poc_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	
	--estas  variables se utilizan en la mayoria de los catalogos
	str_data text[];
	app_selected integer;
	command_selected text;
	valor_retorno character varying;
	usuario_id integer;
	emp_id integer:=0;
	suc_id integer:=0;
	suc_id_consecutivo integer=0; --sucursal de donde se tomara el consecutivo
	id_tipo_consecutivo integer=0;
	ultimo_id integer:=0;
	ultimo_id2 integer:=0;
	ultimo_id_det integer:=0;
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer:=0;
	mes_actual integer:=0;
	sql_select character varying = '';
	sql_update character varying = '';
	sql_insert character varying = '';
	
	str_filas text[];
	total_filas integer;--total de elementos de arreglo
	cont_fila integer;--contador de filas o posiciones del arreglo
	str_incoterms char[];
	iter_y integer;
	
	--variable para pedidos
	facpar record;--parametros de Facturacion
	ultimo_id_proceso integer = 0;
	id_proceso integer = 0;
	id_proceso_flujo integer =0;
	prefijo_consecutivo character varying = '';
	nuevo_consecutivo bigint=0;
	nuevo_folio character varying = '';
	incluye_modulo_produccion boolean;
	empresa_transportista boolean;
	tipo_prod integer=0;
	id_producto integer = 0;
	total_existencia double precision = 0;
	cantidad_produccion double precision = 0;
	cant_reservada_anterior double precision = 0;
	cant_reservar_nuevo double precision = 0;
	generar_backorder boolean = false;
	en_proceso_produccion boolean = false;
	
	importe_del_descto_partida double precision = 0;
	importe_partida_con_descto double precision = 0;
	suma_descuento double precision = 0;
	suma_subtotal_con_descuento double precision = 0;
	
	importe_partida double precision = 0;
	impuesto_partida double precision = 0;
	monto_subtotal double precision = 0;
	monto_total double precision = 0;
	monto_impuesto double precision = 0;
	total_retencion double precision = 0;
	importe_ieps_partida double precision = 0;
	suma_ieps double precision = 0;
	retener_iva boolean = false;
	tasa_retencion double precision = 0;
	retencion_partida double precision = 0;
	suma_retencion_de_partidas double precision = 0;
	
	--variables autorizacion de pedidos
	pedido record;
	fila record;
	fila2 record;
	fila_detalle record;
	
	exis integer = 0;
	exis_rem_doc integer = 0;
	tipo_movimiento_id integer =0;
	identificador_nuevo_movimiento integer =0;
	remision_detalle record;
	bandera_tipo_4 boolean;
	id_almacen integer =0;
	folio_remision character varying='';
	id_cliente integer=0;
	obser_prefactura text='';

	result character varying='';
	
	noDecUnidad integer=0;--numero de decimales permitidos para la unidad
	exisActualPres double precision=0;--existencia actual de la presentacion
	equivalenciaPres double precision=0; --equivalencia de la presentacion en la unidad del producto
	cantPres double precision=0; --Cantidad que se esta Intentando traspasar
	cantPresAsignado double precision=0;
	cantPresReservAnterior double precision=0;
	controlExisPres boolean; --Variable que indica  si se debe controlar Existencias por Presentacion
	cambiaUnidadMedida boolean:=false;
	
	--Id de la unidad de medida del producto
	idUnidadMedida integer:=0;
	--Nombre de la unidad de medida del producto
	nombreUnidadMedida character varying:=0;
	--Densidad del producto
	densidadProd double precision:=0;
	--Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantUnidadVenta double precision:=0;
	--Cantidad de la existencia convertida a la unidad de venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
	cantExisUnidadVenta double precision:=0;
	match_cadena boolean:=false;

	--Variable para controlar la creacion de un registro en la tabla header de requisiciones cuando la configuracion lo permita
	header_requisicion_generada boolean:=false;
	--Variable que indica si una partida gener√≥ requisicion
	generar_requisicion  boolean:=false;
BEGIN
	controlExisPres:=false;
	
	--convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	--aplicativo seleccionado
	app_selected := str_data[1]::integer;
	
	command_selected := str_data[2];--new, edit, delete. Para aplicativo 14 pagos: pago, anticipo, cancelacion
	
	-- usuario que utiliza el aplicativo
	usuario_id := str_data[3]::integer;
	
	--obtiene empresa_id y sucursal_id
	--SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	--WHERE gral_usr_suc.gral_usr_id = usuario_id
	--INTO emp_id, suc_id;
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	--obtener id de empresa, sucursal y almacen de la sucursal
	/*
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id,inv_suc_alm.almacen_id 
  	FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id, id_almacen;
	*/
	
  	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id
  	FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	WHERE gral_usr_suc.gral_usr_id = usuario_id
	INTO emp_id, suc_id;
	
	valor_retorno:='0';
	
	--Obtener parametros para la facturacion
	SELECT * FROM fac_par WHERE gral_suc_id=suc_id INTO facpar;

			
	--query para verificar si la Empresa actual incluye Modulo de Produccion y control de Existencias por Presentacion
	SELECT incluye_produccion, control_exis_pres, transportista  FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, controlExisPres, empresa_transportista;

	
	--tomar el id del almacen para ventas
	--id_almacen := facpar.inv_alm_id;

	--√©ste consecutivo es para el folio del Pedido y folio para BackOrder(poc_ped_bo)
	suc_id_consecutivo := facpar.gral_suc_id_consecutivo;
	
	
	--aplicativo Cotizaciones a Clientes
	IF app_selected = 12 THEN
		IF command_selected = 'new' THEN
			--str_data[1]	app_selected
			--str_data[2]	command_selected
			--str_data[3]	id_usuario
			--str_data[4]	identificador
			--str_data[5] 	select_tipo_cotizacion
			--str_data[6]	id_cliente √≥ id_prospecto
			--str_data[7]	check_descripcion_larga
			--str_data[8]	observaciones
			--str_data[9]	tipo_cambio
			--str_data[10]	moneda_id
			--str_data[11]	fecha
			--str_data[12]  agente_id
			--str_data[13]  vigencia
			--str_data[14]  incluye_iva
			--str_data[15]  incoterms
			--str_data[16]  tc_usd
			
			--crea registro en tabla erp_proceso y retorna el id del registro creado. El flujo del proceso es 1=Cotizacion
			INSERT INTO  erp_proceso(proceso_flujo_id,empresa_id,sucursal_id)VALUES(4, emp_id, suc_id) RETURNING id into ultimo_id_proceso;
			
			id_tipo_consecutivo:=5;--consecutivo de Cotizaciones a clientes
			
			--aqui entra para tomar el consecutivo del pedido de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			--suc_id_consecutivo
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--crear registro en la tabla poc_cot y retorna el id del registro creado
			 INSERT INTO  poc_cot(
				folio, --nuevo_folio,
				tipo, --str_data[5]::integer,
				observaciones, --str_data[8]::text,
				incluye_img_desc,--str_data[7]::boolean,
				tipo_cambio,--str_data[9]::double precision,
				gral_mon_id,--str_data[10]::integer,
				fecha,--str_data[11]::date,
				cxc_agen_id,--str_data[12]::integer,
				dias_vigencia,--str_data[13]::smallint,
				incluye_iva,--str_data[14]::boolean,
				tc_usd, --str_data[16]::double precision,
				proceso_id,--ultimo_id_proceso,
				gral_usr_id_creacion,--usuario_id,
				momento_creacion,--espacio_tiempo_ejecucion,
				borrado_logico--false
			)VALUES(nuevo_folio, str_data[5]::integer, str_data[8]::text, str_data[7]::boolean, str_data[9]::double precision, str_data[10]::integer, str_data[11]::date, str_data[12]::integer, str_data[13]::smallint, str_data[14]::boolean, str_data[16]::double precision, ultimo_id_proceso, usuario_id, espacio_tiempo_ejecucion, false) 
			RETURNING id INTO ultimo_id;
			
			
			--tipo 1=Cliente, 2=Prospecto
			IF str_data[5]::integer=1 THEN 
				--crear registro para relacionar la Cotizacion con el Cliente
				INSERT INTO poc_cot_clie(poc_cot_id, cxc_clie_id) VALUES(ultimo_id, str_data[6]::integer);
			ELSE
				--crear registro para relacionar la Cotizacion con el Prospecto
				INSERT INTO poc_cot_prospecto(poc_cot_id, crm_prospecto_id) VALUES(ultimo_id, str_data[6]::integer);
			END IF;
			
			
			IF str_data[15] is not null AND str_data[15]!='' THEN
				--Convertir en arreglo los id de inconterms
				SELECT INTO str_incoterms string_to_array(str_data[15],',');
				
				FOR iter_y IN array_lower(str_incoterms,1) .. array_upper(str_incoterms,1) LOOP
					INSERT INTO poc_cot_incoterm_x_cot(poc_cot_id,poc_cot_incoterms_id) VALUES (ultimo_id,str_incoterms[iter_y]::integer);
				END LOOP;
			END IF;
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	cantidad
					--str_filas[6]	precio
					--str_filas[7]	monedagrid
					--str_filas[8]	notr
					--str_filas[9]	id_imp_prod
					--str_filas[10]	valor_imp
					--str_filas[11]	unidad_id
					--str_filas[12]	status_autorizacion
					--str_filas[13]	precio_autorizado
					--str_filas[14]	id_user_aut
					--str_filas[15]	requiere_autorizacion
					--str_filas[16]	salvar_registro

					if str_filas[12]::boolean then 
						--Si esta autorizado por default le asignamos true al campo requiere_autorizacion
						str_filas[15]:='true';
					end if;
					
					--crea registros para tabla poc_pedidos_detalle
					INSERT INTO poc_cot_detalle(
						poc_cot_id, --ultimo_id,
						inv_prod_id, --str_filas[3]:.integer,
						inv_presentacion_id,--str_filas[4]::integer,
						cantidad, --str_filas[5]::double precision,
						precio_unitario, --str_filas[6]::double precision,
						gral_mon_id,--str_filas[7]::integer,
						gral_impto_id,--str_filas[9]::integer,
						valor_imp,--str_filas[10]::double precision
						inv_prod_unidad_id,--str_filas[11]::integer,
						requiere_aut, --str_filas[15]::boolean,
						autorizado, --str_filas[12]::boolean, 
						precio_aut, --str_filas[13]::double precision,
						gral_usr_id_aut --str_filas[14]::integer 
					)
					VALUES(ultimo_id, str_filas[3]::integer, str_filas[4]::integer, str_filas[5]::double precision, str_filas[6]::double precision, str_filas[7]::integer, str_filas[9]::integer,str_filas[10]::double precision, str_filas[11]::integer, str_filas[15]::boolean, str_filas[12]::boolean, str_filas[13]::double precision, str_filas[14]::integer );
					
					importe_partida := str_filas[5]::double precision * str_filas[6]::double precision;
					
					IF str_data[10]::integer <> str_filas[7]::integer THEN 
						IF str_data[10]::integer=1 AND str_filas[7]::integer<>1 THEN
							importe_partida := importe_partida::double precision * str_data[9]::double precision;
						ELSE
							IF str_data[10]::integer<>1 AND str_filas[7]::integer=1 THEN
								importe_partida :=  importe_partida::double precision / str_data[9]::double precision;
							END IF;
						END IF;
					END IF;
					
					--Redondear el importe de la partida a 4 digitos
					importe_partida := round(importe_partida::double precision::numeric,4)::double precision;
					
					impuesto_partida := round((importe_partida::double precision * str_filas[10]::double precision)::numeric,4)::double precision;
					
					monto_subtotal := round((monto_subtotal + importe_partida)::numeric,4)::double precision;
					monto_impuesto := round((monto_impuesto + impuesto_partida)::numeric,4)::double precision;
					
				END IF;
			END LOOP;
			
			--calcula el monto del pedido
			--monto_total:= monto_subtotal + monto_impuesto - total_retencion;
			monto_total:= monto_subtotal + monto_impuesto;
			
			--actualiza campos subtotal, impuesto, retencion, total de tabla poc_cot
			UPDATE poc_cot SET subtotal=monto_subtotal, impuesto=monto_impuesto, total=monto_total
			WHERE id=ultimo_id;
			
			valor_retorno := '1';
		END IF;--termina nueva Cotizacion
		
		
		
		
		IF command_selected = 'edit' THEN
			UPDATE  poc_cot SET observaciones=str_data[8]::text, incluye_img_desc=str_data[7]::boolean, tipo_cambio=str_data[9]::double precision, gral_mon_id=str_data[10]::integer, fecha=str_data[11]::date, cxc_agen_id=str_data[12]::integer, dias_vigencia=str_data[13]::smallint, incluye_iva=str_data[14]::boolean, tc_usd=str_data[16]::double precision, gral_usr_id_actualizacion=usuario_id, momento_actualizacion=espacio_tiempo_ejecucion 
			WHERE id=str_data[4]::integer;
			
			--elimina los registros de las presentaciones del producto
			DELETE FROM poc_cot_incoterm_x_cot WHERE poc_cot_id = str_data[4]::integer;
			
			IF str_data[15] is not null  AND str_data[15]!='' THEN
				--RAISE EXCEPTION '%' ,'str_data[15]: '||str_data[15];
				
				--convertir en arreglo los id de inconterms
				SELECT INTO str_incoterms string_to_array(str_data[15],',');
				
				FOR iter_y IN array_lower(str_incoterms,1) .. array_upper(str_incoterms,1) LOOP
					INSERT INTO poc_cot_incoterm_x_cot(poc_cot_id,poc_cot_incoterms_id) VALUES (str_data[4]::integer,str_incoterms[iter_y]::integer);
				END LOOP;
			END IF;
			
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				IF str_filas[1]::integer != 0 THEN--1: no esta eliminado, 0:eliminado

					if str_filas[12]::boolean then 
						--Si esta autorizado por default le asignamos true al campo requiere_autorizacion
						str_filas[15]:='true';
					end if;
					
					IF str_filas[2]::integer=0 THEN 
						--crea registros para tabla poc_pedidos_detalle porque es nueva partida
						INSERT INTO poc_cot_detalle(poc_cot_id, inv_prod_id, inv_presentacion_id, cantidad,  precio_unitario,gral_mon_id, gral_impto_id, valor_imp, inv_prod_unidad_id,requiere_aut, autorizado, precio_aut, gral_usr_id_aut)
						VALUES(str_data[4]::integer, str_filas[3]::integer, str_filas[4]::integer, str_filas[5]::double precision, str_filas[6]::double precision, str_filas[7]::integer, str_filas[9]::integer,str_filas[10]::double precision, str_filas[11]::integer, str_filas[15]::boolean, str_filas[12]::boolean, str_filas[13]::double precision, str_filas[14]::integer);
					ELSE
						--actualizar registro ya existente
						UPDATE poc_cot_detalle SET cantidad=str_filas[5]::double precision, precio_unitario=str_filas[6]::double precision, gral_mon_id=str_filas[7]::integer,gral_impto_id=str_filas[9]::integer, valor_imp=str_filas[10]::double precision, inv_prod_unidad_id=str_filas[11]::integer, requiere_aut=str_filas[15]::boolean, autorizado=str_filas[12]::boolean, precio_aut=str_filas[13]::double precision, gral_usr_id_aut=str_filas[14]::integer 
						WHERE id=str_filas[2]::integer;
					END IF;
					
					importe_partida := str_filas[5]::double precision * str_filas[6]::double precision;
					
					IF str_data[10]::integer <> str_filas[7]::integer THEN 
						IF str_data[10]::integer=1 AND str_filas[7]::integer<>1 THEN
							importe_partida := importe_partida::double precision * str_data[9]::double precision;
						ELSE
							IF str_data[10]::integer<>1 AND str_filas[7]::integer=1 THEN
								importe_partida :=  importe_partida::double precision / str_data[9]::double precision;
							END IF;
						END IF;
					END IF;
					
					--Redondear el importe de la partida a 4 digitos
					importe_partida := round(importe_partida::double precision::numeric,4)::double precision;
					
					impuesto_partida := round((importe_partida * str_filas[10]::double precision)::numeric,4)::double precision;
					
					monto_subtotal := round((monto_subtotal + importe_partida)::numeric,4)::double precision;
					monto_impuesto := round((monto_impuesto + impuesto_partida)::numeric,4)::double precision;
					
				ELSE
					--RAISE EXCEPTION '%' ,'str_filas[2]: '||str_filas[2];
					IF str_filas[1]::integer = 0 THEN 
						--eliminar registro
						DELETE FROM poc_cot_detalle WHERE id=str_filas[2]::integer;
					END IF;
				END IF;
			END LOOP;

			monto_total:= monto_subtotal + monto_impuesto;
			
			--actualiza campos subtotal, impuesto, retencion, total de tabla poc_cot
			UPDATE poc_cot SET subtotal=monto_subtotal, impuesto=monto_impuesto, total=monto_total
			WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;--termina edit Cotizacion


		IF command_selected = 'delete' THEN
			UPDATE  poc_cot SET borrado_logico=true, gral_usr_id_baja=usuario_id, momento_baja=espacio_tiempo_ejecucion
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina aplicativo Cotizaciones a Clientes
	



	
	--Aplicativo Pedidos de Clientes
	IF app_selected = 64 THEN
		
		IF command_selected = 'new' THEN
			--str_data[3]	id_usuario
			--str_data[4]	id_pedido
			--str_data[5] 	id_cliente
			--str_data[6]	select_moneda
			--str_data[7]	observaciones
			--str_data[8]	tipo_cambio
			--str_data[9]	id_agente
			--str_data[10]	select_condiciones
			--str_data[11]	orden_compra
			--str_data[12]	fecha_compromiso
			--str_data[13]	lugar_entrega
			--str_data[14]	transporte
			--str_data[15]	tasa_ret_immex
			--str_data[16]	select_metodo_pago
			--str_data[17]	no_cuenta
			--str_data[18]	check_ruta
			--str_data[19]	select_almacen
			--str_data[20]	id_df
			--str_data[21]	check_enviar_obser
			
			--str_data[43]	permitir_descto
			--str_data[44]	motivo_descuento
			--str_data[45]	porcentaje_descto
			--str_data[46]	nocot
			
			
			id_almacen = str_data[19]::integer;
			
			--crea registro en tabla erp_proceso y retorna el id del registro creado. El flujo del proceso es 4=Pedido
			INSERT INTO  erp_proceso(proceso_flujo_id,empresa_id,sucursal_id)VALUES(4, emp_id, suc_id) RETURNING id into ultimo_id_proceso;
			
			id_tipo_consecutivo:=7;--consecutivo de pedidos
			
			--aqui entra para tomar el consecutivo del pedido de la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			--suc_id_consecutivo
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del pedido
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--crear registro en la tabla poc_pedidos y retorna el id del registro creado
			 INSERT INTO  poc_pedidos(
				folio, --nuevo_folio,
				cxc_clie_id, --str_data[5]::integer,
				moneda_id,--str_data[6]::integer,
				observaciones, --str_data[7]::text,
				tipo_cambio,--str_data[8]::double precision,
				cxc_agen_id,--str_data[9]::integer,
				cxp_prov_credias_id,--str_data[10]::integer,
				orden_compra,--str_data[11],
				proceso_id,--ultimo_id_proceso,
				fecha_compromiso,--str_data[12]::date,
				lugar_entrega,--str_data[13],
				transporte,--str_data[14],
				tasa_retencion_immex,--str_data[15]::double precision,
				fac_metodos_pago_id,--str_data[16]::integer,
				no_cuenta,--str_data[17],
				enviar_ruta,--str_data[18]::boolean,
				inv_alm_id,--str_data[19]::smallint
				cxc_clie_df_id,--str_data[20]::integer,
				enviar_obser_fac,--str_data[21]::boolean,
				flete,--str_data[22]::boolean,
				subtotal,--0,
				impuesto,--0,
				monto_retencion,--0,
				total,--0,
				borrado_logico,--false,
				cancelado,--false,
				momento_creacion,--espacio_tiempo_ejecucion,
				gral_usr_id_creacion,--usuario_id
				motivo_descto, --str_data[44]
				porcentaje_descto, --str_data[45]
				folio_cot--str_data[46] 
			)VALUES(nuevo_folio, str_data[5]::integer, str_data[6]::integer, str_data[7]::text, str_data[8]::double precision, str_data[9]::integer, str_data[10]::integer, str_data[11], ultimo_id_proceso, str_data[12]::date, str_data[13], str_data[14], str_data[15]::double precision, str_data[16]::integer, str_data[17], str_data[18]::boolean, str_data[19]::smallint, str_data[20]::integer, str_data[21]::boolean, str_data[22]::boolean, 0, 0, 0, 0, false, false, espacio_tiempo_ejecucion, usuario_id, str_data[44], str_data[45]::double precision, str_data[46]) 
			RETURNING id INTO ultimo_id;
			
			
			
			IF empresa_transportista THEN 
				--Aqui solo entra cuando la empresa es transportista
				IF str_data[22]='true' THEN
					--Aqui entra cuando el pedido es de flete.
					INSERT INTO poc_ped_trans(
						poc_pedido_id,--ultimo_id
						documentador,--str_data[23],
						valor_declarado,--str_data[24],
						tipo_viaje,--str_data[25]::integer,
						remolque1,--str_data[26],
						remolque2,--str_data[27],
						log_vehiculo_id,--str_data[28]::integer,
						no_operador,--str_data[29],
						nombre_operador,--str_data[30],
						gral_pais_id_orig,--str_data[31]::integer,
						gral_edo_id_orig,--str_data[32]::integer,
						gral_mun_id_orig,--str_data[33]::integer,
						gral_pais_id_dest,--str_data[34]::integer,
						gral_edo_id_dest,--str_data[35]::integer,
						gral_mun_id_dest,--str_data[36]::integer,
						cxc_agente_aduanal_id,--str_data[37]::integer,
						cxc_remitente_id,--str_data[38]::integer,
						rem_dir_alterna,--str_data[39],
						cxc_destinatario_id,--str_data[40]::integer,
						dest_dir_alterna,--str_data[41],
						trans_observaciones--str_data[42]
					)
					VALUES(ultimo_id, str_data[23], str_data[24], str_data[25]::integer, str_data[26], str_data[27], str_data[28]::integer, str_data[29], str_data[30], str_data[31]::integer, str_data[32]::integer, str_data[33]::integer, str_data[34]::integer, str_data[35]::integer, str_data[36]::integer, str_data[37]::integer, str_data[38]::integer, str_data[39], str_data[40]::integer, str_data[41], str_data[42]);
					
				END IF;
			END IF;
			
			
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			FOR cont_fila IN 1 .. total_filas LOOP
				generar_requisicion:=false;
				retencion_partida:=0;
				
				SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
				
				--str_filas[1] eliminado
				IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
					--str_filas[2]	iddetalle
					--str_filas[3]	idproducto
					--str_filas[4]	id_presentacion
					--str_filas[5]	id_impuesto
					--str_filas[6]	cantidad
					--str_filas[7]	costo
					--str_filas[8]	valor_impuesto
					--str_filas[12]	id_ieps
					--str_filas[13]	tasa_ieps
					--str_filas[14]	vdescto
					--str_filas[15]	idcot
					--str_filas[16]	iddetcot
					--str_filas[17]	status_autorizacion
					--str_filas[18]	precio_autorizado
					--str_filas[19]	id_user_autoriza
					--str_filas[20]	reqauth
					--str_filas[21]	salvar_registro
					--str_filas[22]	retencion_id
					--str_filas[23]	retencion_tasa
					
					cantPresAsignado:=0;
					equivalenciaPres:=0;
					noDecUnidad:=0;
					--Id de la unidad de medida del producto
					idUnidadMedida:=0;
					--Nombre de la unidad de medida del producto
					nombreUnidadMedida:='';
					--Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
					cantUnidadVenta:=0;
					
					--Obtener datos del Producto
					SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
					FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=str_filas[3]::integer 
					INTO tipo_prod, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
					
					IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
					
					--Tomamos la cantidad en la unidad de Venta seleccionada por el usuario
					cantUnidadVenta:=str_filas[6]::double precision;
					
					IF facpar.cambiar_unidad_medida THEN
						IF idUnidadMedida::integer<>str_filas[11]::integer THEN
							IF densidadProd IS NULL OR densidadProd=0 THEN
								densidadProd:=1;
							END IF;
							
							EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
							IF match_cadena=true THEN
								--Convertir a kilos
								str_filas[6] := str_filas[6]::double precision * densidadProd;
							ELSE
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
								IF match_cadena=true THEN 
									--Convertir a Litros
									str_filas[6] := str_filas[6]::double precision / densidadProd;
								END IF;
							END IF;
							--RAISE EXCEPTION '%',match_cadena;
						END IF;
					END IF;
					
					--Redondear la cantidad de la Partida
					str_filas[6] := round(str_filas[6]::numeric,noDecUnidad)::double precision;
					cantUnidadVenta := round(cantUnidadVenta::numeric,noDecUnidad)::double precision; 
					
					--Si el tipo de producto es diferente de 4, hay que RESERVAR existencias
					--tipo=4 Servicios
					--para el tipo servicios no se debe reservar existencias
					IF tipo_prod<>4 THEN 
						
						--RAISE EXCEPTION '%',incluye_modulo_produccion;
						
						IF incluye_modulo_produccion=FALSE THEN 
							--Aqui entra si la Empresa NO INCLUYE Modulo de Produccion
							
							--reservar toda cantidad la cantidad del pedido
							cant_reservar_nuevo := str_filas[6]::double precision;
							generar_backorder:=false;
						ELSE
							--RAISE EXCEPTION '%','tipo_prod='||tipo_prod;
							
							--Solo para productos formulados
							IF tipo_prod=1 OR tipo_prod=2 OR tipo_prod=8 THEN
								--llamada a proc que devuelve la existencia del producto. 
								--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
								--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
								SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, usuario_id, id_almacen) INTO total_existencia; 
								
								--Redondear la existencia del producto
								total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
								
								IF total_existencia < str_filas[6]::double precision THEN
									IF total_existencia <=0 THEN 
										--reservar cero
										cant_reservar_nuevo=0;
									ELSE
										--tomar la existencia para reservar
										cant_reservar_nuevo:=total_existencia;
									END IF;
									
									generar_backorder:=true;
								ELSE
									--Reservar toda la cantidad del  pedido
									cant_reservar_nuevo := str_filas[6]::double precision;
									
									generar_backorder:=false;
								END IF;
							END IF;
						END IF;
						
						--RAISE EXCEPTION '%','permitir_req_com='|| facpar.permitir_req_com ||'    tipo_prod='||tipo_prod;
						
						/*
						"1";"Prod. Terminado";FALSE
						"2";"Prod. Intermedio";FALSE
						"3";"Kit";FALSE
						"4";"Servicios";FALSE
						"5";"Refacciones";FALSE
						"6";"Accesorios";FALSE
						"7";"Materia Prima";FALSE
						"8";"Prod. en Desarrollo";FALSE
						*/
						IF facpar.permitir_req_com THEN 
							--7=Materia Prima - Hay que generar una requisicion de compra.
							IF tipo_prod=7 THEN 
								--llamada a proc que devuelve la existencia del producto. 
								--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
								--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
								SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, usuario_id, id_almacen) INTO total_existencia; 
								
								--Redondear la existencia del producto
								total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
								
								IF total_existencia < str_filas[6]::double precision THEN
									IF total_existencia <=0 THEN 
										--reservar cero
										cant_reservar_nuevo=0;
									ELSE
										--tomar la existencia para reservar
										cant_reservar_nuevo:=total_existencia;
									END IF;
									
									generar_requisicion:=true;
								ELSE
									--Reservar toda la cantidad del  pedido
									cant_reservar_nuevo := str_filas[6]::double precision;
									
									generar_requisicion:=false;
								END IF;
							END IF;
						ELSE
							if tipo_prod=7 then  
								--Reservar toda cantidad la cantidad del pedido ya que no incluye
								cant_reservar_nuevo := str_filas[6]::double precision;
								generar_backorder:=false;
								generar_requisicion:=false;
							end if;
						END IF;
						
						--RAISE EXCEPTION '%','permitir_req_com='|| facpar.permitir_req_com ||'    tipo_prod='||tipo_prod ||'    cant_reservar_nuevo='||cant_reservar_nuevo;
						
						--Redondear la cantidad de a Reservar
						cant_reservar_nuevo := round(cant_reservar_nuevo::numeric,noDecUnidad)::double precision;
						
						--Reservar cantidad para el  pedido
						UPDATE inv_exi SET reservado=(reservado::double precision + cant_reservar_nuevo::double precision) WHERE inv_prod_id=str_filas[3]::integer AND inv_alm_id=id_almacen AND ano=ano_actual;
						
						------inicia reservar existencias en presentaciones--------------------------
						--Verificar si hay que validar existencias de Presentaciones
						IF controlExisPres=true THEN 
							--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
							--TRUE = Validar presentaciones desde el Pedido
							--FALSE = No validar presentaciones desde el Pedido
							IF facpar.validar_pres_pedido=true THEN 
								--buscar la equivalencia de la Presentacion
								SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_filas[4]::integer 
								INTO equivalenciaPres;
								
								IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
								
								--Convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
								cantPresAsignado := cant_reservar_nuevo::double precision / equivalenciaPres::double precision;
								
								--Redondear la cantidad de Presentaciones Asignado en la partida
								cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
								
								--Reservar existencia en inv_exi_pres
								UPDATE inv_exi_pres SET reservado=(reservado::double precision + cantPresAsignado::double precision)
								WHERE inv_alm_id=id_almacen::integer
								AND inv_prod_id=str_filas[3]::integer
								AND inv_prod_presentacion_id=str_filas[4]::integer;
								
							END IF;
						END IF;
						------termina reservar existencias de Presentaciones------------------------------------
						
					ELSE
						generar_backorder:=false;
						generar_requisicion:=false;
						cant_reservar_nuevo=0;
					END IF;--termina IF tipo 4

					--Tasa ieps
					IF str_filas[13]::double precision>0 THEN 
						str_filas[13]:=str_filas[13]::double precision/100;
					END IF;

					--Tasa retencion
					IF str_filas[23]::double precision>0 THEN 
						str_filas[23]:=str_filas[23]::double precision/100;
					END IF;
					
					--Crea registros para tabla poc_pedidos_detalle
					INSERT INTO poc_pedidos_detalle(poc_pedido_id, inv_prod_id, presentacion_id, gral_imp_id, cantidad, precio_unitario, valor_imp, reservado, backorder, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, requisicion, requiere_aut, autorizado, precio_aut, gral_usr_id_aut, gral_imptos_ret_id, tasa_ret)
					VALUES(ultimo_id,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::integer,cantUnidadVenta::double precision,str_filas[7]::double precision,str_filas[8]::double precision, cant_reservar_nuevo, generar_backorder, str_filas[11]::integer, str_filas[12]::integer, str_filas[13]::double precision, str_filas[14]::double precision, generar_requisicion, str_filas[20]::boolean, str_filas[17]::boolean, str_filas[18]::double precision, str_filas[19]::integer, str_filas[22]::integer, str_filas[23]::double precision) 
					RETURNING id INTO ultimo_id_det;
					
					--Calcula el Importe de la Partida
					importe_partida := round((cantUnidadVenta::double precision * str_filas[7]::double precision)::numeric,4)::double precision;
					
					--Calcula el IEPS de la partida
					importe_ieps_partida := round((importe_partida::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
					
					--Calcula el IVA de la Partida
					impuesto_partida := (importe_partida::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision;
					
					--str_filas[22]::integer		retencion_id
					--str_filas[23]::double precision	retencion_tasa
					
					--Calcular el importe de la retencion de la partida si existe la tasa de retencion
					if str_filas[23]::double precision>0 then 
						retencion_partida := round((importe_partida::double precision * str_filas[23]::double precision)::numeric,4)::double precision;
					end if;
					
					
					--Cargar tabla que relaciona el pedido con la cotizacion
					IF str_filas[16]::integer>0 THEN 
						INSERT INTO poc_ped_cot(poc_ped_id, poc_cot_id, poc_ped_det_id, poc_cot_det_id)VALUES(ultimo_id, str_filas[15]::integer, ultimo_id_det, str_filas[16]::integer);
					END IF;
					
					IF lower(str_data[43])='true' THEN
						IF str_filas[14]::double precision>0 THEN
							--$pu_con_descto.val(parseFloat(parseFloat($campoPrecioU.val()) - (parseFloat($campoPrecioU.val()) * (parseFloat($vdescto.val())/100))).toFixed(4));
							importe_del_descto_partida = round((importe_partida * (str_filas[14]::double precision/100))::numeric,4)::double precision;

							importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
							
							--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
							importe_ieps_partida := round((importe_partida_con_descto::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
							
							--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
							impuesto_partida := (importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision;
							
							--Reclacular el nuevo el importe de la retencion de la partida si existe la tasa de retencion
							if str_filas[23]::double precision>0 then 
								retencion_partida := round((importe_partida::double precision * str_filas[23]::double precision)::numeric,4)::double precision;
							end if;
						END IF;
					END IF;
					
					suma_descuento = suma_descuento + importe_del_descto_partida::double precision;
					suma_subtotal_con_descuento = suma_subtotal_con_descuento + importe_partida_con_descto::double precision;
					
					monto_subtotal := monto_subtotal + importe_partida::double precision;
					suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
					monto_impuesto := monto_impuesto + impuesto_partida::double precision;
					suma_retencion_de_partidas := suma_retencion_de_partidas + retencion_partida::double precision;
				END IF;
			END LOOP;
			
			--Verificar si hay que retener iva para este cliente
			SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex::double precision/100 end FROM cxc_clie WHERE id=str_data[5]::integer INTO retener_iva, tasa_retencion;
			
			IF lower(str_data[43])='true' AND suma_descuento>0 THEN
				IF retener_iva=true THEN 
					total_retencion := suma_subtotal_con_descuento::double precision * tasa_retencion;
				ELSE
					total_retencion :=0;
				END IF;
				
				if suma_retencion_de_partidas > 0 then 
					total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
				end if;
				
				--Calcula el monto del pedido
				monto_total:= suma_subtotal_con_descuento::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
				
				--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
				UPDATE poc_pedidos SET subtotal=suma_subtotal_con_descuento, monto_descto=suma_descuento, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
				WHERE id=ultimo_id;
			ELSE
				IF retener_iva=true THEN
					total_retencion := monto_subtotal::double precision * tasa_retencion;
				ELSE
					total_retencion :=0;
				END IF;

				if suma_retencion_de_partidas > 0 then 
					total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
				end if;
				
				--Calcula el monto del pedido
				monto_total:= monto_subtotal::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
				
				--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
				UPDATE poc_pedidos SET subtotal=monto_subtotal, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
				WHERE id=ultimo_id;
			END IF;
			
			valor_retorno := '1';
		END IF;--termina accion NEW pedido
		
		
		
		
		IF command_selected = 'edit' THEN
			
			id_almacen = str_data[19]::integer;
			
			--obtener el id del proceso para este pedido
			SELECT proceso_id FROM poc_pedidos WHERE id=str_data[4]::integer INTO id_proceso;
			
			--obtener el id del flujo del proceso
			SELECT proceso_flujo_id FROM erp_proceso WHERE id=id_proceso INTO id_proceso_flujo;
			
			IF id_proceso_flujo::integer=4 THEN 
				
				UPDATE poc_pedidos SET cxc_clie_id=str_data[5]::integer,moneda_id=str_data[6]::integer,observaciones=str_data[7]::text,tipo_cambio=str_data[8]::double precision,cxc_agen_id=str_data[9]::integer,cxp_prov_credias_id=str_data[10]::integer,orden_compra=str_data[11], fecha_compromiso=str_data[12]::date,lugar_entrega=str_data[13], transporte=str_data[14], tasa_retencion_immex=str_data[15]::double precision, fac_metodos_pago_id=str_data[16]::integer, no_cuenta=str_data[17], enviar_ruta=str_data[18]::boolean, inv_alm_id=str_data[19]::smallint, cxc_clie_df_id=str_data[20]::integer, enviar_obser_fac=str_data[21]::boolean, flete=str_data[22]::boolean, momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id, motivo_descto=str_data[44], porcentaje_descto=str_data[45]::double precision 
				WHERE id = str_data[4]::integer;
				
				IF empresa_transportista THEN 
					--Aqui solo entra cuando la empresa es transportista
					IF str_data[22]='true' THEN
						--Aqui entra cuando el pedido es de flete.
						UPDATE poc_ped_trans SET documentador=str_data[23], valor_declarado=str_data[24], tipo_viaje=str_data[25]::integer, remolque1=str_data[26], remolque2=str_data[27], log_vehiculo_id=str_data[28]::integer, no_operador=str_data[29], nombre_operador=str_data[30], gral_pais_id_orig=str_data[31]::integer, gral_edo_id_orig=str_data[32]::integer, gral_mun_id_orig=str_data[33]::integer, gral_pais_id_dest=str_data[34]::integer, gral_edo_id_dest=str_data[35]::integer, gral_mun_id_dest=str_data[36]::integer, cxc_agente_aduanal_id=str_data[37]::integer, cxc_remitente_id=str_data[38]::integer, rem_dir_alterna=str_data[39], cxc_destinatario_id=str_data[40]::integer, dest_dir_alterna=str_data[41], trans_observaciones=str_data[42] 
						WHERE poc_pedido_id = str_data[4]::integer;
					END IF;
				END IF;
				
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					generar_requisicion:=false;
					generar_backorder:=false;
					retencion_partida:=0;
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					
					--str_filas[1] eliminado
					IF str_filas[1]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
						--str_filas[2]	iddetalle
						--str_filas[3]	idproducto
						--str_filas[4]	id_presentacion
						--str_filas[5]	id_impuesto
						--str_filas[6]	cantidad
						--str_filas[7]	costo
						--str_filas[8]	valor_impuesto
						
						--str_filas[12]	id_ieps
						--str_filas[13]	tasa_ieps
						--str_filas[14]	vdescto
						
						cant_reservada_anterior:=0;
						cant_reservar_nuevo:=0;
						cantPresAsignado:=0;
						equivalenciaPres:=0;
						noDecUnidad:=0;
						cantPresReservAnterior:=0;
						idUnidadMedida:=0;
						nombreUnidadMedida:='';
						cantUnidadVenta:=0;
						cantExisUnidadVenta:=0;
					
						--Obtener datos del Producto
						SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
						FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
						WHERE inv_prod.id=str_filas[3]::integer 
						INTO tipo_prod, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
						
						IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;

						--Tomamos la cantidad en la unidad de Venta seleccionada por el usuario
						cantUnidadVenta:=str_filas[6]::double precision;
					
						IF facpar.cambiar_unidad_medida THEN
							IF idUnidadMedida::integer<>str_filas[11]::integer THEN
								IF densidadProd IS NULL OR densidadProd=0 THEN
									densidadProd:=1;
								END IF;
								
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
								IF match_cadena=true THEN
									--Convertir a kilos
									str_filas[6] := str_filas[6]::double precision * densidadProd;
								ELSE
									EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
									IF match_cadena=true THEN 
										--Convertir a Litros
										str_filas[6] := str_filas[6]::double precision / densidadProd;
									END IF;
								END IF;
							END IF;
						END IF;
						
						--Redondear la cantidad de la Partida
						str_filas[6] := round(str_filas[6]::numeric,noDecUnidad)::double precision;
						cantUnidadVenta := round(cantUnidadVenta::numeric,noDecUnidad)::double precision; 
						
						--Si el tipo de producto es diferente de 4, hay que RESERVAR existencias
						--tipo=4 Servicios
						--para el tipo servicios no se debe reservar existencias
						IF tipo_prod::integer<>4 THEN 

							--Solo Para productos formulados
							IF tipo_prod=5 OR tipo_prod=6 THEN 
								--Reservar toda cantidad de la partida del pedido
								cant_reservar_nuevo := str_filas[6]::double precision;
								generar_backorder:=false;
							end if;
									
							
							IF incluye_modulo_produccion=false THEN
								--Aqui entra si la Empresa NO INCLUYE Modulo de Produccion
								
								--Solo Para productos formulados
								IF tipo_prod=1 OR tipo_prod=2 OR tipo_prod=8 THEN
									--si es diferente de cero estamos en editar
									IF str_filas[2]::integer > 0 THEN 
										--Buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=str_filas[2]::integer INTO id_producto, cant_reservada_anterior;
										
										--redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=id_almacen AND ano=ano_actual;
									END IF;
									
									--Reservar toda cantidad de la partida del pedido
									cant_reservar_nuevo := str_filas[6]::double precision;
									generar_backorder:=false;
									
								END IF;
							ELSE
								--Solo Para productos formulados
								IF tipo_prod=1 OR tipo_prod=2 OR tipo_prod=8 THEN
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, usuario_id, id_almacen) INTO total_existencia; 
									
									--Si es diferente de cero estamos en editar
									IF str_filas[2]::integer > 0 THEN 
										--buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=str_filas[2]::integer INTO id_producto, cant_reservada_anterior;

										--redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=id_almacen AND ano=ano_actual;
										
										--le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
										total_existencia := total_existencia + cant_reservada_anterior;
									END IF;
									
									IF total_existencia < str_filas[6]::double precision THEN
										IF total_existencia <=0 THEN 
											cant_reservar_nuevo=0;--reservar cero
										ELSE
											cant_reservar_nuevo:=total_existencia;--tomar la existencia para reservar
										END IF;
										
										generar_backorder:=true;
									ELSE
										cant_reservar_nuevo := str_filas[6]::double precision;--reservar toda la cantidad del  pedido
										generar_backorder:=false;
									END IF;
								END IF;
							END IF;



							
							
							IF facpar.permitir_req_com THEN 
								--7=Materia Prima - Hay que generar una requisicion de compra.
								IF tipo_prod=7 THEN 
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, usuario_id, id_almacen) INTO total_existencia; 
									
									--si es diferente de cero estamos en editar
									IF str_filas[2]::integer > 0 THEN 
										--Buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=str_filas[2]::integer INTO id_producto, cant_reservada_anterior;

										--Redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--Restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=id_almacen AND ano=ano_actual;
										
										--Le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
										total_existencia := total_existencia + cant_reservada_anterior;
									END IF;
									
									IF total_existencia < str_filas[6]::double precision THEN
										IF total_existencia <=0 THEN 
											--Reservar cero
											cant_reservar_nuevo=0;
										ELSE
											--Tomar la existencia para reservar
											cant_reservar_nuevo:=total_existencia;
										END IF;
										
										generar_requisicion:=true;
									ELSE
										--Reservar toda la cantidad del  pedido
										cant_reservar_nuevo := str_filas[6]::double precision;
										generar_requisicion:=false;
									END IF;
								END IF;
							ELSE
								if tipo_prod=7 then  
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, str_filas[3]::integer, usuario_id, id_almacen) INTO total_existencia; 
									
									--si es diferente de cero estamos en editar
									IF str_filas[2]::integer > 0 THEN 
										--Buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=str_filas[2]::integer INTO id_producto, cant_reservada_anterior;

										--Redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--Restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=id_almacen AND ano=ano_actual;
										
										--Le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
										total_existencia := total_existencia + cant_reservada_anterior;
									END IF;
									
									IF total_existencia < str_filas[6]::double precision THEN
										IF total_existencia <=0 THEN 
											--Reservar cero
											cant_reservar_nuevo=0;
										ELSE
											--Tomar la existencia para reservar
											cant_reservar_nuevo:=total_existencia;
										END IF;
										
										generar_requisicion:=false;
									ELSE
										--Reservar toda la cantidad del  pedido
										cant_reservar_nuevo := str_filas[6]::double precision;
										generar_requisicion:=false;
									END IF;
								end if;
							END IF;
							
							--Redondear la nueva cantidad a reservar
							cant_reservar_nuevo := round(cant_reservar_nuevo::numeric,noDecUnidad)::double precision;
							
							--RAISE EXCEPTION '%','incluye_modulo_produccion: '||incluye_modulo_produccion;
							
							--Reservar cantidad para el  pedido
							UPDATE inv_exi SET reservado=(reservado::double precision + cant_reservar_nuevo::double precision) WHERE inv_prod_id=str_filas[3]::integer AND inv_alm_id=id_almacen AND ano=ano_actual;
							
							------inicia reservar existencias en presentaciones--------------------------
							--verificar si hay que validar existencias de Presentaciones
							IF controlExisPres=true THEN 
								--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
								--TRUE = Validar presentaciones desde el Pedido
								--FALSE = No validar presentaciones desde el Pedido
								IF facpar.validar_pres_pedido=true THEN 
									--buscar la equivalencia de la Presentacion
									SELECT cantidad  FROM inv_prod_presentaciones WHERE id=str_filas[4]::integer 
									INTO equivalenciaPres;
									
									IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
									
									--si es diferente de cero estamos en editar
									IF str_filas[2]::integer > 0 THEN 
										cantPresReservAnterior := cant_reservada_anterior::double precision / equivalenciaPres::double precision;

										--redondear la cantidad de Presentaciones Reservada anteriormente
										cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
										
										--Quitar la Cantidad Reservada anteriormente
										UPDATE inv_exi_pres SET reservado=(reservado::double precision - cantPresReservAnterior::double precision)
										WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=str_filas[3]::integer AND inv_prod_presentacion_id=str_filas[4]::integer;
									END IF;
									
									
									--convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
									cantPresAsignado := cant_reservar_nuevo::double precision / equivalenciaPres::double precision;
									
									--redondear la cantidad de Presentaciones Asignado en la partida
									cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
									
									--Reservar existencia en inv_exi_pres
									UPDATE inv_exi_pres SET reservado=(reservado::double precision + cantPresAsignado::double precision)
									WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=str_filas[3]::integer AND inv_prod_presentacion_id=str_filas[4]::integer;
									
								END IF;
							END IF;
							------termina reservar existencias de Presentaciones------------------------------------
						ELSE
							generar_backorder:=false;
							cant_reservar_nuevo=0;
						END IF;--termina if tipo_prod!=4
						
						--Dividir entre 100 la tasa del IEPS
						IF str_filas[13]::double precision>0 THEN 
							str_filas[13]:=str_filas[13]::double precision/100;
						END IF;

						--Tasa retencion
						IF str_filas[23]::double precision>0 THEN 
							str_filas[23]:=str_filas[23]::double precision/100;
						END IF;

						--requiere_aut=str_filas[20]::boolean, autorizado=str_filas[17]::boolean, precio_aut=str_filas[18]::double precision, gral_usr_id_aut=str_filas[19]::integer 
						--requiere_aut, autorizado, precio_aut, gral_usr_id_aut
						--str_filas[20]::boolean, str_filas[17]::boolean, str_filas[18]::double precision, str_filas[19]::integer 
						
						--str_filas[2]=0 Es registro Nuevo
						--str_filas[2]>0 El registro ya existe, solo hay que actualizar
						IF str_filas[2]::integer = 0 THEN
							--Crea registro nuevo en tabla poc_pedidos_detalle
							INSERT INTO poc_pedidos_detalle(poc_pedido_id,inv_prod_id,presentacion_id,gral_imp_id,cantidad,precio_unitario,valor_imp, reservado, backorder, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, requisicion, requiere_aut, autorizado, precio_aut, gral_usr_id_aut, gral_imptos_ret_id, tasa_ret)
							VALUES(str_data[4]::integer,str_filas[3]::integer,str_filas[4]::integer,str_filas[5]::integer, cantUnidadVenta::double precision,str_filas[7]::double precision,str_filas[8]::double precision, cant_reservar_nuevo, generar_backorder, str_filas[11]::integer, str_filas[12]::integer, str_filas[13]::double precision, str_filas[14]::double precision, generar_requisicion, str_filas[20]::boolean, str_filas[17]::boolean, str_filas[18]::double precision, str_filas[19]::integer, str_filas[22]::integer, str_filas[23]::double precision); 
						ELSE
							--Actualiza registro
							UPDATE poc_pedidos_detalle SET poc_pedido_id=str_data[4]::integer, inv_prod_id=str_filas[3]::integer, presentacion_id=str_filas[4]::integer, gral_imp_id=str_filas[5]::integer, cantidad=cantUnidadVenta::double precision, precio_unitario=str_filas[7]::double precision, valor_imp=str_filas[8]::double precision, reservado=cant_reservar_nuevo, backorder=generar_backorder,inv_prod_unidad_id=str_filas[11]::integer, valor_ieps=str_filas[13]::double precision, descto=str_filas[14]::double precision, requisicion=generar_requisicion, requiere_aut=str_filas[20]::boolean, autorizado=str_filas[17]::boolean, precio_aut=str_filas[18]::double precision, gral_usr_id_aut=str_filas[19]::integer, gral_imptos_ret_id=str_filas[22]::integer, tasa_ret=str_filas[23]::double precision  
							WHERE id=str_filas[2]::integer AND poc_pedido_id=str_data[4]::integer;
						END IF;
						
						--Calcular el Importe de la partida y redondealo a 4 digitos
						importe_partida := round((cantUnidadVenta::double precision * str_filas[7]::double precision)::numeric,4)::double precision;
						
						--Calcula el IEPS de la partida y redondear a 4 digitos
						importe_ieps_partida := round((importe_partida::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
						
						--Calcula el IVA de la Partida
						impuesto_partida := (importe_partida::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision;

						--Calcular el importe de la retencion de la partida si existe la tasa de retencion
						if str_filas[23]::double precision>0 then 
							retencion_partida := round((importe_partida::double precision * str_filas[23]::double precision)::numeric,4)::double precision;
						end if;
						
						IF lower(str_data[43])='true' THEN
							IF str_filas[14]::double precision>0 THEN
								importe_del_descto_partida = round((importe_partida * (str_filas[14]::double precision/100))::numeric,4)::double precision;
								
								importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
								
								--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
								importe_ieps_partida := round((importe_partida_con_descto::double precision * str_filas[13]::double precision)::numeric,4)::double precision;
								
								--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
								impuesto_partida := (importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * str_filas[8]::double precision;

								--Reclacular el nuevo el importe de la retencion de la partida si existe la tasa de retencion
								if str_filas[23]::double precision>0 then 
									retencion_partida := round((importe_partida_con_descto::double precision * str_filas[23]::double precision)::numeric,4)::double precision;
								end if;
							END IF;
						END IF;
						
						suma_descuento = suma_descuento + importe_del_descto_partida::double precision;
						suma_subtotal_con_descuento = suma_subtotal_con_descuento + importe_partida_con_descto::double precision;
						
						monto_subtotal := monto_subtotal + importe_partida::double precision;
						suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
						monto_impuesto := monto_impuesto + impuesto_partida::double precision;
						suma_retencion_de_partidas := suma_retencion_de_partidas + retencion_partida::double precision;
					ELSE
						IF trim(str_filas[2])='' THEN
							--Aqui solo entra cuando se ha eliminado un registro nuevo que nunca fue guardado
							str_filas[2]:='0';
						END IF;
						
						--Extraer datos del registro eliminado
						sql_select:='SELECT * FROM poc_pedidos_detalle WHERE id='||str_filas[2]||'::integer AND poc_pedido_id='||str_data[4]::integer;
						
						--Regresar existencias reservadas
						FOR fila IN EXECUTE (sql_select) LOOP
							UPDATE inv_exi SET reservado=(reservado::double precision - fila.reservado::double precision) WHERE inv_prod_id=fila.inv_prod_id AND inv_alm_id=id_almacen AND ano=ano_actual;
						END LOOP;
						
						--Elimina registro que se elimino en el grid del navegador
						DELETE FROM poc_pedidos_detalle where id=str_filas[2]::integer AND poc_pedido_id=str_data[4]::integer;
						
						--Eliminar el registro de la tabla que relaciona la Cotizacion con el Pedido
						DELETE FROM poc_ped_cot where poc_ped_det_id=str_filas[2]::integer AND poc_ped_id=str_data[4]::integer;
					END IF;
				END LOOP;
				
				--Verificar si hay que retener iva para este cliente
				SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex/100 end FROM cxc_clie WHERE id=str_data[5]::integer INTO retener_iva, tasa_retencion;
				
				--RAISE EXCEPTION '%','desct: '||str_data[43]||'        suma_descuento:'||suma_descuento;
				IF lower(str_data[43])='true' AND suma_descuento>0 THEN
					IF retener_iva=true THEN
						total_retencion := suma_subtotal_con_descuento::double precision * tasa_retencion;
					ELSE 
						total_retencion :=0;
					END IF;
					
					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					---RAISE EXCEPTION '%','suma_subtotal_con_descuento:'||suma_subtotal_con_descuento||'        suma_ieps:'||suma_ieps||'        monto_impuesto:'||monto_impuesto;
					--Calcula el monto del pedido
					monto_total:= suma_subtotal_con_descuento::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
					
					--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
					UPDATE poc_pedidos SET subtotal=suma_subtotal_con_descuento, monto_descto=suma_descuento, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
					WHERE id=str_data[4]::integer;
				ELSE 
					IF retener_iva=true THEN
						total_retencion := monto_subtotal * tasa_retencion;
					ELSE
						total_retencion :=0;
					END IF;
					
					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					--Calcula el monto Total del pedido
					monto_total:= monto_subtotal::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
					
					--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
					UPDATE poc_pedidos SET subtotal=monto_subtotal, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
					WHERE id=str_data[4]::integer;
				END IF;
				
				valor_retorno := '1';
			ELSE
				IF id_proceso_flujo=2 THEN 
					valor_retorno := 'El pedido no pudo ser Actualizado ya fue autorizado. Se encuentra en proceso de Facturacion.';
				END IF;
				
				IF id_proceso_flujo=3 THEN 
					valor_retorno := 'El pedido no pudo ser Actualizado, ya fue Facturado.';
				END IF;
			END IF;
		END IF;--termina edit pedido
		
		
		
		
		--Aqui entra cuando la persona que cancela es la misma que hizo el pedido
		IF command_selected = 'cancelar' THEN
			
			--Obtener el id del proceso para este pedido
			SELECT proceso_id FROM poc_pedidos WHERE id=str_data[4]::integer INTO id_proceso;
			
			--obtener el id del flujo del proceso
			SELECT proceso_flujo_id FROM erp_proceso WHERE id=id_proceso INTO id_proceso_flujo;
			
			IF id_proceso_flujo=4 THEN 
				UPDATE poc_pedidos SET cancelado=true, momento_cancelacion=espacio_tiempo_ejecucion,gral_usr_id_cancelacion=usuario_id
				WHERE id=str_data[4]::integer
				RETURNING inv_alm_id INTO id_almacen;
				
				--extraer datos del detalle del pedido
				sql_select:='SELECT * FROM poc_pedidos_detalle WHERE poc_pedido_id='||str_data[4]::integer;
				
				--crea devolver existencias reservadas
				FOR fila IN EXECUTE (sql_select) LOOP
					cantPresReservAnterior:=0;
					noDecUnidad:=0;
					equivalenciaPres:=0;
					
					--obtener el tipo de producto y el numero de Decimales Permitidos
					SELECT inv_prod.tipo_de_producto_id AS tipo_producto,(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
					FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=fila.inv_prod_id 
					INTO tipo_prod, noDecUnidad;
					
					IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
					
					--Redondear la cantidad reservada
					fila.reservado := round(fila.reservado::numeric,noDecUnidad)::double precision;
					
					--Quitar reservado de la tabla inv_exi
					UPDATE inv_exi SET reservado=(reservado::double precision - fila.reservado::double precision) WHERE inv_prod_id=fila.inv_prod_id AND inv_alm_id=id_almacen AND ano=ano_actual;
					
					------Inicia quitar existencias reservadas en inv_exi_pres--------------------------
					--Verificar si la configuracion indica que se esta controlando existencias por presentaciones
					IF controlExisPres=true THEN 
						--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
						--TRUE = Validar presentaciones desde el Pedido
						--FALSE = No validar presentaciones desde el Pedido
						IF facpar.validar_pres_pedido=true THEN 
							--buscar la equivalencia de la Presentacion
							SELECT cantidad  FROM inv_prod_presentaciones WHERE id=fila.presentacion_id::integer 
							INTO equivalenciaPres;
							
							IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
							
							--convertir a Presentaciones la cantidad Reservada
							cantPresReservAnterior := fila.reservado::double precision / equivalenciaPres::double precision;
							
							--redondear la cantidad de Presentaciones Reservada anteriormente
							cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
							
							--Quitar la Cantidad Reservada anteriormente
							UPDATE inv_exi_pres SET reservado=(reservado::double precision - cantPresReservAnterior::double precision)
							WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=fila.inv_prod_id::integer AND inv_prod_presentacion_id=fila.presentacion_id::integer;
						END IF;
					END IF;
					
				END LOOP;
				
				valor_retorno := '1';
			ELSE
				IF id_proceso_flujo=2 THEN 
					valor_retorno := 'El pedido ya fue Autorizado, se encuentra en Facturacion. No se puede Cancelar.';
				END IF;
				
				IF id_proceso_flujo=3 THEN 
					valor_retorno := 'El pedido ya fue Facturado. No se puede Cancelar.';
				END IF;
			END IF;
		END IF;
		
	END IF;--termina aplicativo Pedidos de Clientes
	
	
	
	
	--Aplicativo Autorizacion de Pedidos de Clientes
	IF app_selected = 65 THEN
		
		IF command_selected = 'autorizar' THEN 
			--actualiza el pedido con datos del usuario que autoriza
			UPDATE poc_pedidos SET momento_autorizacion=espacio_tiempo_ejecucion,gral_usr_id_autoriza=usuario_id 
			WHERE id=str_data[4]::integer;
			
			--extraer datos del pedido
			SELECT * FROM poc_pedidos WHERE id=str_data[4]::integer INTO pedido;
			
			id_almacen := pedido.inv_alm_id;
			
			IF pedido.cancelado=false THEN
				
				--Actualiza el flujo del proceso a 2=Prefactura
				UPDATE erp_proceso SET proceso_flujo_id=2 WHERE id=pedido.proceso_id;
				
				IF pedido.lugar_entrega!='' AND pedido.lugar_entrega IS NOT NULL THEN
					obser_prefactura:='LUGAR DE ENTREGA: '||pedido.lugar_entrega;
				ELSE
					obser_prefactura:='';
				END IF;
				
				--si enviar_obser_fac=true, hay que enviar las observaciones del pedido a las observaciones de la prefactura
				IF pedido.enviar_obser_fac=true THEN
					--verificamos que las observaciones del pedido no venga vacio
					IF pedido.observaciones!='' AND pedido.observaciones IS NOT NULL THEN
						IF obser_prefactura!='' THEN
							--si obser_prefactura no viene vacio, le agregamos un salto de linea
							obser_prefactura:=obser_prefactura||E'\n';
						END IF;
						
						obser_prefactura:=obser_prefactura||pedido.observaciones;
					END IF;
				END IF;
				
				--Crear registro en la tabla erp_prefacturas y retorna el id del registro creado
				 INSERT INTO  erp_prefacturas(
					proceso_id,--pedido.proceso_id,
					folio_pedido,--pedido.folio,
					cliente_id,--pedido.cxc_clie_id,
					moneda_id,--pedido.moneda_id,
					--observaciones,--pedido.observaciones,
					observaciones,--obser_prefactura,
					subtotal,--pedido.subtotal,
					impuesto,--pedido.impuesto,
					monto_retencion,--pedido.monto_retencion,
					total,--pedido.total,
					tasa_retencion_immex,--pedido.tasa_retencion_immex,
					tipo_cambio,--pedido.tipo_cambio,
					empleado_id,--pedido.cxc_agen_id,
					terminos_id,--pedido.cxp_prov_credias_id
					orden_compra,--pedido.orden_compra,
					fac_metodos_pago_id,--pedido.fac_metodos_pago_id,
					no_cuenta,--pedido.no_cuenta,
					enviar_ruta,--pedido.enviar_ruta,
					inv_alm_id,--pedido.inv_alm_id,
					cxc_clie_df_id,--pedido.cxc_clie_df_id,
					refacturar,--false,
					id_usuario_creacion,--usuario_id,
					momento_creacion,--espacio_tiempo_ejecucion
					monto_ieps, --pedido.monto_ieps
					monto_descto, --pedido.monto_descto
					motivo_descto, --pedido.motivo_descto
					cfdi_usos_id,
					cfdi_metodo_id
				)VALUES(
					pedido.proceso_id,
					pedido.folio,
					pedido.cxc_clie_id,
					pedido.moneda_id,
					--pedido.observaciones,
					obser_prefactura,
					pedido.subtotal,
					pedido.impuesto,
					pedido.monto_retencion,
					pedido.total,
					pedido.tasa_retencion_immex,
					pedido.tipo_cambio,
					pedido.cxc_agen_id,
					pedido.cxp_prov_credias_id,
					pedido.orden_compra,
					pedido.fac_metodos_pago_id,
					pedido.no_cuenta,
					pedido.enviar_ruta,
					pedido.inv_alm_id,
					pedido.cxc_clie_df_id,
					false,
					usuario_id,
					espacio_tiempo_ejecucion,
					pedido.monto_ieps,
					pedido.monto_descto,
					pedido.motivo_descto,
					pedido.cfdi_usos_id,
                                        pedido.cfdi_metodo_id
				) RETURNING id into ultimo_id;
				
				--Extraer datos del detalle del pedido
				sql_select:='SELECT *, 0::integer as depto_id, 0::integer as empleado_id FROM poc_pedidos_detalle WHERE poc_pedido_id='||str_data[4]::integer;
				
				--RAISE EXCEPTION '%','sql_select: '||sql_select;
				
				--crea registros para tabla erp_prefacturas_detalles
				FOR fila IN EXECUTE (sql_select) LOOP
					
					INSERT INTO erp_prefacturas_detalles(prefacturas_id,producto_id,presentacion_id,tipo_impuesto_id,valor_imp,cantidad,precio_unitario, reservado, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, gral_imptos_ret_id, tasa_ret)
					VALUES(ultimo_id,fila.inv_prod_id,fila.presentacion_id,fila.gral_imp_id,fila.valor_imp,fila.cantidad,fila.precio_unitario, fila.reservado, fila.inv_prod_unidad_id, fila.gral_ieps_id, fila.valor_ieps, fila.descto, fila.gral_imptos_ret_id, fila.tasa_ret);
					
					IF facpar.cambiar_unidad_medida THEN 
						--Obtener datos del Producto
						SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
						FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
						WHERE inv_prod.id=fila.inv_prod_id
						INTO tipo_prod, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
						
						IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
						
						IF idUnidadMedida::integer<>fila.inv_prod_unidad_id THEN
							IF densidadProd IS NULL OR densidadProd=0 THEN
								densidadProd:=1;
							END IF;
							
							EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
							IF match_cadena=true THEN
								--Convertir a kilos
								fila.cantidad := fila.cantidad::double precision * densidadProd;
								fila.cantidad := round(fila.cantidad::numeric,noDecUnidad)::double precision;
							ELSE
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
								IF match_cadena=true THEN 
									--Convertir a Litros
									fila.cantidad := fila.cantidad::double precision / densidadProd;
									fila.cantidad := round(fila.cantidad::numeric,noDecUnidad)::double precision;
								END IF;
							END IF;
						END IF;
					END IF;

					
					
					
					--Aqui debe entrar cuando la partida va a Requisicion de Compra
					IF fila.backorder=false AND fila.requisicion=true THEN 
						IF header_requisicion_generada=false THEN
							id_tipo_consecutivo:=32;--consecutivo de Requisicion
							
							--Aqui entra para tomar el consecutivo de la Requisicion de la sucursal actual
							UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
							WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
							
							--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio
							nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

							--Obtener id del empleado y departamento la que pertenece el usuario
							--select gral_empleados.id, gral_empleados.gral_depto_id from gral_usr join gral_empleados on gral_empleados.id=gral_usr.gral_empleados_id into fila.empleado_id, fila.depto_id;
							
							select gral_empleados.id, gral_empleados.gral_depto_id from gral_empleados where gral_empleados.id=pedido.cxc_agen_id 
							into fila.empleado_id, fila.depto_id;
							
							
							IF fila.empleado_id IS NULL THEN fila.empleado_id:=0; END IF;
							IF fila.depto_id IS NULL THEN fila.depto_id:=0; END IF;
							
							--Tipo 1=Requisiciones creadas manualmente, 2=Requisiciones generadas desde un pedido.
							INSERT INTO com_oc_req(folio,fecha_compromiso, observaciones, cancelado, borrado_logico, gral_emp_id, gral_suc_id, momento_creacion, gral_usr_id_creacion, gral_empleado_id, gral_depto_id, folio_pedido, tipo)
							VALUES(nuevo_folio,pedido.fecha_compromiso, pedido.observaciones, false, false, emp_id, suc_id, espacio_tiempo_ejecucion, usuario_id, fila.empleado_id, fila.depto_id, pedido.folio, 2) 
							RETURNING id INTO ultimo_id2;
							
							--Cambiar bandera para indicar que ya se gener√≥ el header de la tabla de requisiciones
							header_requisicion_generada:=true;
						END IF;
						
						--Aqui se calcula la cantidad que se debe enviar a la requisicion de compra
						cantidad_produccion := fila.cantidad - fila.reservado;
						
						--Genera registro en la tabla detalle de la requisicion
						INSERT INTO com_oc_req_detalle(com_oc_req_id,inv_prod_id,presentacion_id,cantidad) VALUES(ultimo_id2, fila.inv_prod_id, fila.presentacion_id, cantidad_produccion);
						
					END IF;
					
					
					--Aqui debe entrar solo cuando la partida va a backorder de produccion
					IF fila.backorder=true AND fila.requisicion=false THEN 
						id_tipo_consecutivo:=24;--Folio backorder
						
						--aqui entra para tomar el consecutivo del pedido de la sucursal actual
						UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
						WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
						--suc_id_consecutivo
						
						--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del pedido
						nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
						
						cantidad_produccion := fila.cantidad - fila.reservado;
						
						INSERT INTO poc_ped_bo(folio, poc_ped_detalle_id, inv_prod_id, cantidad, inv_alm_id, inv_mov_tipo_id, cxc_clie_id, orden_compra, observaciones, autorizado, momento_autorizacion, momento_creacion, gral_usr_id_autoriza, gral_usr_id_creacion, gral_emp_id, gral_suc_id)
						VALUES(nuevo_folio,fila.id,fila.inv_prod_id,cantidad_produccion,id_almacen,0,pedido.cxc_clie_id,pedido.orden_compra,pedido.observaciones,true,espacio_tiempo_ejecucion,espacio_tiempo_ejecucion,usuario_id,usuario_id,emp_id,suc_id);
					END IF;
					
				END LOOP;
				
				valor_retorno := '1';
			ELSE
				valor_retorno := 'El pedido fue CANCELADO en un proceso anterior. No se puede Autorizar.';
			END IF;
		END IF;
		
		
		
		--Aqui entra cuando la persona que autoriza es la que cancela el pedido
		IF command_selected = 'cancelar' THEN
			
			--Obtener el id del proceso, id_cliente para este pedido
			SELECT proceso_id, cxc_clie_id, folio FROM poc_pedidos WHERE id=str_data[4]::integer INTO pedido;
			
			id_proceso:=pedido.proceso_id;
			id_cliente:=pedido.cxc_clie_id;
			
			--obtener el id del flujo del proceso
			SELECT proceso_flujo_id,empresa_id,sucursal_id  FROM erp_proceso WHERE id=id_proceso INTO fila2;
			
			id_proceso_flujo := fila2.proceso_flujo_id;
			
			--RAISE EXCEPTION '%','id_proceso_flujo:'||id_proceso_flujo;
			/*
			Proceso flujo 
			4=Pedido, 
			2=Facturacion o Prefactura
			7=FAC PARCIAL
			8=REM PARCIAL
			*/
			IF id_proceso_flujo::integer=4 OR id_proceso_flujo::integer=2 OR id_proceso_flujo::integer=7 OR id_proceso_flujo::integer=8 THEN 
				
				select 
					count(com_oc_requisicion.id) as exis_oc
				from com_oc_req
				join com_oc_req_detalle on com_oc_req_detalle.com_oc_req_id=com_oc_req.id 
				join com_oc_requisicion on com_oc_requisicion.com_oc_req_det_id=com_oc_req_detalle.id
				where trim(com_oc_req.folio_pedido)=trim(pedido.folio) and com_oc_req.gral_suc_id=fila2.sucursal_id and com_oc_req.cancelado=false
				into exis;
				
				if exis<=0 then 
					--Cancelar Requisici√≥n si es que existe.
					update com_oc_req set cancelado=true, momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancelacion=usuario_id 
					where trim(com_oc_req.folio_pedido)=trim(pedido.folio) and com_oc_req.gral_suc_id=fila2.sucursal_id;
					
					--Extraer datos del backorder
					sql_select:='SELECT poc_ped_bo.estatus FROM poc_pedidos
						JOIN poc_pedidos_detalle ON poc_pedidos_detalle.poc_pedido_id=poc_pedidos.id
						JOIN poc_ped_bo ON poc_ped_bo.poc_ped_detalle_id=poc_pedidos_detalle.id
						WHERE poc_pedidos.id='||str_data[4]::integer;
					
					en_proceso_produccion:=false;
					
					--Crea devolver existencias reservadas
					FOR fila IN EXECUTE (sql_select) LOOP
						IF fila.estatus=1 THEN
							--Por lo menos una partida del pedido genero backorder y se encuentra en produccion
							en_proceso_produccion := true;
						END IF;
					END LOOP;
					
					IF en_proceso_produccion=false THEN
						/*
						Aqui entra cuando no hay nada en proceso de produccion 
						y se puede proceder a cancelar el pedido y los registros en la tabla poc_ped_bo
						*/
						UPDATE poc_pedidos SET cancelado=true, momento_cancelacion=espacio_tiempo_ejecucion,gral_usr_id_cancelacion=usuario_id
						where id=str_data[4]::integer
						RETURNING inv_alm_id INTO id_almacen;
						
						sql_select:='';
						
						--Extraer datos del detalle del pedido
						sql_select:='SELECT * FROM poc_pedidos_detalle WHERE poc_pedido_id='||str_data[4]::integer;
						
						--Devolver existencias reservadas
						FOR fila IN EXECUTE (sql_select) LOOP
							cantPresReservAnterior:=0;
							noDecUnidad:=0;
							equivalenciaPres:=0;
							
							--Obtener datos del Producto
							SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
							FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
							WHERE inv_prod.id=fila.inv_prod_id 
							INTO tipo_prod, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
							
							IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
							
							--Quitar reservados de poc_pedidos_detalle
							UPDATE poc_pedidos_detalle SET reservado=0 WHERE id=fila.id;
							
							--Redondear la cantidad reservada
							fila.reservado := round(fila.reservado::numeric,noDecUnidad)::double precision; 
							
							--Quitar la cantidad reservada de la tabla inv_exi
							UPDATE inv_exi SET reservado=(reservado::double precision - fila.reservado::double precision) WHERE inv_prod_id=fila.inv_prod_id AND inv_alm_id=id_almacen AND ano=ano_actual;
							
							------Inicia quitar existencias reservadas en inv_exi_pres--------------------------
							--verificar si la configuracion indica que se esta controlando existencias por presentaciones
							IF controlExisPres=true THEN 
								--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
								--TRUE = Validar presentaciones desde el Pedido
								--FALSE = No validar presentaciones desde el Pedido
								IF facpar.validar_pres_pedido=true THEN 
									--buscar la equivalencia de la Presentacion
									SELECT cantidad  FROM inv_prod_presentaciones WHERE id=fila.presentacion_id::integer 
									INTO equivalenciaPres;
									
									IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
									
									--convertir a Presentaciones la cantidad Reservada
									cantPresReservAnterior := fila.reservado::double precision / equivalenciaPres::double precision;
									
									--redondear la cantidad de Presentaciones Reservada anteriormente
									cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
									
									--Quitar la Cantidad Reservada anteriormente
									UPDATE inv_exi_pres SET reservado=(reservado::double precision - cantPresReservAnterior::double precision)
									WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=fila.inv_prod_id::integer AND inv_prod_presentacion_id=fila.presentacion_id::integer;
								END IF;
							END IF;
							
						END LOOP;
						
						
						sql_select:='';
						--Extraer datos del backorder
						sql_select:='
						SELECT poc_ped_bo.id
						FROM poc_pedidos
						JOIN poc_pedidos_detalle ON poc_pedidos_detalle.poc_pedido_id=poc_pedidos.id
						JOIN poc_ped_bo ON poc_ped_bo.poc_ped_detalle_id=poc_pedidos_detalle.id
						WHERE poc_pedidos.id='||str_data[4]::integer;
						
						--cancelar los registros en la tabla poc_ped_bo(backorder)
						FOR fila IN EXECUTE (sql_select) LOOP
							UPDATE poc_ped_bo SET cancelado=TRUE, momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_cancelacion=usuario_id  WHERE poc_ped_bo.id=fila.id;
						END LOOP;
						
						
						IF id_proceso_flujo::integer=2 THEN 
							--Elimina la prefactura que se creo al momento de autorizar, solo para pedidos autorizados
							DELETE FROM erp_prefacturas WHERE proceso_id=id_proceso;
						END IF;
						
						IF id_proceso_flujo::integer=7 OR id_proceso_flujo::integer=8 THEN 
							sql_select:='';
							--Extraer datos del backorder
							sql_select:='SELECT 
								prefact_det.id AS id_det,
								prefact_det.producto_id AS prod_id 
							FROM erp_prefacturas 
							JOIN erp_prefacturas_detalles AS prefact_det ON (prefact_det.prefacturas_id=erp_prefacturas.id AND prefact_det.facturado=false)
							WHERE erp_prefacturas.proceso_id='||id_proceso||' 
							AND erp_prefacturas.cliente_id='||id_cliente;
							
							--RAISE EXCEPTION '%','sql_select: '||sql_select;
							--Cancelar los registros pendientes de Facturar o Remisionar
							FOR fila IN EXECUTE (sql_select) LOOP
								UPDATE erp_prefacturas_detalles SET facturado=TRUE, reservado=0 
								WHERE id=fila.id_det;
							END LOOP;
							
							IF id_proceso_flujo::integer=7 THEN 
								--Si el flujo del proceso es Fac Parcial, se le asigna Facturado
								UPDATE erp_proceso SET proceso_flujo_id=3 WHERE id=id_proceso;
							END IF;
							
							IF id_proceso_flujo::integer=8 THEN 
								--Si el flujo del proceso es REM PARCIAL, se le asigna Remiionado
								UPDATE erp_proceso SET proceso_flujo_id=5 WHERE id=id_proceso;
							END IF;
						END IF;
						
						valor_retorno := '1';
					ELSE
						valor_retorno := 'El pedido gener&oacute; una Preorden de Producci&oacute;n. No se puede Cancelar.';
					END IF;
				else
					valor_retorno := 'El pedido gener&oacute; una Reqisici&oacute;n que ya fue agregada a una Orden de Compra. No se puede Cancelar.';
				end if;
			ELSE
				IF id_proceso_flujo=3 THEN 
					valor_retorno := 'El pedido ya fue Facturado. No se puede Cancelar.';
				END IF;
				
				IF id_proceso_flujo=5 THEN 
					valor_retorno := 'El pedido ya genero una Remisi&oacute;n. No se puede Cancelar.';
				END IF;
			END IF;
		END IF;
	END IF;--termina aplicativo Autorizacion de Pedidos de Clientes
	


	
	
	--Aplicativo Remisiones
	IF app_selected = 66 THEN
		
		IF command_selected = 'edit' THEN
			--Aqui entra para actualizar la orden de compra de la remision
			UPDATE fac_rems SET orden_compra=str_data[5] WHERE id=str_data[4]::integer;
			
			valor_retorno := 'true';
		END IF;
		
		
		IF command_selected = 'cancelar' THEN
			SELECT COUNT(fac_rems_docs.fac_rem_id) FROM fac_rems_docs WHERE fac_rem_id IN (str_data[4]::integer) INTO exis_rem_doc;
			
			IF exis_rem_doc <= 0 THEN 
				UPDATE fac_rems SET cancelado=true, momento_cancelacion=espacio_tiempo_ejecucion,gral_usr_id_cancelacion=usuario_id
				WHERE id=str_data[4]::integer
				RETURNING folio, inv_alm_id, cxc_clie_id INTO folio_remision, id_almacen, id_cliente;
				
				--AQUI INICIA DEVOLUCION DE PRODUCTOS AL INVENTARIO
				--genera registro del movimiento de cancelacion
				tipo_movimiento_id:=22;
				INSERT INTO inv_mov(observacion,momento_creacion,gral_usr_id,gral_app_id, inv_mov_tipo_id, referencia, fecha_mov) 
				VALUES('CANCELACION DE REMISION',espacio_tiempo_ejecucion,usuario_id,app_selected,tipo_movimiento_id, folio_remision, espacio_tiempo_ejecucion) 
				RETURNING id INTO identificador_nuevo_movimiento;
				
				--obtiene lista de productos de la factura
				sql_select:='SELECT  fac_rems_detalles.inv_prod_id,
							fac_rems_detalles.cantidad,
							inv_prod.tipo_de_producto_id as tipo_producto,
							fac_rems_detalles.inv_prod_presentacion_id AS presentacion_id,
							(case when inv_prod_unidades.decimales is null then 0 else inv_prod_unidades.decimales end) AS no_dec,
							inv_prod.unidad_id AS id_uni_prod,
							inv_prod.densidad AS densidad_prod,
							inv_prod_unidades.titulo AS nombre_unidad,
							fac_rems_detalles.inv_prod_unidad_id
						FROM fac_rems_detalles 
						JOIN inv_prod ON inv_prod.id=fac_rems_detalles.inv_prod_id
						JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id 
						WHERE fac_rems_id='||str_data[4]::integer;
				
				--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
				FOR remision_detalle IN EXECUTE(sql_select) LOOP
					--Inicializar valores
					noDecUnidad:=0;
					cantPres:=0;
					equivalenciaPres:=0;
					
					noDecUnidad:=remision_detalle.no_dec;
					
					idUnidadMedida:=remision_detalle.id_uni_prod;
					densidadProd:=remision_detalle.densidad_prod;
					nombreUnidadMedida:=remision_detalle.nombre_unidad;
					
					IF facpar.cambiar_unidad_medida THEN
						IF idUnidadMedida::integer<>remision_detalle.inv_prod_unidad_id THEN
							IF densidadProd IS NULL OR densidadProd=0 THEN densidadProd:=1; END IF;
							
							EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
							IF match_cadena=true THEN
								--Convertir a kilos
								remision_detalle.cantidad := remision_detalle.cantidad::double precision * densidadProd;
							ELSE
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
								IF match_cadena=true THEN 
									--Convertir a Litros
									remision_detalle.cantidad := remision_detalle.cantidad::double precision / densidadProd;
								END IF;
							END IF;
						END IF;
					END IF;

					
					--Redondear la cantidad de la partida
					remision_detalle.cantidad := round(remision_detalle.cantidad::numeric,noDecUnidad)::double precision; 
					
					--Si el tipo de producto es diferente de 4, hay que descontar existencias y generar Movimientos
					--tipo=4 Servicios
					--para el tipo servicios debe generar movimientos ni descontar existencias
					IF remision_detalle.tipo_producto <> 4 THEN
						bandera_tipo_4=FALSE;--indica que por lo menos un producto es diferente de tipo4, por lo tanto debe generarse movimientos
						
						--genera registro en detalles del movimiento
						INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, alm_destino_id, cantidad, inv_mov_id, inv_prod_presentacion_id)
						VALUES(remision_detalle.inv_prod_id, 0,id_almacen, remision_detalle.cantidad, identificador_nuevo_movimiento, remision_detalle.presentacion_id);
						
						--reiniciamos las variables
						exis:=0;
						sql_select:='';
						
						--query para verificar existencia del producto en el almacen y en el a√±o actual
						sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||remision_detalle.inv_prod_id||' AND inv_alm_id='||id_almacen||' AND ano = '||ano_actual;
						--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
						EXECUTE sql_select INTO exis;
						
						IF exis >0 THEN
							sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||remision_detalle.cantidad||'::double precision),momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
							WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||remision_detalle.inv_prod_id||' AND ano='||ano_actual;
							EXECUTE sql_update;
						ELSE
							sql_insert:='INSERT INTO inv_exi (inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial) '||
							'VALUES('||remision_detalle.inv_prod_id||','||id_almacen||','||ano_actual||','||remision_detalle.cantidad||','''|| espacio_tiempo_ejecucion ||''',0)';
							EXECUTE sql_insert;
						END IF;
						
						
						
						
						------Inicia regresar existencias a la tabla inv_exi_pres---------------------------------
						--Verificar si la configuraci√≥n indica que se esta controlando existencias por presentaciones
						IF controlExisPres=true THEN 
							--buscar la equivalencia de la Presentacion
							SELECT cantidad  FROM inv_prod_presentaciones WHERE id=remision_detalle.presentacion_id::integer 
							INTO equivalenciaPres;

							IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
							
							--convertir a Presentaciones la cantidad de la Remision
							cantPres := remision_detalle.cantidad::double precision / equivalenciaPres::double precision;
							
							--redondear la cantidad de Presentaciones a regresar al invetario
							cantPres := round(cantPres::numeric,noDecUnidad)::double precision; 
							
							-------------------------------------------------------------------------------------
							--***** Sumar campo entradas en la tabla inv_exi_pres******
							--inicializar a cero
							exis := 0;
							
							--Buscar Registro de la Presentacion
							SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres 
							WHERE inv_exi_pres.inv_alm_id=id_almacen::integer AND inv_exi_pres.inv_prod_id=remision_detalle.inv_prod_id::integer AND inv_exi_pres.inv_prod_presentacion_id=remision_detalle.presentacion_id::integer 
							INTO exis;
							
							IF exis >0 THEN 
								--Sumar Entradas en la presentacion de la Partida
								UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantPres::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id 
								WHERE inv_alm_id=id_almacen::integer AND inv_prod_id=remision_detalle.inv_prod_id::integer AND inv_prod_presentacion_id=remision_detalle.presentacion_id::integer;
								
							ELSE
								--Aqu√≠ entra para crear registro en inv_exi_pres
								INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
								VALUES(id_almacen, remision_detalle.inv_prod_id, remision_detalle.presentacion_id, cantPres, espacio_tiempo_ejecucion, usuario_id);
							END IF;
							--**Termina actualizar existencia de Presentaciones
							-----------------------------------------------------------------------------------------
						END IF;
						
					END IF;--termina validacion tipo 4
					
				END LOOP;
				
				IF bandera_tipo_4=TRUE THEN 
					--la factura es de un producto tipo 4, por lo tanto se elimina el movimiento generado anteriormente
					DELETE FROM inv_mov WHERE id=identificador_nuevo_movimiento;
				END IF;
				
				
				
				
				--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
				--INICIA GENERACION DE ORDERN DE DEVOLUCION PARA LA REMISION
				--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
				
				--Obtener datos de la Orden de Salida que genero esta Remision
				SELECT * FROM inv_osal WHERE inv_osal.folio_documento=folio_remision AND  inv_osal.cxc_clie_id=id_cliente AND inv_osal.tipo_documento=2 
				INTO fila;
				--RAISE EXCEPTION '%','fila.id: '||fila.id;
				
				--Cancelar la Orden de Salida
				UPDATE inv_osal SET cancelacion=true, momento_cancelacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id 
				WHERE id=fila.id;
				
				--Estatus 0=No se ha tocado por el personal de Almacen, 
				--Estatus 1=Ya se ha ingresado cantidaddes, lotes, pedimentos y fechas de caducidad pero aun no se ha descontado del lote
				--Estatus 2=Confirmado(ya se le dio salida)
				
				--Solo se puede generar orden de devolucion cuando el estatus de la Orden de Salida es mayor a Uno
				IF fila.estatus::integer >= 1 THEN 
					--Folio Orden de Devolucion
					id_tipo_consecutivo:=26;
					
					--Aqui entra para tomar el consecutivo del folio  la sucursal actual
					UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
					WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
					
					--Concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
					nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
					
					INSERT INTO inv_odev(
						folio,--nuevo_folio,
						inv_mov_tipo_id,--tipo_movimiento_id,
						tipo_documento,--fila.tipo_documento,
						folio_documento,--fila.folio_documento,
						folio_ncto,--'',
						fecha_exp,--fila.fecha_exp,
						cxc_clie_id,--fila.cxc_clie_id
						inv_alm_id,--fila.inv_alm_id,
						moneda_id,--fila.moneda_id,
						erp_proceso_id,--fila.erp_proceso_id,
						momento_creacion,--espacio_tiempo_ejecucion,
						gral_usr_id_creacion,--usuario_id,
						gral_emp_id,--emp_id,
						gral_suc_id,--suc_id,
						cancelacion--false
					)VALUES(nuevo_folio, tipo_movimiento_id, fila.tipo_documento, fila.folio_documento, '', fila.fecha_exp, fila.cxc_clie_id, fila.inv_alm_id, fila.moneda_id, fila.erp_proceso_id, espacio_tiempo_ejecucion, usuario_id, emp_id, suc_id, false) 
					RETURNING id INTO ultimo_id;
					
					
					--Obtiene lista de la Nota de Credito por Devolucion
					sql_select:='
					SELECT 
						inv_osal_detalle.id,
						inv_osal_detalle.inv_prod_id,
						inv_osal_detalle.inv_prod_presentacion_id,
						(inv_osal_detalle.cantidad::double precision - cant_dev::double precision) AS cantidad_devolucion
					FROM inv_osal_detalle 
					WHERE inv_osal_detalle.inv_osal_id='||fila.id||';';
					
					--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
					FOR remision_detalle IN EXECUTE(sql_select) LOOP
						--Registrar cantidades que se devolvieron a inv_osal_detalle
						UPDATE inv_osal_detalle SET cant_dev=(cant_dev + remision_detalle.cantidad_devolucion::double precision) 
						WHERE id=remision_detalle.id; 
						
						--Obtiene lista de lotes de la Salida
						sql_select:='
						SELECT 
							inv_lote_detalle.inv_lote_id AS id_lote,
							inv_lote_detalle.inv_osal_detalle_id,
							inv_lote_detalle.cantidad_sal AS cant_fac,
							(inv_lote_detalle.cantidad_sal::double precision - cantidad_dev::double precision) AS devolucion,
							inv_osal_detalle.inv_prod_unidad_id AS id_unidad_venta 
						FROM inv_osal_detalle 
						JOIN inv_lote_detalle ON inv_lote_detalle.inv_osal_detalle_id=inv_osal_detalle.id 
						JOIN inv_lote ON inv_lote.id=inv_lote_detalle.inv_lote_id
						WHERE inv_osal_detalle.id='||remision_detalle.id||' AND inv_lote.inv_prod_id='||remision_detalle.inv_prod_id||';';
						
						--RAISE EXCEPTION '%','cadena_sql '||cadena_sql;
						FOR fila_detalle IN EXECUTE(sql_select) LOOP
							fila_detalle.devolucion:=remision_detalle.cantidad_devolucion::double precision;
							
							--Crear registro en inv_odev_detalle
							INSERT INTO inv_odev_detalle(inv_odev_id,inv_osal_detalle_id,inv_lote_id,cant_fac_lote,cant_dev_lote,inv_prod_unidad_id)
							VALUES(ultimo_id,fila_detalle.inv_osal_detalle_id,fila_detalle.id_lote,fila_detalle.cant_fac,fila_detalle.devolucion,fila_detalle.id_unidad_venta);
						END LOOP;
					END LOOP;
				END IF;
				---TERMINA GENERACION DE ORDEN DE DEVOLUCION DE LA REMSION CANCELADA
				--::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
				
				valor_retorno := 'true';
			ELSE
				valor_retorno := 'La Remisi&oacute;n ya se encuentra en Proceso de facturaci&oacute;n. No se puede Cancelar.';
			END IF;
		END IF;
		
		--Aqu√≠ entra cuando se paga la remision
		IF command_selected = 'pagar' THEN
			UPDATE fac_rems SET estatus=1 WHERE id=str_data[4]::integer;
			valor_retorno := 'true';
		END IF;
	END IF;--termina aplicativo Pedidos de Clientes
	
	
	
	-- Actualizador de Saludo y Despedida para Cotizacion
	IF app_selected = 131 THEN
		IF command_selected = 'edit' THEN
			--str_data[4] 	id
			--str_data[5] 	titulo
			--str_data[6] 	status
			UPDATE poc_cot_saludo_despedida SET  titulo=str_data[5], status=str_data[6]::boolean, momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id WHERE id=str_data[4]::integer;
			
			valor_retorno := '1';
		END IF;
	END IF;--termina Actualizador Saludo y Despedida para Cotizacion



	-- Catalogo de Incoterms
	IF app_selected = 132 THEN
		IF command_selected = 'new' THEN
			--str_data[4] 	identificador
			--str_data[5] 	nombre
			--str_data[6] 	descripcion_es
			--str_data[7] 	descripcion_ing
			
			INSERT INTO poc_cot_incoterms(nombre, descripcion_esp, descripcion_ing, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_suc_id, gral_emp_id) VALUES (str_data[5], str_data[6], str_data[7], false, espacio_tiempo_ejecucion, usuario_id, suc_id, emp_id);			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			--str_data[4] 	identificador
			--str_data[5] 	nombre
			--str_data[6] 	descripcion_es
			--str_data[7] 	descripcion_ing
			UPDATE poc_cot_incoterms SET nombre=str_data[5], descripcion_esp=str_data[6], descripcion_ing=str_data[7], momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id WHERE id=str_data[4]::integer;			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			--str_data[4] 	identificador
			UPDATE poc_cot_incoterms SET borrado_logico=true, momento_baja=espacio_tiempo_ejecucion, gral_usr_id_baja=usuario_id WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de Incoterms



	-- Catalogo de  Politicas de Pago
	IF app_selected = 134 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         descripcion
			INSERT INTO poc_cot_politicas_pago (descripcion,borrado_logico,gral_emp_id,gral_suc_id) VALUES (str_data[5],false,emp_id,suc_id );
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE poc_cot_politicas_pago SET descripcion=str_data[5] WHERE poc_cot_politicas_pago.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE poc_cot_politicas_pago SET borrado_logico=true WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo Politicas de Pago
	
	
	
	-- Catalogo de  CONDICIONES COMERCIALES
	IF app_selected = 135 THEN
		IF command_selected = 'new' THEN
			--str_data[4]         id
			--str_data[5]         descripcion
			
			INSERT INTO poc_cot_condiciones_com (descripcion,borrado_logico,gral_emp_id,gral_suc_id) VALUES (str_data[5],false,emp_id,suc_id );
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE poc_cot_condiciones_com SET descripcion=str_data[5] WHERE poc_cot_condiciones_com.id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN UPDATE poc_cot_condiciones_com SET borrado_logico=true WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Catalogo de  CONDICIONES COMERCIALES



	--quitar y reasignar reservados
	--select * from quitar_y_reasignar_reservados(emp_id) into result;
	
	
	RETURN valor_retorno;
	
END;$_$;


--
-- Name: poc_cat_cusorder(character varying, integer, integer, integer, integer, integer, integer, integer, integer, integer, double precision, double precision, double precision, boolean, boolean, boolean, boolean, text, text, text, character varying, character varying, character varying, character varying, character varying, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.poc_cat_cusorder(cmd character varying, usuario_id integer, salesman_id integer, customer_id integer, cust_df_id integer, warehouse_id integer, currency_id integer, sup_credays_id integer, met_pago_id integer, pedido_id integer, tasaretimmex double precision, currency_val double precision, perc_desc double precision, allow_desc boolean, send_comments boolean, flete_enable boolean, send_route boolean, comments text, razon_desc text, trans text, date_limit character varying, delivery_place character varying, purch_order character varying, account character varying, no_cot character varying, matrix text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE

    -- >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    -- >> Catalog of customer order    >>
    -- >> Version: CDGB                >>
    -- >> Date: 20/Jul/2017            >>
    -- >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    C_DELFLAG  integer := 1;
    C_DETID integer := 2;
    C_PRODID integer := 3;
    C_PRESENID integer := 4;
    C_TAXID integer := 5;
    C_QUANTITY integer := 6;
    C_COSTO integer := 7;
    C_TAXVALUE integer := 8;
    C_PROUNIID integer := 11;
    C_IEPSID integer := 12;
    C_IEPSTASA integer := 13;
    C_VDESCTO integer := 14;
    C_COTID integer := 15;
    C_COTDETID integer := 16;    
    C_STATUS_AUTH integer := 17;
    C_PRICE_AUTH integer := 18;
    C_USER_AUTH integer := 19;
    C_REQ_AUTH integer := 20;
    C_SAVE_REG integer := 21;
    C_RETEID integer := 22;
    C_RETETASA integer := 23;


    --estas  variables se utilizan en la mayoria de los catalogos
    valor_retorno character varying;
    emp_id integer:=0;
    suc_id integer:=0;
    suc_id_consecutivo integer=0; --sucursal de donde se tomara el consecutivo
    id_tipo_consecutivo integer=0;
    ultimo_id integer:=0;
    ultimo_id2 integer:=0;
    ultimo_id_det integer:=0;
    espacio_tiempo_ejecucion timestamp with time zone = now();
    ano_actual integer:=0;
    mes_actual integer:=0;
    sql_select character varying = '';
    sql_update character varying = '';
    sql_insert character varying = '';

    row_cells text[];
    no_rows integer;--total de elementos de arreglo
    counter integer;--contador de filas o posiciones del arreglo
    str_incoterms char[];
    iter_y integer;

    --variable para pedidos
    facpar record;--parametros de Facturacion
    ultimo_id_proceso integer = 0;
    id_proceso integer = 0;
    id_proceso_flujo integer =0;
    prefijo_consecutivo character varying = '';
    nuevo_consecutivo bigint=0;
    nuevo_folio character varying = '';
    incluye_modulo_produccion boolean;
    empresa_transportista boolean;
    tipo_prod integer=0;
    id_producto integer = 0;
    total_existencia double precision = 0;
    cantidad_produccion double precision = 0;
    cant_reservada_anterior double precision = 0;
    cant_reservar_nuevo double precision = 0;
    generar_backorder boolean = false;
    en_proceso_produccion boolean = false;

    importe_del_descto_partida double precision = 0;
    importe_partida_con_descto double precision = 0;
    suma_descuento double precision = 0;
    suma_subtotal_con_descuento double precision = 0;

    importe_partida double precision = 0;
    impuesto_partida double precision = 0;
    monto_subtotal double precision = 0;
    monto_total double precision = 0;
    monto_impuesto double precision = 0;
    total_retencion double precision = 0;
    importe_ieps_partida double precision = 0;
    suma_ieps double precision = 0;
    retener_iva boolean = false;
    tasa_retencion double precision = 0;
    retencion_partida double precision = 0;
    suma_retencion_de_partidas double precision = 0;

    --variables autorizacion de pedidos
    pedido record;
    fila record;
    fila2 record;
    fila_detalle record;

    exis integer = 0;
    exis_rem_doc integer = 0;
    tipo_movimiento_id integer =0;
    identificador_nuevo_movimiento integer =0;
    remision_detalle record;
    bandera_tipo_4 boolean;
    folio_remision character varying='';
    obser_prefactura text='';

    result character varying='';

    noDecUnidad integer=0;--numero de decimales permitidos para la unidad
    exisActualPres double precision=0;--existencia actual de la presentacion
    equivalenciaPres double precision=0; --equivalencia de la presentacion en la unidad del producto
    cantPres double precision=0; --Cantidad que se esta Intentando traspasar
    cantPresAsignado double precision=0;
    cantPresReservAnterior double precision=0;
    controlExisPres boolean; --Variable que indica  si se debe controlar Existencias por Presentacion
    cambiaUnidadMedida boolean:=false;

    --Id de la unidad de medida del producto
    idUnidadMedida integer:=0;
    --Nombre de la unidad de medida del producto
    nombreUnidadMedida character varying:=0;
    --Densidad del producto
    densidadProd double precision:=0;
    --Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
    cantUnidadVenta double precision:=0;
    --Cantidad de la existencia convertida a la unidad de venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
    cantExisUnidadVenta double precision:=0;
    match_cadena boolean:=false;

    --Variable para controlar la creacion de un registro en la tabla header de requisiciones cuando la configuracion lo permita
    header_requisicion_generada boolean:=false;
    --Variable que indica si una partida gener√≥ requisicion
    generar_requisicion  boolean:=false;

BEGIN
    controlExisPres:=false;
	
    SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
    SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;

    SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id
    FROM gral_usr_suc 
    JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
    WHERE gral_usr_suc.gral_usr_id = usuario_id
    INTO emp_id, suc_id;

    valor_retorno:='0';

    --Obtener parametros para la facturacion
    SELECT * FROM fac_par WHERE gral_suc_id=suc_id INTO facpar;

    --query para verificar si la Empresa actual incluye Modulo de Produccion y control de Existencias por Presentacion
    SELECT incluye_produccion, control_exis_pres, transportista  FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, controlExisPres, empresa_transportista;

    --√©ste consecutivo es para el folio del Pedido y folio para BackOrder(poc_ped_bo)
    suc_id_consecutivo := facpar.gral_suc_id_consecutivo;

    IF cmd = 'new' THEN

        --crea registro en tabla erp_proceso y retorna el id del registro creado. El flujo del proceso es 4=Pedido
        INSERT INTO erp_proceso(proceso_flujo_id, empresa_id, sucursal_id)
        VALUES(4, emp_id, suc_id) RETURNING id into ultimo_id_proceso;

        id_tipo_consecutivo := 7; --consecutivo de pedidos
			
        -- aqui entra para tomar el consecutivo del pedido de la sucursal actual
        UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
        WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;

        -- concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del pedido
        nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

        -- crear registro en la tabla poc_pedidos y retorna el id del registro creado
        INSERT INTO  poc_pedidos(
            folio, --nuevo_folio,
            cxc_clie_id, --customer_id,
            moneda_id,--currency_id,
            observaciones, --comments,
            tipo_cambio,--currency_val,
            cxc_agen_id,--salesman_id,
            cxp_prov_credias_id,--sup_credays_id,
            orden_compra,--purch_order,
            proceso_id,--ultimo_id_proceso,
            fecha_compromiso,--date_limit::date,
            lugar_entrega,--delivery_place,
            transporte,--trans,
            tasa_retencion_immex,--tasaretimmex,
            fac_metodos_pago_id,--met_pago_id,
            no_cuenta,--account,
            enviar_ruta,--send_route,
            inv_alm_id,--warehouse_id::smallint
            cxc_clie_df_id,--cust_df_id,
            enviar_obser_fac,--send_comments,
            flete,--flete_enable,
            subtotal,--0,
            impuesto,--0,
            monto_retencion,--0,
            total,--0,
            borrado_logico,--false,
            cancelado,--false,
            momento_creacion,--espacio_tiempo_ejecucion,
            gral_usr_id_creacion,--usuario_id
            motivo_descto, --razon_desc
            porcentaje_descto, --perc_desc
            folio_cot--no_cot 
			)VALUES(nuevo_folio, customer_id, currency_id, comments, currency_val, salesman_id, sup_credays_id, purch_order, ultimo_id_proceso, date_limit::date, delivery_place, trans, tasaretimmex, met_pago_id, account, send_route, warehouse_id::smallint, cust_df_id, send_comments, flete_enable, 0, 0, 0, 0, false, false, espacio_tiempo_ejecucion, usuario_id, razon_desc, perc_desc, no_cot) 
			RETURNING id INTO ultimo_id;
			
			
			no_rows:= array_length(matrix,1);--obtiene total de elementos del arreglo
			counter:=1;
			FOR counter IN 1 .. no_rows LOOP
				generar_requisicion:=false;
				retencion_partida:=0;
				
				SELECT INTO row_cells string_to_array(matrix[counter],'___');
				

				--1: no esta eliminado, 0:eliminado
                                IF row_cells[ C_DELFLAG ]::integer <> 0 THEN
					
					cantPresAsignado:=0;
					equivalenciaPres:=0;
					noDecUnidad:=0;
					--Id de la unidad de medida del producto
					idUnidadMedida:=0;
					--Nombre de la unidad de medida del producto
					nombreUnidadMedida:='';
					--Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
					cantUnidadVenta:=0;
					
					--Obtener datos del Producto
					SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
					FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=row_cells[ C_PRODID ]::integer 
					INTO tipo_prod, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
					
					IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
					
					--Tomamos la cantidad en la unidad de Venta seleccionada por el usuario
					cantUnidadVenta:=row_cells[ C_QUANTITY ]::double precision;
					
					IF facpar.cambiar_unidad_medida THEN
						IF idUnidadMedida::integer<>row_cells[ C_PROUNIID ]::integer THEN
							IF densidadProd IS NULL OR densidadProd=0 THEN
								densidadProd:=1;
							END IF;
							
							EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
							IF match_cadena=true THEN
								--Convertir a kilos
								row_cells[ C_QUANTITY ] := row_cells[ C_QUANTITY ]::double precision * densidadProd;
							ELSE
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
								IF match_cadena=true THEN 
									--Convertir a Litros
									row_cells[ C_QUANTITY ] := row_cells[ C_QUANTITY ]::double precision / densidadProd;
								END IF;
							END IF;
							--RAISE EXCEPTION '%',match_cadena;
						END IF;
					END IF;
					
					--Redondear la cantidad de la Partida
					row_cells[ C_QUANTITY ] := round(row_cells[ C_QUANTITY ]::numeric,noDecUnidad)::double precision;
					cantUnidadVenta := round(cantUnidadVenta::numeric,noDecUnidad)::double precision; 
					
					--Si el tipo de producto es diferente de 4, hay que RESERVAR existencias
					--tipo=4 Servicios
					--para el tipo servicios no se debe reservar existencias
					IF tipo_prod<>4 THEN 
					
						IF incluye_modulo_produccion=FALSE THEN 
							--Aqui entra si la Empresa NO INCLUYE Modulo de Produccion
							
							--reservar toda cantidad la cantidad del pedido
							cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
							generar_backorder:=false;
						ELSE
							--RAISE EXCEPTION '%','tipo_prod='||tipo_prod;
							
							--Solo para productos formulados
							IF tipo_prod=1 OR tipo_prod=2 OR tipo_prod=8 THEN
								--llamada a proc que devuelve la existencia del producto. 
								--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
								--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
								SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
								
								--Redondear la existencia del producto
								total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
								
								IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
									IF total_existencia <=0 THEN 
										--reservar cero
										cant_reservar_nuevo=0;
									ELSE
										--tomar la existencia para reservar
										cant_reservar_nuevo:=total_existencia;
									END IF;
									
									generar_backorder:=true;
								ELSE
									--Reservar toda la cantidad del  pedido
									cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
									
									generar_backorder:=false;
								END IF;
							END IF;
						END IF;
						
						
						/*
						"1";"Prod. Terminado";FALSE
						"2";"Prod. Intermedio";FALSE
						"3";"Kit";FALSE
						"4";"Servicios";FALSE
						"5";"Refacciones";FALSE
						"6";"Accesorios";FALSE
						"7";"Materia Prima";FALSE
						"8";"Prod. en Desarrollo";FALSE
						*/
						IF facpar.permitir_req_com THEN 
							--7=Materia Prima - Hay que generar una requisicion de compra.
							IF tipo_prod=7 THEN 
								--llamada a proc que devuelve la existencia del producto. 
								--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
								--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
								SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
								
								--Redondear la existencia del producto
								total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
								
								IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
									IF total_existencia <=0 THEN 
										--reservar cero
										cant_reservar_nuevo=0;
									ELSE
										--tomar la existencia para reservar
										cant_reservar_nuevo:=total_existencia;
									END IF;
									
									generar_requisicion:=true;
								ELSE
									--Reservar toda la cantidad del  pedido
									cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
									
									generar_requisicion:=false;
								END IF;
							END IF;
						ELSE
							if tipo_prod=7 then  
								--Reservar toda cantidad la cantidad del pedido ya que no incluye
								cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
								generar_backorder:=false;
								generar_requisicion:=false;
							end if;
						END IF;
						
						--RAISE EXCEPTION '%','permitir_req_com='|| facpar.permitir_req_com ||'    tipo_prod='||tipo_prod ||'    cant_reservar_nuevo='||cant_reservar_nuevo;
						
						--Redondear la cantidad de a Reservar
						cant_reservar_nuevo := round(cant_reservar_nuevo::numeric,noDecUnidad)::double precision;
						
						--Reservar cantidad para el  pedido
						UPDATE inv_exi SET reservado=(reservado::double precision + cant_reservar_nuevo::double precision) WHERE inv_prod_id=row_cells[ C_PRODID ]::integer AND inv_alm_id=warehouse_id AND ano=ano_actual;
						
						------inicia reservar existencias en presentaciones--------------------------
						--Verificar si hay que validar existencias de Presentaciones
						IF controlExisPres=true THEN 
							--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
							--TRUE = Validar presentaciones desde el Pedido
							--FALSE = No validar presentaciones desde el Pedido
							IF facpar.validar_pres_pedido=true THEN 
								--buscar la equivalencia de la Presentacion
								SELECT cantidad  FROM inv_prod_presentaciones WHERE id=row_cells[ C_PRESENID ]::integer 
								INTO equivalenciaPres;
								
								IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
								
								--Convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
								cantPresAsignado := cant_reservar_nuevo::double precision / equivalenciaPres::double precision;
								
								--Redondear la cantidad de Presentaciones Asignado en la partida
								cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
								
								--Reservar existencia en inv_exi_pres
								UPDATE inv_exi_pres SET reservado=(reservado::double precision + cantPresAsignado::double precision)
								WHERE inv_alm_id=warehouse_id
								AND inv_prod_id=row_cells[ C_PRODID ]::integer
								AND inv_prod_presentacion_id=row_cells[ C_PRESENID ]::integer;
								
							END IF;
						END IF;
						------termina reservar existencias de Presentaciones------------------------------------
						
					ELSE
						generar_backorder:=false;
						generar_requisicion:=false;
						cant_reservar_nuevo=0;
					END IF;--termina IF tipo 4

					--Tasa ieps
					IF row_cells[ C_IEPSTASA ]::double precision>0 THEN 
						row_cells[ C_IEPSTASA ]:=row_cells[ C_IEPSTASA ]::double precision/100;
					END IF;

					--Tasa retencion
					IF row_cells[ C_RETETASA ]::double precision>0 THEN 
						row_cells[ C_RETETASA ]:=row_cells[ C_RETETASA ]::double precision/100;
					END IF;
					
					--Crea registros para tabla poc_pedidos_detalle
					INSERT INTO poc_pedidos_detalle(poc_pedido_id, inv_prod_id, presentacion_id, gral_imp_id, cantidad, precio_unitario, valor_imp, reservado, backorder, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, requisicion, requiere_aut, autorizado, precio_aut, gral_usr_id_aut, gral_imptos_ret_id, tasa_ret)
					VALUES(ultimo_id,row_cells[ C_PRODID ]::integer,row_cells[ C_PRESENID ]::integer,row_cells[ C_TAXID ]::integer,cantUnidadVenta::double precision,row_cells[ C_COSTO ]::double precision,row_cells[ C_TAXVALUE ]::double precision, cant_reservar_nuevo, generar_backorder, row_cells[ C_PROUNIID ]::integer, row_cells[ C_IEPSID ]::integer, row_cells[ C_IEPSTASA ]::double precision, row_cells[ C_VDESCTO ]::double precision, generar_requisicion, row_cells[ C_REQ_AUTH ]::boolean, row_cells[ C_STATUS_AUTH ]::boolean, row_cells[ C_PRICE_AUTH]::double precision, row_cells[ C_USER_AUTH ]::integer, row_cells[ C_RETEID ]::integer, row_cells[ C_RETETASA ]::double precision) 
					RETURNING id INTO ultimo_id_det;
					
					--Calcula el Importe de la Partida
					importe_partida := round((cantUnidadVenta::double precision * row_cells[ C_COSTO ]::double precision)::numeric,4)::double precision;
					
					--Calcula el IEPS de la partida
					importe_ieps_partida := round((importe_partida::double precision * row_cells[ C_IEPSTASA ]::double precision)::numeric,4)::double precision;
					
					--Calcula el IVA de la Partida
					impuesto_partida := (importe_partida::double precision + importe_ieps_partida::double precision) * row_cells[ C_TAXVALUE ]::double precision;
					
					--row_cells[ C_RETEID ]::integer		retencion_id
					--row_cells[ C_RETETASA ]::double precision	retencion_tasa
					
					--Calcular el importe de la retencion de la partida si existe la tasa de retencion
					if row_cells[ C_RETETASA ]::double precision>0 then 
						retencion_partida := round((importe_partida::double precision * row_cells[ C_RETETASA ]::double precision)::numeric,4)::double precision;
					end if;
					
					
					--Cargar tabla que relaciona el pedido con la cotizacion
					IF row_cells[ C_COTDETID ]::integer>0 THEN 
						INSERT INTO poc_ped_cot(poc_ped_id, poc_cot_id, poc_ped_det_id, poc_cot_det_id)VALUES(ultimo_id, row_cells[ C_COTID ]::integer, ultimo_id_det, row_cells[ C_COTDETID ]::integer);
					END IF;
					
					IF allow_desc THEN
						IF row_cells[ C_VDESCTO ]::double precision>0 THEN
							--$pu_con_descto.val(parseFloat(parseFloat($campoPrecioU.val()) - (parseFloat($campoPrecioU.val()) * (parseFloat($vdescto.val())/100))).toFixed(4));
							importe_del_descto_partida = round((importe_partida * (row_cells[ C_VDESCTO ]::double precision/100))::numeric,4)::double precision;

							importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
							
							--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
							importe_ieps_partida := round((importe_partida_con_descto::double precision * row_cells[ C_IEPSTASA ]::double precision)::numeric,4)::double precision;
							
							--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
							impuesto_partida := (importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * row_cells[ C_TAXVALUE ]::double precision;
							
							--Reclacular el nuevo el importe de la retencion de la partida si existe la tasa de retencion
							if row_cells[ C_RETETASA ]::double precision>0 then 
								retencion_partida := round((importe_partida::double precision * row_cells[ C_RETETASA ]::double precision)::numeric,4)::double precision;
							end if;
						END IF;
					END IF;
					
					suma_descuento = suma_descuento + importe_del_descto_partida::double precision;
					suma_subtotal_con_descuento = suma_subtotal_con_descuento + importe_partida_con_descto::double precision;
					
					monto_subtotal := monto_subtotal + importe_partida::double precision;
					suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
					monto_impuesto := monto_impuesto + impuesto_partida::double precision;
					suma_retencion_de_partidas := suma_retencion_de_partidas + retencion_partida::double precision;
				END IF;
			END LOOP;
			
			--Verificar si hay que retener iva para este cliente
			SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex::double precision/100 end FROM cxc_clie WHERE id=customer_id INTO retener_iva, tasa_retencion;
			
			IF allow_desc AND suma_descuento>0 THEN
				IF retener_iva=true THEN 
					total_retencion := suma_subtotal_con_descuento::double precision * tasa_retencion;
				ELSE
					total_retencion :=0;
				END IF;
				
				if suma_retencion_de_partidas > 0 then 
					total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
				end if;
				
				--Calcula el monto del pedido
				monto_total:= suma_subtotal_con_descuento::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
				
				--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
				UPDATE poc_pedidos SET subtotal=suma_subtotal_con_descuento, monto_descto=suma_descuento, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
				WHERE id=ultimo_id;
			ELSE
				IF retener_iva=true THEN
					total_retencion := monto_subtotal::double precision * tasa_retencion;
				ELSE
					total_retencion :=0;
				END IF;

				if suma_retencion_de_partidas > 0 then 
					total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
				end if;
				
				--Calcula el monto del pedido
				monto_total:= monto_subtotal::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
				
				--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
				UPDATE poc_pedidos SET subtotal=monto_subtotal, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
				WHERE id=ultimo_id;
			END IF;
			
			valor_retorno := '1';
		END IF;--termina accion NEW pedido
		
		
		
		
		IF cmd = 'edit' THEN
			
			--obtener el id del proceso para este pedido
			SELECT proceso_id FROM poc_pedidos WHERE id=pedido_id INTO id_proceso;
			
			--obtener el id del flujo del proceso
			SELECT proceso_flujo_id FROM erp_proceso WHERE id=id_proceso INTO id_proceso_flujo;
			
			IF id_proceso_flujo::integer=4 THEN 
				
				UPDATE poc_pedidos SET cxc_clie_id=customer_id,moneda_id=currency_id,observaciones=comments,tipo_cambio=currency_val,cxc_agen_id=salesman_id,cxp_prov_credias_id=sup_credays_id,orden_compra=purch_order, fecha_compromiso=date_limit::date,lugar_entrega=delivery_place, transporte=trans, tasa_retencion_immex=tasaretimmex, fac_metodos_pago_id=met_pago_id, no_cuenta=account, enviar_ruta=send_route, inv_alm_id=warehouse_id::smallint, cxc_clie_df_id=cust_df_id, enviar_obser_fac=send_comments, flete=flete_enable, momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_id, motivo_descto=razon_desc, porcentaje_descto=perc_desc 
				WHERE id = pedido_id;
				
				no_rows:= array_length(matrix,1);--obtiene total de elementos del arreglo
				counter:=1;
				FOR counter IN 1 .. no_rows LOOP
					generar_requisicion:=false;
					generar_backorder:=false;
					retencion_partida:=0;
					
					SELECT INTO row_cells string_to_array(matrix[counter],'___');
					
					--row_cells[ C_DELFLAG ] eliminado
					IF row_cells[ C_DELFLAG ]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
						cant_reservada_anterior:=0;
						cant_reservar_nuevo:=0;
						cantPresAsignado:=0;
						equivalenciaPres:=0;
						noDecUnidad:=0;
						cantPresReservAnterior:=0;
						idUnidadMedida:=0;
						nombreUnidadMedida:='';
						cantUnidadVenta:=0;
						cantExisUnidadVenta:=0;
					
						--Obtener datos del Producto
						SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
						FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
						WHERE inv_prod.id=row_cells[ C_PRODID ]::integer 
						INTO tipo_prod, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
						
						IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;

						--Tomamos la cantidad en la unidad de Venta seleccionada por el usuario
						cantUnidadVenta:=row_cells[ C_QUANTITY ]::double precision;
					
						IF facpar.cambiar_unidad_medida THEN
							IF idUnidadMedida::integer<>row_cells[ C_PROUNIID ]::integer THEN
								IF densidadProd IS NULL OR densidadProd=0 THEN
									densidadProd:=1;
								END IF;
								
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
								IF match_cadena=true THEN
									--Convertir a kilos
									row_cells[ C_QUANTITY ] := row_cells[ C_QUANTITY ]::double precision * densidadProd;
								ELSE
									EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
									IF match_cadena=true THEN 
										--Convertir a Litros
										row_cells[ C_QUANTITY ] := row_cells[ C_QUANTITY ]::double precision / densidadProd;
									END IF;
								END IF;
							END IF;
						END IF;
						
						--Redondear la cantidad de la Partida
						row_cells[ C_QUANTITY ] := round(row_cells[ C_QUANTITY ]::numeric,noDecUnidad)::double precision;
						cantUnidadVenta := round(cantUnidadVenta::numeric,noDecUnidad)::double precision; 
						
						--Si el tipo de producto es diferente de 4, hay que RESERVAR existencias
						--tipo=4 Servicios
						--para el tipo servicios no se debe reservar existencias
						IF tipo_prod::integer<>4 THEN 

							--Solo Para productos formulados
							IF tipo_prod=5 OR tipo_prod=6 THEN 
								--Reservar toda cantidad de la partida del pedido
								cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
								generar_backorder:=false;
							end if;
									
							
							IF incluye_modulo_produccion=false THEN
								--Aqui entra si la Empresa NO INCLUYE Modulo de Produccion
								
								--Solo Para productos formulados
								IF tipo_prod=1 OR tipo_prod=2 OR tipo_prod=8 THEN
									--si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										--Buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=row_cells[ C_DETID ]::integer INTO id_producto, cant_reservada_anterior;
										
										--redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=warehouse_id AND ano=ano_actual;
									END IF;
									
									--Reservar toda cantidad de la partida del pedido
									cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
									generar_backorder:=false;
									
								END IF;
							ELSE
								--Solo Para productos formulados
								IF tipo_prod=1 OR tipo_prod=2 OR tipo_prod=8 THEN
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
									
									--Si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										--buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=row_cells[ C_DETID ]::integer INTO id_producto, cant_reservada_anterior;

										--redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=warehouse_id AND ano=ano_actual;
										
										--le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
										total_existencia := total_existencia + cant_reservada_anterior;
									END IF;
									
									IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
										IF total_existencia <=0 THEN 
											cant_reservar_nuevo=0;--reservar cero
										ELSE
											cant_reservar_nuevo:=total_existencia;--tomar la existencia para reservar
										END IF;
										
										generar_backorder:=true;
									ELSE
										cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;--reservar toda la cantidad del  pedido
										generar_backorder:=false;
									END IF;
								END IF;
							END IF;



							
							
							IF facpar.permitir_req_com THEN 
								--7=Materia Prima - Hay que generar una requisicion de compra.
								IF tipo_prod=7 THEN 
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
									
									--si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										--Buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=row_cells[ C_DETID ]::integer INTO id_producto, cant_reservada_anterior;

										--Redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--Restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=warehouse_id AND ano=ano_actual;
										
										--Le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
										total_existencia := total_existencia + cant_reservada_anterior;
									END IF;
									
									IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
										IF total_existencia <=0 THEN 
											--Reservar cero
											cant_reservar_nuevo=0;
										ELSE
											--Tomar la existencia para reservar
											cant_reservar_nuevo:=total_existencia;
										END IF;
										
										generar_requisicion:=true;
									ELSE
										--Reservar toda la cantidad del  pedido
										cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
										generar_requisicion:=false;
									END IF;
								END IF;
							ELSE
								if tipo_prod=7 then  
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
									
									--si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										--Buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=row_cells[ C_DETID ]::integer INTO id_producto, cant_reservada_anterior;

										--Redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--Restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=warehouse_id AND ano=ano_actual;
										
										--Le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
										total_existencia := total_existencia + cant_reservada_anterior;
									END IF;
									
									IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
										IF total_existencia <=0 THEN 
											--Reservar cero
											cant_reservar_nuevo=0;
										ELSE
											--Tomar la existencia para reservar
											cant_reservar_nuevo:=total_existencia;
										END IF;
										
										generar_requisicion:=false;
									ELSE
										--Reservar toda la cantidad del  pedido
										cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
										generar_requisicion:=false;
									END IF;
								end if;
							END IF;
							
							--Redondear la nueva cantidad a reservar
							cant_reservar_nuevo := round(cant_reservar_nuevo::numeric,noDecUnidad)::double precision;
							
							--Reservar cantidad para el  pedido
							UPDATE inv_exi SET reservado=(reservado::double precision + cant_reservar_nuevo::double precision) WHERE inv_prod_id=row_cells[ C_PRODID ]::integer AND inv_alm_id=warehouse_id AND ano=ano_actual;
							
							------inicia reservar existencias en presentaciones--------------------------
							--verificar si hay que validar existencias de Presentaciones
							IF controlExisPres=true THEN 
								--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
								--TRUE = Validar presentaciones desde el Pedido
								--FALSE = No validar presentaciones desde el Pedido
								IF facpar.validar_pres_pedido=true THEN 
									--buscar la equivalencia de la Presentacion
									SELECT cantidad  FROM inv_prod_presentaciones WHERE id=row_cells[ C_PRESENID ]::integer 
									INTO equivalenciaPres;
									
									IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
									
									--si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										cantPresReservAnterior := cant_reservada_anterior::double precision / equivalenciaPres::double precision;

										--redondear la cantidad de Presentaciones Reservada anteriormente
										cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
										
										--Quitar la Cantidad Reservada anteriormente
										UPDATE inv_exi_pres SET reservado=(reservado::double precision - cantPresReservAnterior::double precision)
										WHERE inv_alm_id=warehouse_id AND inv_prod_id=row_cells[ C_PRODID ]::integer AND inv_prod_presentacion_id=row_cells[ C_PRESENID ]::integer;
									END IF;
									
									
									--convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
									cantPresAsignado := cant_reservar_nuevo::double precision / equivalenciaPres::double precision;
									
									--redondear la cantidad de Presentaciones Asignado en la partida
									cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
									
									--Reservar existencia en inv_exi_pres
									UPDATE inv_exi_pres SET reservado=(reservado::double precision + cantPresAsignado::double precision)
									WHERE inv_alm_id=warehouse_id AND inv_prod_id=row_cells[ C_PRODID ]::integer AND inv_prod_presentacion_id=row_cells[ C_PRESENID ]::integer;
									
								END IF;
							END IF;
							------termina reservar existencias de Presentaciones------------------------------------
						ELSE
							generar_backorder:=false;
							cant_reservar_nuevo=0;
						END IF;--termina if tipo_prod!=4
						
						--Dividir entre 100 la tasa del IEPS
						IF row_cells[ C_IEPSTASA ]::double precision>0 THEN 
							row_cells[ C_IEPSTASA ]:=row_cells[ C_IEPSTASA ]::double precision/100;
						END IF;

						--Tasa retencion
						IF row_cells[ C_RETETASA ]::double precision>0 THEN 
							row_cells[ C_RETETASA ]:=row_cells[ C_RETETASA ]::double precision/100;
						END IF;

						--requiere_aut=row_cells[ C_REQ_AUTH ]::boolean, autorizado=row_cells[ C_STATUS_AUTH ]::boolean, precio_aut=row_cells[ C_PRICE_AUTH]::double precision, gral_usr_id_aut=row_cells[ C_USER_AUTH ]::integer 
						--requiere_aut, autorizado, precio_aut, gral_usr_id_aut
						--row_cells[ C_REQ_AUTH ]::boolean, row_cells[ C_STATUS_AUTH ]::boolean, row_cells[ C_PRICE_AUTH]::double precision, row_cells[ C_USER_AUTH ]::integer 
						
						--row_cells[ C_DETID ]=0 Es registro Nuevo
						--row_cells[ C_DETID ]>0 El registro ya existe, solo hay que actualizar
						IF row_cells[ C_DETID ]::integer = 0 THEN
							--Crea registro nuevo en tabla poc_pedidos_detalle
							INSERT INTO poc_pedidos_detalle(poc_pedido_id,inv_prod_id,presentacion_id,gral_imp_id,cantidad,precio_unitario,valor_imp, reservado, backorder, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, requisicion, requiere_aut, autorizado, precio_aut, gral_usr_id_aut, gral_imptos_ret_id, tasa_ret)
							VALUES(pedido_id,row_cells[ C_PRODID ]::integer,row_cells[ C_PRESENID ]::integer,row_cells[ C_TAXID ]::integer, cantUnidadVenta::double precision,row_cells[ C_COSTO ]::double precision,row_cells[ C_TAXVALUE ]::double precision, cant_reservar_nuevo, generar_backorder, row_cells[ C_PROUNIID ]::integer, row_cells[ C_IEPSID ]::integer, row_cells[ C_IEPSTASA ]::double precision, row_cells[ C_VDESCTO ]::double precision, generar_requisicion, row_cells[ C_REQ_AUTH ]::boolean, row_cells[ C_STATUS_AUTH ]::boolean, row_cells[ C_PRICE_AUTH]::double precision, row_cells[ C_USER_AUTH ]::integer, row_cells[ C_RETEID ]::integer, row_cells[ C_RETETASA ]::double precision); 
						ELSE
							--Actualiza registro
							UPDATE poc_pedidos_detalle SET poc_pedido_id=pedido_id, inv_prod_id=row_cells[ C_PRODID ]::integer, presentacion_id=row_cells[ C_PRESENID ]::integer, gral_imp_id=row_cells[ C_TAXID ]::integer, cantidad=cantUnidadVenta::double precision, precio_unitario=row_cells[ C_COSTO ]::double precision, valor_imp=row_cells[ C_TAXVALUE ]::double precision, reservado=cant_reservar_nuevo, backorder=generar_backorder,inv_prod_unidad_id=row_cells[ C_PROUNIID ]::integer, valor_ieps=row_cells[ C_IEPSTASA ]::double precision, descto=row_cells[ C_VDESCTO ]::double precision, requisicion=generar_requisicion, requiere_aut=row_cells[ C_REQ_AUTH ]::boolean, autorizado=row_cells[ C_STATUS_AUTH ]::boolean, precio_aut=row_cells[ C_PRICE_AUTH]::double precision, gral_usr_id_aut=row_cells[ C_USER_AUTH ]::integer, gral_imptos_ret_id=row_cells[ C_RETEID ]::integer, tasa_ret=row_cells[ C_RETETASA ]::double precision  
							WHERE id=row_cells[ C_DETID ]::integer AND poc_pedido_id=pedido_id;
						END IF;
						
						--Calcular el Importe de la partida y redondealo a 4 digitos
						importe_partida := round((cantUnidadVenta::double precision * row_cells[ C_COSTO ]::double precision)::numeric,4)::double precision;
						
						--Calcula el IEPS de la partida y redondear a 4 digitos
						importe_ieps_partida := round((importe_partida::double precision * row_cells[ C_IEPSTASA ]::double precision)::numeric,4)::double precision;
						
						--Calcula el IVA de la Partida
						impuesto_partida := (importe_partida::double precision + importe_ieps_partida::double precision) * row_cells[ C_TAXVALUE ]::double precision;

						--Calcular el importe de la retencion de la partida si existe la tasa de retencion
						if row_cells[ C_RETETASA ]::double precision>0 then 
							retencion_partida := round((importe_partida::double precision * row_cells[ C_RETETASA ]::double precision)::numeric,4)::double precision;
						end if;
						
						IF allow_desc THEN
							IF row_cells[ C_VDESCTO ]::double precision>0 THEN
								importe_del_descto_partida = round((importe_partida * (row_cells[ C_VDESCTO ]::double precision/100))::numeric,4)::double precision;
								
								importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
								
								--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
								importe_ieps_partida := round((importe_partida_con_descto::double precision * row_cells[ C_IEPSTASA ]::double precision)::numeric,4)::double precision;
								
								--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
								impuesto_partida := (importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * row_cells[ C_TAXVALUE ]::double precision;

								--Reclacular el nuevo el importe de la retencion de la partida si existe la tasa de retencion
								if row_cells[ C_RETETASA ]::double precision>0 then 
									retencion_partida := round((importe_partida_con_descto::double precision * row_cells[ C_RETETASA ]::double precision)::numeric,4)::double precision;
								end if;
							END IF;
						END IF;
						
						suma_descuento = suma_descuento + importe_del_descto_partida::double precision;
						suma_subtotal_con_descuento = suma_subtotal_con_descuento + importe_partida_con_descto::double precision;
						
						monto_subtotal := monto_subtotal + importe_partida::double precision;
						suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
						monto_impuesto := monto_impuesto + impuesto_partida::double precision;
						suma_retencion_de_partidas := suma_retencion_de_partidas + retencion_partida::double precision;
					ELSE
						IF trim(row_cells[ C_DETID ])='' THEN
							--Aqui solo entra cuando se ha eliminado un registro nuevo que nunca fue guardado
							row_cells[ C_DETID ]:='0';
						END IF;
						
						--Extraer datos del registro eliminado
						sql_select:='SELECT * FROM poc_pedidos_detalle WHERE id='||row_cells[ C_DETID ]||'::integer AND poc_pedido_id='||pedido_id;
						
						--Regresar existencias reservadas
						FOR fila IN EXECUTE (sql_select) LOOP
							UPDATE inv_exi SET reservado=(reservado::double precision - fila.reservado::double precision) WHERE inv_prod_id=fila.inv_prod_id AND inv_alm_id=warehouse_id AND ano=ano_actual;
						END LOOP;
						
						--Elimina registro que se elimino en el grid del navegador
						DELETE FROM poc_pedidos_detalle where id=row_cells[ C_DETID ]::integer AND poc_pedido_id=pedido_id;
						
						--Eliminar el registro de la tabla que relaciona la Cotizacion con el Pedido
						DELETE FROM poc_ped_cot where poc_ped_det_id=row_cells[ C_DETID ]::integer AND poc_ped_id=pedido_id;
					END IF;
				END LOOP;
				
				--Verificar si hay que retener iva para este cliente
				SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex/100 end FROM cxc_clie WHERE id=customer_id INTO retener_iva, tasa_retencion;
				
				--RAISE EXCEPTION '%','desct: '||allow_desc||'        suma_descuento:'||suma_descuento;
				IF allow_desc AND suma_descuento>0 THEN
					IF retener_iva=true THEN
						total_retencion := suma_subtotal_con_descuento::double precision * tasa_retencion;
					ELSE 
						total_retencion :=0;
					END IF;
					
					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					---RAISE EXCEPTION '%','suma_subtotal_con_descuento:'||suma_subtotal_con_descuento||'        suma_ieps:'||suma_ieps||'        monto_impuesto:'||monto_impuesto;
					--Calcula el monto del pedido
					monto_total:= suma_subtotal_con_descuento::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
					
					--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
					UPDATE poc_pedidos SET subtotal=suma_subtotal_con_descuento, monto_descto=suma_descuento, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
					WHERE id=pedido_id;
				ELSE 
					IF retener_iva=true THEN
						total_retencion := monto_subtotal * tasa_retencion;
					ELSE
						total_retencion :=0;
					END IF;
					
					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					--Calcula el monto Total del pedido
					monto_total:= monto_subtotal::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
					
					--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
					UPDATE poc_pedidos SET subtotal=monto_subtotal, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
					WHERE id=pedido_id;
				END IF;
				
				valor_retorno := '1';
			ELSE
				IF id_proceso_flujo=2 THEN 
					valor_retorno := 'El pedido no pudo ser Actualizado ya fue autorizado. Se encuentra en proceso de Facturacion.';
				END IF;
				
				IF id_proceso_flujo=3 THEN 
					valor_retorno := 'El pedido no pudo ser Actualizado, ya fue Facturado.';
				END IF;
			END IF;
		END IF;--termina edit pedido
		
		
		
		
		--Aqui entra cuando la persona que cancela es la misma que hizo el pedido
		IF cmd = 'cancelar' THEN
			
			--Obtener el id del proceso para este pedido
			SELECT proceso_id FROM poc_pedidos WHERE id=pedido_id INTO id_proceso;
			
			--obtener el id del flujo del proceso
			SELECT proceso_flujo_id FROM erp_proceso WHERE id=id_proceso INTO id_proceso_flujo;
			
			IF id_proceso_flujo=4 THEN 
				UPDATE poc_pedidos SET cancelado=true, momento_cancelacion=espacio_tiempo_ejecucion,gral_usr_id_cancelacion=usuario_id
				WHERE id=pedido_id
				RETURNING inv_alm_id INTO warehouse_id;
				
				--extraer datos del detalle del pedido
				sql_select:='SELECT * FROM poc_pedidos_detalle WHERE poc_pedido_id='||pedido_id;
				
				--crea devolver existencias reservadas
				FOR fila IN EXECUTE (sql_select) LOOP
					cantPresReservAnterior:=0;
					noDecUnidad:=0;
					equivalenciaPres:=0;
					
					--obtener el tipo de producto y el numero de Decimales Permitidos
					SELECT inv_prod.tipo_de_producto_id AS tipo_producto,(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
					FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=fila.inv_prod_id 
					INTO tipo_prod, noDecUnidad;
					
					IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
					
					--Redondear la cantidad reservada
					fila.reservado := round(fila.reservado::numeric,noDecUnidad)::double precision;
					
					--Quitar reservado de la tabla inv_exi
					UPDATE inv_exi SET reservado=(reservado::double precision - fila.reservado::double precision) WHERE inv_prod_id=fila.inv_prod_id AND inv_alm_id=warehouse_id AND ano=ano_actual;
					
					------Inicia quitar existencias reservadas en inv_exi_pres--------------------------
					--Verificar si la configuracion indica que se esta controlando existencias por presentaciones
					IF controlExisPres=true THEN 
						--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
						--TRUE = Validar presentaciones desde el Pedido
						--FALSE = No validar presentaciones desde el Pedido
						IF facpar.validar_pres_pedido=true THEN 
							--buscar la equivalencia de la Presentacion
							SELECT cantidad  FROM inv_prod_presentaciones WHERE id=fila.presentacion_id::integer 
							INTO equivalenciaPres;
							
							IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
							
							--convertir a Presentaciones la cantidad Reservada
							cantPresReservAnterior := fila.reservado::double precision / equivalenciaPres::double precision;
							
							--redondear la cantidad de Presentaciones Reservada anteriormente
							cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
							
							--Quitar la Cantidad Reservada anteriormente
							UPDATE inv_exi_pres SET reservado=(reservado::double precision - cantPresReservAnterior::double precision)
							WHERE inv_alm_id=warehouse_id AND inv_prod_id=fila.inv_prod_id::integer AND inv_prod_presentacion_id=fila.presentacion_id::integer;
						END IF;
					END IF;
					
				END LOOP;
				
				valor_retorno := '1';
			ELSE
				IF id_proceso_flujo=2 THEN 
					valor_retorno := 'El pedido ya fue Autorizado, se encuentra en Facturacion. No se puede Cancelar.';
				END IF;
				
				IF id_proceso_flujo=3 THEN 
					valor_retorno := 'El pedido ya fue Facturado. No se puede Cancelar.';
				END IF;
			END IF;
		END IF;

    RETURN valor_retorno;

END;
$_$;


--
-- Name: poc_cat_cusorder(character varying, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, integer, double precision, double precision, double precision, boolean, boolean, boolean, boolean, text, text, text, character varying, character varying, character varying, character varying, character varying, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.poc_cat_cusorder(cmd character varying, usuario_id integer, salesman_id integer, customer_id integer, cust_df_id integer, warehouse_id integer, currency_id integer, sup_credays_id integer, _met_pago_id integer, _forma_pago_id integer, _uso_id integer, pedido_id integer, tasaretimmex double precision, currency_val double precision, perc_desc double precision, allow_desc boolean, send_comments boolean, flete_enable boolean, send_route boolean, comments text, razon_desc text, trans text, date_limit character varying, delivery_place character varying, purch_order character varying, account character varying, no_cot character varying, matrix text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE

    -- >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    -- >> Catalog of customer order    >>
    -- >> Version: CDGB                >>
    -- >> Date: 25/Feb/2018            >>
    -- >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    C_DELFLAG  integer := 1;
    C_DETID integer := 2;
    C_PRODID integer := 3;
    C_PRESENID integer := 4;
    C_TAXID integer := 5;
    C_QUANTITY integer := 6;
    C_COSTO integer := 7;
    C_TAXVALUE integer := 8;
    C_PROUNIID integer := 11;
    C_IEPSID integer := 12;
    C_IEPSTASA integer := 13;
    C_VDESCTO integer := 14;
    C_COTID integer := 15;
    C_COTDETID integer := 16;    
    C_STATUS_AUTH integer := 17;
    C_PRICE_AUTH integer := 18;
    C_USER_AUTH integer := 19;
    C_REQ_AUTH integer := 20;
    C_SAVE_REG integer := 21;
    C_RETEID integer := 22;
    C_RETETASA integer := 23;


    --estas  variables se utilizan en la mayoria de los catalogos
    valor_retorno character varying;
    emp_id integer:=0;
    suc_id integer:=0;
    suc_id_consecutivo integer=0; --sucursal de donde se tomara el consecutivo
    id_tipo_consecutivo integer=0;
    ultimo_id integer:=0;
    ultimo_id2 integer:=0;
    ultimo_id_det integer:=0;
    espacio_tiempo_ejecucion timestamp with time zone = now();
    ano_actual integer:=0;
    mes_actual integer:=0;
    sql_select character varying = '';
    sql_update character varying = '';
    sql_insert character varying = '';

    row_cells text[];
    no_rows integer;--total de elementos de arreglo
    counter integer;--contador de filas o posiciones del arreglo
    str_incoterms char[];
    iter_y integer;

    --variable para pedidos
    facpar record;--parametros de Facturacion
    ultimo_id_proceso integer = 0;
    id_proceso integer = 0;
    id_proceso_flujo integer =0;
    prefijo_consecutivo character varying = '';
    nuevo_consecutivo bigint=0;
    nuevo_folio character varying = '';
    incluye_modulo_produccion boolean;
    empresa_transportista boolean;
    tipo_prod integer=0;
    id_producto integer = 0;
    total_existencia double precision = 0;
    cantidad_produccion double precision = 0;
    cant_reservada_anterior double precision = 0;
    cant_reservar_nuevo double precision = 0;
    generar_backorder boolean = false;
    en_proceso_produccion boolean = false;

    importe_del_descto_partida double precision = 0;
    importe_partida_con_descto double precision = 0;
    suma_descuento double precision = 0;
    suma_subtotal_con_descuento double precision = 0;

    importe_partida double precision = 0;
    impuesto_partida double precision = 0;
    monto_subtotal double precision = 0;
    monto_total double precision = 0;
    monto_impuesto double precision = 0;
    total_retencion double precision = 0;
    importe_ieps_partida double precision = 0;
    suma_ieps double precision = 0;
    retener_iva boolean = false;
    tasa_retencion double precision = 0;
    retencion_partida double precision = 0;
    suma_retencion_de_partidas double precision = 0;

    --variables autorizacion de pedidos
    pedido record;
    fila record;
    fila2 record;
    fila_detalle record;

    exis integer = 0;
    exis_rem_doc integer = 0;
    tipo_movimiento_id integer =0;
    identificador_nuevo_movimiento integer =0;
    remision_detalle record;
    bandera_tipo_4 boolean;
    folio_remision character varying='';
    obser_prefactura text='';

    result character varying='';

    noDecUnidad integer=0;--numero de decimales permitidos para la unidad
    exisActualPres double precision=0;--existencia actual de la presentacion
    equivalenciaPres double precision=0; --equivalencia de la presentacion en la unidad del producto
    cantPres double precision=0; --Cantidad que se esta Intentando traspasar
    cantPresAsignado double precision=0;
    cantPresReservAnterior double precision=0;
    controlExisPres boolean; --Variable que indica  si se debe controlar Existencias por Presentacion
    cambiaUnidadMedida boolean:=false;

    --Id de la unidad de medida del producto
    idUnidadMedida integer:=0;
    --Nombre de la unidad de medida del producto
    nombreUnidadMedida character varying:=0;
    --Densidad del producto
    densidadProd double precision:=0;
    --Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
    cantUnidadVenta double precision:=0;
    --Cantidad de la existencia convertida a la unidad de venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
    cantExisUnidadVenta double precision:=0;
    match_cadena boolean:=false;

    --Variable para controlar la creacion de un registro en la tabla header de requisiciones cuando la configuracion lo permita
    header_requisicion_generada boolean:=false;
    --Variable que indica si una partida gener√≥ requisicion
    generar_requisicion  boolean:=false;

BEGIN
    controlExisPres:=false;
	
    SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
    SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;

    SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id
    FROM gral_usr_suc 
    JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
    WHERE gral_usr_suc.gral_usr_id = usuario_id
    INTO emp_id, suc_id;

    valor_retorno:='0';

    --Obtener parametros para la facturacion
    SELECT * FROM fac_par WHERE gral_suc_id=suc_id INTO facpar;

    --query para verificar si la Empresa actual incluye Modulo de Produccion y control de Existencias por Presentacion
    SELECT incluye_produccion, control_exis_pres, transportista  FROM gral_emp WHERE id=emp_id INTO incluye_modulo_produccion, controlExisPres, empresa_transportista;

    --√©ste consecutivo es para el folio del Pedido y folio para BackOrder(poc_ped_bo)
    suc_id_consecutivo := facpar.gral_suc_id_consecutivo;

    IF cmd = 'new' THEN

        --crea registro en tabla erp_proceso y retorna el id del registro creado. El flujo del proceso es 4=Pedido
        INSERT INTO erp_proceso(proceso_flujo_id, empresa_id, sucursal_id)
        VALUES(4, emp_id, suc_id) RETURNING id into ultimo_id_proceso;

        id_tipo_consecutivo := 7; --consecutivo de pedidos
			
        -- aqui entra para tomar el consecutivo del pedido de la sucursal actual
        UPDATE gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
        WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;

        -- concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del pedido
        nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;

        -- crear registro en la tabla poc_pedidos y retorna el id del registro creado
        INSERT INTO  poc_pedidos(
            folio, --nuevo_folio,
            cxc_clie_id, --customer_id,
            moneda_id,--currency_id,
            observaciones, --comments,
            tipo_cambio,--currency_val,
            cxc_agen_id,--salesman_id,
            cxp_prov_credias_id,--sup_credays_id,
            orden_compra,--purch_order,
            proceso_id,--ultimo_id_proceso,
            fecha_compromiso,--date_limit::date,
            lugar_entrega,--delivery_place,
            transporte,--trans,
            tasa_retencion_immex,--tasaretimmex,
            fac_metodos_pago_id,--_forma_pago_id,
            no_cuenta,--account,
            enviar_ruta,--send_route,
            inv_alm_id,--warehouse_id::smallint
            cxc_clie_df_id,--cust_df_id,
            enviar_obser_fac,--send_comments,
            flete,--flete_enable,
            subtotal,--0,
            impuesto,--0,
            monto_retencion,--0,
            total,--0,
            borrado_logico,--false,
            cancelado,--false,
            momento_creacion,--espacio_tiempo_ejecucion,
            gral_usr_id_creacion,--usuario_id
            motivo_descto, --razon_desc
            porcentaje_descto, --perc_desc
            folio_cot,--no_cot
	    cfdi_usos_id, --_uso_id
            cfdi_metodo_id --_met_pago_id			
			)VALUES(
			nuevo_folio, 
			customer_id, 
			currency_id, 
			comments, 
			currency_val, 
			salesman_id, 
			sup_credays_id, 
			purch_order, 
			ultimo_id_proceso, 
			date_limit::date, 
			delivery_place, 
			trans, 
			tasaretimmex, 
			_forma_pago_id, 
			account, 
			send_route, 
			warehouse_id::smallint, 
			cust_df_id, 
			send_comments, 
			flete_enable, 
			0, 
			0, 
			0, 
			0, 
			false, 
			false, 
			espacio_tiempo_ejecucion, 
			usuario_id, 
			razon_desc, 
			perc_desc, 
			no_cot,
			_uso_id,
            _met_pago_id
		) RETURNING id INTO ultimo_id;
			
			
			no_rows:= array_length(matrix,1);--obtiene total de elementos del arreglo
			counter:=1;
			FOR counter IN 1 .. no_rows LOOP
				generar_requisicion:=false;
				retencion_partida:=0;
				
				SELECT INTO row_cells string_to_array(matrix[counter],'___');
				

				--1: no esta eliminado, 0:eliminado
                                IF row_cells[ C_DELFLAG ]::integer <> 0 THEN
					
					cantPresAsignado:=0;
					equivalenciaPres:=0;
					noDecUnidad:=0;
					--Id de la unidad de medida del producto
					idUnidadMedida:=0;
					--Nombre de la unidad de medida del producto
					nombreUnidadMedida:='';
					--Cantidad en la unidad de Venta, esto se utiliza cuando la unidad del producto es diferente a la de venta
					cantUnidadVenta:=0;
					
					--Obtener datos del Producto
					SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
					FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=row_cells[ C_PRODID ]::integer 
					INTO tipo_prod, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
					
					IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
					
					--Tomamos la cantidad en la unidad de Venta seleccionada por el usuario
					cantUnidadVenta:=row_cells[ C_QUANTITY ]::double precision;
					
					IF facpar.cambiar_unidad_medida THEN
						IF idUnidadMedida::integer<>row_cells[ C_PROUNIID ]::integer THEN
							IF densidadProd IS NULL OR densidadProd=0 THEN
								densidadProd:=1;
							END IF;
							
							EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
							IF match_cadena=true THEN
								--Convertir a kilos
								row_cells[ C_QUANTITY ] := row_cells[ C_QUANTITY ]::double precision * densidadProd;
							ELSE
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
								IF match_cadena=true THEN 
									--Convertir a Litros
									row_cells[ C_QUANTITY ] := row_cells[ C_QUANTITY ]::double precision / densidadProd;
								END IF;
							END IF;
							--RAISE EXCEPTION '%',match_cadena;
						END IF;
					END IF;
					
					--Redondear la cantidad de la Partida
					row_cells[ C_QUANTITY ] := round(row_cells[ C_QUANTITY ]::numeric,noDecUnidad)::double precision;
					cantUnidadVenta := round(cantUnidadVenta::numeric,noDecUnidad)::double precision; 
					
					--Si el tipo de producto es diferente de 4, hay que RESERVAR existencias
					--tipo=4 Servicios
					--para el tipo servicios no se debe reservar existencias
					IF tipo_prod<>4 THEN 
					
						IF incluye_modulo_produccion=FALSE THEN 
							--Aqui entra si la Empresa NO INCLUYE Modulo de Produccion
							
							--reservar toda cantidad la cantidad del pedido
							cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
							generar_backorder:=false;
						ELSE
							--RAISE EXCEPTION '%','tipo_prod='||tipo_prod;
							
							--Solo para productos formulados
							IF tipo_prod=1 OR tipo_prod=2 OR tipo_prod=8 THEN
								--llamada a proc que devuelve la existencia del producto. 
								--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
								--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
								SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
								
								--Redondear la existencia del producto
								total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
								
								IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
									IF total_existencia <=0 THEN 
										--reservar cero
										cant_reservar_nuevo=0;
									ELSE
										--tomar la existencia para reservar
										cant_reservar_nuevo:=total_existencia;
									END IF;
									
									generar_backorder:=true;
								ELSE
									--Reservar toda la cantidad del  pedido
									cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
									
									generar_backorder:=false;
								END IF;
							END IF;
						END IF;
						
						
						/*
						"1";"Prod. Terminado";FALSE
						"2";"Prod. Intermedio";FALSE
						"3";"Kit";FALSE
						"4";"Servicios";FALSE
						"5";"Refacciones";FALSE
						"6";"Accesorios";FALSE
						"7";"Materia Prima";FALSE
						"8";"Prod. en Desarrollo";FALSE
						*/
						IF facpar.permitir_req_com THEN 
							--7=Materia Prima - Hay que generar una requisicion de compra.
							IF tipo_prod=7 THEN 
								--llamada a proc que devuelve la existencia del producto. 
								--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
								--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
								SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
								
								--Redondear la existencia del producto
								total_existencia := round(total_existencia::numeric,noDecUnidad)::double precision;
								
								IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
									IF total_existencia <=0 THEN 
										--reservar cero
										cant_reservar_nuevo=0;
									ELSE
										--tomar la existencia para reservar
										cant_reservar_nuevo:=total_existencia;
									END IF;
									
									generar_requisicion:=true;
								ELSE
									--Reservar toda la cantidad del  pedido
									cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
									
									generar_requisicion:=false;
								END IF;
							END IF;
						ELSE
							if tipo_prod=7 then  
								--Reservar toda cantidad la cantidad del pedido ya que no incluye
								cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
								generar_backorder:=false;
								generar_requisicion:=false;
							end if;
						END IF;
						
						--RAISE EXCEPTION '%','permitir_req_com='|| facpar.permitir_req_com ||'    tipo_prod='||tipo_prod ||'    cant_reservar_nuevo='||cant_reservar_nuevo;
						
						--Redondear la cantidad de a Reservar
						cant_reservar_nuevo := round(cant_reservar_nuevo::numeric,noDecUnidad)::double precision;
						
						--Reservar cantidad para el  pedido
						UPDATE inv_exi SET reservado=(reservado::double precision + cant_reservar_nuevo::double precision) WHERE inv_prod_id=row_cells[ C_PRODID ]::integer AND inv_alm_id=warehouse_id AND ano=ano_actual;
						
						------inicia reservar existencias en presentaciones--------------------------
						--Verificar si hay que validar existencias de Presentaciones
						IF controlExisPres=true THEN 
							--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
							--TRUE = Validar presentaciones desde el Pedido
							--FALSE = No validar presentaciones desde el Pedido
							IF facpar.validar_pres_pedido=true THEN 
								--buscar la equivalencia de la Presentacion
								SELECT cantidad  FROM inv_prod_presentaciones WHERE id=row_cells[ C_PRESENID ]::integer 
								INTO equivalenciaPres;
								
								IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
								
								--Convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
								cantPresAsignado := cant_reservar_nuevo::double precision / equivalenciaPres::double precision;
								
								--Redondear la cantidad de Presentaciones Asignado en la partida
								cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
								
								--Reservar existencia en inv_exi_pres
								UPDATE inv_exi_pres SET reservado=(reservado::double precision + cantPresAsignado::double precision)
								WHERE inv_alm_id=warehouse_id
								AND inv_prod_id=row_cells[ C_PRODID ]::integer
								AND inv_prod_presentacion_id=row_cells[ C_PRESENID ]::integer;
								
							END IF;
						END IF;
						------termina reservar existencias de Presentaciones------------------------------------
						
					ELSE
						generar_backorder:=false;
						generar_requisicion:=false;
						cant_reservar_nuevo=0;
					END IF;--termina IF tipo 4

					--Tasa ieps
					IF row_cells[ C_IEPSTASA ]::double precision>0 THEN 
						row_cells[ C_IEPSTASA ]:=row_cells[ C_IEPSTASA ]::double precision/100;
					END IF;

					--Tasa retencion
					IF row_cells[ C_RETETASA ]::double precision>0 THEN 
						row_cells[ C_RETETASA ]:=row_cells[ C_RETETASA ]::double precision/100;
					END IF;
					
					--Crea registros para tabla poc_pedidos_detalle
					INSERT INTO poc_pedidos_detalle(poc_pedido_id, inv_prod_id, presentacion_id, gral_imp_id, cantidad, precio_unitario, valor_imp, reservado, backorder, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, requisicion, requiere_aut, autorizado, precio_aut, gral_usr_id_aut, gral_imptos_ret_id, tasa_ret)
					VALUES(ultimo_id,row_cells[ C_PRODID ]::integer,row_cells[ C_PRESENID ]::integer,row_cells[ C_TAXID ]::integer,cantUnidadVenta::double precision,row_cells[ C_COSTO ]::double precision,row_cells[ C_TAXVALUE ]::double precision, cant_reservar_nuevo, generar_backorder, row_cells[ C_PROUNIID ]::integer, row_cells[ C_IEPSID ]::integer, row_cells[ C_IEPSTASA ]::double precision, row_cells[ C_VDESCTO ]::double precision, generar_requisicion, row_cells[ C_REQ_AUTH ]::boolean, row_cells[ C_STATUS_AUTH ]::boolean, row_cells[ C_PRICE_AUTH]::double precision, row_cells[ C_USER_AUTH ]::integer, row_cells[ C_RETEID ]::integer, row_cells[ C_RETETASA ]::double precision) 
					RETURNING id INTO ultimo_id_det;
					
					--Calcula el Importe de la Partida
					importe_partida := round((cantUnidadVenta::double precision * row_cells[ C_COSTO ]::double precision)::numeric,4)::double precision;
					
					--Calcula el IEPS de la partida
					importe_ieps_partida := round((importe_partida::double precision * row_cells[ C_IEPSTASA ]::double precision)::numeric,4)::double precision;
					
					--Calcula el IVA de la Partida
					impuesto_partida := (importe_partida::double precision + importe_ieps_partida::double precision) * row_cells[ C_TAXVALUE ]::double precision;
					
					--row_cells[ C_RETEID ]::integer		retencion_id
					--row_cells[ C_RETETASA ]::double precision	retencion_tasa
					
					--Calcular el importe de la retencion de la partida si existe la tasa de retencion
					if row_cells[ C_RETETASA ]::double precision>0 then 
						retencion_partida := round((importe_partida::double precision * row_cells[ C_RETETASA ]::double precision)::numeric,4)::double precision;
					end if;
					
					
					--Cargar tabla que relaciona el pedido con la cotizacion
					IF row_cells[ C_COTDETID ]::integer>0 THEN 
						INSERT INTO poc_ped_cot(poc_ped_id, poc_cot_id, poc_ped_det_id, poc_cot_det_id)VALUES(ultimo_id, row_cells[ C_COTID ]::integer, ultimo_id_det, row_cells[ C_COTDETID ]::integer);
					END IF;
					
					IF allow_desc THEN
						IF row_cells[ C_VDESCTO ]::double precision>0 THEN
							--$pu_con_descto.val(parseFloat(parseFloat($campoPrecioU.val()) - (parseFloat($campoPrecioU.val()) * (parseFloat($vdescto.val())/100))).toFixed(4));
							importe_del_descto_partida = round((importe_partida * (row_cells[ C_VDESCTO ]::double precision/100))::numeric,4)::double precision;

							importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
							
							--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
							importe_ieps_partida := round((importe_partida_con_descto::double precision * row_cells[ C_IEPSTASA ]::double precision)::numeric,4)::double precision;
							
							--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
							impuesto_partida := (importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * row_cells[ C_TAXVALUE ]::double precision;
							
							--Reclacular el nuevo el importe de la retencion de la partida si existe la tasa de retencion
							if row_cells[ C_RETETASA ]::double precision>0 then 
								retencion_partida := round((importe_partida::double precision * row_cells[ C_RETETASA ]::double precision)::numeric,4)::double precision;
							end if;
						END IF;
					END IF;
					
					suma_descuento = suma_descuento + importe_del_descto_partida::double precision;
					suma_subtotal_con_descuento = suma_subtotal_con_descuento + importe_partida_con_descto::double precision;
					
					monto_subtotal := monto_subtotal + importe_partida::double precision;
					suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
					monto_impuesto := monto_impuesto + impuesto_partida::double precision;
					suma_retencion_de_partidas := suma_retencion_de_partidas + retencion_partida::double precision;
				END IF;
			END LOOP;
			
			--Verificar si hay que retener iva para este cliente
			SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex::double precision/100 end FROM cxc_clie WHERE id=customer_id INTO retener_iva, tasa_retencion;
			
			IF allow_desc AND suma_descuento>0 THEN
				IF retener_iva=true THEN 
					total_retencion := suma_subtotal_con_descuento::double precision * tasa_retencion;
				ELSE
					total_retencion :=0;
				END IF;
				
				if suma_retencion_de_partidas > 0 then 
					total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
				end if;
				
				--Calcula el monto del pedido
				monto_total:= suma_subtotal_con_descuento::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
				
				--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
				UPDATE poc_pedidos SET subtotal=suma_subtotal_con_descuento, monto_descto=suma_descuento, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
				WHERE id=ultimo_id;
			ELSE
				IF retener_iva=true THEN
					total_retencion := monto_subtotal::double precision * tasa_retencion;
				ELSE
					total_retencion :=0;
				END IF;

				if suma_retencion_de_partidas > 0 then 
					total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
				end if;
				
				--Calcula el monto del pedido
				monto_total:= monto_subtotal::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
				
				--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
				UPDATE poc_pedidos SET subtotal=monto_subtotal, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
				WHERE id=ultimo_id;
			END IF;
			
			valor_retorno := '1';
		END IF;--termina accion NEW pedido
		
		
		
		
		IF cmd = 'edit' THEN
			
			--obtener el id del proceso para este pedido
			SELECT proceso_id FROM poc_pedidos WHERE id=pedido_id INTO id_proceso;
			
			--obtener el id del flujo del proceso
			SELECT proceso_flujo_id FROM erp_proceso WHERE id=id_proceso INTO id_proceso_flujo;
			
			IF id_proceso_flujo::integer=4 THEN 
				
				UPDATE poc_pedidos 
				SET cxc_clie_id = customer_id,
					moneda_id = currency_id,
					observaciones = comments,
					tipo_cambio = currency_val,
					cxc_agen_id = salesman_id,
					cxp_prov_credias_id = sup_credays_id,
					orden_compra = purch_order, 
					fecha_compromiso = date_limit::date,
					lugar_entrega = delivery_place, 
					transporte = trans, 
					tasa_retencion_immex = tasaretimmex, 
					fac_metodos_pago_id = _forma_pago_id, 
					no_cuenta = account, 
					enviar_ruta = send_route, 
					inv_alm_id = warehouse_id::smallint, 
					cxc_clie_df_id = cust_df_id, 
					enviar_obser_fac = send_comments, 
					flete = flete_enable, 
					momento_actualizacion = espacio_tiempo_ejecucion, 
					gral_usr_id_actualizacion = usuario_id, 
					motivo_descto = razon_desc, 
					porcentaje_descto = perc_desc,
					cfdi_usos_id = _uso_id,
					cfdi_metodo_id = _met_pago_id
				WHERE id = pedido_id;
				
				no_rows:= array_length(matrix,1);--obtiene total de elementos del arreglo
				counter:=1;
				FOR counter IN 1 .. no_rows LOOP
					generar_requisicion:=false;
					generar_backorder:=false;
					retencion_partida:=0;
					
					SELECT INTO row_cells string_to_array(matrix[counter],'___');
					
					--row_cells[ C_DELFLAG ] eliminado
					IF row_cells[ C_DELFLAG ]::integer<>0 THEN--1: no esta eliminado, 0:eliminado
						cant_reservada_anterior:=0;
						cant_reservar_nuevo:=0;
						cantPresAsignado:=0;
						equivalenciaPres:=0;
						noDecUnidad:=0;
						cantPresReservAnterior:=0;
						idUnidadMedida:=0;
						nombreUnidadMedida:='';
						cantUnidadVenta:=0;
						cantExisUnidadVenta:=0;
					
						--Obtener datos del Producto
						SELECT inv_prod.tipo_de_producto_id AS tipo_producto, inv_prod.unidad_id, inv_prod_unidades.titulo, inv_prod.densidad, (CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
						FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
						WHERE inv_prod.id=row_cells[ C_PRODID ]::integer 
						INTO tipo_prod, idUnidadMedida, nombreUnidadMedida, densidadProd, noDecUnidad;
						
						IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;

						--Tomamos la cantidad en la unidad de Venta seleccionada por el usuario
						cantUnidadVenta:=row_cells[ C_QUANTITY ]::double precision;
					
						IF facpar.cambiar_unidad_medida THEN
							IF idUnidadMedida::integer<>row_cells[ C_PROUNIID ]::integer THEN
								IF densidadProd IS NULL OR densidadProd=0 THEN
									densidadProd:=1;
								END IF;
								
								EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''KILO*'';' INTO match_cadena;
								IF match_cadena=true THEN
									--Convertir a kilos
									row_cells[ C_QUANTITY ] := row_cells[ C_QUANTITY ]::double precision * densidadProd;
								ELSE
									EXECUTE 'select '''||nombreUnidadMedida||''' ~* ''LITRO*'';' INTO match_cadena;
									IF match_cadena=true THEN 
										--Convertir a Litros
										row_cells[ C_QUANTITY ] := row_cells[ C_QUANTITY ]::double precision / densidadProd;
									END IF;
								END IF;
							END IF;
						END IF;
						
						--Redondear la cantidad de la Partida
						row_cells[ C_QUANTITY ] := round(row_cells[ C_QUANTITY ]::numeric,noDecUnidad)::double precision;
						cantUnidadVenta := round(cantUnidadVenta::numeric,noDecUnidad)::double precision; 
						
						--Si el tipo de producto es diferente de 4, hay que RESERVAR existencias
						--tipo=4 Servicios
						--para el tipo servicios no se debe reservar existencias
						IF tipo_prod::integer<>4 THEN 

							--Solo Para productos formulados
							IF tipo_prod=5 OR tipo_prod=6 THEN 
								--Reservar toda cantidad de la partida del pedido
								cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
								generar_backorder:=false;
							end if;
									
							
							IF incluye_modulo_produccion=false THEN
								--Aqui entra si la Empresa NO INCLUYE Modulo de Produccion
								
								--Solo Para productos formulados
								IF tipo_prod=1 OR tipo_prod=2 OR tipo_prod=8 THEN
									--si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										--Buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=row_cells[ C_DETID ]::integer INTO id_producto, cant_reservada_anterior;
										
										--redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=warehouse_id AND ano=ano_actual;
									END IF;
									
									--Reservar toda cantidad de la partida del pedido
									cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
									generar_backorder:=false;
									
								END IF;
							ELSE
								--Solo Para productos formulados
								IF tipo_prod=1 OR tipo_prod=2 OR tipo_prod=8 THEN
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
									
									--Si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										--buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=row_cells[ C_DETID ]::integer INTO id_producto, cant_reservada_anterior;

										--redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=warehouse_id AND ano=ano_actual;
										
										--le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
										total_existencia := total_existencia + cant_reservada_anterior;
									END IF;
									
									IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
										IF total_existencia <=0 THEN 
											cant_reservar_nuevo=0;--reservar cero
										ELSE
											cant_reservar_nuevo:=total_existencia;--tomar la existencia para reservar
										END IF;
										
										generar_backorder:=true;
									ELSE
										cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;--reservar toda la cantidad del  pedido
										generar_backorder:=false;
									END IF;
								END IF;
							END IF;



							
							
							IF facpar.permitir_req_com THEN 
								--7=Materia Prima - Hay que generar una requisicion de compra.
								IF tipo_prod=7 THEN 
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
									
									--si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										--Buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=row_cells[ C_DETID ]::integer INTO id_producto, cant_reservada_anterior;

										--Redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--Restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=warehouse_id AND ano=ano_actual;
										
										--Le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
										total_existencia := total_existencia + cant_reservada_anterior;
									END IF;
									
									IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
										IF total_existencia <=0 THEN 
											--Reservar cero
											cant_reservar_nuevo=0;
										ELSE
											--Tomar la existencia para reservar
											cant_reservar_nuevo:=total_existencia;
										END IF;
										
										generar_requisicion:=true;
									ELSE
										--Reservar toda la cantidad del  pedido
										cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
										generar_requisicion:=false;
									END IF;
								END IF;
							ELSE
								if tipo_prod=7 then  
									--llamada a proc que devuelve la existencia del producto. 
									--El tipo de busqueda de existencia es 1=Busqueda en el almacen de la Sucursal
									--el valor false que se le esta pasando es para indicarle que en las existencias no incluya reservados, y que solo me devualva existencias disponibles
									SELECT inv_calculo_existencia_producto AS existencia FROM inv_calculo_existencia_producto(1,false, row_cells[ C_PRODID ]::integer, usuario_id, warehouse_id) INTO total_existencia; 
									
									--si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										--Buscamos la cantidad reservada anterior
										SELECT inv_prod_id, reservado FROM poc_pedidos_detalle WHERE id=row_cells[ C_DETID ]::integer INTO id_producto, cant_reservada_anterior;

										--Redondear la cantidad de Presentaciones reservada anteriormente
										cant_reservada_anterior := round(cant_reservada_anterior::numeric,noDecUnidad)::double precision;
										
										--Restar la cantidad reservada anterior
										UPDATE inv_exi SET reservado=(reservado::double precision - cant_reservada_anterior::double precision) WHERE inv_prod_id=id_producto AND inv_alm_id=warehouse_id AND ano=ano_actual;
										
										--Le sumamos a la existencia la cantidad reservada anterior para tener la existencia real
										total_existencia := total_existencia + cant_reservada_anterior;
									END IF;
									
									IF total_existencia < row_cells[ C_QUANTITY ]::double precision THEN
										IF total_existencia <=0 THEN 
											--Reservar cero
											cant_reservar_nuevo=0;
										ELSE
											--Tomar la existencia para reservar
											cant_reservar_nuevo:=total_existencia;
										END IF;
										
										generar_requisicion:=false;
									ELSE
										--Reservar toda la cantidad del  pedido
										cant_reservar_nuevo := row_cells[ C_QUANTITY ]::double precision;
										generar_requisicion:=false;
									END IF;
								end if;
							END IF;
							
							--Redondear la nueva cantidad a reservar
							cant_reservar_nuevo := round(cant_reservar_nuevo::numeric,noDecUnidad)::double precision;
							
							--Reservar cantidad para el  pedido
							UPDATE inv_exi SET reservado=(reservado::double precision + cant_reservar_nuevo::double precision) WHERE inv_prod_id=row_cells[ C_PRODID ]::integer AND inv_alm_id=warehouse_id AND ano=ano_actual;
							
							------inicia reservar existencias en presentaciones--------------------------
							--verificar si hay que validar existencias de Presentaciones
							IF controlExisPres=true THEN 
								--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
								--TRUE = Validar presentaciones desde el Pedido
								--FALSE = No validar presentaciones desde el Pedido
								IF facpar.validar_pres_pedido=true THEN 
									--buscar la equivalencia de la Presentacion
									SELECT cantidad  FROM inv_prod_presentaciones WHERE id=row_cells[ C_PRESENID ]::integer 
									INTO equivalenciaPres;
									
									IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
									
									--si es diferente de cero estamos en editar
									IF row_cells[ C_DETID ]::integer > 0 THEN 
										cantPresReservAnterior := cant_reservada_anterior::double precision / equivalenciaPres::double precision;

										--redondear la cantidad de Presentaciones Reservada anteriormente
										cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
										
										--Quitar la Cantidad Reservada anteriormente
										UPDATE inv_exi_pres SET reservado=(reservado::double precision - cantPresReservAnterior::double precision)
										WHERE inv_alm_id=warehouse_id AND inv_prod_id=row_cells[ C_PRODID ]::integer AND inv_prod_presentacion_id=row_cells[ C_PRESENID ]::integer;
									END IF;
									
									
									--convertir a su equivalencia en Presentacion, la cantidad de la partida actual del pedido
									cantPresAsignado := cant_reservar_nuevo::double precision / equivalenciaPres::double precision;
									
									--redondear la cantidad de Presentaciones Asignado en la partida
									cantPresAsignado := round(cantPresAsignado::numeric,noDecUnidad)::double precision; 
									
									--Reservar existencia en inv_exi_pres
									UPDATE inv_exi_pres SET reservado=(reservado::double precision + cantPresAsignado::double precision)
									WHERE inv_alm_id=warehouse_id AND inv_prod_id=row_cells[ C_PRODID ]::integer AND inv_prod_presentacion_id=row_cells[ C_PRESENID ]::integer;
									
								END IF;
							END IF;
							------termina reservar existencias de Presentaciones------------------------------------
						ELSE
							generar_backorder:=false;
							cant_reservar_nuevo=0;
						END IF;--termina if tipo_prod!=4
						
						--Dividir entre 100 la tasa del IEPS
						IF row_cells[ C_IEPSTASA ]::double precision>0 THEN 
							row_cells[ C_IEPSTASA ]:=row_cells[ C_IEPSTASA ]::double precision/100;
						END IF;

						--Tasa retencion
						IF row_cells[ C_RETETASA ]::double precision>0 THEN 
							row_cells[ C_RETETASA ]:=row_cells[ C_RETETASA ]::double precision/100;
						END IF;

						--requiere_aut=row_cells[ C_REQ_AUTH ]::boolean, autorizado=row_cells[ C_STATUS_AUTH ]::boolean, precio_aut=row_cells[ C_PRICE_AUTH]::double precision, gral_usr_id_aut=row_cells[ C_USER_AUTH ]::integer 
						--requiere_aut, autorizado, precio_aut, gral_usr_id_aut
						--row_cells[ C_REQ_AUTH ]::boolean, row_cells[ C_STATUS_AUTH ]::boolean, row_cells[ C_PRICE_AUTH]::double precision, row_cells[ C_USER_AUTH ]::integer 
						
						--row_cells[ C_DETID ]=0 Es registro Nuevo
						--row_cells[ C_DETID ]>0 El registro ya existe, solo hay que actualizar
						IF row_cells[ C_DETID ]::integer = 0 THEN
							--Crea registro nuevo en tabla poc_pedidos_detalle
							INSERT INTO poc_pedidos_detalle(poc_pedido_id,inv_prod_id,presentacion_id,gral_imp_id,cantidad,precio_unitario,valor_imp, reservado, backorder, inv_prod_unidad_id, gral_ieps_id, valor_ieps, descto, requisicion, requiere_aut, autorizado, precio_aut, gral_usr_id_aut, gral_imptos_ret_id, tasa_ret)
							VALUES(pedido_id,row_cells[ C_PRODID ]::integer,row_cells[ C_PRESENID ]::integer,row_cells[ C_TAXID ]::integer, cantUnidadVenta::double precision,row_cells[ C_COSTO ]::double precision,row_cells[ C_TAXVALUE ]::double precision, cant_reservar_nuevo, generar_backorder, row_cells[ C_PROUNIID ]::integer, row_cells[ C_IEPSID ]::integer, row_cells[ C_IEPSTASA ]::double precision, row_cells[ C_VDESCTO ]::double precision, generar_requisicion, row_cells[ C_REQ_AUTH ]::boolean, row_cells[ C_STATUS_AUTH ]::boolean, row_cells[ C_PRICE_AUTH]::double precision, row_cells[ C_USER_AUTH ]::integer, row_cells[ C_RETEID ]::integer, row_cells[ C_RETETASA ]::double precision); 
						ELSE
							--Actualiza registro
							UPDATE poc_pedidos_detalle SET poc_pedido_id=pedido_id, inv_prod_id=row_cells[ C_PRODID ]::integer, presentacion_id=row_cells[ C_PRESENID ]::integer, gral_imp_id=row_cells[ C_TAXID ]::integer, cantidad=cantUnidadVenta::double precision, precio_unitario=row_cells[ C_COSTO ]::double precision, valor_imp=row_cells[ C_TAXVALUE ]::double precision, reservado=cant_reservar_nuevo, backorder=generar_backorder,inv_prod_unidad_id=row_cells[ C_PROUNIID ]::integer, valor_ieps=row_cells[ C_IEPSTASA ]::double precision, descto=row_cells[ C_VDESCTO ]::double precision, requisicion=generar_requisicion, requiere_aut=row_cells[ C_REQ_AUTH ]::boolean, autorizado=row_cells[ C_STATUS_AUTH ]::boolean, precio_aut=row_cells[ C_PRICE_AUTH]::double precision, gral_usr_id_aut=row_cells[ C_USER_AUTH ]::integer, gral_imptos_ret_id=row_cells[ C_RETEID ]::integer, tasa_ret=row_cells[ C_RETETASA ]::double precision  
							WHERE id=row_cells[ C_DETID ]::integer AND poc_pedido_id=pedido_id;
						END IF;
						
						--Calcular el Importe de la partida y redondealo a 4 digitos
						importe_partida := round((cantUnidadVenta::double precision * row_cells[ C_COSTO ]::double precision)::numeric,4)::double precision;
						
						--Calcula el IEPS de la partida y redondear a 4 digitos
						importe_ieps_partida := round((importe_partida::double precision * row_cells[ C_IEPSTASA ]::double precision)::numeric,4)::double precision;
						
						--Calcula el IVA de la Partida
						impuesto_partida := (importe_partida::double precision + importe_ieps_partida::double precision) * row_cells[ C_TAXVALUE ]::double precision;

						--Calcular el importe de la retencion de la partida si existe la tasa de retencion
						if row_cells[ C_RETETASA ]::double precision>0 then 
							retencion_partida := round((importe_partida::double precision * row_cells[ C_RETETASA ]::double precision)::numeric,4)::double precision;
						end if;
						
						IF allow_desc THEN
							IF row_cells[ C_VDESCTO ]::double precision>0 THEN
								importe_del_descto_partida = round((importe_partida * (row_cells[ C_VDESCTO ]::double precision/100))::numeric,4)::double precision;
								
								importe_partida_con_descto = round((importe_partida - importe_del_descto_partida)::numeric,4)::double precision;
								
								--Recalcular el IEPS de la partida tomando el importe_partida_con_descto
								importe_ieps_partida := round((importe_partida_con_descto::double precision * row_cells[ C_IEPSTASA ]::double precision)::numeric,4)::double precision;
								
								--Recalcular el IVA de la Partida tomando el importe_partida_con_descto
								impuesto_partida := (importe_partida_con_descto::double precision + importe_ieps_partida::double precision) * row_cells[ C_TAXVALUE ]::double precision;

								--Reclacular el nuevo el importe de la retencion de la partida si existe la tasa de retencion
								if row_cells[ C_RETETASA ]::double precision>0 then 
									retencion_partida := round((importe_partida_con_descto::double precision * row_cells[ C_RETETASA ]::double precision)::numeric,4)::double precision;
								end if;
							END IF;
						END IF;
						
						suma_descuento = suma_descuento + importe_del_descto_partida::double precision;
						suma_subtotal_con_descuento = suma_subtotal_con_descuento + importe_partida_con_descto::double precision;
						
						monto_subtotal := monto_subtotal + importe_partida::double precision;
						suma_ieps := suma_ieps + importe_ieps_partida::double precision; 
						monto_impuesto := monto_impuesto + impuesto_partida::double precision;
						suma_retencion_de_partidas := suma_retencion_de_partidas + retencion_partida::double precision;
					ELSE
						IF trim(row_cells[ C_DETID ])='' THEN
							--Aqui solo entra cuando se ha eliminado un registro nuevo que nunca fue guardado
							row_cells[ C_DETID ]:='0';
						END IF;
						
						--Extraer datos del registro eliminado
						sql_select:='SELECT * FROM poc_pedidos_detalle WHERE id='||row_cells[ C_DETID ]||'::integer AND poc_pedido_id='||pedido_id;
						
						--Regresar existencias reservadas
						FOR fila IN EXECUTE (sql_select) LOOP
							UPDATE inv_exi SET reservado=(reservado::double precision - fila.reservado::double precision) WHERE inv_prod_id=fila.inv_prod_id AND inv_alm_id=warehouse_id AND ano=ano_actual;
						END LOOP;
						
						--Elimina registro que se elimino en el grid del navegador
						DELETE FROM poc_pedidos_detalle where id=row_cells[ C_DETID ]::integer AND poc_pedido_id=pedido_id;
						
						--Eliminar el registro de la tabla que relaciona la Cotizacion con el Pedido
						DELETE FROM poc_ped_cot where poc_ped_det_id=row_cells[ C_DETID ]::integer AND poc_ped_id=pedido_id;
					END IF;
				END LOOP;
				
				--Verificar si hay que retener iva para este cliente
				SELECT empresa_immex, case when tasa_ret_immex is null then 0 else tasa_ret_immex/100 end FROM cxc_clie WHERE id=customer_id INTO retener_iva, tasa_retencion;
				
				--RAISE EXCEPTION '%','desct: '||allow_desc||'        suma_descuento:'||suma_descuento;
				IF allow_desc AND suma_descuento>0 THEN
					IF retener_iva=true THEN
						total_retencion := suma_subtotal_con_descuento::double precision * tasa_retencion;
					ELSE 
						total_retencion :=0;
					END IF;
					
					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					---RAISE EXCEPTION '%','suma_subtotal_con_descuento:'||suma_subtotal_con_descuento||'        suma_ieps:'||suma_ieps||'        monto_impuesto:'||monto_impuesto;
					--Calcula el monto del pedido
					monto_total:= suma_subtotal_con_descuento::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
					
					--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
					UPDATE poc_pedidos SET subtotal=suma_subtotal_con_descuento, monto_descto=suma_descuento, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
					WHERE id=pedido_id;
				ELSE 
					IF retener_iva=true THEN
						total_retencion := monto_subtotal * tasa_retencion;
					ELSE
						total_retencion :=0;
					END IF;
					
					if suma_retencion_de_partidas > 0 then 
						total_retencion := round((total_retencion + suma_retencion_de_partidas)::numeric,4)::double precision;
					end if;
					
					--Calcula el monto Total del pedido
					monto_total:= monto_subtotal::double precision + suma_ieps::double precision + monto_impuesto::double precision - total_retencion::double precision;
					
					--Actualiza campos subtotal, impuesto, retencion, total de tabla poc_pedidos
					UPDATE poc_pedidos SET subtotal=monto_subtotal, monto_ieps=suma_ieps, impuesto=monto_impuesto, monto_retencion=total_retencion, total=monto_total
					WHERE id=pedido_id;
				END IF;
				
				valor_retorno := '1';
			ELSE
				IF id_proceso_flujo=2 THEN 
					valor_retorno := 'El pedido no pudo ser Actualizado ya fue autorizado. Se encuentra en proceso de Facturacion.';
				END IF;
				
				IF id_proceso_flujo=3 THEN 
					valor_retorno := 'El pedido no pudo ser Actualizado, ya fue Facturado.';
				END IF;
			END IF;
		END IF;--termina edit pedido
		
		
		
		
		--Aqui entra cuando la persona que cancela es la misma que hizo el pedido
		IF cmd = 'cancelar' THEN
			
			--Obtener el id del proceso para este pedido
			SELECT proceso_id FROM poc_pedidos WHERE id=pedido_id INTO id_proceso;
			
			--obtener el id del flujo del proceso
			SELECT proceso_flujo_id FROM erp_proceso WHERE id=id_proceso INTO id_proceso_flujo;
			
			IF id_proceso_flujo=4 THEN 
				UPDATE poc_pedidos SET cancelado=true, momento_cancelacion=espacio_tiempo_ejecucion,gral_usr_id_cancelacion=usuario_id
				WHERE id=pedido_id
				RETURNING inv_alm_id INTO warehouse_id;
				
				--extraer datos del detalle del pedido
				sql_select:='SELECT * FROM poc_pedidos_detalle WHERE poc_pedido_id='||pedido_id;
				
				--crea devolver existencias reservadas
				FOR fila IN EXECUTE (sql_select) LOOP
					cantPresReservAnterior:=0;
					noDecUnidad:=0;
					equivalenciaPres:=0;
					
					--obtener el tipo de producto y el numero de Decimales Permitidos
					SELECT inv_prod.tipo_de_producto_id AS tipo_producto,(CASE WHEN inv_prod_unidades.id IS NULL THEN 0 ELSE inv_prod_unidades.decimales END) AS no_dec
					FROM inv_prod LEFT JOIN inv_prod_unidades ON inv_prod_unidades.id=inv_prod.unidad_id
					WHERE inv_prod.id=fila.inv_prod_id 
					INTO tipo_prod, noDecUnidad;
					
					IF noDecUnidad IS NULL THEN noDecUnidad:=0; END IF;
					
					--Redondear la cantidad reservada
					fila.reservado := round(fila.reservado::numeric,noDecUnidad)::double precision;
					
					--Quitar reservado de la tabla inv_exi
					UPDATE inv_exi SET reservado=(reservado::double precision - fila.reservado::double precision) WHERE inv_prod_id=fila.inv_prod_id AND inv_alm_id=warehouse_id AND ano=ano_actual;
					
					------Inicia quitar existencias reservadas en inv_exi_pres--------------------------
					--Verificar si la configuracion indica que se esta controlando existencias por presentaciones
					IF controlExisPres=true THEN 
						--Verificar si hay que validar las existencias de presentaciones desde el Pedido.
						--TRUE = Validar presentaciones desde el Pedido
						--FALSE = No validar presentaciones desde el Pedido
						IF facpar.validar_pres_pedido=true THEN 
							--buscar la equivalencia de la Presentacion
							SELECT cantidad  FROM inv_prod_presentaciones WHERE id=fila.presentacion_id::integer 
							INTO equivalenciaPres;
							
							IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
							
							--convertir a Presentaciones la cantidad Reservada
							cantPresReservAnterior := fila.reservado::double precision / equivalenciaPres::double precision;
							
							--redondear la cantidad de Presentaciones Reservada anteriormente
							cantPresReservAnterior := round(cantPresReservAnterior::numeric,noDecUnidad)::double precision; 
							
							--Quitar la Cantidad Reservada anteriormente
							UPDATE inv_exi_pres SET reservado=(reservado::double precision - cantPresReservAnterior::double precision)
							WHERE inv_alm_id=warehouse_id AND inv_prod_id=fila.inv_prod_id::integer AND inv_prod_presentacion_id=fila.presentacion_id::integer;
						END IF;
					END IF;
					
				END LOOP;
				
				valor_retorno := '1';
			ELSE
				IF id_proceso_flujo=2 THEN 
					valor_retorno := 'El pedido ya fue Autorizado, se encuentra en Facturacion. No se puede Cancelar.';
				END IF;
				
				IF id_proceso_flujo=3 THEN 
					valor_retorno := 'El pedido ya fue Facturado. No se puede Cancelar.';
				END IF;
			END IF;
		END IF;

    RETURN valor_retorno;

END;
$_$;


--
-- Name: pro_adm_procesos(text, text[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.pro_adm_procesos(campos_data text, extra_data text[]) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$


DECLARE
	app_selected integer;
	command_selected text;
	sql_update text;
	sql_select text;
	sql_insert text;
	usuario_ejecutor integer;
	emp_id integer;
	suc_id integer;
	id_almacen integer;
	id_almacen_partida integer;
	str_data text[];
	str_filas text[];
	str_elemnts1 text[];
	str_elemnts2 text[];
	
	--varianles para guardar cadenas de select
	str_select1 text:='';
	str_select2 text:='';
	str_select3 text:='';
	
	valor_retorno character varying := ''; 
	total_filas integer;--total de elementos de arreglo
	cont_fila integer;--contador de filas o posiciones del arreglo
	total_filas1 integer;--total de elementos de arreglo
	cont_fila1 integer;--contador de filas o posiciones del arreglo
	
	iter_y integer;--contador de filas o posiciones del arreglo (iterador eje y del arreglo iterado)
	ultimo_id integer :=0;
	ultimo_id2 integer :=0;
	reg_count integer :=0;
	espacio_tiempo_ejecucion timestamp with time zone = now();
--	numero_dias_credito integer=0;
--	fecha_de_vencimiento timestamp with time zone;
--	fcaducidad date;
	exis integer := 0;
--	tip_cam double precision=0.0;
--	valor_impuesto double precision = 0.0;
--	importe double precision = 0.0;
--	subtotal_factura double precision = 0.0;
--	impuesto_partida double precision = 0.0;
--	suma_impuesto double precision = 0.0;
--	total_factura double precision = 0.0;
--	tasa_retencion double precision = 0.0;
--	total_retencion double precision = 0.0;
	
	ano_actual integer;
	mes_actual integer;
	mes_actual00 character varying := '0';
	
	tipo_movimiento_id integer:=0;
	ultimo_tes_mov_id integer :=0;
	ultimo_estatus_id integer :=0;
	
	--variables para orden de produccion
	operador_id integer:=0;
	equipo_id integer:=0;
	equipo_adicional_id integer:=0;
	id_unidad integer:=0;
	
	parametro record;
	record1 record;
	record2 record;
	record3 record;
	record4 record;
	
	--- variables para los consecutivos--
	id_tipo_consecutivo integer:= 0;
	prefijo_consecutivo character varying :='';
	nuevo_consecutivo bigint:=0;
	nuevo_folio character varying:= '';
	nuevo_folio_osal character varying:= '';
	anterior_folio character varying :='0';
	
	id_proceso integer:= 0;
	id_procedo_flijo integer :=0;
	id_osal integer:=0;
	id_invmov integer:=0;
	ultimo_id_inv_oent integer:=0;
	crear_inv_osal integer:=0;--esta variable se utiliza para verificar si hay agregados y si se debe de crear una nueva orden de salida (0-> no, 1-> si)
	id_tras1 integer:=0;
	id_tras2 integer:=0;
	
	costo_ultimo_actual double precision:= 0;
	costo_promedio_actual double precision:= 0;
	cantidad_calculada double precision:= 0;
	sum_costos double precision:= 0.0;
	existencia_prod double precision:= 0.0;
	costo_prod double precision :=0.0;
	titulo_unidad character varying:= '';
	match_cadena boolean := false;
	calculo_con_densidad double precision :=0;
	calculo_con_densidad_elemento double precision:= 0;
	densidad_tmp double precision:= 0;
	cantidad_presentacion double precision:= 0;
	controla_presentacion boolean := false;
	
	nuevo_lote character varying :='';
	ano_actual_2_digitos character varying:= '';
	
	folio1 character varying:= '';
	folio2 character varying:= '';
	folio3 character varying :='';
	folio4 character varying:= '';
	identificador_nuevo_movimiento integer:=0;
	identificador_nuevo_movimiento_entrada integer:=0;
	precio_unitario double precision:= 0;

	cantTraspasoAnterior double precision:= 0;
	cantDiferencia double precision:= 0;
	--Presentacion Default definido en el catalogo de productos
	idPresDefault double precision:= 0;
	--Cantidad en presentaciones
	cantPres double precision=0;
	--Equivalencia de la presentacion en la unidad del producto
	equivalenciaPres double precision=0;
	--Id del Lote
	idLote integer:=0;

	incrementa integer:=0;
	idProductoActual integer:=0;
	sumaCantidadUsada double precision:=0;
BEGIN
	
	-- convertir cadena en arreglo
	SELECT INTO str_data string_to_array(''||campos_data||'','___');
	
	-- aplicativo que manda a llamar este procedimiento almacenado
	app_selected := str_data[1]::integer;
	
	-- comando que desea ejecutar el aplicativo que llamo el procedimiento almacenado
	command_selected := str_data[2];
	
	-- usuario que utiliza el aplicativo
	usuario_ejecutor := str_data[3]::integer;
	
	--obtiene empresa_id, la sucursal_id y el id_almacen
	--SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id FROM gral_usr_suc 
	--JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	--WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	--INTO emp_id, suc_id;
	
	SELECT gral_suc.empresa_id, gral_usr_suc.gral_suc_id,inv_suc_alm.almacen_id 
  	FROM gral_usr_suc 
	JOIN gral_suc ON gral_suc.id = gral_usr_suc.gral_suc_id
	JOIN inv_suc_alm ON inv_suc_alm.sucursal_id = gral_suc.id
	WHERE gral_usr_suc.gral_usr_id = usuario_ejecutor
	INTO emp_id, suc_id, id_almacen;
	
	SELECT incluye_crm from gral_emp WHERE id=emp_id INTO controla_presentacion;
	
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	SELECT to_char(espacio_tiempo_ejecucion,'mm') INTO mes_actual00;
	
	IF app_selected = 67 THEN
		IF command_selected = 'new' THEN
			
			id_tipo_consecutivo:=14;--Folio Configuracion Produccion
			
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			
			insert into pro_procesos(titulo, vigente, inv_prod_id, dias_caducidad,momento_creacion, borrado_logico, gral_emp_id, gral_suc_id, folio) 
			values(str_data[5], true, str_data[6]::integer, str_data[7]::integer, now(), false, emp_id, suc_id, nuevo_folio) RETURNING id INTO ultimo_id;
			
			--ultimo_id
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					
					IF str_filas[7]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
						--str_filas[1] no_partida
						--str_filas[2] especificaciones
						--str_filas[3] procediemientos
						--str_filas[4] id_subproceso_grid
						--str_filas[5] id_master
						--str_filas[6] nivel_grid
						--str_filas[7] eliminado
						--str_filas[8] tipo_maquina_grid
						--str_filas[9] doc_calidad_grid
						--str_filas[10] id_reg
						--str_filas[11] id_formula
						--str_elemnts1 text[];
						--str_elemnts2 text[];
						
						--RAISE EXCEPTION '%' ,str_filas[6];
						insert into pro_subproceso_prod(pro_subprocesos_id, inv_prod_id, fecha_creacion, momento_creacion, nivel, 
						pro_tipo_equipo_id, documento_calidad, pro_procesos_id, pro_estruc_id) 
						values(str_filas[4]::integer, str_filas[5]::integer, now(), now(), str_filas[6]::integer, str_filas[8]::integer,
						str_filas[9], ultimo_id, str_filas[11]::integer) RETURNING id INTO ultimo_id2;
						
						
						--Este codigo es para las especificaciones
						SELECT INTO str_elemnts1 string_to_array(str_filas[2],'&&&');
						total_filas1:= array_length(str_elemnts1,1);--obtiene total de elementos del arreglo
						IF total_filas1 > 11 THEN
							----str_filas[4] id_subproceso_grid
							--str_filas[5] id_master
							--str_filas[6] nivel_grid
							
							INSERT INTO pro_proc_esp(fineza_inicial,viscosidads_inicial,viscosidadku_inicial ,viscosidadcps_inicial,densidad_inicial,volatiles_inicial,
							cubriente_inicial,tono_inicial,brillo_inicial,dureza_inicial,adherencia_inicial,hidrogeno_inicial, 
							fineza_final,viscosidads_final,viscosidadku_final ,viscosidadcps_final,densidad_final,volatiles_final,
							cubriente_final,tono_final,brillo_final,dureza_final,adherencia_final,hidrogeno_final, 
							inv_prod_id, nivel_form, pro_proceso_id, pro_subproceso_prod_id, 
							
							pro_instrumentos_fineza,
							pro_instrumentos_viscosidad1,
							pro_instrumentos_viscosidad2,
							pro_instrumentos_viscosidad3,
							pro_instrumentos_densidad,
							pro_instrumentos_volatil,
							pro_instrumentos_cubriente,
							pro_instrumentos_tono,
							pro_instrumentos_brillo,
							pro_instrumentos_dureza,
							pro_instrumentos_adherencia,
							pro_instrumentos_hidrogeno
							) 
							values(str_elemnts1[1]::integer, str_elemnts1[2]::integer, str_elemnts1[3]::double precision, str_elemnts1[4]::integer, str_elemnts1[5]::double precision,
							str_elemnts1[6]::double precision, str_elemnts1[7]::double precision, str_elemnts1[8]::double precision, str_elemnts1[9]::double precision, str_elemnts1[10], str_elemnts1[11]::double precision,
							str_elemnts1[12]::double precision, 
							str_elemnts1[13]::integer, str_elemnts1[14]::integer, str_elemnts1[15]::double precision, str_elemnts1[16]::integer, str_elemnts1[17]::double precision,
							str_elemnts1[18]::double precision, str_elemnts1[19]::double precision, str_elemnts1[20]::double precision, str_elemnts1[21]::double precision, str_elemnts1[22], str_elemnts1[23]::double precision,
							str_elemnts1[24]::double precision, 
							str_filas[5]::integer, str_filas[6]::integer, ultimo_id, ultimo_id2,
							str_elemnts1[25]::smallint,
							str_elemnts1[26]::smallint,
							str_elemnts1[27]::smallint,
							str_elemnts1[28]::smallint,
							str_elemnts1[29]::smallint,
							str_elemnts1[30]::smallint,
							str_elemnts1[31]::smallint,
							str_elemnts1[32]::smallint,
							str_elemnts1[33]::smallint,
							str_elemnts1[34]::smallint,
							str_elemnts1[35]::smallint,
							str_elemnts1[36]::smallint);
							
						END IF;
						
						
						
						SELECT INTO str_elemnts1 string_to_array(str_filas[3],'$$$');
						total_filas1:= array_length(str_elemnts1,1);--obtiene total de elementos del arreglo
						cont_fila1:=1;
						FOR cont_fila1 IN 1 .. total_filas1 LOOP
							SELECT INTO str_elemnts2 string_to_array(str_elemnts1[cont_fila1],'&&&');
							IF array_length(str_elemnts2,1) > 1 THEN
								INSERT INTO pro_proc_procedimiento(posicion, descripcion, inv_prod_id, nivel_form, pro_proceso_id, pro_subproceso_prod_id) 
								values(str_elemnts2[1]::integer, str_elemnts2[2], str_filas[5]::integer, str_filas[6]::integer, ultimo_id, ultimo_id2);
							END IF;
						END LOOP;
						--total_filas1 integer;--total de elementos de arreglo
						--cont_fila1 integer;--contador de filas o posiciones del arreglo
						
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		
		
		IF command_selected = 'edit' THEN

			update pro_procesos set titulo=str_data[5], dias_caducidad=str_data[7]::integer where id=str_data[4]::integer;
			
			--ultimo_id
			total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
			cont_fila:=1;
			IF extra_data[1] != 'sin datos' THEN
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					ultimo_id := str_data[4]::integer;
					
					IF str_filas[7]::integer != 0 THEN--1: no esta eliminado, 0:eliminado
						--str_filas[1] no_partida
						--str_filas[2] especificaciones
						--str_filas[3] procediemientos
						--str_filas[4] id_subproceso_grid
						--str_filas[5] id_master
						--str_filas[6] nivel_grid
						--str_filas[7] eliminado
						--str_filas[8] tipo_maquina_grid
						--str_filas[9] doc_calidad_grid
						--str_filas[10] id_registro
						--str_elemnts1 text[];
						--str_elemnts2 text[];
						--str_data[4]::integer; -- me falta terminar esta parte
						ultimo_id2 := str_filas[10]::integer;
						
						IF str_filas[10] = '0' THEN
							insert into pro_subproceso_prod(pro_subprocesos_id, inv_prod_id, fecha_creacion, momento_creacion, nivel, 
							pro_tipo_equipo_id, documento_calidad, pro_procesos_id, pro_estruc_id) 
							values(str_filas[4]::integer, str_filas[5]::integer, now(), now(), str_filas[6]::integer, str_filas[8]::integer,
							str_filas[9], ultimo_id, str_filas[11]::integer) RETURNING id INTO ultimo_id2;
							
							--RAISE EXCEPTION '%' ,'sql_select: '||ultimo_id2;
							
							--Este codigo es para las especificaciones
							SELECT INTO str_elemnts1 string_to_array(str_filas[2],'&&&');
							total_filas1:= array_length(str_elemnts1,1);--obtiene total de elementos del arreglo
							IF total_filas1 > 11 THEN
								----str_filas[4] id_subproceso_grid
								--str_filas[5] id_master
								--str_filas[6] nivel_grid
								
								INSERT INTO pro_proc_esp(fineza_inicial,viscosidads_inicial,viscosidadku_inicial ,viscosidadcps_inicial,densidad_inicial,volatiles_inicial,
								cubriente_inicial,tono_inicial,brillo_inicial,dureza_inicial,adherencia_inicial,hidrogeno_inicial, 
								fineza_final,viscosidads_final,viscosidadku_final ,viscosidadcps_final,densidad_final,volatiles_final,
								cubriente_final,tono_final,brillo_final,dureza_final,adherencia_final,hidrogeno_final, 
								inv_prod_id, nivel_form, pro_proceso_id, pro_subproceso_prod_id,
								pro_instrumentos_fineza,
								pro_instrumentos_viscosidad1,
								pro_instrumentos_viscosidad2,
								pro_instrumentos_viscosidad3,
								pro_instrumentos_densidad,
								pro_instrumentos_volatil,
								pro_instrumentos_cubriente,
								pro_instrumentos_tono,
								pro_instrumentos_brillo,
								pro_instrumentos_dureza,
								pro_instrumentos_adherencia,
								pro_instrumentos_hidrogeno) 
								values(str_elemnts1[1]::integer, str_elemnts1[2]::integer, str_elemnts1[3]::double precision, str_elemnts1[4]::integer, str_elemnts1[5]::double precision,
								str_elemnts1[6]::double precision, str_elemnts1[7]::double precision, str_elemnts1[8]::double precision, str_elemnts1[9]::double precision, str_elemnts1[10], str_elemnts1[11]::double precision,
								str_elemnts1[12]::double precision, 
								str_elemnts1[13]::integer, str_elemnts1[14]::integer, str_elemnts1[15]::double precision, str_elemnts1[16]::integer, str_elemnts1[17]::double precision,
								str_elemnts1[18]::double precision, str_elemnts1[19]::double precision, str_elemnts1[20]::double precision, str_elemnts1[21]::double precision, str_elemnts1[22], str_elemnts1[23]::double precision,
								str_elemnts1[24]::double precision, 
								str_filas[5]::integer, str_filas[6]::integer, ultimo_id, ultimo_id2,
								str_elemnts1[25]::smallint,
								str_elemnts1[26]::smallint,
								str_elemnts1[27]::smallint,
								str_elemnts1[28]::smallint,
								str_elemnts1[29]::smallint,
								str_elemnts1[30]::smallint,
								str_elemnts1[31]::smallint,
								str_elemnts1[32]::smallint,
								str_elemnts1[33]::smallint,
								str_elemnts1[34]::smallint,
								str_elemnts1[35]::smallint,
								str_elemnts1[36]::smallint);
								
							END IF;
							
							
							
							SELECT INTO str_elemnts1 string_to_array(str_filas[3],'$$$');
							total_filas1:= array_length(str_elemnts1,1);--obtiene total de elementos del arreglo
							cont_fila1:=1;
							FOR cont_fila1 IN 1 .. total_filas1 LOOP
								SELECT INTO str_elemnts2 string_to_array(str_elemnts1[cont_fila1],'&&&');
								IF array_length(str_elemnts2,1) > 1 THEN
									INSERT INTO pro_proc_procedimiento(posicion, descripcion, inv_prod_id, nivel_form, pro_proceso_id, pro_subproceso_prod_id) 
									values(str_elemnts2[1]::integer, str_elemnts2[2], str_filas[5]::integer, str_filas[6]::integer, ultimo_id, ultimo_id2);
								END IF;
							END LOOP;
						ELSE
							update pro_subproceso_prod set momento_actualizacion=now(), pro_tipo_equipo_id=str_filas[8]::integer, documento_calidad=str_filas[9] where id=ultimo_id2;
							
							--Este codigo es para las especificaciones
							SELECT INTO str_elemnts1 string_to_array(str_filas[2],'&&&');
							total_filas1:= array_length(str_elemnts1,1);--obtiene total de elementos del arreglo
							IF total_filas1 > 11 THEN
								
								----str_filas[4] id_subproceso_grid
								--str_filas[5] id_master
								--str_filas[6] nivel_grid
								
								EXECUTE 'select count(id) from pro_proc_esp where pro_subproceso_prod_id='||ultimo_id2||';' INTO reg_count;
								IF reg_count > 0 THEN
									update pro_proc_esp set 
									fineza_inicial=str_elemnts1[1]::double precision,
									viscosidads_inicial=str_elemnts1[2]::double precision,
									viscosidadku_inicial=str_elemnts1[3]::double precision,
									viscosidadcps_inicial=str_elemnts1[4]::double precision,
									densidad_inicial=str_elemnts1[5]::double precision,
									volatiles_inicial=str_elemnts1[6]::double precision,
									cubriente_inicial=str_elemnts1[7]::double precision,
									tono_inicial=str_elemnts1[8]::double precision,
									brillo_inicial=str_elemnts1[9]::double precision,
									dureza_inicial=str_elemnts1[10],
									adherencia_inicial=str_elemnts1[11]::double precision,
									hidrogeno_inicial=str_elemnts1[12]::double precision, 
									fineza_final=str_elemnts1[13]::double precision,
									viscosidads_final=str_elemnts1[14]::double precision,
									viscosidadku_final=str_elemnts1[15]::double precision,
									viscosidadcps_final=str_elemnts1[16]::double precision,
									densidad_final=str_elemnts1[17]::double precision,
									volatiles_final=str_elemnts1[18]::double precision,
									cubriente_final=str_elemnts1[19]::double precision,
									tono_final=str_elemnts1[20]::double precision,
									brillo_final=str_elemnts1[21]::double precision,
									dureza_final=str_elemnts1[22],
									adherencia_final=str_elemnts1[23]::double precision,
									hidrogeno_final=str_elemnts1[24]::double precision, 
									pro_instrumentos_fineza=str_elemnts1[25]::smallint,
									pro_instrumentos_viscosidad1=str_elemnts1[26]::smallint,
									pro_instrumentos_viscosidad2=str_elemnts1[27]::smallint,
									pro_instrumentos_viscosidad3=str_elemnts1[28]::smallint,
									pro_instrumentos_densidad=str_elemnts1[29]::smallint,
									pro_instrumentos_volatil=str_elemnts1[30]::smallint,
									pro_instrumentos_cubriente=str_elemnts1[31]::smallint,
									pro_instrumentos_tono=str_elemnts1[32]::smallint,
									pro_instrumentos_brillo=str_elemnts1[33]::smallint,
									pro_instrumentos_dureza=str_elemnts1[34]::smallint,
									pro_instrumentos_adherencia=str_elemnts1[35]::smallint,
									pro_instrumentos_hidrogeno=str_elemnts1[36]::smallint  
									where pro_subproceso_prod_id=ultimo_id2;
								ELSE
									INSERT INTO pro_proc_esp(fineza_inicial,viscosidads_inicial,viscosidadku_inicial ,viscosidadcps_inicial,densidad_inicial,volatiles_inicial,
									cubriente_inicial,tono_inicial,brillo_inicial,dureza_inicial,adherencia_inicial,hidrogeno_inicial, 
									fineza_final,viscosidads_final,viscosidadku_final ,viscosidadcps_final,densidad_final,volatiles_final,
									cubriente_final,tono_final,brillo_final,dureza_final,adherencia_final,hidrogeno_final, 
									inv_prod_id, nivel_form, pro_proceso_id, pro_subproceso_prod_id,
									pro_instrumentos_fineza,
									pro_instrumentos_viscosidad1,
									pro_instrumentos_viscosidad2,
									pro_instrumentos_viscosidad3,
									pro_instrumentos_densidad,
									pro_instrumentos_volatil,
									pro_instrumentos_cubriente,
									pro_instrumentos_tono,
									pro_instrumentos_brillo,
									pro_instrumentos_dureza,
									pro_instrumentos_adherencia,
									pro_instrumentos_hidrogeno)  
									values(str_elemnts1[1]::integer, str_elemnts1[2]::integer, str_elemnts1[3]::double precision, str_elemnts1[4]::integer, str_elemnts1[5]::double precision,
									str_elemnts1[6]::double precision, str_elemnts1[7]::double precision, str_elemnts1[8]::double precision, str_elemnts1[9]::double precision, str_elemnts1[10], str_elemnts1[11]::double precision,
									str_elemnts1[12]::double precision, 
									str_elemnts1[13]::integer, str_elemnts1[14]::integer, str_elemnts1[15]::double precision, str_elemnts1[16]::integer, str_elemnts1[17]::double precision,
									str_elemnts1[18]::double precision, str_elemnts1[19]::double precision, str_elemnts1[20]::double precision, str_elemnts1[21]::double precision, str_elemnts1[22], str_elemnts1[23]::double precision,
									str_elemnts1[24]::double precision, 
									str_filas[5]::integer, str_filas[6]::integer, ultimo_id, ultimo_id2,
									str_elemnts1[25]::smallint,
									str_elemnts1[26]::smallint,
									str_elemnts1[27]::smallint,
									str_elemnts1[28]::smallint,
									str_elemnts1[29]::smallint,
									str_elemnts1[30]::smallint,
									str_elemnts1[31]::smallint,
									str_elemnts1[32]::smallint,
									str_elemnts1[33]::smallint,
									str_elemnts1[34]::smallint,
									str_elemnts1[35]::smallint,
									str_elemnts1[36]::smallint);
									
								END IF;
								
							END IF;
							
							
							delete from pro_proc_procedimiento where pro_subproceso_prod_id=ultimo_id2;
							SELECT INTO str_elemnts1 string_to_array(str_filas[3],'$$$');
							total_filas1:= array_length(str_elemnts1,1);--obtiene total de elementos del arreglo
							cont_fila1:=1;
							
							FOR cont_fila1 IN 1 .. total_filas1 LOOP
								SELECT INTO str_elemnts2 string_to_array(str_elemnts1[cont_fila1],'&&&');
								--RAISE EXCEPTION '%' ,'sql_select: '||str_elemnts1[cont_fila1];
								IF array_length(str_elemnts2,1) > 1 THEN
									INSERT INTO pro_proc_procedimiento(posicion, descripcion, inv_prod_id, nivel_form, pro_proceso_id, pro_subproceso_prod_id) 
									values(str_elemnts2[1]::integer, str_elemnts2[2], str_filas[5]::integer, str_filas[6]::integer, ultimo_id, ultimo_id2);
								END IF;
							END LOOP;
							
						END IF;
					ELSE
						IF str_filas[10] != '0' THEN
							--pro_subproceso_prod_id
							
							delete from pro_proc_procedimiento where pro_subproceso_prod_id=str_filas[10]::integer;
							delete from pro_proc_esp where pro_subproceso_prod_id=str_filas[10]::integer;
							delete from pro_subproceso_prod where id=str_filas[10]::integer;
						END IF;
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			valor_retorno := '1';
		END IF;
	END IF;
	
	--Catalogo de formulas
	IF app_selected = 69 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  id_prod_master
		--str_data[6]  inv_prod_id
		--str_data[7]  nivel
		--str_data[8]  producto_elemento_id
		--str_data[9]  cantidad
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		
                IF command_selected = 'new' THEN
			
			insert into pro_estruc(titulo_descrip,inv_prod_id, observaciones, gral_emp_id, gral_suc_id, gral_usr_id_creacion, momento_creacion, borrado_logico) 
			values('', str_data[5]::integer, '', emp_id, suc_id,usuario_ejecutor, now(), false) RETURNING id INTO ultimo_id;
			
			
			
			-- validaciones para el grid --
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					----aqui se vuelven a crear los registros
					IF str_filas[4] != '0' THEN
						insert into pro_estruc_det(pro_estruc_id,nivel, elemento, inv_prod_id, cantidad, inv_prod_id_salida) 
						values(ultimo_id, str_data[7]::integer, str_filas[3]::integer, str_filas[1]::integer,str_filas[2]::double precision,str_data[6]::integer);
					END IF;
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
                
                IF command_selected = 'edit' THEN
                       
			update pro_estruc set momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_ejecutor  where id=str_data[4]::integer RETURNING id INTO ultimo_id;
			
			
			-- validaciones para el grid --
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					----aqui se vuelven a crear los registros
					IF str_filas[4] != '0' THEN
						--and str_filas[6] == '0'
						
						IF str_filas[6] = '0' THEN
							--RAISE EXCEPTION '%' ,str_data[7];
							insert into pro_estruc_det(pro_estruc_id,nivel, elemento, inv_prod_id, cantidad, inv_prod_id_salida) 
							values(ultimo_id, str_data[7]::integer, str_filas[3]::integer, str_filas[1]::integer,str_filas[2]::double precision,str_data[6]::integer);
							
							--insert into pro_estruc_det(pro_estruc_id,nivel, elemento, inv_prod_id, cantidad, inv_prod_id_salida) 
							--values(ultimo_id, str_data[7]::integer, str_filas[3]::integer, str_filas[1]::integer,str_filas[2]::double precision,str_data[6]::integer);
						ELSE
							update pro_estruc_det set elemento=str_filas[3]::integer, cantidad=str_filas[2]::double precision, 
							inv_prod_id_salida=str_data[6]::integer where id=str_filas[6]::integer;
						END IF;
					ELSE
						IF str_filas[6] != '0' THEN
							delete from pro_estruc_det where id=str_filas[6]::integer;
						END IF;
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
                END IF;
		
                IF command_selected = 'delete' THEN

			select count(id) as cantidad from pro_subproceso_prod where pro_estruc_id=str_data[4]::integer INTO exis;
			IF exis > 0 THEN
				valor_retorno := 'La formula esta siendo utilizada por un subproceso';
			ELSE
				update pro_estruc set borrado_logico=false, momento_baja=now(), gral_usr_id_baja=usuario_ejecutor 
				WHERE id = str_data[4]::integer;
				valor_retorno := '1';
			END IF;
		END IF;
                
	END IF;--termina Catalogo de formulas



	----actualizador de formulas
	IF app_selected = 86 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  id_producto_existe
		--str_data[6]  id_producto_sustituto
		
                IF command_selected = 'new' THEN
			
			--insert into pro_estruc(titulo_descrip,inv_prod_id, observaciones, gral_emp_id, gral_suc_id, gral_usr_id_creacion, momento_creacion, borrado_logico) 
			--values('', str_data[5]::integer, '', emp_id, suc_id,usuario_ejecutor, now(), false) RETURNING id INTO ultimo_id;
			
			-- validaciones para el grid --
			--RAISE EXCEPTION '%' ,extra_data[1] != 'sin datos';
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				
				FOR cont_fila IN 1 .. total_filas LOOP
					--RAISE EXCEPTION '%' ,extra_data[cont_fila]::integer;
					update pro_estruc_det set inv_prod_id=str_data[6]::integer where pro_estruc_id=extra_data[cont_fila]::integer and inv_prod_id=str_data[5]::integer;
				END LOOP;
				
			END IF;
			valor_retorno := '1';
		END IF;
                
	END IF;--actualizador de formulas
	
	
	--Proceso Preorden produccion
	IF app_selected = 89 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  tipo_orden
		--str_data[6]  observaciones
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		
                IF command_selected = 'new' THEN
			
			id_tipo_consecutivo:=18;--Folio Preorden de Produccion
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			insert into pro_preorden_prod(gral_emp_id,gral_suc_id, momento_creacion, borrado_logico,pro_orden_tipos_id,observaciones, folio, id_usuario_creacion,estatus) 
			values(emp_id, suc_id, now(), false, str_data[5]::integer,str_data[6],nuevo_folio, usuario_ejecutor, 1) RETURNING id INTO ultimo_id;
			
			-- validaciones para el grid --
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					--id_reg[i] +"___" + 
					--presentacion_id[i]+"___" + 
					--inv_prod_id[i]+"___" + 
					--id_pedido[i]+"___" + 
					--no_partida+"___" + cantidad[i]+"___" + eliminado[i]
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					----aqui se vuelven a crear los registros
					IF str_filas[7] != '0' THEN
						insert into pro_preorden_prod_det(pro_preorden_prod_id, cantidad, poc_pedidos_id, inv_prod_id, inv_prod_presentaciones_id) 
						values(ultimo_id, str_filas[6]::double precision,str_filas[4]::integer,str_filas[3]::integer,str_filas[2]::integer);
						
						--cambia de estatus para que no puedan cancelar el pedido mientras este siendo utilizado por una preorden
						str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
						join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
						poc_ped_bo.inv_prod_id='||str_filas[3]::integer||' );';
						FOR record1 IN EXECUTE (str_select1) LOOP
							UPDATE poc_ped_bo set estatus=3 where id=record1.id;
						END LOOP;
					END IF;
					str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
					join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
					poc_ped_bo.estatus=1 );';
					FOR record1 IN EXECUTE (str_select1) LOOP
						UPDATE poc_ped_bo set estatus=0 where id=record1.id;
					END LOOP;
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
                
                IF command_selected = 'edit' THEN
                       
			update pro_preorden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor, observaciones=str_data[6]  where id=str_data[4]::integer RETURNING id INTO ultimo_id;
			update pro_preorden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor, observaciones=str_data[6]  where id=str_data[4]::integer RETURNING id INTO ultimo_id;
			
			-- validaciones para el grid --
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					
					--RAISE EXCEPTION '%',str_filas[4]||'  '||str_filas[3];
					----aqui se vuelven a crear los registros
					IF str_filas[7] != '0' THEN
						--and str_filas[6] == '0'
						
						IF str_filas[1] = '0' THEN
							--RAISE EXCEPTION '%' ,str_data[7];
							insert into pro_preorden_prod_det(pro_preorden_prod_id, cantidad, poc_pedidos_id, inv_prod_id, inv_prod_presentaciones_id) 
							values(ultimo_id, str_filas[6]::double precision,str_filas[4]::integer,str_filas[3]::integer,str_filas[2]::integer);
							
						ELSE
							update pro_preorden_prod_det set cantidad=str_filas[6]::double precision where id=str_filas[1]::integer;
						END IF;
						
						str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
						join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
						poc_ped_bo.inv_prod_id='||str_filas[3]::integer||' );';
						FOR record1 IN EXECUTE (str_select1) LOOP
							UPDATE poc_ped_bo set estatus=3 where id=record1.id;
						END LOOP;
					ELSE
						IF str_filas[1] != '0' THEN
							str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
							join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
							poc_ped_bo.inv_prod_id='||str_filas[3]::integer||' );';
							FOR record1 IN EXECUTE (str_select1) LOOP
								UPDATE poc_ped_bo set estatus=0 where id=record1.id;
							END LOOP;
							delete from pro_preorden_prod_det where id=str_filas[1]::integer;
						END IF;
						
					END IF;
					str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
					join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
					poc_ped_bo.estatus=1 );';
					FOR record1 IN EXECUTE (str_select1) LOOP
						UPDATE poc_ped_bo set estatus=0 where id=record1.id;
					END LOOP;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
                END IF;
		
		IF command_selected = 'confirm' THEN
                       
			update pro_preorden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor, observaciones=str_data[6], confirmado=true  where id=str_data[4]::integer RETURNING id INTO ultimo_id;
			update pro_preorden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor, observaciones=str_data[6],estatus=2  where id=str_data[4]::integer RETURNING id INTO ultimo_id;
			
			-- validaciones para el grid --
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					----aqui se vuelven a crear los registros
					IF str_filas[7] != '0' THEN
						--and str_filas[6] == '0'
						
						IF str_filas[1] = '0' THEN
							--RAISE EXCEPTION '%' ,str_data[7];
							insert into pro_preorden_prod_det(pro_preorden_prod_id, cantidad, poc_pedidos_id, inv_prod_id, inv_prod_presentaciones_id) 
							values(ultimo_id, str_filas[6]::double precision,str_filas[4]::integer,str_filas[3]::integer,str_filas[2]::integer);
						ELSE
							update pro_preorden_prod_det set cantidad=str_filas[6]::double precision where id=str_filas[1]::integer;
						END IF;
						
						str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
						join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
						poc_ped_bo.inv_prod_id='||str_filas[3]::integer||' );';
						FOR record1 IN EXECUTE (str_select1) LOOP
							UPDATE poc_ped_bo set estatus=3 where id=record1.id;
						END LOOP;
					ELSE
						IF str_filas[1] != '0' THEN
							delete from pro_preorden_prod_det where id=str_filas[1]::integer;
							
							str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
							join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
							poc_ped_bo.inv_prod_id='||str_filas[3]::integer||' );';
							FOR record1 IN EXECUTE (str_select1) LOOP
								UPDATE poc_ped_bo set estatus=0 where id=record1.id;
							END LOOP;
						END IF;
						
					END IF;
					str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
					join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
					poc_ped_bo.estatus=1 );';
					FOR record1 IN EXECUTE (str_select1) LOOP
						UPDATE poc_ped_bo set estatus=0 where id=record1.id;
					END LOOP;
				END LOOP;
			END IF;
			
			--str_select1 := 'select gral_emp_id, gral_suc_id, pro_orden_tipos_id, folio, observaciones, confirmado from pro_preorden_prod where id='||str_data[4]::integer||';';
			str_select1 := 'select pro_preorden_prod_det.id, preorden.gral_emp_id, preorden.gral_suc_id, preorden.pro_orden_tipos_id,preorden.folio, preorden.observaciones, 
			preorden.confirmado, pro_preorden_prod_det.cantidad, pro_preorden_prod_det.inv_prod_id 
			 from 
			(select id, gral_emp_id, gral_suc_id, pro_orden_tipos_id, folio, observaciones, confirmado from pro_preorden_prod where id='||str_data[4]::integer||') as preorden 
			join pro_preorden_prod_det on pro_preorden_prod_det.pro_preorden_prod_id=preorden.id';
			
			--RAISE EXCEPTION '%',str_select1;
			
			FOR record1 IN EXECUTE (str_select1) LOOP
				
				--crea el proceso en nivel Generada
				insert into pro_proceso(pro_proceso_flujo_id, empresa_id, sucursal_id)
				values(2,emp_id, suc_id) RETURNING id INTO tipo_movimiento_id;
				
				id_tipo_consecutivo:=20;--Folio Orden Produccion
				
				--aqui entra para tomar el consecutivo del folio  la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;


				--====== Para generar el numero de lote para el producto que se esta produciendo
				id_tipo_consecutivo:=25;--Consecutivo Numero de Lote
				
				--aqui entra para tomar el consecutivo del folio  la sucursal actual
				UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
				WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
				
				--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
				--folio_entrada := prefijo_consecutivo || nuevo_consecutivo::character varying;
				
				--convertir a hexadecimal el nuevo consecutivo
				nuevo_lote=to_hex(nuevo_consecutivo);
				
				--tipo_movimiento_id=10 ENTRADA PRODUCCION
				--extraer los dos digitos del a√±o
				SELECT to_char(espacio_tiempo_ejecucion,'yy') INTO ano_actual_2_digitos;
				 
				--agregar ceros a la izquierda para acompletar 6 caracteres con lpad y convertir a mayusculas con upper
				nuevo_lote := upper(lpad(nuevo_lote, 6, '0'));
				
				--agregar a√±o y mes al consecutivo del lote para acompletar 10 caractares
				nuevo_lote := ano_actual_2_digitos || mes_actual00 || nuevo_lote;
				
				
				insert into pro_orden_prod(gral_emp_id, gral_suc_id, momento_creacion, folio, observaciones, id_usuario_creacion, pro_orden_tipos_id, pro_proceso_id, lote) 
				values(emp_id, suc_id, now(),nuevo_folio,record1.observaciones,  usuario_ejecutor, record1.pro_orden_tipos_id, tipo_movimiento_id, nuevo_lote) RETURNING id INTO ultimo_id;
				
				str_select2 :='select poc_pedidos_id, preorden_detalle.inv_prod_id, pro_subproceso_prod.pro_subprocesos_id,inv_prod.densidad, 
					inv_prod.unidad_id, pro_estruc.id from (select * from pro_preorden_prod_det where id='||record1.id||') as preorden_detalle 
					left join 
					pro_estruc on pro_estruc.inv_prod_id=preorden_detalle.inv_prod_id 
					left join 
					pro_subproceso_prod on pro_subproceso_prod.pro_estruc_id=pro_estruc.id 
					join inv_prod on inv_prod.id=preorden_detalle.inv_prod_id ';
					
				--RAISE EXCEPTION '%',''||str_select2;
				--para insertar los datos en la preorden pro_orden_prod_det
				FOR record2 IN EXECUTE (str_select2) LOOP
					IF record2.pro_subprocesos_id  is not null THEN
						
						update pro_orden_prod set pro_estruc_id=record2.id where id=ultimo_id;
						
						insert into pro_orden_prod_det(pro_orden_prod_id, cantidad,  inv_prod_id, pro_subprocesos_id, unidad_id, densidad) 
						values(ultimo_id, record1.cantidad, record1.inv_prod_id,record2.pro_subprocesos_id,record2.unidad_id,record2.densidad ) RETURNING id INTO ultimo_id2;
						
						str_select3:= 'select * from pro_proc_esp where pro_proc_esp.pro_subproceso_prod_id = (
						select id from pro_subproceso_prod where pro_procesos_id=
						(select id from pro_procesos where inv_prod_id='||record2.inv_prod_id||' and borrado_logico=false and gral_emp_id='||emp_id||' AND gral_suc_id='||suc_id||') AND  pro_subprocesos_id='||record2.pro_subprocesos_id||' )';
						
						FOR record3 IN EXECUTE (str_select3) LOOP
							
							INSERT INTO pro_orden_prod_subp_esp(--fineza_inicial,viscosidads_inicial,viscosidadku_inicial ,viscosidadcps_inicial,densidad_inicial,
							--volatiles_inicial,cubriente_inicial,tono_inicial,brillo_inicial,dureza_inicial,adherencia_inicial,hidrogeno_inicial, 
							pro_instrumentos_fineza,pro_instrumentos_viscosidad1,pro_instrumentos_viscosidad2,pro_instrumentos_viscosidad3,
							pro_instrumentos_densidad,pro_instrumentos_volatil,pro_instrumentos_cubriente,pro_instrumentos_tono,
							pro_instrumentos_brillo,pro_instrumentos_dureza,pro_instrumentos_adherencia,pro_instrumentos_hidrogeno,
							inv_prod_id, nivel_form, pro_orden_prod_det_id, pro_subprocesos_id) 
							values(
							--str_elemnts1[1]::double precision, str_elemnts1[2]::double precision, str_elemnts1[3]::double precision, str_elemnts1[4]::double precision, str_elemnts1[5]::double precision,
							--str_elemnts1[6]::double precision, str_elemnts1[7]::double precision, str_elemnts1[8]::double precision, str_elemnts1[9]::double precision, str_elemnts1[10], str_elemnts1[11]::double precision,
							--str_elemnts1[12]::double precision, 
							record3.pro_instrumentos_fineza,record3.pro_instrumentos_viscosidad1,record3.pro_instrumentos_viscosidad2,record3.pro_instrumentos_viscosidad3,
							record3.pro_instrumentos_densidad,record3.pro_instrumentos_volatil,record3.pro_instrumentos_cubriente,record3.pro_instrumentos_tono,
							record3.pro_instrumentos_brillo,record3.pro_instrumentos_dureza,record3.pro_instrumentos_adherencia,record3.pro_instrumentos_hidrogeno,
							record2.inv_prod_id, 1, ultimo_id2, record2.pro_subprocesos_id);
							
						END LOOP;
					END IF;
				END LOOP;
			END LOOP;
			
			valor_retorno := '1';
			
                END IF;
		
                IF command_selected = 'cancelar' THEN
                       
			update pro_preorden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor,estatus=3  where id=str_data[4]::integer RETURNING id INTO ultimo_id;
			
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					
					str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
					join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
					poc_ped_bo.estatus=1 );';
					FOR record1 IN EXECUTE (str_select1) LOOP
						UPDATE poc_ped_bo set estatus=0 where id=record1.id;
					END LOOP;
					
				END LOOP;
			END IF;
			
			str_select1 := 'select poc_ped_bo.id, poc_ped_bo.estatus  from  pro_preorden_prod_det as prepd  join poc_pedidos_detalle as pocpd ON 
			 (pocpd.poc_pedido_id=prepd.poc_pedidos_id AND pocpd.inv_prod_id=prepd.inv_prod_id AND 
			 prepd.pro_preorden_prod_id='||str_data[4]::integer||') join poc_ped_bo ON  poc_ped_bo.poc_ped_detalle_id=pocpd.id;';
			
			--RAISE EXCEPTION '%',str_select2;
			
			FOR record1 IN EXECUTE (str_select1) LOOP
				UPDATE poc_ped_bo set estatus=0 where id=record1.id;
			END LOOP;
			
			valor_retorno := '1';
			
                END IF;
		
		
                IF command_selected = 'cerrar' THEN
                       
			-- validaciones para el grid --
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--RAISE EXCEPTION '%',str_filas[4];
					str_select1 := 'select poc_ped_bo.id from poc_pedidos_detalle as pedd
					join poc_ped_bo on (poc_ped_bo.poc_ped_detalle_id=pedd.id AND pedd.poc_pedido_id='||str_filas[4]::integer||' AND 
					poc_ped_bo.estatus=1 );';
					FOR record1 IN EXECUTE (str_select1) LOOP
						UPDATE poc_ped_bo set estatus=0 where id=record1.id;
					END LOOP;
					
				END LOOP;
			END IF;
			
			valor_retorno := '2';
                END IF;
                
                IF command_selected = 'delete' THEN
			select count(id) as cantidad from pro_subproceso_prod where pro_estruc_id=str_data[4]::integer INTO exis;
			IF exis > 0 THEN
				valor_retorno := 'La formula esta siendo utilizada por un subproceso';
			ELSE
				update pro_estruc set borrado_logico=false, momento_baja=now(), gral_usr_id_baja=usuario_ejecutor 
				WHERE id = str_data[4]::integer;
				valor_retorno := '1';
			END IF;
		END IF;
		
	END IF;--termina preorden produccion
	
	
	
		--Proceso Orden produccion
	IF app_selected = 93 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  tipo_orden
		--str_data[6]  fecha_elavorar
		--str_data[7]  observaciones
		--str_data[8]  command_selected
		
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		--obtenemos el id de el almacen de produccion
		select inv_alm_id from pro_par where gral_emp_id=emp_id limit 1 INTO id_almacen;
		
		
                IF command_selected = 'new' THEN
			
			--crea el proceso en nivel Generada
			insert into pro_proceso(pro_proceso_flujo_id, empresa_id, sucursal_id)
			values(1,emp_id, suc_id) RETURNING id INTO tipo_movimiento_id;
			
			id_tipo_consecutivo:=20;--Folio Orden Produccion
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			
			--====== Para generar el numero de lote para el producto que se esta produciendo
			id_tipo_consecutivo:=25;--Consecutivo Numero de Lote
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			--folio_entrada := prefijo_consecutivo || nuevo_consecutivo::character varying;
			
			--convertir a hexadecimal el nuevo consecutivo
			nuevo_lote=to_hex(nuevo_consecutivo);
			
			--tipo_movimiento_id=10 ENTRADA PRODUCCION
			--extraer los dos digitos del a√±o
			SELECT to_char(espacio_tiempo_ejecucion,'yy') INTO ano_actual_2_digitos;
			 
			--agregar ceros a la izquierda para acompletar 6 caracteres con lpad y convertir a mayusculas con upper
			nuevo_lote := upper(lpad(nuevo_lote, 6, '0'));
			
			--agregar a√±o y mes al consecutivo del lote para acompletar 10 caractares
			nuevo_lote := ano_actual_2_digitos || mes_actual00 || nuevo_lote;
			
			insert into pro_orden_prod(gral_emp_id, gral_suc_id, momento_creacion, folio, observaciones, id_usuario_creacion, pro_orden_tipos_id, fecha_elavorar, pro_proceso_id, lote, pro_estruc_id) 
			values(emp_id, suc_id, now(),nuevo_folio,str_data[7],  usuario_ejecutor, str_data[5]::integer,str_data[6]::date,  tipo_movimiento_id, nuevo_lote, str_data[10]::integer) RETURNING id INTO ultimo_id;
			--ALTER TABLE pro_orden_prod ADD COLUMN pro_estruc_id integer;
			-- validaciones para el grid --
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					--eliminar[i] +"--1
					--___" + id_reg[i]+"--2
					--___" + inv_prod_id[i]+"--3
					--___" + subproceso_id[i]+"--4
					--___"+ pro_subproceso_prod_id[i]+"--5
					--___"+persona[i]+"--6
					--___"+ equipo[i]+"--7
					--___"+ eq_adicional[i]+"--8
					--___"+ cantidad[i]+"--9
					--___" + no_partida--10
					--unidad_default--11
					--densidad--12
					--unidad_id--13
					
					--select 'KILOGRAMO' ~* 'KILO*'
					
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');

/*
					RAISE EXCEPTION '%' ,'extra_data['||cont_fila||']: '||extra_data[cont_fila];
					--eliminar[i]=	1___
					--id_reg[i]=	0___
					--inv_prod_id[i]=2044___
					--subproceso_id[i]=3___
					--pro_subproceso_prod_id[i]=769___
					___
					___
					___
					100___
					1___
					0___
					0.8100___
					2
*/
					
					----aqui se vuelven a crear los registros
					IF str_filas[7] != '0' THEN 
						
						EXECUTE 'select titulo from inv_prod_unidades where id='||str_filas[13]::integer||'' INTO titulo_unidad;
						EXECUTE 'select '''||titulo_unidad||''' ~* ''KILO*'';' INTO match_cadena;
						
						IF str_filas[11] = str_filas[13] THEN
							IF match_cadena = true THEN
								calculo_con_densidad := str_filas[9]::double precision;
							ELSE
								calculo_con_densidad := str_filas[9]::double precision;--(str_filas[9]::double precision * str_filas[12]::double precision);
							END IF;
						ELSE
							IF match_cadena = true THEN
								calculo_con_densidad := (str_filas[9]::double precision * str_filas[12]::double precision);
							ELSE
								calculo_con_densidad := (str_filas[9]::double precision / str_filas[12]::double precision);
							END IF;
						END IF;
						
						calculo_con_densidad := round((calculo_con_densidad)::numeric, 4)::double precision;
						
						insert into pro_orden_prod_det(pro_orden_prod_id, cantidad, pro_subprocesos_id, inv_prod_id, unidad_id, densidad) 
						values(ultimo_id, calculo_con_densidad,str_filas[4]::integer,str_filas[3]::integer,str_filas[13]::integer,str_filas[12]::double precision) RETURNING id INTO ultimo_id2;
						
						str_select1:= 'select * from pro_proc_esp where pro_proc_esp.pro_subproceso_prod_id = (
						select id from pro_subproceso_prod where inv_prod_id='||str_filas[3]::integer||' 
						AND  pro_subprocesos_id='||str_filas[4]::integer||' )';
						
						--select id from pro_subproceso_prod where pro_procesos_id='||str_filas[3]::integer||' 
						--(select id from pro_procesos where inv_prod_id='||str_filas[3]::integer||' and borrado_logico=false and gral_emp_id='||emp_id||' AND gral_suc_id='||suc_id||') 
						
						
						--RAISE EXCEPTION '%' ,str_select1;
						
						FOR record1 IN EXECUTE (str_select1) LOOP
							INSERT INTO pro_orden_prod_subp_esp(--fineza_inicial,viscosidads_inicial,viscosidadku_inicial ,viscosidadcps_inicial,densidad_inicial,
							--volatiles_inicial,cubriente_inicial,tono_inicial,brillo_inicial,dureza_inicial,adherencia_inicial,hidrogeno_inicial, 
							pro_instrumentos_fineza,pro_instrumentos_viscosidad1,pro_instrumentos_viscosidad2,pro_instrumentos_viscosidad3,
							pro_instrumentos_densidad,pro_instrumentos_volatil,pro_instrumentos_cubriente,pro_instrumentos_tono,
							pro_instrumentos_brillo,pro_instrumentos_dureza,pro_instrumentos_adherencia,pro_instrumentos_hidrogeno,
							inv_prod_id, nivel_form, pro_orden_prod_det_id, pro_subprocesos_id) 
							values(
							--str_elemnts1[1]::double precision, str_elemnts1[2]::double precision, str_elemnts1[3]::double precision, str_elemnts1[4]::double precision, str_elemnts1[5]::double precision,
							--str_elemnts1[6]::double precision, str_elemnts1[7]::double precision, str_elemnts1[8]::double precision, str_elemnts1[9]::double precision, str_elemnts1[10], str_elemnts1[11]::double precision,
							--str_elemnts1[12]::double precision, 
							record1.pro_instrumentos_fineza,record1.pro_instrumentos_viscosidad1,record1.pro_instrumentos_viscosidad2,record1.pro_instrumentos_viscosidad3,
							record1.pro_instrumentos_densidad,record1.pro_instrumentos_volatil,record1.pro_instrumentos_cubriente,record1.pro_instrumentos_tono,
							record1.pro_instrumentos_brillo,record1.pro_instrumentos_dureza,record1.pro_instrumentos_adherencia,record1.pro_instrumentos_hidrogeno,
							str_filas[3]::integer, 1, ultimo_id2, str_filas[4]::integer);
						END LOOP;
						
					END IF;
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
                
                IF command_selected = 'edit' THEN
			
                       --obtener el id del proceso para este pedido
			SELECT pro_proceso_id FROM pro_orden_prod WHERE id=str_data[4]::integer INTO id_proceso;
			
			--Para editar la orden
			IF str_data[8]='1' THEN
				
				--Programada
				update pro_proceso set pro_proceso_flujo_id=1  WHERE id=id_proceso;
				
				update pro_orden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor, 
				observaciones=str_data[7],fecha_elavorar=str_data[6]::date 
				where id=str_data[4]::integer 
				RETURNING id INTO ultimo_id;
				
				-- datos para el grid --
				IF extra_data[1] != 'sin datos' THEN
					total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
					cont_fila:=1;
					FOR cont_fila IN 1 .. total_filas LOOP
						
						SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
						----aqui se vuelven a crear los registros
						
						IF str_filas[1] != '0' THEN
							
							IF str_filas[6] != '' OR str_filas[6] != ' ' THEN 
								SELECT id FROM gral_empleados where gral_empleados.nombre_pila||' '||gral_empleados.apellido_paterno||' '||gral_empleados.apellido_materno ilike ''||str_filas[6]||'' and borrado_logico=false and gral_emp_id=emp_id INTO operador_id;
							ELSE
								str_filas[6] := '0';
							END IF;
							
							IF str_filas[7] != '' OR str_filas[7] != ' ' THEN
								SELECT id FROM pro_equipos where titulo ilike ''||str_filas[7]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_id;
							ELSE
								str_filas[7] := '0';
							END IF;
							
							IF str_filas[8] != '' OR str_filas[8] != ' ' THEN
								SELECT id FROM pro_equipos_adic where titulo ilike ''||str_filas[8]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_adicional_id;
							ELSE
								str_filas[8] := '0';
							END IF;
							
							IF str_filas[2] = '0' THEN
								IF str_data[8] = '1' THEN 
									EXECUTE 'select titulo from inv_prod_unidades where id='||str_filas[13]::integer||'' INTO titulo_unidad;
									EXECUTE 'select '''||titulo_unidad||''' ~* ''KILO*'';' INTO match_cadena;
									
									IF str_filas[11] = str_filas[13] THEN
										IF match_cadena = true THEN
											calculo_con_densidad := str_filas[9]::double precision;
										ELSE
											calculo_con_densidad := str_filas[9]::double precision;--(str_filas[9]::double precision * str_filas[12]::double precision);
										END IF;
									ELSE
										IF match_cadena = true THEN
											calculo_con_densidad := (str_filas[9]::double precision * str_filas[12]::double precision);
										ELSE
											calculo_con_densidad := (str_filas[9]::double precision / str_filas[12]::double precision);
										END IF;
									END IF;
									calculo_con_densidad := round((calculo_con_densidad)::numeric, 4)::double precision;
									--RAISE EXCEPTION '%' ,str_filas[11] ||'    '|| str_filas[13];
									insert into pro_orden_prod_det(pro_orden_prod_id, cantidad, pro_subprocesos_id, inv_prod_id, unidad_id, densidad) 
									values(ultimo_id, calculo_con_densidad,str_filas[4]::integer,str_filas[3]::integer,str_filas[13]::integer,str_filas[12]::double precision);
									
									--insert into pro_orden_prod_det(pro_orden_prod_id, cantidad, pro_subprocesos_id, inv_prod_id) 
									--values(ultimo_id, str_filas[9]::double precision,str_filas[4]::integer,str_filas[3]::integer);
									
								END IF;
							ELSE
								IF str_data[8] = '1' THEN 
									EXECUTE 'select titulo from inv_prod_unidades where id='||str_filas[13]::integer||'' INTO titulo_unidad;
									EXECUTE 'select '''||titulo_unidad||''' ~* ''KILO*'';' INTO match_cadena;
									
									IF str_filas[11] = str_filas[13] THEN 
										IF match_cadena = true THEN 
											calculo_con_densidad := str_filas[9]::double precision;
										ELSE
											calculo_con_densidad := str_filas[9]::double precision;--(str_filas[9]::double precision * str_filas[12]::double precision);
										END IF;
									ELSE
										
										--RAISE EXCEPTION '%' ,match_cadena;
										IF match_cadena = true THEN
											calculo_con_densidad := (str_filas[9]::double precision * str_filas[12]::double precision);
											--calculo_con_densidad := (str_filas[9]::double precision );
										ELSE
											calculo_con_densidad := (str_filas[9]::double precision / str_filas[12]::double precision);
										END IF;
									END IF;
									
									calculo_con_densidad := round((calculo_con_densidad)::numeric, 4)::double precision;
									--RAISE EXCEPTION '%' ,str_filas[11] ||'  '|| str_filas[13];
									update pro_orden_prod_det set cantidad=calculo_con_densidad where id=str_filas[2]::integer;
								END IF;
							END IF;
						ELSE
							IF str_filas[1] != '0' THEN
								delete from pro_orden_prod_det where id=str_filas[2]::integer;
							END IF;
						END IF;
					END LOOP;
				END IF;
				
			END IF;
			
			--Para programar la orden
			IF str_data[8]='2' THEN
				--Programada
				update pro_proceso set pro_proceso_flujo_id=2  WHERE id=id_proceso;
				
				update pro_orden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor, 
				observaciones=str_data[7],fecha_elavorar=str_data[6]::date where id=str_data[4]::integer RETURNING id INTO ultimo_id;
				
				-- validaciones para el grid --
				IF extra_data[1] != 'sin datos' THEN
					total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
					cont_fila:=1;
					FOR cont_fila IN 1 .. total_filas LOOP
						
						SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
						----aqui se vuelven a crear los registros
						IF str_filas[1] != '0' THEN
							
							IF str_filas[6] != '' OR str_filas[6] != ' ' THEN
								SELECT id FROM gral_empleados where gral_empleados.nombre_pila||' '||gral_empleados.apellido_paterno||' '||gral_empleados.apellido_materno ilike ''||str_filas[6]||'' and borrado_logico=false and gral_emp_id=emp_id INTO operador_id;
							ELSE
								str_filas[6] := '0';
							END IF;
							
							IF str_filas[7] != '' OR str_filas[7] != ' ' THEN
								SELECT id FROM pro_equipos where titulo ilike ''||str_filas[7]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_id;
							ELSE
								str_filas[7] := '0';
							END IF;
							
							IF str_filas[8] != '' OR str_filas[8] != ' ' THEN
								SELECT id FROM pro_equipos_adic where titulo ilike ''||str_filas[8]||'' and borrado_logico=false and gral_emp_id=emp_id INTO equipo_adicional_id;
							ELSE
								str_filas[8] := '0';
							END IF;
							
							IF str_filas[2] = '0' THEN
								IF str_data[8] = '1' THEN 
									--RAISE EXCEPTION '%' ,str_data[7];
									--insert into pro_orden_prod_det(pro_orden_prod_id, cantidad, pro_subprocesos_id, inv_prod_id) 
									--values(ultimo_id, str_filas[9]::double precision,str_filas[4]::integer,str_filas[3]::integer);
									--calculo_con_densidad := round((calculo_con_densidad)::numeric, 4)::double precision;
									insert into pro_orden_prod_det(pro_orden_prod_id, cantidad, pro_subprocesos_id, inv_prod_id) 
									values(ultimo_id, str_filas[9]::double precision,str_filas[4]::integer,str_filas[3]::integer);
								ELSE
									IF str_data[8] = '2' THEN
										--RAISE EXCEPTION '%' ,str_data[7];
										insert into pro_orden_prod_det(pro_orden_prod_id, cantidad, pro_subprocesos_id, inv_prod_id, gral_empleados_id, pro_equipos_id, pro_equipos_adic_id) 
										values(ultimo_id, str_filas[9]::double precision,str_filas[4]::integer,str_filas[3]::integer,operador_id,equipo_id,equipo_adicional_id);
									END IF;
								END IF;
							ELSE
								IF str_data[8] = '1' THEN 
									--RAISE EXCEPTION '%' ,str_data[7];
									--update pro_orden_prod_det set cantidad=str_filas[9]::double precision where id=str_filas[2]::integer;
								ELSE
									IF str_data[8] = '2' THEN 
										--RAISE EXCEPTION '%' ,str_data[7];
										--cantidad=str_filas[9]::double precision,
										update pro_orden_prod_det set gral_empleados_id=operador_id, pro_equipos_id=equipo_id, 
										pro_equipos_adic_id=equipo_adicional_id  where id=str_filas[2]::integer;
									END IF;
								END IF;
							END IF;
						ELSE
							IF str_filas[1] != '0' THEN
								delete from pro_orden_prod_det where id=str_filas[2]::integer;
							END IF;
						END IF;
					END LOOP;
				END IF;
				
				
				--------
				----Agrega la formula a la tabla pro_orden_detalle_mov para que durante todo el proceso de produccion y de ahi se jenere la orden de requisicion
				--------
				
				--str_select1:='SELECT  pro_orden_prod_det.id, pro_orden_prod_det.pro_subprocesos_id, pro_orden_prod_det.inv_prod_id,
				--pro_orden_prod_det.cantidad FROM pro_orden_prod_det JOIN inv_prod ON inv_prod.id=pro_orden_prod_det.inv_prod_id 
				--AND  pro_orden_prod_det.pro_orden_prod_id='||str_data[4]::integer||' 
				--group by pro_orden_prod_det.inv_prod_id, pro_orden_prod_det.cantidad, pro_orden_prod_det.id, 
				--pro_orden_prod_det.pro_subprocesos_id';
				str_select1:='SELECT  pro_orden_prod_det.id, pro_orden_prod_det.pro_subprocesos_id, pro_orden_prod_det.inv_prod_id,
				pro_orden_prod_det.cantidad, pro_orden_prod_det.unidad_id, pro_orden_prod_det.densidad FROM pro_orden_prod_det 
				JOIN inv_prod ON inv_prod.id=pro_orden_prod_det.inv_prod_id 
				AND  pro_orden_prod_det.pro_orden_prod_id='||str_data[4]::integer||' 
				group by pro_orden_prod_det.inv_prod_id, pro_orden_prod_det.cantidad, pro_orden_prod_det.id, 
				pro_orden_prod_det.pro_subprocesos_id, pro_orden_prod_det.unidad_id, pro_orden_prod_det.densidad  limit 1';
				
				--RAISE EXCEPTION '%' ,str_select1;
				
				--select * from pro_orden_detalle_mov where pro_orden_prod_det_id=
				
				FOR record1 IN EXECUTE (str_select1) LOOP
					
					select count(id) from pro_orden_detalle_mov where pro_orden_prod_det_id=record1.id INTO exis;
					
					
					IF exis = 0 THEN
						
						str_select2 := 'select pro_estruc_det.inv_prod_id, pro_estruc_det.cantidad, pro_estruc_det.elemento  
						from (select id from pro_estruc where id='||str_data[10]::integer||' and borrado_logico=false) as formula join 
						pro_estruc_det on pro_estruc_det.pro_estruc_id=formula.id order by pro_estruc_det.elemento';
						--RAISE EXCEPTION '%' ,str_select2;
						
						FOR record2 IN EXECUTE (str_select2) LOOP
							
							--para verificar si la unidad de medida, viene en kilos o litros
							EXECUTE 'select titulo from inv_prod_unidades where id='||record1.unidad_id||'' INTO titulo_unidad;
							EXECUTE 'select '''||titulo_unidad||''' ~* ''KILO*'';' INTO match_cadena;
							
							--RAISE EXCEPTION '%' ,match_cadena;
							
							--todos los pedidos, se tienen que hacer en kilos
							IF match_cadena = true THEN
								calculo_con_densidad := record1.cantidad;
							ELSE
								calculo_con_densidad := record1.cantidad * record1.densidad;
							END IF;
							
							--calculo_con_densidad_elemento := 0;
							
							--RAISE EXCEPTION '%' ,calculo_con_densidad;
							cantidad_calculada = round(((record2.cantidad/100)*calculo_con_densidad)::numeric, 4)::double precision;
							--insert alos datos por primera vez, en pro_orden_detalle_mov
							INSERT INTO pro_orden_detalle_mov(pro_orden_prod_det_id,cantidad,cantidad_adicional ,
								pro_subprocesos_id,num_lote,
								inv_prod_id,gral_empleados_id, elemento, inv_osal_id, agregado) 
								values(record1.id, 
								cantidad_calculada,
								0, 
								record1.pro_subprocesos_id, '',
								record2.inv_prod_id, usuario_ejecutor, record2.elemento,0, false);
						END LOOP;
					END IF;
					
				END LOOP;
				--------
				----terina el codigo para copiar la formula a pro_orden_detalle_mov
				--------
				
			END IF;
			

			
			
			--Para mandarla a producir
			IF str_data[8]='3' THEN

				--RAISE EXCEPTION '%' ,str_data[8];
				
				--Programada
				--update pro_proceso set pro_proceso_flujo_id=3  WHERE id=id_proceso;
				select pro_proceso_flujo_id from pro_proceso where id=id_proceso INTO ultimo_estatus_id;
				
				--Programada
				--update pro_proceso set pro_proceso_flujo_id=3  WHERE id=id_proceso;
				
				update pro_orden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor 
				 where id=str_data[4]::integer RETURNING id INTO ultimo_id;
				--observaciones=str_data[7],fecha_elavorar=str_data[6]::date
				
				-- validaciones para el grid --
				IF extra_data[1] != 'Sin Datos' THEN
					total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
					cont_fila:=1;
					FOR cont_fila IN 1 .. total_filas LOOP
						
						IF str_data[9]='especificaiocnes' THEN
							--eliminar_tmp+"___1
							--id_reg_tmp+"___2
							--inv_prod_id+"___3
							--subproceso_id___4
							--especificaciones___5
							--id_especificacion___6
							
							SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
							----aqui se vuelven a crear los registros
							
							IF str_filas[1] != '0' THEN
								
								--RAISE EXCEPTION '%' ,str_filas[2];
								
								IF str_filas[6] = '0' THEN
									SELECT INTO str_elemnts1 string_to_array(str_filas[5],'&&&');
									
									total_filas1:= array_length(str_elemnts1,1);--obtiene total de elementos del arreglo
									
									IF total_filas1 > 11 THEN
										
										--====== Insert de cuando no existeian lo instrumentos
										--INSERT INTO pro_orden_prod_subp_esp(fineza_inicial,viscosidads_inicial,viscosidadku_inicial ,viscosidadcps_inicial,densidad_inicial,
										--volatiles_inicial,cubriente_inicial,tono_inicial,brillo_inicial,dureza_inicial,adherencia_inicial,hidrogeno_inicial, 
										--fineza_final,viscosidads_final,viscosidadku_final ,viscosidadcps_final,densidad_final,volatiles_final,
										--cubriente_final,tono_final,brillo_final,dureza_final,adherencia_final,hidrogeno_final, 
										--inv_prod_id, nivel_form, pro_orden_prod_det_id, pro_subprocesos_id) 
										--values(str_elemnts1[1]::double precision, str_elemnts1[2]::double precision, str_elemnts1[3]::double precision, str_elemnts1[4]::double precision, str_elemnts1[5]::double precision,
										--str_elemnts1[6]::double precision, str_elemnts1[7]::double precision, str_elemnts1[8]::double precision, str_elemnts1[9]::double precision, str_elemnts1[10], str_elemnts1[11]::double precision,
										--str_elemnts1[12]::double precision, 
										--str_elemnts1[13]::double precision, str_elemnts1[14]::double precision, str_elemnts1[15]::double precision, str_elemnts1[16]::double precision, str_elemnts1[17]::double precision,
										--str_elemnts1[18]::double precision, str_elemnts1[19]::double precision, str_elemnts1[20]::double precision, str_elemnts1[21]::double precision, str_elemnts1[22], str_elemnts1[23]::double precision,
										--str_elemnts1[24]::double precision, 
										--str_filas[3]::integer, 1, str_filas[2]::integer, str_filas[4]::integer);
										--RAISE EXCEPTION '%' ,calculo_con_densidad;
										--====Insert con instrumentos
										
										
										INSERT INTO pro_orden_prod_subp_esp(fineza_inicial,viscosidads_inicial,viscosidadku_inicial ,viscosidadcps_inicial,densidad_inicial,
										volatiles_inicial,cubriente_inicial,tono_inicial,brillo_inicial,dureza_inicial,adherencia_inicial,hidrogeno_inicial, 
										
										pro_instrumentos_fineza,pro_instrumentos_viscosidad1,pro_instrumentos_viscosidad2,pro_instrumentos_viscosidad3,
										pro_instrumentos_densidad,pro_instrumentos_volatil,pro_instrumentos_cubriente,pro_instrumentos_tono,
										pro_instrumentos_brillo,pro_instrumentos_dureza,pro_instrumentos_adherencia,pro_instrumentos_hidrogeno,
										
										inv_prod_id, nivel_form, pro_orden_prod_det_id, pro_subprocesos_id) 
										values(str_elemnts1[1]::double precision, str_elemnts1[2]::double precision, str_elemnts1[3]::double precision, str_elemnts1[4]::double precision, str_elemnts1[5]::double precision,
										str_elemnts1[6]::double precision, str_elemnts1[7]::double precision, str_elemnts1[8]::double precision, str_elemnts1[9]::double precision, str_elemnts1[10], str_elemnts1[11]::double precision,
										str_elemnts1[12]::double precision, 
										
										str_elemnts1[13]::smallint, str_elemnts1[14]::smallint, str_elemnts1[15]::smallint, str_elemnts1[16]::smallint, str_elemnts1[17]::smallint,
										str_elemnts1[18]::smallint, str_elemnts1[19]::smallint, str_elemnts1[20]::smallint, str_elemnts1[21]::smallint, str_elemnts1[22]::smallint, str_elemnts1[23]::smallint,
										str_elemnts1[24]::smallint, 
										
										str_filas[3]::integer, 1, str_filas[2]::integer, str_filas[4]::integer);
										
									END IF;
								ELSE
									SELECT INTO str_elemnts1 string_to_array(str_filas[5],'&&&');
									
									total_filas1:= array_length(str_elemnts1,1);--obtiene total de elementos del arreglo
									
									IF total_filas1 > 11 THEN
										
										--RAISE EXCEPTION '%' ,str_filas[6];
										--##Update despues de que se in tegraron los instrumentos
										update pro_orden_prod_subp_esp set 
										fineza_inicial=str_elemnts1[1]::double precision,viscosidads_inicial=str_elemnts1[2]::double precision,viscosidadku_inicial=str_elemnts1[3]::double precision ,viscosidadcps_inicial=str_elemnts1[4]::integer,densidad_inicial=str_elemnts1[5]::double precision
										,volatiles_inicial=str_elemnts1[6]::double precision,
										cubriente_inicial=str_elemnts1[7]::double precision,tono_inicial=str_elemnts1[8]::double precision,brillo_inicial=str_elemnts1[9]::double precision,dureza_inicial=str_elemnts1[10],adherencia_inicial=str_elemnts1[11]::double precision,hidrogeno_inicial=str_elemnts1[12]::double precision, 
										pro_instrumentos_fineza=str_elemnts1[13]::smallint,pro_instrumentos_viscosidad1=str_elemnts1[14]::smallint,pro_instrumentos_viscosidad2=str_elemnts1[15]::smallint,pro_instrumentos_viscosidad3=str_elemnts1[16]::smallint,
										pro_instrumentos_densidad=str_elemnts1[17]::smallint,pro_instrumentos_volatil=str_elemnts1[18]::smallint,pro_instrumentos_cubriente=str_elemnts1[19]::smallint,pro_instrumentos_tono=str_elemnts1[20]::smallint,
										pro_instrumentos_brillo=str_elemnts1[21]::smallint,pro_instrumentos_dureza=str_elemnts1[22]::smallint,pro_instrumentos_adherencia=str_elemnts1[23]::smallint,pro_instrumentos_hidrogeno=str_elemnts1[24]::smallint 
										where id=str_filas[6]::integer;
										
									END IF;
								END IF;
							ELSE
								IF str_filas[6] != '0' THEN
									delete from pro_orden_prod_subp_esp where id=str_filas[6]::integer;
								END IF;
							END IF;
							
						ELSE
							IF str_data[9]='lotes' THEN
								
									--eliminar_tmp+"___"+--1
									--id_reg_tmp+"___"+--2
									--id_prod_detalle_tmp+"___"+--3
									--cantidad_elemento_tmp+"___"+--4
									--cantidad_adicional_tmp+"___"+--5
									--lote_tmp--6
									--inv_prod_id_elemento_tmp--7
									--id_reg_parent--8
									--$subproceso_id--9
									--id_reg_tmp+"___"+--10
									--inv_osal_id+"___"+--11
									
									--SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
									----aqui se vuelven a crear los registros
									SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
									
									IF str_filas[6] = ' ' THEN
										str_filas[6] := '';
									END IF;
									
									IF str_filas[11] = '0' THEN
										
										IF str_filas[1] != '0' THEN
											
											IF str_filas[10] = '0' THEN
												
												select count(id) as cantidad from pro_orden_detalle_mov where pro_orden_prod_det_id=str_filas[8]::integer INTO cont_fila1;
												IF str_filas[14] = '1' THEN
													--RAISE EXCEPTION '%' ,str_filas[14];
													str_filas[14] := 'true';--PAra cuando es un producto agregado
												ELSE
													str_filas[14] := 'false';--PAra cuando es un equivalente o un producto de la formula
												END IF;
												--RAISE EXCEPTION '%' ,str_filas[8];
												INSERT INTO pro_orden_detalle_mov(pro_orden_prod_det_id,cantidad,cantidad_adicional ,
												pro_subprocesos_id,num_lote,
												inv_prod_id,gral_empleados_id, elemento, inv_osal_id, inv_alm_id,gral_suc_id, agregado) 
												values(str_filas[8]::integer, str_filas[4]::double precision,
												str_filas[5]::double precision, 
												str_filas[9]::integer, str_filas[6],
												str_filas[3]::integer, usuario_ejecutor, (cont_fila1+1), str_filas[11]::integer, 
												str_filas[12]::integer, str_filas[13]::integer, str_filas[14]::boolean);
												--RAISE EXCEPTION '%' ,str_filas[14];
												--ALTER TABLE pro_orden_detalle_mov ADD COLUMN gral_suc_id integer NOT NULL DEFAULT 0;
												
												crear_inv_osal := 1;--si se crerara una orden de salida
											ELSE
												--RAISE EXCEPTION '%' ,str_filas[10];
												
												update pro_orden_detalle_mov set cantidad_adicional=str_filas[5]::double precision,cantidad=str_filas[4]::double precision, 
												num_lote=str_filas[6],gral_empleados_id= usuario_ejecutor, inv_alm_id=str_filas[12]::integer, gral_suc_id=str_filas[13]::integer where 
												id=str_filas[10]::integer;
												--
												crear_inv_osal := 1;--si se crerara una orden de salida
												
											END IF;
										ELSE
											IF str_filas[10] != '0' THEN
												delete from pro_orden_detalle_mov where id=str_filas[10]::integer;
											END IF;
										END IF;
									ELSE
										--cont_fila
										--aqui para hacer cambios cunado ya esta en orden de salida
										----INSERT INTO pro_orden_detalle_mov(pro_orden_prod_det_id,cantidad,cantidad_adicional ,
										----	pro_subprocesos_id,num_lote,
										----	inv_prod_id,gral_empleados_id, elemento, inv_osal_id) 
										----	values(str_filas[8]::integer, str_filas[4]::double precision,
										----	str_filas[5]::double precision, 
										----	str_filas[9]::integer, str_filas[6],
										----	str_filas[3]::integer, usuario_ejecutor, cont_fila, str_filas[11]::integer);
										--RAISE EXCEPTION '%' ,str_filas[11]::integer;
										--update pro_orden_detalle_mov set cantidad_adicional=str_filas[5]::double precision,cantidad=str_filas[4]::double precision, 
										--num_lote=str_filas[6],gral_empleados_id= usuario_ejecutor where 
										--id=str_filas[10]::integer;
										
									END IF;	
									
							END IF;
							
						END IF;
						
					END LOOP;
				END IF;	
				
				
				--RAISE EXCEPTION '%' ,crear_inv_osal;
				--para generar la orden de traspaso de la materia prima para la orden de produccion.
				IF str_data[9]='lotes' THEN 
					--campo agregado para guardar el almacen de el cual seleccionaron
					--ALTER TABLE pro_orden_detalle_mov ADD COLUMN inv_alm_id integer NOT NULL DEFAULT 0;
					
					IF crear_inv_osal = 1 THEN
						
						--Query para Generar las ordendes de traspasos de acuerdo a las materias prmias seleccionadas para al orden de produccion (Stable)
						str_select1:='
						select 
							pro_det.id,
							pro_det.inv_prod_id, 
							pro_det.cantidad,
							pro_det.cantidad_adicional,
							inv_prod.densidad, 
							inv_prod.unidad_id, 
							pro_det.inv_alm_id, 
							pro_det.gral_suc_id, 
							pro_det.agregado, 
							inv_prod.inv_prod_presentacion_id, 
							pres.cantidad  as cant_eq_pres, 
							inv_prod_unidades.decimales,
							''''::character varying AS folio_op   
						from ( select id from pro_orden_prod_det where pro_orden_prod_id='||str_data[4]::integer||' ) as ord_det 
						join pro_orden_detalle_mov as pro_det on pro_det.pro_orden_prod_det_id=ord_det.id 
						join inv_prod on inv_prod.id=pro_det.inv_prod_id 
						join inv_prod_unidades on inv_prod_unidades.id=inv_prod.unidad_id  
						left join inv_prod_presentaciones as pres on pres.id=inv_prod.inv_prod_presentacion_id 
						where pro_det.inv_osal_id=0 order by inv_alm_id;';
						
						--select * from pro_orden_detalle_mov limit 10
						--RAISE EXCEPTION '%' ,str_select1;
						
						id_almacen_partida := 0;
						
						FOR record1 IN EXECUTE (str_select1) LOOP 
							IF id_almacen_partida <> record1.inv_alm_id THEN 
								id_almacen_partida := record1.inv_alm_id;
								
								id_tipo_consecutivo:=29;--Folio Traspaso
								
								--aqui entra para tomar el consecutivo del folio  la sucursal actual
								UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
								WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
								
								--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del traspaso
								folio1 := prefijo_consecutivo || nuevo_consecutivo::character varying;

								--Obtener el folio de la Orden de Produccion para agregar la Orden de Traspaso
								SELECT folio FROM pro_orden_prod WHERE id=str_data[4]::integer INTO record1.folio_op;
								IF record1.folio_op IS NULL THEN record1.folio_op:=''; END IF;
								
								
								INSERT INTO inv_tras
								(
									folio,--folio1,
									fecha_traspaso,--str_data[10]::date,
									gral_suc_id_origen,--str_data[5]::integer,
									inv_alm_id_origen,--str_data[6]::integer,
									gral_suc_id_destino,--str_data[7]::integer,
									inv_alm_id_destino,--str_data[8]::integer,
									observaciones,--str_data[9],
									momento_creacion,--espacio_tiempo_ejecucion,
									gral_emp_id,--emp_id,
									gral_suc_id,--suc_id,
									gral_usr_id_creacion--usuario_ejecutor
								)
								--1 sucursal
								VALUES (folio1, now()::date, record1.gral_suc_id, record1.inv_alm_id,1, id_almacen, 'Traspaso para Orden de Produccion '||record1.folio_op, espacio_tiempo_ejecucion, emp_id, suc_id, usuario_ejecutor)
								RETURNING id INTO ultimo_id;
								
								--********************************************************************************************************
								--GENERA REGISTRO PARA ORDEN DE TRASPASO(inv_otras)
								id_tipo_consecutivo:=30;--Folio Orden de Traspaso
								
								--aqui entra para tomar el consecutivo del folio  la sucursal actual
								UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
								WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
								
								--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio dela Orden de Traspaso
								folio2 := prefijo_consecutivo || nuevo_consecutivo::character varying;
								
								--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
								
								INSERT INTO inv_otras(folio, fecha, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion, inv_tras_id, observaciones)
								VALUES (folio2, now()::date, record1.gral_suc_id, record1.inv_alm_id, 1, id_almacen, espacio_tiempo_ejecucion, emp_id, suc_id, usuario_ejecutor, ultimo_id, 'Orden de Traspaso para Orden de Produccion '||record1.folio_op)
								RETURNING id INTO ultimo_id2;
								
								--********************************************************************************************************
								
								
								tipo_movimiento_id := 7;--SALIDA POR TRASPASO
								
								--Genera registro del movimiento SALIDA POR TRASPASO
								INSERT INTO inv_mov(
									referencia,--folio1,
									inv_mov_tipo_id,--tipo_movimiento_id,
									fecha_mov,--str_data[10]::date,
									observacion,--str_data[9],
									momento_creacion,--espacio_tiempo_ejecucion,
									gral_usr_id,--usuario_ejecutor,
									gral_app_id --app_selected
								) 
								VALUES(folio1, tipo_movimiento_id, now()::date, 'Salida por traspaso de produccion', espacio_tiempo_ejecucion, usuario_ejecutor, app_selected) 
								RETURNING id INTO identificador_nuevo_movimiento;
								
								tipo_movimiento_id := 3;--ENTRADA TRASPASO
								
								--genera registro del movimiento
								INSERT INTO inv_mov(
									referencia,--folio1,
									inv_mov_tipo_id,--tipo_movimiento_id,
									fecha_mov,--str_data[10]::date,
									observacion,--str_data[9],
									momento_creacion,--espacio_tiempo_ejecucion,
									gral_usr_id,--usuario_ejecutor,
									gral_app_id --app_selected
								) 
								VALUES(folio1, tipo_movimiento_id, now()::date, 'Entrada por raspaso de produccion', espacio_tiempo_ejecucion, usuario_ejecutor, app_selected) 
								RETURNING id INTO identificador_nuevo_movimiento_entrada;
								
								insert into pro_ordenprod_invosal(pro_orden_prod_id, inv_osal_id, agregado) 
								values(str_data[4]::integer, ultimo_id2, record1.agregado);
								
								--Se quito lo de orden de salida, por la orden de traspaso (Cambio de ultimo momento)
							END IF;
							
							--Pasar todo a quilos
							--Inicia para calcular cantidad, tomando en cuenta la densidad
							----calculo_con_densidad_elemento := 0;
							--para verificar si la unidad de medida, viene en kilos o litros
							
							EXECUTE 'select titulo from inv_prod_unidades where id='||record1.unidad_id||'' INTO titulo_unidad;
							EXECUTE 'select '''||titulo_unidad||''' ~* ''KILO*'';' INTO match_cadena;
							
							IF record1.cantidad_adicional = 0 THEN
								
								--todos los pedidos, se tienen que hacer en kilos
								IF match_cadena = false THEN
									record1.cantidad := record1.cantidad / record1.densidad;
								END IF;
								
								cantidad_calculada = round(record1.cantidad::numeric, 4)::double precision;
								
								--crear registro en orden salida detalle (Comentado, por que ya no se genera orden de salida en produccion)
								--INSERT INTO inv_osal_detalle(inv_osal_id,inv_prod_id,inv_prod_presentacion_id,cantidad,precio_unitario) 
								--VALUES(id_osal,record1.inv_prod_id,0,cantidad_calculada,costo_promedio_actual);
								
							ELSE
								--todos los pedidos, se tienen que hacer en kilos
								IF match_cadena = false THEN
									record1.cantidad_adicional := record1.cantidad_adicional / record1.densidad;
								END IF;
								
								cantidad_calculada = round(record1.cantidad_adicional::numeric, 4)::double precision;
								
							END IF;
							
							--Termina para calcular cantidad, tomando en cuenta la densidad
							----reservar cantidad para el  pedido
							
							--Calcula la cantidad en la unidad de medida de el producto por default
							cantidad_presentacion := round((cantidad_calculada / record1.cant_eq_pres)::numeric,record1.decimales)::double precision;
							--round((cantidad_presentacion)::numeric,record1.decimales)::double precision
							
							--crear registro en detalles de traspaso
							INSERT INTO inv_tras_det(inv_tras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id) 
							VALUES(ultimo_id, record1.inv_prod_id,cantidad_calculada, record1.inv_prod_presentacion_id);--cantidad
							
							--inv_prod.inv_prod_presentacion_id 
							--crea registro para detalles Orden de Traspaso
							INSERT INTO inv_otras_det(inv_otras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id) 
							VALUES(ultimo_id2, record1.inv_prod_id,cantidad_calculada, record1.inv_prod_presentacion_id);
							
							--obtener el costo promedio actual del producto
							SELECT * FROM inv_obtiene_costo_promedio_actual(record1.inv_prod_id, espacio_tiempo_ejecucion) INTO precio_unitario;
							--IF record1.inv_prod_id = 1111 THEN
							--	RAISE EXCEPTION '%' ,'sql_select: '||'SELECT * FROM inv_obtiene_costo_promedio_actual('||record1.inv_prod_id||','''|| espacio_tiempo_ejecucion||''')';
							--END IF;
							
							--***** RESGISTRAR SALIDA *********************
							--genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id)
							VALUES(identificador_nuevo_movimiento, record1.inv_alm_id ,id_almacen, record1.inv_prod_id, cantidad_calculada, precio_unitario, record1.inv_prod_presentacion_id);
							
							--query para descontar producto de existencias
							sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||record1.cantidad||'),momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
							WHERE inv_alm_id='||record1.inv_alm_id ||' AND inv_prod_id='||record1.inv_prod_id||' AND ano='||ano_actual;
							EXECUTE sql_update;
							
							IF controla_presentacion = true THEN
								--buscar Registro de la Presentacion en el Almacen Destino
								SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres 
								WHERE inv_exi_pres.inv_alm_id=record1.inv_alm_id AND 
								inv_exi_pres.inv_prod_id=record1.inv_prod_id AND inv_exi_pres.inv_prod_presentacion_id=record1.inv_prod_presentacion_id 
								INTO exis;
								
								IF exis > 0 THEN
									--cantidad_presentacion
									--Sumar existencia de la presentacion
									UPDATE inv_exi_pres SET salidas=(salidas::double precision + cantidad_presentacion::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor  
									WHERE inv_alm_id = record1.inv_alm_id AND inv_prod_id = record1.inv_prod_id AND inv_prod_presentacion_id = record1.inv_prod_presentacion_id;
								ELSE
									--aqui entra para CREAR registro en inv_exi
									INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
									VALUES(record1.inv_alm_id, record1.inv_prod_id, record1.inv_prod_presentacion_id, cantidad_presentacion::double precision, espacio_tiempo_ejecucion, usuario_ejecutor);
								END IF;
							END IF;
							
							
							--***** RESGISTRAR ENTRADA *********************
							--genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id)
							VALUES(identificador_nuevo_movimiento_entrada, record1.inv_alm_id ,id_almacen, record1.inv_prod_id, cantidad_calculada, precio_unitario, record1.inv_prod_presentacion_id);
							
							sql_select := '';
							--query para verificar existencia del producto en el almacen y en el a√±o actual
							sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||record1.inv_prod_id||' AND inv_alm_id = '||id_almacen||' AND ano = '||ano_actual;
							EXECUTE sql_select INTO exis;
							
							--Afecta inv_exi y reserva la materia prima
							IF exis > 0 THEN
								------UPDATE inv_exi SET reservado=(reservado + cantidad_calculada) WHERE inv_prod_id=record1.inv_prod_id AND inv_alm_id=id_almacen AND ano=ano_actual;
								------UPDATE inv_exi SET reservado=(reservado + cantidad_calculada) WHERE inv_prod_id=record1.inv_prod_id AND inv_alm_id=id_almacen AND ano=ano_actual;
								
								--aqui entra para ACTUALIZAR registro en inv_exi
								sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||cantidad_calculada||'::double precision), costo_ultimo_'||mes_actual||'='||precio_unitario||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
								WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||record1.inv_prod_id||' AND ano='||ano_actual||';';
								EXECUTE sql_update;
								
								--Aumenta la cantidad reservada en esze almacen
								UPDATE inv_exi SET reservado=(reservado + cantidad_calculada) WHERE inv_prod_id=record1.inv_prod_id AND 
								inv_alm_id=id_almacen AND ano=ano_actual;
							ELSE
								--aqui entra para CREAR registro en inv_exi
								sql_insert:='INSERT INTO inv_exi (inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial, costo_ultimo_'||mes_actual||') '||
								'VALUES('||record1.inv_prod_id||','||id_almacen||','||ano_actual||','||cantidad_calculada||','''|| espacio_tiempo_ejecucion ||''',0,'||precio_unitario||' );';
								EXECUTE sql_insert;
								
								--Aumenta la cantidad reservada en ese almacen
								UPDATE inv_exi SET reservado=(reservado + cantidad_calculada) WHERE inv_prod_id=record1.inv_prod_id AND 
								inv_alm_id=id_almacen AND ano=ano_actual;
							END IF;
							
							IF controla_presentacion = true THEN
								--buscar Registro de la Presentacion en el Almacen Destino
								SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres 
								WHERE inv_exi_pres.inv_alm_id=id_almacen AND 
								inv_exi_pres.inv_prod_id=record1.inv_prod_id AND inv_exi_pres.inv_prod_presentacion_id=record1.inv_prod_presentacion_id 
								INTO exis;
								
								--Esto se tiene que eliminar
								--Aumenta la cantidad reservada en esze almacen
								--UPDATE inv_exi SET reservado=(reservado + cantidad_calculada) WHERE inv_prod_id=record1.inv_prod_id AND 
								--inv_alm_id=id_almacen AND ano=ano_actual;
								
								IF exis > 0 THEN
									--cantidad_presentacion
									--Sumar existencia de la presentacion
									UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantidad_presentacion::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor  
									WHERE inv_alm_id = id_almacen AND inv_prod_id = record1.inv_prod_id AND inv_prod_presentacion_id = record1.inv_prod_presentacion_id;
								ELSE
									--aqui entra para CREAR registro en inv_exi
									INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
									VALUES(id_almacen, record1.inv_prod_id, record1.inv_prod_presentacion_id, cantidad_presentacion::double precision, espacio_tiempo_ejecucion, usuario_ejecutor);
								END IF;
								
								UPDATE inv_exi_pres SET reservado = (reservado::double precision +  cantidad_presentacion::double precision)::double precision
								WHERE inv_alm_id=id_almacen  
								AND inv_prod_id=record1.inv_prod_id 
								AND inv_prod_presentacion_id=record1.inv_prod_presentacion_id;
								
							END IF;
							
							--actualizar la orden de salida que se genero
							--inv_osal_id almacena el id de la orden de traspaso, en vez de la orden de salida, por la nueva version
							UPDATE pro_orden_detalle_mov set inv_osal_id=ultimo_id2 where id=record1.id;
							
							--reiniciamos el valor de la variable exis a cero
							--exis:=0;
							
						END LOOP;
						
					END IF;
				END IF;
			END IF;
			
			--Guarda los productos, de la formula, sin enviar la requisicion (3 cambios de ultimo momento, sin probar al 100%), 
			IF str_data[8]='6' THEN
				
				--guarda los productos para la requisicion final para la orden de produccion
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--eliminar_tmp+"___"+1
					--id_reg_requisicion+"___"+2
					--id_prod_requisicion+"___"+3
				       --cantidad_requisicion+"___"+4
				       --existencia_requisicion+"";5
				       --elemento+"";6
				       --pro_orden_prod_det_id+"";7
					--pro_subprocesos_id+"";8
					
					IF str_filas[1] = '1' THEN
						
						IF str_filas[2] = '0' THEN
							--RAISE EXCEPTION '%' ,str_filas[12];
							IF str_filas[12] is null THEN
								str_filas[12] := '0';
							END IF;
							INSERT INTO pro_orden_detalle_mov(pro_orden_prod_det_id,cantidad,cantidad_adicional ,
							pro_subprocesos_id,
							inv_prod_id,gral_empleados_id, elemento, inv_osal_id, inv_alm_id) 
							values(str_filas[7]::integer, str_filas[4]::double precision,
							0, 
							str_filas[8]::integer,
							str_filas[3]::integer, usuario_ejecutor,str_filas[6]::integer, 0, str_filas[12]::integer);
						ELSE
						--	UPDATE pro_orden_detalle_mov SET cantidad=str_filas[4]::double precision where str_filas[2]::integer;
						END IF;
					ELSE
						--si en el gris se elimino el producto, aqui lo elimina de la tabla
						delete from pro_orden_detalle_mov where id=str_filas[2]::integer;
					END IF;
				END LOOP;
				
				----cambia el estatus a produccion de la orden
				update pro_proceso set pro_proceso_flujo_id=3  WHERE id=id_proceso;
			END IF;
			
			
			
			--Guarda las cantidades que se utilizaron en la orden de produccion.
			IF str_data[8]='9' THEN
				
				--guarda los productos para la requisicion final para la orden de produccion
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				
				FOR cont_fila IN 1 .. total_filas LOOP
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					--eliminar_tmp+"___"+1
					--id_reg_requisicion+"___"+2
					--id_prod_requisicion+"___"+3
				       --cantidad_requisicion+"___"+4
				       --existencia_requisicion+"";5
				       --elemento+"";6
				       --pro_orden_prod_det_id+"";7
					--pro_subprocesos_id+"";8
					
					--eliminar_tmp+"___"+--1
					--id_reg_tmp+"___"+--2
					--id_prod_detalle_tmp+"___"+ --3
					--cantidad_elemento_tmp+"___"+--4
					--cantidad_adicional_tmp+"___"+--5
					--lote_tmp+"___"+//inv_osal_id--6
					--inv_prod_id_elemento_tmp+"___"+--7
					--id_reg_parent+"___"+--8
					--$subproceso_id.val()+"___"+--9
					--id_reg_det+"___"+--10
					--inv_osal_id+"___"+--11
					--almacen_id+"___"+--12
					--sucursal_id+"___"+--13
					--agregado+"___"+--14
					--cantidad_real_tmp--15
					
					--RAISE EXCEPTION '%' ,'cont_fila: '||cont_fila;
					--IF cont_fila=4 THEN 
						--RAISE EXCEPTION '%' ,'fila'||cont_fila||': '||extra_data[cont_fila];
					--END IF;
					
					
					IF str_filas[1] = '1' THEN
						
						IF str_filas[2] <> '0' THEN
							--RAISE EXCEPTION '%' ,str_filas[12];
							--Convierte la cantidad en base  a la unidad de medida de el producto
							SELECT unidad_id, densidad, (CASE WHEN inv_prod_presentacion_id IS NULL THEN 0 ELSE inv_prod_presentacion_id END) AS id_pres FROM inv_prod where id=str_filas[3]::integer AND empresa_id=emp_id AND borrado_logico=false INTO id_unidad, densidad_tmp, idPresDefault;
							--RAISE EXCEPTION '%' ,'id_unidad: '||id_unidad||'   densidad_tmp: '||densidad_tmp;
							
							--Calcula la cantidad en base a la unidad de medida de el producto
							EXECUTE 'select titulo from inv_prod_unidades where id='||id_unidad||'' INTO titulo_unidad;
							EXECUTE 'select '''||titulo_unidad||''' ~* ''KILO*'';' INTO match_cadena;
							--RAISE EXCEPTION '%' ,'titulo_unidad: '||titulo_unidad||'   match_cadena: '||match_cadena;
							
							calculo_con_densidad := 0;
							IF match_cadena = true THEN
								calculo_con_densidad := str_filas[15]::double precision;
							ELSE
								calculo_con_densidad := round((str_filas[15]::double precision/densidad_tmp)::numeric, 4)::double precision;
							END IF;
							--str_filas[15]::double precision
							/*
							IF str_filas[6]='0000002828' THEN
								RAISE EXCEPTION '%' ,'round(('||str_filas[15]||'::double precision/'||densidad_tmp||')::numeric, 4)::double precision;';
							END IF; 
							*/
							
							IF idProductoActual<>str_filas[3]::integer THEN 
								idProductoActual:=str_filas[3]::integer;
								sumaCantidadUsada:=0;
								sumaCantidadUsada:=calculo_con_densidad;
							ELSE
								sumaCantidadUsada:=sumaCantidadUsada + calculo_con_densidad::double precision;
							END IF;
							
							--Redondear cantidad usada
							sumaCantidadUsada:=round((sumaCantidadUsada)::numeric, 4)::double precision;

							/*
							IF str_filas[6]='00000033E9' THEN
								RAISE EXCEPTION '%' ,'sumaCantidadUsada:'||sumaCantidadUsada||' | cantTraspasoAnterior:'||cantTraspasoAnterior;
							END IF; 
							*/
							
							SELECT count(id) 
							from pro_orden_mp_usado 
							where inv_otras_id=str_filas[11]::integer 
							AND inv_otras_det_id=str_filas[2]::integer 
							AND inv_prod_id=str_filas[3]::integer  
							INTO exis;
							
							--IF str_filas[6]='0000002828' THEN
								--RAISE EXCEPTION '%' ,'exis: '||exis;
								--RAISE EXCEPTION '%' ,'str_filas[2]::integer: '||str_filas[2]::integer;
								--RAISE EXCEPTION '%' ,'calculo_con_densidad: '||calculo_con_densidad;
							--END IF; 
							
							
							
							--RAISE EXCEPTION '%' ,str_filas[11]::integer;
							--Se guardan las cantidades en kilos
							IF exis > 0 THEN 
								UPDATE pro_orden_mp_usado SET cantidad_usada=sumaCantidadUsada WHERE inv_otras_det_id = str_filas[2]::integer;
							ELSE
								INSERT INTO pro_orden_mp_usado(cantidad_usada, inv_otras_id, inv_otras_det_id, inv_prod_id) 
								values(sumaCantidadUsada, str_filas[11]::integer,str_filas[2]::integer, str_filas[3]::integer);
							END IF;
							
							--Inicializar valor
							cantTraspasoAnterior:=0.0;
							
							--Buscar la cantidad del trapaso guardado anteriormente
							--SELECT cantidad_tras FROM inv_otras_det WHERE id=str_filas[2]::integer INTO cantTraspasoAnterior;
							SELECT * FROM (
								SELECT  inv_lote_mov_det.cantidad AS cantidad_tras,
									--inv_otras_det.cantidad_tras, 
									inv_otras.inv_tras_id AS id_tras,
									''::character varying AS folio_tras,
									inv_tras_det.id AS id_tras_det,
									0::integer AS id_mov 
								FROM inv_otras_det 
								JOIN inv_otras ON inv_otras.id=inv_otras_det.inv_otras_id 
								JOIN inv_tras_det ON (inv_tras_det.inv_tras_id=inv_otras.inv_tras_id AND inv_tras_det.inv_prod_id=inv_otras_det.inv_prod_id)
								JOIN inv_lote_mov_det ON inv_lote_mov_det.referencia_det_id=inv_otras_det.id 
								JOIN inv_lote ON (inv_lote.id=inv_lote_mov_det.inv_lote_id  AND inv_lote.lote_int=str_filas[6])
								WHERE inv_otras_det.id=str_filas[2]::integer 
								LIMIT 1
							) AS sbt INTO record4;
							
							cantTraspasoAnterior:= record4.cantidad_tras;
							
							IF cantTraspasoAnterior IS NULL THEN cantTraspasoAnterior:=0; END IF;
							
							--RAISE EXCEPTION '%' ,'cont_fila:'||cont_fila;
							
							--Redondear cantidades
							cantTraspasoAnterior:=round((cantTraspasoAnterior)::numeric, 4)::double precision;
							calculo_con_densidad:=round((calculo_con_densidad)::numeric, 4)::double precision;
							
							/*
							Verificar que la cantidad del traspaso anterior no es cero, si es cero es nuevo, 
							por lo tanto no se debe aplicar los calculos posteriores.
							*/
							IF cantTraspasoAnterior>0 THEN 
								
			
								
								
								--Verifica si la Nueva cantidad es menor que la anterior.
								--Cuando la cantidad es menor  que la anterior, entonces se tiene que modificar todos los movimientos anteriores
								IF calculo_con_densidad < cantTraspasoAnterior THEN 
									--Buscar el Folio del Traspaso
									SELECT folio FROM inv_tras WHERE id=record4.id_tras INTO record4.folio_tras;
									
									--Calcular la diferencia
									cantDiferencia := cantTraspasoAnterior::double precision - calculo_con_densidad::double precision;
									cantDiferencia:=round((cantDiferencia)::numeric, 4)::double precision;
									
									--Actualizar el registro del Traspaso
									UPDATE inv_tras_det SET cantidad_tras=sumaCantidadUsada WHERE id=record4.id_tras_det;
									
									--Actualizar registro de inv_exi
									sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||cantDiferencia||'::double precision), momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
									WHERE inv_alm_id='||str_filas[12]::integer||' AND inv_prod_id='||str_filas[3]::integer||' AND ano='||ano_actual||';';
									EXECUTE sql_update;
									
									--Buscar ID del movimiento de Inventario de SALIDA
									--inv_mov_tipo_id=7;--SALIDA POR TRASPASO
									SELECT id FROM inv_mov WHERE referencia=record4.folio_tras AND inv_mov_tipo_id=7 LIMIT 1 INTO record4.id_mov;
									
									--Actualizar el registo del Movimiento de Salida por Traspaso
									UPDATE inv_mov_detalle SET cantidad=sumaCantidadUsada WHERE inv_mov_id=record4.id_mov AND producto_id=str_filas[3]::integer;
									--AND inv_prod_presentacion_id=idPresDefault
									

									--Inicializar Valores
									record4.id_mov:=0;
									
									
									--Buscar ID del movimiento de Inventario de ENTRADA
									--inv_mov_tipo_id=3;--ENTRADA TRASPASO
									SELECT id FROM inv_mov WHERE referencia=record4.folio_tras AND inv_mov_tipo_id=3 LIMIT 1 INTO record4.id_mov;
									
									/*
									Actualizar el registo del Movimiento de Entrada por Traspaso
									Se utiliza la sumaCantidadUsada, porque el registro solo se actualiza, si son dos o mas lotes,
									se actualizar√° varias veces quedando con la ultima suma que es la que nos interesa que se guarde
									*/
									UPDATE inv_mov_detalle SET cantidad=sumaCantidadUsada WHERE inv_mov_id=record4.id_mov AND producto_id=str_filas[3]::integer;
									--AND inv_prod_presentacion_id=idPresDefault
									
									
									
									/*
									Actualizar registro de la Orden de Traspaso cuando la nueva cantidad es menor que la anterior
									Se utiliza la sumaCantidadUsada, porque el registro solo se actualiza, si son dos o mas lotes,
									se actualizar√° varias veces quedando con la ultima suma que es la que nos interesa que se guarde
									*/
									UPDATE inv_otras_det SET cantidad_tras=sumaCantidadUsada  WHERE id=str_filas[2]::integer;
									
									--Obtener id del Lote 
									SELECT id FROM inv_lote WHERE inv_lote.lote_int=trim(str_filas[6]) INTO idLote;
									IF idLote IS NULL THEN idLote:=0; END IF;
									
									--Actualizar la existencia del Lote
									UPDATE inv_lote SET entradas=(entradas + cantDiferencia::double precision) WHERE id=idLote;
									
									--Actualizar registro del inv_lote_mov_det, esto actualizar√° origen y destino
									UPDATE inv_lote_mov_det SET cantidad = (cantidad - cantDiferencia::double precision )
									WHERE inv_lote_mov_det.referencia_det_id=str_filas[2]::integer;
									--AND inv_lote_mov_det.inv_lote_id=idLote;
									
									--RAISE EXCEPTION '%' ,'idLote: '||idLote||'     referencia_det_id: '||str_filas[2]::integer;
									
									IF controla_presentacion = true THEN
										cantPres:=0;
										equivalenciaPres:=0;
										
										--Buscar la equivalencia de la Presentacion
										SELECT cantidad  FROM inv_prod_presentaciones WHERE id=idPresDefault INTO equivalenciaPres;
										IF equivalenciaPres IS NULL THEN equivalenciaPres:=0; END IF;
										
										--Convertir la cantidad en su Equivalente a Presentaciones 
										cantPres := cantDiferencia::double precision / equivalenciaPres::double precision;
										
										--Redondear la cantidad de Presentaciones Asignado en la partida
										cantPres := round(cantPres::numeric,4)::double precision; 
										
										--Buscar Registro de la Presentacion en el Almacen Destino
										SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres WHERE inv_exi_pres.inv_alm_id=str_filas[12]::integer AND inv_exi_pres.inv_prod_id=str_filas[3]::integer AND inv_exi_pres.inv_prod_presentacion_id=idPresDefault 
										INTO exis;
										
										IF exis > 0 THEN 
											--Sumar existencia de la presentacion
											UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantPres::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor  
											WHERE inv_alm_id=str_filas[12]::integer AND inv_prod_id=str_filas[3]::integer AND inv_prod_presentacion_id=idPresDefault;
										ELSE
											--Aqui entra para CREAR registro en inv_exi
											INSERT INTO inv_exi_pres (inv_alm_id,inv_prod_id,inv_prod_presentacion_id,entradas,momento_creacion,gral_usr_id_creacion) 
											VALUES(str_filas[12]::integer,str_filas[3]::integer,idPresDefault,cantPres::double precision,espacio_tiempo_ejecucion,usuario_ejecutor);
										END IF;
										
									END IF;
								END IF;
								/*
								IF str_filas[6]='00000033E9' THEN
									RAISE EXCEPTION '%' ,'calculo_con_densidad:'||calculo_con_densidad||' | cantTraspasoAnterior:'||cantTraspasoAnterior||' | sumaCantidadUsada:'||sumaCantidadUsada;
								END IF;
								*/
							END IF;
							
						END IF;
						
					END IF;
					
				END LOOP;
				
				----cambia el estatus a produccion de la orden
				update pro_proceso set pro_proceso_flujo_id=3  WHERE id=id_proceso;
			END IF;
			
			
			
			--Para finalizar la orden de produccion
			IF str_data[8]='4' THEN
				
				--Actualizar la cantidad de la prden de produccion (Cambio de ultimo memento, sin probar al 100%)
				IF extra_data[1] != 'sin datos' THEN
					total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
					cont_fila:=1;
					FOR cont_fila IN 1 .. total_filas LOOP
						
						SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
						----aqui se vuelven a crear los registros
						
						IF str_filas[1] != '0' THEN
							
							IF str_filas[2] <> '0' THEN
								--RAISE EXCEPTION '%' ,str_filas[2];
								
								IF str_data[8] = '4' THEN 
									
									EXECUTE 'select titulo from inv_prod_unidades where id='||str_filas[8]::integer||'' INTO titulo_unidad;
									EXECUTE 'select '''||titulo_unidad||''' ~* ''KILO*'';' INTO match_cadena;
									
									IF str_filas[6] = str_filas[8] THEN
										IF match_cadena = true THEN
											calculo_con_densidad := str_filas[4]::double precision;
										ELSE
											calculo_con_densidad := str_filas[4]::double precision;--(str_filas[9]::double precision * str_filas[12]::double precision);
										END IF;
									ELSE
										--RAISE EXCEPTION '%' ,match_cadena;
										IF match_cadena = true THEN
											calculo_con_densidad := (str_filas[4]::double precision * str_filas[7]::double precision);
											--calculo_con_densidad := (str_filas[9]::double precision );
										ELSE
											calculo_con_densidad := (str_filas[4]::double precision / str_filas[7]::double precision);
										END IF;
									END IF;
									
									calculo_con_densidad := round((calculo_con_densidad)::numeric, 4)::double precision;
									
									update pro_orden_prod_det set cantidad=calculo_con_densidad where id=str_filas[2]::integer;
									
								END IF;
							END IF;
						END IF;
					END LOOP;
				END IF;
				--Termina la parte para actualizar la cantidad e la orden de produccion
				--
				
				nuevo_folio := '0';
				anterior_folio := '0';
				update pro_proceso set pro_proceso_flujo_id=4  WHERE id=id_proceso;

--AQUI SE OBTIENE EL COSTO ULTIMO ACTUAL :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::				


				--str_select1:= 'select * from pro_obtiene_costo_ultimo_actual(2, '||emp_id||','|| str_data[4]::integer||', now())';

				--RAISE EXCEPTION '%',str_select1;

				
				--Calcula el costo ultimo tomando en cuenta los productos de una orden de produccion
				select * from pro_obtiene_costo_ultimo_actual(2, emp_id, str_data[4]::integer, now()) INTO costo_ultimo_actual;

--AQUI SE OBTIENE EL COSTO ULTIMO ACTUAL :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

				--RAISE EXCEPTION '%','costo_ultimo_actual: '|| costo_ultimo_actual;

				
				update pro_orden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor,  costo_ultimo=costo_ultimo_actual 
				where id=str_data[4]::integer RETURNING id INTO ultimo_id;
				--observaciones=str_data[7],fecha_elavorar=str_data[6]::date
				
				--orden salida separa para lotes y descuenta para lotes
				--tengo que cerrar la orden de salida y descontar para lotes
				--al descontar de inv_exi
				--verifica si ya hay una orden de salida para este proceso de produccion
				SELECT count(prosal.pro_orden_prod_id) as cantidad 
				from pro_ordenprod_invosal as prosal 
				join inv_otras on (inv_otras.id=prosal.inv_osal_id and inv_otras.estatus=1) 
				where prosal.pro_orden_prod_id=str_data[4]::integer INTO exis;
				--RAISE EXCEPTION '%' ,costo_ultimo_actual;
				
				IF exis > 0 THEN 
					
					--Para enviar la requisicion de la orden de produccion a el almacen
					--str_data[4]::integer
					tipo_movimiento_id:=11;--SALIDA POR OORDEN DE PRODUCCION (Requesicion de la orden de produccion)
					
					
					--=========Record para hacer movimientos en inventarios de acuerdo a las requisiciones que se surtieron
					--extraer datos del detalle de  la prefactura
					--Verifica las odenes de traspaso 
					/*
					str_select1:= 'select inv_otras_det.inv_prod_id, sum(pro_orden_mp_usado.cantidad_usada) as cantidad
					, sum(inv_otras_det.cantidad_tras) as cantidad_inicial,
					inv_otras.folio,inv_otras.inv_alm_id_destino as inv_alm_id,
					inv_otras.gral_suc_id_origen, inv_otras.inv_alm_id_origen, inv_otras.gral_suc_id_destino, 
					inv_otras.inv_alm_id_destino
					 from  
					(select inv_osal_id from pro_ordenprod_invosal where pro_orden_prod_id='||str_data[4]::integer||') as prosal 
					join inv_otras on (inv_otras.id=prosal.inv_osal_id and inv_otras.estatus=1) 
					join inv_otras_det on inv_otras_det.inv_otras_id=prosal.inv_osal_id 
					JOIN pro_orden_mp_usado ON pro_orden_mp_usado.inv_otras_det_id= inv_otras_det.id  
					GROUP BY inv_otras_det.inv_prod_id, inv_otras.folio,
					    inv_otras.gral_suc_id_origen, inv_otras.inv_alm_id_origen, inv_otras.gral_suc_id_destino, 
					inv_otras.inv_alm_id_destino order by inv_otras.folio, inv_otras.inv_alm_id_origen';
					*/
					str_select1:= '';
					str_select1:= '
					select 
						inv_otras_det.inv_prod_id, 
						sum(pro_orden_mp_usado.cantidad_usada) as cantidad, 
						sum(inv_otras_det.cantidad_tras) as cantidad_inicial,
						inv_otras.folio,
						inv_otras.inv_alm_id_destino as inv_alm_id,
						inv_otras.gral_suc_id_origen, 
						inv_otras.inv_alm_id_origen, 
						inv_otras.gral_suc_id_destino, 
						inv_otras.inv_alm_id_destino, 
						inv_prod.inv_prod_presentacion_id, 
						presentaciones.cantidad as cant_eq_pres, 
						unidades.decimales 
					from (select inv_osal_id from pro_ordenprod_invosal where pro_orden_prod_id='||str_data[4]::integer||') as prosal 
					join inv_otras on (inv_otras.id=prosal.inv_osal_id and inv_otras.estatus=1) 
					join inv_otras_det on inv_otras_det.inv_otras_id=prosal.inv_osal_id 
					JOIN pro_orden_mp_usado ON pro_orden_mp_usado.inv_otras_det_id= inv_otras_det.id  
					join inv_prod on inv_prod.id=inv_otras_det.inv_prod_id 
					join inv_prod_presentaciones as presentaciones on presentaciones.id=inv_prod.inv_prod_presentacion_id 
					join inv_prod_unidades as unidades on unidades.id=inv_prod.unidad_id 
					GROUP BY inv_otras_det.inv_prod_id, inv_otras.folio, 
					inv_otras.gral_suc_id_origen, inv_otras.inv_alm_id_origen, inv_otras.gral_suc_id_destino, 
					inv_otras.inv_alm_id_destino, inv_prod.inv_prod_presentacion_id,presentaciones.cantidad, 
					unidades.decimales  order by inv_otras.folio, inv_otras.inv_alm_id_origen';
					
					--select * from inv_otras
					--RAISE EXCEPTION '%' ,str_select1;
					
					crear_inv_osal = 0;
					id_almacen_partida := 0;
					FOR record1 IN EXECUTE (str_select1) LOOP
						crear_inv_osal = 0;
						
						--Genera el encabezado de el trspaso
						IF (record1.cantidad < record1.cantidad_inicial) AND (id_almacen_partida <> record1.inv_alm_id_origen) THEN
							crear_inv_osal = 1;
							id_almacen_partida := record1.inv_alm_id_origen;
							
							id_tipo_consecutivo:=29;--Folio Traspaso
								
							--aqui entra para tomar el consecutivo del folio  la sucursal actual
							UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
							WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
							
							--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio del traspaso
							folio1 := prefijo_consecutivo || nuevo_consecutivo::character varying;
							
							INSERT INTO inv_tras
							(
								folio,--folio1,
								fecha_traspaso,--str_data[10]::date,
								gral_suc_id_origen,--str_data[5]::integer,
								inv_alm_id_origen,--str_data[6]::integer,
								gral_suc_id_destino,--str_data[7]::integer,
								inv_alm_id_destino,--str_data[8]::integer,
								observaciones,--str_data[9],
								momento_creacion,--espacio_tiempo_ejecucion,
								gral_emp_id,--emp_id,
								gral_suc_id,--suc_id,
								gral_usr_id_creacion--usuario_ejecutor
							)
							--1 sucursal
							VALUES (folio1, now()::date, record1.gral_suc_id_destino, record1.inv_alm_id_destino,record1.gral_suc_id_origen, record1.inv_alm_id_origen, 'Traspaso por devolucion de produccion', espacio_tiempo_ejecucion, emp_id, suc_id, usuario_ejecutor)
							RETURNING id INTO ultimo_id;
							
							--********************************************************************************************************
							--GENERA REGISTRO PARA ORDEN DE TRASPASO(inv_otras)
							id_tipo_consecutivo:=30;--Folio Orden de Traspaso
							
							--aqui entra para tomar el consecutivo del folio  la sucursal actual
							UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
							WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
							
							--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio dela Orden de Traspaso
							folio2 := prefijo_consecutivo || nuevo_consecutivo::character varying;
							
							INSERT INTO inv_otras(folio, fecha, gral_suc_id_origen, inv_alm_id_origen, gral_suc_id_destino, inv_alm_id_destino, momento_creacion, gral_emp_id, gral_suc_id, gral_usr_id_creacion, inv_tras_id)
							VALUES (folio2, now()::date, record1.gral_suc_id_destino, record1.inv_alm_id_destino, record1.gral_suc_id_origen, record1.inv_alm_id_origen, espacio_tiempo_ejecucion, emp_id, suc_id, usuario_ejecutor, ultimo_id)
							RETURNING id INTO ultimo_id2;
							
							--********************************************************************************************************
							
							
							tipo_movimiento_id := 7;--SALIDA POR TRASPASO
							
							--genera registro del movimiento SALIDA POR TRASPASO
							INSERT INTO inv_mov(
								referencia,--folio1,
								inv_mov_tipo_id,--tipo_movimiento_id,
								fecha_mov,--str_data[10]::date,
								observacion,--str_data[9],
								momento_creacion,--espacio_tiempo_ejecucion,
								gral_usr_id,--usuario_ejecutor,
								gral_app_id --app_selected
							) 
							VALUES(folio1, tipo_movimiento_id, now()::date, 'Salida por traspaso de produccion', espacio_tiempo_ejecucion, usuario_ejecutor, app_selected) 
							RETURNING id INTO identificador_nuevo_movimiento;
							
							tipo_movimiento_id := 3;--ENTRADA TRASPASO
							
							--genera registro del movimiento
							INSERT INTO inv_mov(
								referencia,--folio1,
								inv_mov_tipo_id,--tipo_movimiento_id,
								fecha_mov,--str_data[10]::date,
								observacion,--str_data[9],
								momento_creacion,--espacio_tiempo_ejecucion,
								gral_usr_id,--usuario_ejecutor,
								gral_app_id --app_selected
							) 
							VALUES(folio1, tipo_movimiento_id, now()::date, 'Entrada por raspaso de produccion', espacio_tiempo_ejecucion, usuario_ejecutor, app_selected) 
							RETURNING id INTO identificador_nuevo_movimiento_entrada;
							
						END IF;
						
						--Genera el cuerpo de el traspaso
						IF record1.cantidad < record1.cantidad_inicial THEN
							
							cantidad_calculada := (record1.cantidad_inicial - record1.cantidad);
							--RAISE EXCEPTION '%' ,3;
							--Calcula la cantidad en la unidad de medida de el producto por default
							cantidad_presentacion := round((cantidad_calculada / record1.cant_eq_pres)::numeric,record1.decimales)::double precision;
							--round((cantidad_presentacion)::numeric,record1.decimales)::double precision
							
							--RAISE EXCEPTION '%' ,record1.cant_eq_pres;
							
							--crear registro en detalles de traspaso
							INSERT INTO inv_tras_det(inv_tras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id ) 
							VALUES(ultimo_id, record1.inv_prod_id,cantidad_calculada, record1.inv_prod_presentacion_id);
							
							--crea registro para detalles Orden de Traspaso
							INSERT INTO inv_otras_det(inv_otras_id, inv_prod_id, cantidad_tras, inv_prod_presentacion_id) 
							VALUES(ultimo_id2, record1.inv_prod_id,cantidad_calculada, record1.inv_prod_presentacion_id);
							
							--obtener el costo promedio actual del producto
							SELECT * FROM inv_obtiene_costo_promedio_actual(record1.inv_prod_id, espacio_tiempo_ejecucion) INTO precio_unitario;
							/*(((((((((((((((((((((((( AQUI ME QUEDE ))))))))))))))))))))))))*/
							--***** RESGISTRAR SALIDA *********************
							--genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id) 
							VALUES(identificador_nuevo_movimiento, record1.inv_alm_id_destino ,record1.inv_alm_id_origen , record1.inv_prod_id, cantidad_calculada, precio_unitario, record1.inv_prod_presentacion_id);
							
							--query para descontar producto de existencias
							sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||cantidad_calculada||'),momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
							WHERE inv_alm_id='||record1.inv_alm_id_destino ||' AND inv_prod_id='||record1.inv_prod_id||' AND ano='||ano_actual;
							EXECUTE sql_update;
							IF controla_presentacion = true THEN
								
								--buscar Registro de la Presentacion en el Almacen Destino
								SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres 
								WHERE inv_exi_pres.inv_alm_id=record1.inv_alm_id_destino AND 
								inv_exi_pres.inv_prod_id=record1.inv_prod_id AND inv_exi_pres.inv_prod_presentacion_id=record1.inv_prod_presentacion_id 
								INTO exis;
								
								IF exis > 0 THEN
									--cantidad_presentacion
									--Sumar existencia de la presentacion
									UPDATE inv_exi_pres SET salidas=(salidas::double precision + cantidad_presentacion::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor  
									WHERE inv_alm_id = record1.inv_alm_id_destino AND inv_prod_id = record1.inv_prod_id AND inv_prod_presentacion_id = record1.inv_prod_presentacion_id;
								ELSE
									--aqui entra para CREAR registro en inv_exi
									INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
									VALUES(record1.inv_alm_id_destino, record1.inv_prod_id, record1.inv_prod_presentacion_id, cantidad_presentacion::double precision, espacio_tiempo_ejecucion, usuario_ejecutor);
								END IF;
								
							END IF;
							
							
							
							
							--***** RESGISTRAR ENTRADA *********************
							--genera registro en detalles del movimiento
							INSERT INTO inv_mov_detalle(inv_mov_id, alm_origen_id, alm_destino_id, producto_id, cantidad, costo, inv_prod_presentacion_id) 
							VALUES(identificador_nuevo_movimiento_entrada, record1.inv_alm_id_destino ,record1.inv_alm_id_origen, record1.inv_prod_id, cantidad_calculada, precio_unitario, record1.inv_prod_presentacion_id);
							
							sql_select := '';
							--query para verificar existencia del producto en el almacen y en el a√±o actual
							sql_select := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||record1.inv_prod_id||' AND inv_alm_id = '||id_almacen||' AND ano = '||ano_actual;
							EXECUTE sql_select INTO exis;
							
							
							--aqui entra para ACTUALIZAR registro en inv_exi
							sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||cantidad_calculada||'::double precision), costo_ultimo_'||mes_actual||'='||precio_unitario||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
							WHERE inv_alm_id='||record1.inv_alm_id_origen||' AND inv_prod_id='||record1.inv_prod_id||' AND ano='||ano_actual||';';
							EXECUTE sql_update;
							
							--Disminuye la cantidad reservada en ese almacen
							UPDATE inv_exi SET reservado=(reservado - cantidad_calculada) WHERE inv_prod_id=record1.inv_prod_id AND 
							inv_alm_id=record1.inv_alm_id_origen AND ano=ano_actual;
							
							IF controla_presentacion = true THEN
								--buscar Registro de la Presentacion en el Almacen Destino
								SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres 
								WHERE inv_exi_pres.inv_alm_id=record1.inv_alm_id_origen AND 
								inv_exi_pres.inv_prod_id=record1.inv_prod_id AND inv_exi_pres.inv_prod_presentacion_id=record1.inv_prod_presentacion_id 
								INTO exis;
								--RAISE EXCEPTION '%' ,record1.inv_alm_id_origen||' adds';
								
								IF exis > 0 THEN
									--cantidad_presentacion
									--Sumar existencia de la presentacion
									UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantidad_presentacion::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor  
									WHERE inv_alm_id = record1.inv_alm_id_origen AND inv_prod_id = record1.inv_prod_id AND inv_prod_presentacion_id = record1.inv_prod_presentacion_id;
								ELSE
									--aqui entra para CREAR registro en inv_exi
									INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
									VALUES(record1.inv_alm_id_origen, record1.inv_prod_id, record1.inv_prod_presentacion_id, cantidad_presentacion::double precision, espacio_tiempo_ejecucion, usuario_ejecutor);
								END IF;
								
								UPDATE inv_exi_pres SET reservado = (reservado::double precision +  cantidad_presentacion::double precision)::double precision
								WHERE inv_alm_id=record1.inv_alm_id_origen  
								AND inv_prod_id=record1.inv_prod_id 
								AND inv_prod_presentacion_id=record1.inv_prod_presentacion_id;
								
							END IF;
							
							
						END IF;
						
						
						/*==============  Da Salida a la requicicion de la materioa prima que en realidad se utilizo ============*/
						nuevo_folio := record1.folio;
						
						IF nuevo_folio != anterior_folio THEN
							
							anterior_folio := record1.folio;
							/*==============  Encabezado De la Salida a la requicicion de la materioa prima que en realidad se utilizo ============*/
							--Guarda en inv mov para la requisicion de la orden de produccion
							INSERT INTO inv_mov(observacion,momento_creacion, gral_usr_id, gral_app_id, inv_mov_tipo_id, referencia,fecha_mov) 
							values('',espacio_tiempo_ejecucion, usuario_ejecutor, app_selected, tipo_movimiento_id,nuevo_folio ,espacio_tiempo_ejecucion) 
							RETURNING id INTO id_invmov;
							
						END IF;
						
						/*==============  Detalle De la Salida a la requicicion de la materioa prima que en realidad se utilizo ============*/
						--obtener costo promedio actual del producto o materia prima que se utilizo en √±la formula
						SELECT * FROM inv_obtiene_costo_promedio_actual(record1.inv_prod_id, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
						
						--Guarda el detalle de inv_mov para la requisicion
						INSERT INTO inv_mov_detalle(producto_id, alm_origen_id, cantidad, inv_mov_id, costo, inv_prod_presentacion_id) 
						values(record1.inv_prod_id, id_almacen, record1.cantidad, id_invmov, costo_promedio_actual, record1.inv_prod_presentacion_id);
						
						--Quita lo reservado para la orden de rpoduccion, de el almacen de origen de la orden de produccion
						UPDATE inv_exi SET reservado=(reservado - record1.cantidad) WHERE inv_prod_id=record1.inv_prod_id 
						AND inv_alm_id=id_almacen AND ano=ano_actual;
						
						IF controla_presentacion = true THEN
							UPDATE inv_exi_pres SET reservado = (reservado::double precision -  cantidad_presentacion::double precision)::double precision
							WHERE inv_alm_id=id_almacen 
							AND inv_prod_id=record1.inv_prod_id 
							AND inv_prod_presentacion_id=record1.inv_prod_presentacion_id;
						END IF;
						
						--Seduenta los produtos de la existencia de el almacens de produccion,  para descontar producto de existencias
						sql_update := 'UPDATE inv_exi SET salidas_'||mes_actual||'=(salidas_'||mes_actual||' + '||record1.cantidad||'),
						momento_salida_'||mes_actual||'='''||espacio_tiempo_ejecucion||''' 
						WHERE inv_alm_id='||record1.inv_alm_id||' AND inv_prod_id='||record1.inv_prod_id||' AND ano='||ano_actual;
						
						EXECUTE sql_update;
						
						IF controla_presentacion = true THEN
							--cantidad_presentacion
							--Sumar existencia de la presentacion
							UPDATE inv_exi_pres SET salidas=(salidas::double precision + cantidad_presentacion::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor  
							WHERE inv_alm_id = record1.inv_alm_id AND inv_prod_id = record1.inv_prod_id AND inv_prod_presentacion_id = record1.inv_prod_presentacion_id;
						END IF;
						
					END LOOP;
					
					/*
					iisudasdua sdu asud asdgags d asudjhajsdn alsdmaAS$%
					4545$%$%/&/&/&/&%$¬∑"$%&/(/&%
					/(()/&%$¬∑$%&/()=(/&%$&/(&%$&/())/&%$¬∑$$%&/(
					%&/()(&/%&$¬∑$%%&/(/&%%$¬∑$$%&(/&&%$¬∑$%%&
					*/
					
					--=========Record para hacer registro de entradas y movimientos de inventarios de acuerdo a los productos que se produjeron en la orden de produccion
					/*str_select1:='select det_o.inv_prod_id, det_o.cantidad, orden.folio, orden.fecha_elavorar, orden.observaciones from pro_orden_prod as orden 
					join pro_orden_prod_det as det_o on det_o.pro_orden_prod_id=orden.id where orden.id='||str_data[4]::integer||' 
					group by det_o.inv_prod_id, det_o.cantidad, orden.folio, orden.fecha_elavorar, orden.observaciones';
					*/
					
					str_select1:='
					select 
						det_o.inv_prod_id, 
						det_o.cantidad, 
						orden.folio, 
						orden.fecha_elavorar, 
						orden.observaciones, 
						inv_prod.inv_prod_presentacion_id, 
						presentaciones.cantidad as cant_eq_pres, 
						unidades.decimales,
						unidades.id AS uni_prod,
						unidades.titulo AS titulo_unidad_prod,
						det_o.unidad_id AS uni_pro_orden,
						(CASE WHEN unidades.id<>det_o.unidad_id THEN (CASE WHEN upper(unidades.titulo) ILIKE ''%KILO%'' THEN det_o.cantidad * det_o.densidad ELSE (CASE WHEN upper(unidades.titulo) ILIKE ''%LITRO%'' THEN det_o.cantidad / det_o.densidad  ELSE det_o.cantidad END) END) ELSE det_o.cantidad END ) AS cant_uni_prod,
						det_o.densidad,
						0::double precision AS cant_prod_kg 
					from pro_orden_prod as orden 
					join pro_orden_prod_det as det_o on det_o.pro_orden_prod_id=orden.id 
					join inv_prod on inv_prod.id=det_o.inv_prod_id 
					join inv_prod_presentaciones as presentaciones on presentaciones.id=inv_prod.inv_prod_presentacion_id 
					join inv_prod_unidades as unidades on unidades.id=inv_prod.unidad_id 
					where orden.id='||str_data[4]::integer||' 
					group by det_o.inv_prod_id, det_o.cantidad, orden.folio, orden.fecha_elavorar, orden.observaciones, inv_prod.inv_prod_presentacion_id, presentaciones.cantidad, unidades.decimales, unidades.id, det_o.unidad_id, unidades.titulo, det_o.densidad';
					exis = 0;--valor cero para poder dar de alta el header de la orden de entrada solo una vez
					
					--RAISE EXCEPTION '%' , str_select1;
					
					FOR record1 IN EXECUTE (str_select1) LOOP
						
						IF exis = 0 THEN
							exis := 1;
							/****************************************************************************************************************************
							AQUI COMIENZA A GENERAR EL REGISTRO PARA LA ORDEN DE ENTRADA
							*****************************************************************************************************************************/
							tipo_movimiento_id := 10;--entrada por produccion
							id_tipo_consecutivo:=17;--Folio Orden de Entrada
							
							--aqui entra para tomar el consecutivo del folio  la sucursal actual
							UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
							WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
							
							--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
							nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
							
							INSERT INTO inv_oent
							(
								folio,--nuevo_folio,
								estatus,--0,
								inv_mov_tipo_id,--tipo_movimiento_id,
								tipo_documento,--doc_com.tipo_documento,
								folio_documento,--record1.folio,
								fecha_exp,--doc_com.factura_fecha_expedicion,
								gral_app_id,--app_selected,
								inv_alm_id,--doc_com.inv_alm_id,
								moneda_id,--doc_com.moneda_id,
								tipo_de_cambio,--doc_com.tipo_de_cambio,
								observaciones,--doc_com.observaciones,
								momento_creacion,--espacio_tiempo_ejecucion
								gral_emp_id,--
								gral_suc_id,--
								gral_usr_id_creacion--usuario_ejecutor
							)
							VALUES(nuevo_folio, 0, tipo_movimiento_id, 4, record1.folio, record1.fecha_elavorar, app_selected, id_almacen, 1, 1, record1.observaciones, espacio_tiempo_ejecucion, emp_id, suc_id, usuario_ejecutor) 
							RETURNING id INTO ultimo_id_inv_oent;
							--usuario_ejecutor, emp_id, suc_id
						END IF;

						
						
						str_select2 := '
						SELECT 
							pro_estruc_det.inv_prod_id, 
							pro_estruc_det.cantidad 
						FROM pro_estruc
						JOIN pro_estruc_det ON pro_estruc_det.pro_estruc_id=pro_estruc.id
						WHERE pro_estruc.inv_prod_id='||record1.inv_prod_id||';';
						--RAISE EXCEPTION '%' ,str_select2;

						
						FOR record2 IN EXECUTE (str_select2) LOOP
							--obtener costo promedio actual del producto
							SELECT * FROM inv_obtiene_costo_promedio_actual(record2.inv_prod_id, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
							--costo_promedio_actual
							sum_costos := sum_costos+((record2.cantidad / 100) * costo_promedio_actual);
						END LOOP;
						
						SELECT * FROM inv_obtiene_costo_promedio_actual(record1.inv_prod_id, espacio_tiempo_ejecucion) INTO costo_promedio_actual;
						SELECT * FROM inv_calculo_existencia_producto(2, true, record1.inv_prod_id, usuario_ejecutor) INTO existencia_prod;
						
						costo_prod := (sum_costos+costo_promedio_actual)/(existencia_prod + record1.cantidad);
						
						--RAISE EXCEPTION '%' , costo_ultimo_actual/record1.cantidad;
						--costo_ultimo_actual
						
						--select densidad from inv_prod limit 1
						SELECT unidad_id, densidad FROM inv_prod where id=record1.inv_prod_id AND empresa_id=emp_id AND borrado_logico=false INTO id_unidad, densidad_tmp;
						
						/*
						--Cancula costo ultimo de acuerdo a la unidad de medida de el producto
						EXECUTE 'select titulo from inv_prod_unidades where id='||id_unidad||'' INTO titulo_unidad;
						EXECUTE 'select '''||titulo_unidad||''' ~* ''KILO*'';' INTO match_cadena;

						--RAISE EXCEPTION '%','costo_ultimo_actual: '|| costo_ultimo_actual||'       titulo_unidad: '||titulo_unidad;
						
						IF match_cadena = true THEN
							costo_ultimo_actual := round((costo_ultimo_actual/record1.cant_uni_prod)::numeric, 4)::double precision;
						ELSE
							costo_ultimo_actual := round((costo_ultimo_actual/(record1.cant_uni_prod * densidad_tmp ))::numeric, 4)::double precision;
						END IF;
						*/

						/***
						***Este es el ultimo cambio para corregir el calculo de costo al terminar la OP
						***La cantidad total en Kilos, se convierte a la Unidad de Medida del Producto.
						***Una vez hecha la conversi√≥n, se divide el Costo total/Cantidad en unidad del Producto
						***/
						--Obtener la cantidad real de la produccion en Kilos
						select sum(cantidad_usada) AS cantidad FROM (select * from pro_get_detalle_orden_produccionv2(record1.inv_prod_id,str_data[4]::integer,1, 0)  as foo(id integer, inv_prod_id integer, sku character varying,descripcion character varying, requiere_numero_lote boolean ,cantidad_adicional double precision,id_reg_det integer, cantidad double precision,elemento integer, lote character varying, inv_osal_id integer, inv_alm_id integer, gral_suc_id integer, agregado boolean, cantidad_usada double precision, guardado boolean) order by elemento) AS abt 
						INTO record1.cant_prod_kg;
						
						IF record1.cant_prod_kg IS NULL THEN record1.cant_prod_kg:=0; END IF;
						--RAISE EXCEPTION '%','costo_ultimo_actual: '|| costo_ultimo_actual;
						
						--Convertir Cantidad Real de la produccion en la unidad de medida del Producto
						SELECT 
						(CASE WHEN record1.uni_prod<>record1.uni_pro_orden THEN 
							(CASE WHEN upper(record1.titulo_unidad_prod) ILIKE '%KILO%' THEN 
								record1.cant_prod_kg * record1.densidad 
							ELSE 
								(CASE WHEN upper(record1.titulo_unidad_prod) ILIKE '%LITRO%' THEN record1.cant_prod_kg / record1.densidad  ELSE record1.cant_prod_kg END) 
							END) 
						ELSE 
							(CASE WHEN upper(record1.titulo_unidad_prod) ILIKE '%LITRO%' THEN (record1.cant_prod_kg / record1.densidad) ELSE record1.cant_prod_kg END) 
						END) AS cant_uni_prod
						INTO record1.cant_uni_prod;
						
						costo_ultimo_actual := round((costo_ultimo_actual/record1.cant_uni_prod)::numeric, 4)::double precision;
						--RAISE EXCEPTION '%','costo_ultimo_actual: '|| costo_ultimo_actual||' | unidad_prod: '||record1.titulo_unidad_prod||' | unidad_orden: '||record1.uni_pro_orden||' | cant_uni_prod: '||record1.cant_uni_prod||' | densidad_tmp: '||densidad_tmp;
						




						
						calculo_con_densidad := round((calculo_con_densidad)::numeric, 4)::double precision;
						---Termina calculo costo ultimo para orden produccion
						
						--Calcula la cantidad en la unidad de medida de el producto por default
						cantidad_presentacion := round((cantidad_calculada / record1.cant_eq_pres)::numeric,record1.decimales)::double precision;
						--round((cantidad_presentacion)::numeric,record1.decimales)::double precision
						
						--RAISE EXCEPTION '%' ,costo_prod;
						INSERT INTO inv_oent_detalle
						(
							inv_oent_id,--ultimo_id_inv_oent,
							cantidad,--detalle.cantidad,
							costo_unitario,--detalle.costo_unitario,
							inv_prod_id,--detalle.producto_id,
							inv_prod_presentacion_id,--detalle.presentacion_id,
							gral_imp_id,--detalle.tipo_de_impuesto_sobre_partida,
							valor_imp--detalle.valor_imp
						)VALUES(ultimo_id_inv_oent, record1.cantidad, costo_ultimo_actual, record1.inv_prod_id, record1.inv_prod_presentacion_id, 0, 0);
						
						str_select2 := 'SELECT count(id) FROM inv_exi WHERE inv_prod_id = '||record1.inv_prod_id||' AND 
						inv_alm_id = '||id_almacen||' AND ano = '||ano_actual;
						--RAISE EXCEPTION '%' ,'str_select2: '||str_select2;
						
						EXECUTE str_select2 INTO exis;
						
						IF exis >0 THEN
							sql_update := 'UPDATE inv_exi SET entradas_'||mes_actual||'=(entradas_'||mes_actual||' + '||record1.cantidad||'::double precision), 
							costo_ultimo_'||mes_actual||'='||costo_ultimo_actual||'::double precision, momento_entrada_'||mes_actual||'='''||espacio_tiempo_ejecucion||'''
							WHERE inv_alm_id='||id_almacen||' AND inv_prod_id='||record1.inv_prod_id||' AND ano='||ano_actual||';';
							EXECUTE sql_update;
						ELSE
							sql_insert:='INSERT INTO inv_exi (inv_prod_id,inv_alm_id, ano, entradas_'||mes_actual||',momento_entrada_'||mes_actual||',exi_inicial, costo_ultimo_'||mes_actual||') '||
							'VALUES('||record1.inv_prod_id||','||id_almacen||','||ano_actual||','||record1.cantidad||','''|| espacio_tiempo_ejecucion ||''',0,'||costo_ultimo_actual||' );';
							EXECUTE sql_insert;
						END IF;
						--RAISE EXCEPTION '%' ,'sql_update: '||sql_update;
						
						IF controla_presentacion = true THEN
							--buscar Registro de la Presentacion en el Almacen Destino
							SELECT count(inv_exi_pres.id) AS exis FROM inv_exi_pres 
							WHERE inv_exi_pres.inv_alm_id=id_almacen AND 
							inv_exi_pres.inv_prod_id=record1.inv_prod_id AND inv_exi_pres.inv_prod_presentacion_id=record1.inv_prod_presentacion_id 
							INTO exis;
							
							--Esto se tiene que eliminar
							--Aumenta la cantidad reservada en esze almacen
							--UPDATE inv_exi SET reservado=(reservado + cantidad_calculada) WHERE inv_prod_id=record1.inv_prod_id AND 
							--inv_alm_id=id_almacen AND ano=ano_actual;
							
							IF exis > 0 THEN
								--cantidad_presentacion
								--Sumar existencia de la presentacion
								UPDATE inv_exi_pres SET entradas=(entradas::double precision + cantidad_presentacion::double precision), momento_actualizacion=espacio_tiempo_ejecucion, gral_usr_id_actualizacion=usuario_ejecutor  
								WHERE inv_alm_id = id_almacen AND inv_prod_id = record1.inv_prod_id AND inv_prod_presentacion_id = record1.inv_prod_presentacion_id;
							ELSE
								--aqui entra para CREAR registro en inv_exi
								INSERT INTO inv_exi_pres (inv_alm_id, inv_prod_id, inv_prod_presentacion_id, entradas, momento_creacion, gral_usr_id_creacion) 
								VALUES(id_almacen, record1.inv_prod_id, record1.inv_prod_presentacion_id, cantidad_presentacion::double precision, espacio_tiempo_ejecucion, usuario_ejecutor);
							END IF;
							
						END IF;
						
						
						str_select2 := 'SELECT count(id) FROM inv_prod_cost_prom WHERE inv_prod_id = '||record1.inv_prod_id||' AND ano = '||ano_actual;
						--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
						EXECUTE str_select2 INTO exis;
						IF exis <=0 THEN
							--sql_update := 'UPDATE inv_prod_cost_prom SET costo_promedio_'||mes_actual||'='||costo_prod||'::double precision, costo_ultimo_'||mes_actual||'='||costo_ultimo_actual||'::double precision WHERE inv_prod_id='||record1.inv_prod_id||' AND ano='||ano_actual||';';
							--EXECUTE sql_update;
							--RAISE EXCEPTION '%' ,'sql_update: '||sql_update;
							
							--Crear el registro si no existe
							INSERT INTO inv_prod_cost_prom (inv_prod_id, ano) VALUES(record1.inv_prod_id, ano_actual);
						END IF;
						
						incrementa := mes_actual + 1;
						--Crear cadena sql para actualizar guardar el costo promedio y Costo Ultimo
						sql_update:= 'UPDATE inv_prod_cost_prom SET costo_promedio_'||mes_actual||'='||costo_prod||', costo_ultimo_'||mes_actual||'='||costo_ultimo_actual;
						WHILE incrementa <= 12 LOOP
							sql_update:=sql_update ||', costo_promedio_'||incrementa||'='||costo_prod||', costo_ultimo_'||incrementa||'='||costo_ultimo_actual||', gral_mon_id_'||incrementa||'=1, tipo_cambio_'||incrementa||'=1';
							incrementa:= incrementa + 1;
						END LOOP;
						sql_update:= sql_update||' WHERE inv_prod_id='||record1.inv_prod_id||' AND ano='||ano_actual||';';
						
						--RAISE EXCEPTION '%' ,'sql_update: '||sql_update;
						
						--Actualizar registro
						EXECUTE sql_update;
						
					END LOOP;
					
				ELSE
					--no hay ordenes de salida que surtir
					--
					
				END IF;
			END IF;
			
			--Para cancelar la orden
			IF str_data[8]='5' THEN
				
				select pro_proceso_flujo_id from pro_proceso where id=id_proceso INTO ultimo_estatus_id;
				
				IF ultimo_estatus_id = 3 THEN
					
					select count(inv_otras.id) as cantidad 
					from ( select inv_osal_id from pro_ordenprod_invosal where pro_orden_prod_id=str_data[4]::integer ) as tmp_ord_prod 
					join inv_otras on inv_otras.id=tmp_ord_prod.inv_osal_id where inv_otras.estatus=1 INTO exis;
					--OR inv_osal.estatus=1
					
					IF exis = 0 THEN
						--=========Para liberar la materia prima que separo la orden de produccion
						--str_select1:='select inv_osal_detalle.cantidad, inv_osal_detalle.inv_prod_id from (
						--select inv_osal_id from pro_ordenprod_invosal where pro_orden_prod_id='||str_data[4]::integer||' ) as osal_tmp 
						--join inv_osal_detalle on inv_osal_detalle.inv_osal_id=osal_tmp.inv_osal_id';
						
						str_select1:='
						select 
							inv_otras_det.cantidad_tras as cantidad, 
							inv_otras_det.inv_prod_id,
							inv_otras_det.inv_prod_presentacion_id,
							inv_otras.inv_alm_id_destino as id_almacen 
						from (select inv_osal_id from pro_ordenprod_invosal where pro_orden_prod_id='||str_data[4]::integer||' ) as osal_tmp 
						join inv_otras on inv_otras.id=osal_tmp.inv_osal_id  
						join inv_otras_det on inv_otras_det.inv_otras_id=inv_otras.id';
						
						--RAISE EXCEPTION '%' ,'sql_select: '||str_select1;
						
						exis = 0;--valor cero para poder dar de alta el header de la orden de entrada solo una vez
						FOR record1 IN EXECUTE (str_select1) LOOP
							--reservar cantidad para el  pedido
							UPDATE inv_exi SET reservado=(reservado - record1.cantidad) WHERE inv_prod_id=record1.inv_prod_id AND inv_alm_id=record1.id_almacen AND ano=ano_actual;
						END LOOP;
						
						IF controla_presentacion = true THEN
							UPDATE inv_exi_pres SET reservado = (reservado::double precision +  cantidad_presentacion::double precision)::double precision 
							WHERE inv_alm_id=record1.id_almacen AND inv_prod_id=record1.inv_prod_id AND inv_prod_presentacion_id=record1.inv_prod_presentacion_id;
						END IF;
						
						--cambia a estatus cancelada
						SELECT pro_proceso_id FROM pro_orden_prod WHERE id=str_data[4]::integer INTO id_proceso;
						
						update pro_proceso set pro_proceso_flujo_id=5  WHERE id=id_proceso;
						
						update pro_orden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor 
						 where id=str_data[4]::integer RETURNING id INTO ultimo_id;
						
					END IF;
				ELSE 
					IF ultimo_estatus_id < 3 THEN
						--cambia a estatus cancelada
						SELECT pro_proceso_id FROM pro_orden_prod WHERE id=str_data[4]::integer INTO id_proceso;
						
						update pro_proceso set pro_proceso_flujo_id=5  WHERE id=id_proceso;
						
						update pro_orden_prod set momento_actualizacion=now(), id_usuario_actualizacion=usuario_ejecutor 
						 where id=str_data[4]::integer RETURNING id INTO ultimo_id;
						 
					END IF;
				END IF;
				
			END IF;
			
			valor_retorno := '1';
		END IF;
		
                
                IF command_selected = 'delete' THEN
			select count(id) as cantidad from pro_subproceso_prod where pro_estruc_id=str_data[4]::integer INTO exis;
			IF exis > 0 THEN
				valor_retorno := 'La formula esta siendo utilizada por un subproceso';
			ELSE
				update pro_estruc set borrado_logico=false, momento_baja=now(), gral_usr_id_baja=usuario_ejecutor 
				WHERE id = str_data[4]::integer;
				valor_retorno := '1';
			END IF;
		END IF;
	END IF;--termina orden produccion

	
	
	
	
	
	--Catalogo de formulas en desarrollo
	IF app_selected = 108 THEN
		--str_data[1]  app_selected
		--str_data[2]  command_selected	
		--str_data[3]  id_usuario
		--str_data[4]  id
		--str_data[5]  id_prod_master
		--str_data[6]  inv_prod_id
		--str_data[7]  nivel
		--str_data[8]  producto_elemento_id
		--str_data[9]  cantidad
		--RAISE EXCEPTION '%','total  de filas???'||str_data[4];
		-- Catalogo de  formulas
		
                IF command_selected = 'new' THEN
			
			IF str_data[9] = '0' THEN
				str_data[9] := '1';
			END IF;
			
			insert into pro_estruc(titulo_descrip,inv_prod_id, observaciones, gral_emp_id, gral_suc_id, gral_usr_id_creacion, 
			momento_creacion, borrado_logico, version, tipo_formula, pro_estruc_id) 
			values('', str_data[5]::integer, '', emp_id, suc_id,usuario_ejecutor, now(), false, str_data[9]::integer, 2, str_data[8]::integer) RETURNING id INTO ultimo_id;
			
			IF str_data[8] = '0' THEN
				update pro_estruc set pro_estruc_id=ultimo_id where id=ultimo_id;
			END IF;
			
			-- validaciones para el grid --
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					----aqui se vuelven a crear los registros
					IF str_filas[4] != '0' THEN
						insert into pro_estruc_det(pro_estruc_id,nivel, elemento, inv_prod_id, cantidad, inv_prod_id_salida) 
						values(ultimo_id, str_data[7]::integer, str_filas[3]::integer, str_filas[1]::integer,str_filas[2]::double precision,str_data[6]::integer);
					END IF;
				END LOOP;
			END IF;
			valor_retorno := '1';
		END IF;
                
                IF command_selected = 'edit' THEN
			
                       IF str_data[9] = '0' THEN
				str_data[9] := '1';
			END IF;
			
			update pro_estruc set momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_ejecutor, version=str_data[9]::integer  where id=str_data[4]::integer RETURNING id INTO ultimo_id;
			update inv_prod set tipo_de_producto_id=str_data[10]::integer where id=(select inv_prod_id from pro_estruc where id=str_data[4]::integer);
			
			-- validaciones para el grid --
			IF extra_data[1] != 'sin datos' THEN
				total_filas:= array_length(extra_data,1);--obtiene total de elementos del arreglo
				cont_fila:=1;
				FOR cont_fila IN 1 .. total_filas LOOP
					
					SELECT INTO str_filas string_to_array(extra_data[cont_fila],'___');
					----aqui se vuelven a crear los registros
					IF str_filas[4] != '0' THEN
						--and str_filas[6] == '0'
						
						IF str_filas[6] = '0' THEN
							--RAISE EXCEPTION '%' ,str_data[7];
							insert into pro_estruc_det(pro_estruc_id,nivel, elemento, inv_prod_id, cantidad, inv_prod_id_salida) 
							values(ultimo_id, str_data[7]::integer, str_filas[3]::integer, str_filas[1]::integer,str_filas[2]::double precision,str_data[6]::integer);
							
							--insert into pro_estruc_det(pro_estruc_id,nivel, elemento, inv_prod_id, cantidad, inv_prod_id_salida) 
							--values(ultimo_id, str_data[7]::integer, str_filas[3]::integer, str_filas[1]::integer,str_filas[2]::double precision,str_data[6]::integer);
						ELSE
							update pro_estruc_det set elemento=str_filas[3]::integer, cantidad=str_filas[2]::double precision, 
							inv_prod_id_salida=str_data[6]::integer where id=str_filas[6]::integer;
						END IF;
					ELSE
						IF str_filas[6] != '0' THEN
							delete from pro_estruc_det where id=str_filas[6]::integer;
						END IF;
					END IF;
				END LOOP;
			END IF;
			
			valor_retorno := '1';
                END IF;
		
                IF command_selected = 'delete' THEN
			select count(id) as cantidad from pro_subproceso_prod where pro_estruc_id=str_data[4]::integer INTO exis;
			IF exis > 0 THEN
				valor_retorno := 'La formula esta siendo utilizada por un subproceso';
			ELSE
				update pro_estruc set borrado_logico=false, momento_baja=now(), gral_usr_id_baja=usuario_ejecutor 
				WHERE id = str_data[4]::integer;
				valor_retorno := '1';
			END IF;
			
		END IF;
                
	END IF;--termina Catalogo de formulas  en desarrollo
	
	
	
	-- Catalogo de Instrumentos de Medicion
	IF app_selected = 112 THEN
		
		IF command_selected = 'new' THEN
			--str_data[4]        id
			--str_data[5]        titulo
			
			/*id_tipo_consecutivo:=35;--Folio de motivo de llamada
			
			--aqui entra para tomar el consecutivo del folio  la sucursal actual
			UPDATE 	gral_cons SET consecutivo=( SELECT sbt.consecutivo + 1  FROM gral_cons AS sbt WHERE sbt.id=gral_cons.id )
			WHERE gral_emp_id=emp_id AND gral_suc_id=suc_id AND gral_cons_tipo_id=id_tipo_consecutivo  RETURNING prefijo,consecutivo INTO prefijo_consecutivo,nuevo_consecutivo;
			
			--concatenamos el prefijo y el nuevo consecutivo para obtener el nuevo folio 
			nuevo_folio := prefijo_consecutivo || nuevo_consecutivo::character varying;
			*/
			
			INSERT INTO pro_instrumentos (titulo,gral_emp_id, borrado_logico, momento_creacion, gral_usr_id_creacion, gral_suc_id)
			VALUES (str_data[5]::character varying,emp_id, false, now(), usuario_ejecutor, suc_id);
			valor_retorno := '1';
			--RAISE EXCEPTION '%',command_selected;
		END IF;	
		
		--RAISE EXCEPTION '%',command_selected;
		IF command_selected = 'edit' THEN
			--112 edit 5 7 
			--RAISE EXCEPTION '%',str_data[1]||str_data[2]||str_data[3]||str_data[4]||str_data[5];
			UPDATE pro_instrumentos SET titulo=str_data[5]::character varying,momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_ejecutor 
		        WHERE pro_instrumentos.id = str_data[4]::integer;
			
			--select * from pro_instrumentos
		        valor_retorno := '0';
		END IF;
		
		IF command_selected = 'delete' THEN
			--RAISE EXCEPTION '%','id de la tabla'||str_data[4];
			update pro_instrumentos SET momento_baja=now(),borrado_logico=true WHERE pro_instrumentos.id = str_data[4]::integer; 
			valor_retorno := '1';
		END IF;
		
	END IF;--termina Instrumentos de Medicion
	
	
	-- Catalogo de Equipo Adcional
	IF app_selected = 140 THEN
		IF command_selected = 'new' THEN
			--str_data[1] app_selected
			--str_data[2] command_selected
			--str_data[3] id_usuario
			--str_data[4] identificador
			--str_data[5] id_cliente
			--str_data[6] calle
						
			INSERT INTO pro_equipos_adic(titulo, titulo_corto, borrado_logico, gral_emp_id, momento_creacion, gral_usr_id_creacion)
			VALUES(str_data[5], str_data[6], false,emp_id, now(), usuario_ejecutor);
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE pro_equipos_adic SET titulo=str_data[5], titulo_corto=str_data[6], momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_ejecutor
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE pro_equipos_adic SET momento_baja=now(),borrado_logico=true, gral_usr_id_baja=usuario_ejecutor
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Equipo Adcional
	



	-- Catalogo de Equipos
	IF app_selected = 141 THEN
		IF command_selected = 'new' THEN
			--str_data[1] app_selected
			--str_data[2] command_selected
			--str_data[3] id_usuario
			--str_data[4] identificador
			--str_data[5] titulo
			--str_data[6] nombre_corto
			--str_data[7] tipo_equipo
						
			INSERT INTO pro_equipos(titulo, titulo_corto, pro_tipo_equipo_id, borrado_logico, gral_emp_id, gral_suc_id, momento_creacion, gral_usr_id_creacion, depto_id, "costo_por_hora_CFE", costo_por_hora_refacc, costo_por_hora_indirec, cap_salida, cap_entrada, merma_std_hora, unid_med_entrada, unid_med_salida, fact_conversion_hora, costo_por_hora_gas, costo_por_hora_mto)
			VALUES(str_data[5], str_data[6], str_data[7]::integer, false,emp_id, suc_id, now(), usuario_ejecutor,1,1,1,1,1,1,1,1,1,1,1,1);
			
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'edit' THEN
			UPDATE pro_equipos SET titulo=str_data[5], titulo_corto=str_data[6], pro_tipo_equipo_id=str_data[7]::integer, momento_actualizacion=now(), gral_usr_id_actualizacion=usuario_ejecutor
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
		
		IF command_selected = 'delete' THEN
			UPDATE pro_equipos SET momento_baja=now(),borrado_logico=true, gral_usr_id_baja=usuario_ejecutor
			WHERE id = str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina catalogo de Equipos




	--Aplicativo de Aseguramiento de Calidad
	IF app_selected = 143 THEN
		--str_data[1] app_selected
		--str_data[2] command_selected
		--str_data[3] id_usuario
		--str_data[4] id_orden
		--str_data[5] select_status_calidad
		--str_data[6] comentarios
		
		IF command_selected = 'edit' THEN
			UPDATE pro_orden_prod SET status_calidad=str_data[5]::smallint, comentarios_calidad=str_data[6], momento_actualizacion_calidad=now(), gral_usar_id_actualiza_calidad=usuario_ejecutor 
			WHERE id=str_data[4]::integer;
			valor_retorno := '1';
		END IF;
	END IF;--termina Aplicativo de Aseguramiento de Calidad

	
	
	
	--RAISE EXCEPTION '%' ,'sql_select: '||sql_select;
	RETURN valor_retorno; 
	
END;
$_$;


--
-- Name: quitar_y_reasignar_reservados(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.quitar_y_reasignar_reservados(id_empresa integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	valor_retorno character varying = 'false';
	espacio_tiempo_ejecucion timestamp with time zone = now();
	ano_actual integer;
	mes_actual integer;
	fila record;
	fila_pres record;
	fila_uni record;
	cadena_sql character varying;
	cadena_sql_producto character varying;
	cadena_sql_unidad character varying;
	exis integer=0;
	existencia_actual double precision;
	diferencia double precision;
	existencia_inicial double precision;
BEGIN
	SELECT EXTRACT(YEAR FROM espacio_tiempo_ejecucion) INTO ano_actual;
	SELECT EXTRACT(MONTH FROM espacio_tiempo_ejecucion) INTO mes_actual;
	
	
	--inicializar campo reservado en cero
	UPDATE inv_exi SET reservado=0 WHERE ano=ano_actual;
	
	--query productos existencias
	cadena_sql:='
		SELECT id_almacen, id_prod, sum(cantidad) AS cant_reserv
		FROM(
			SELECT 
				poc_pedidos.inv_alm_id AS id_almacen,
				poc_pedidos_detalle.inv_prod_id AS id_prod,
				poc_pedidos_detalle.cantidad
			FROM poc_pedidos
			JOIN erp_proceso ON erp_proceso.id=poc_pedidos.proceso_id
			JOIN poc_pedidos_detalle ON poc_pedidos_detalle.poc_pedido_id=poc_pedidos.id
			WHERE poc_pedidos.cancelado=FALSE 
			AND poc_pedidos.borrado_logico=FALSE
			AND poc_pedidos.inv_alm_id=1
			AND erp_proceso.empresa_id='||id_empresa||'
			AND (erp_proceso.proceso_flujo_id=2 OR erp_proceso.proceso_flujo_id=4)
			ORDER BY poc_pedidos.inv_alm_id, poc_pedidos_detalle.inv_prod_id
		) AS sbt GROUP BY id_almacen, id_prod';
	
	--RAISE EXCEPTION '%','cadena_sql: '||cadena_sql;
	
	FOR fila IN EXECUTE(cadena_sql) LOOP
		SELECT count(id) FROM inv_exi WHERE inv_prod_id=fila.id_prod AND inv_alm_id=fila.id_almacen AND ano=ano_actual
		INTO exis; 
		
		IF exis >0 THEN
			UPDATE inv_exi SET reservado=fila.cant_reserv::double precision
			WHERE inv_prod_id=fila.id_prod AND inv_alm_id=fila.id_almacen AND ano=ano_actual;
		END IF;
	END LOOP;
	
	valor_retorno:='true';
	
	return valor_retorno;
	
END	
	
$$;


--
-- Name: repestadisticocompras(integer, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.repestadisticocompras(tipo_reporte integer, proveedor character varying, producto character varying, fecha_inicial character varying, fecha_final character varying, empresa_id integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE
	cadena_sql text = '';
	cadena_where text ='';
	ordenado_por text ='';
	modo_ordenacion text ='';
	
	fila record;

BEGIN
	cadena_where:='';	
	--'||cadena_where||'
	IF  tipo_reporte = 1 THEN   --proveedor
		ordenado_por='cxp_prov.folio,com_fac.momento_creacion ';
		modo_ordenacion='asc';
	END IF;
	
	IF tipo_reporte = 2 THEN    --productos
		ordenado_por='producto, com_fac.momento_creacion ';
		modo_ordenacion='asc';
	END IF;
	
	IF tipo_reporte = 3 THEN   --  +producto
		ordenado_por='producto,cantidad';
		--modo_ordenacion='desc';
		modo_ordenacion='desc';
	END IF;
	
	IF tipo_reporte = 4 THEN    --- +proveedor
		ordenado_por='razon_social,cantidad';
		--modo_ordenacion='desc';
		modo_ordenacion='desc';
	END IF;
	
	IF proveedor != '' THEN
		cadena_where:= cadena_where ||' AND  cxp_prov.razon_social ilike  '''||proveedor||'''';
	END IF;

	if producto != '' THEN
		cadena_where:= cadena_where ||' AND  inv_prod.descripcion ilike  '''||producto||'''';
	END IF;




	cadena_sql:= 'SELECT  cxp_prov.folio,
				cxp_prov.razon_social,  
				inv_prod.sku AS codigo,  
				inv_prod.descripcion AS producto,  
				com_fac.factura,  
				inv_prod_unidades.titulo_abr as unidad, 
				com_fac_detalle.cantidad,  
				com_fac_detalle.costo_unitario,  
				(CASE WHEN gral_mon.id IS NULL THEN '''' ELSE gral_mon.descripcion_abr END)::text AS moneda,
				com_fac.tipo_de_cambio AS tipo_cambio,  
				(CASE WHEN com_fac.moneda_id=1  THEN com_fac_detalle.costo_unitario * com_fac_detalle.cantidad
					ELSE com_fac_detalle.costo_unitario  *com_fac.tipo_de_cambio  * com_fac_detalle.cantidad END) AS total_pesos,
				to_char(com_fac.momento_creacion,''dd/mm/yyyy'') as fecha_factura
			FROM com_fac 
			JOIN com_fac_detalle ON com_fac_detalle.com_fac_id = com_fac.id  
			JOIN inv_prod ON inv_prod.id= com_fac_detalle.producto_id  
			JOIN inv_prod_unidades on inv_prod_unidades.id=inv_prod.unidad_id  
			JOIN cxp_prov ON cxp_prov.id = com_fac.proveedor_id
			LEFT JOIN gral_mon ON gral_mon.id= com_fac.moneda_id 
			WHERE com_fac.cancelacion=false
			'||cadena_where||'   
			AND com_fac.empresa_id='||empresa_id ||'
			AND (to_char(com_fac.momento_creacion,''yyyymmdd'')::integer BETWEEN to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymmdd'')::integer AND to_char('''||fecha_final||'''::timestamp with time zone,''yyyymmdd'')::integer)			
			order by '||ordenado_por||' '||modo_ordenacion||'';
			--desc
	--and moneda_factura = ''USD''
	--RAISE EXCEPTION '%',cadena_sql;
		
		FOR fila IN EXECUTE (cadena_sql) LOOP
			RETURN NEXT fila;
		END LOOP;


	/*
	select * from repventasnetasproductofactura(4,'','','2012-05-01','2012-06-05',4) as foo(
	folio character varying,
	 razon_social character varying,
	 codigo character varying,
	 producto character varying,
	 factura character varying ,
	 unidad character varying ,
	cantidad double precision,
	precio_unitario double precision,
	moneda text,
	tipo_cambio double precision,
	total_pesos double precision,
	fecha_factura text
	);*/

END;

$$;


--
-- Name: repprogramacionpagos_semanas_proximas(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.repprogramacionpagos_semanas_proximas(num_semana integer, empresa_id integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$

DECLARE
	cadena_sql text = '';
	cadena_fecha_lunesproximo text ='';
	cadena_fecha_viernesproximo text ='';
	
	
	fila record;

	lunes integer;
	martes integer;
	miercoles integer;
	jueves integer;
	viernes integer;
	sabado integer;
	domingo integer;
	
BEGIN	
lunes:=7;
martes:=6;
miercoles:=5;
jueves :=4;
viernes:=3;
sabado :=2;
domingo:=1;


	lunes := lunes +((num_semana - 1)*7);
	martes := martes +((num_semana - 1)*7);
	miercoles := miercoles + ((num_semana - 1)*7);
	jueves := jueves +((num_semana - 1)*7);--4 + ((4-1)* 7)
	viernes := viernes +((num_semana - 1)*7);
	sabado := sabado +((num_semana - 1)*7);
	domingo := domingo +((num_semana - 1)*7);
	

	cadena_fecha_lunesproximo='to_char( (	select trim(case  
					when to_char(current_date,''d'') = ''1'' then (select current_date + CAST('''||domingo||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''2'' then (select current_date + CAST('''||lunes||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''3'' then (select current_date + CAST('''||martes||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''4'' then (select current_date + CAST('''||miercoles||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''5'' then (select current_date + CAST('''||jueves||' days''AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''6'' then (select current_date + CAST('''||viernes||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''7'' then (select current_date + CAST('''||sabado||' days'' AS INTERVAL) as fecha)::text
					end)as fecha_lunes 
				   )::timestamp with time zone,''yyyy/mm/dd''  )as lunes_proximo';
	--EXECUTE (cadena_fecha_lunesproximo) into fecha_proxlunes;
	--RAISE EXCEPTION '%',cadena_fecha_lunesproximo;
	cadena_fecha_viernesproximo='to_char((select (
						select trim(case 
						when to_char(current_date,''d'') = ''1'' then (select current_date + CAST('''||domingo||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''2'' then (select current_date + CAST('''||lunes||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''3'' then (select current_date + CAST('''||martes||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''4'' then (select current_date + CAST('''||miercoles||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''5'' then (select current_date + CAST('''||jueves||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''6'' then (select current_date + CAST('''||viernes||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''7'' then (select current_date + CAST('''||sabado||' days'' AS INTERVAL) as fecha)::text end)
				       )::timestamp with time zone + CAST(''4 days'' AS INTERVAL) as fecha_viernes
			       ) ,''yyyy/mm/dd'') as viernes_proximo';

	--EXECUTE (cadena_fecha_viernesproximo) into fecha_proxviernes;
	--RAISE EXCEPTION '%',cadena_fecha_viernesproximo;

	cadena_sql:= 'Select *,
			       '||cadena_fecha_lunesproximo||',
			       '||cadena_fecha_viernesproximo||', 
			      sum (lunes + martes+ miercoles + jueves + viernes)as total
 
		      from ( SELECT  
					--folio,
					proveedor, 
					factura, 
					moneda_factura,
					''$''::character varying as pesos, 
					samana_actual, 
					dia_semana_actual, 
					fecha_vencimiento, 
					semana_vencimiento, 
					dia_semana_vencimiento, 
					(CASE WHEN dia_semana_vencimiento=0 OR dia_semana_vencimiento=1 OR dia_semana_vencimiento=6 THEN saldo_factura ELSE 0 END) AS lunes, 
					(CASE WHEN dia_semana_vencimiento=2 THEN saldo_factura ELSE 0 END) AS martes, 
					(CASE WHEN dia_semana_vencimiento=3 THEN saldo_factura ELSE 0 END) AS miercoles,
					(CASE WHEN dia_semana_vencimiento=4 THEN saldo_factura ELSE 0 END) AS jueves, 
					(CASE WHEN dia_semana_vencimiento=5 THEN saldo_factura ELSE 0 END) AS viernes


				FROM ( 
					SELECT  
						--cxp_prov.folio, 
						cxp_prov.razon_social AS proveedor,
						cxp_facturas.serie_folio as factura,
						gral_mon.descripcion_abr AS moneda_factura,
						--to_char(erp_h_facturas.momento_facturacion,''dd/mm/yyyy'') AS fecha_facturacion, 
						--cxc_clie_credias.dias AS dias_de_pago, 
						to_char(cxp_facturas.fecha_vencimiento,''yyyy-mm-dd'')::DATE AS fecha_vencimiento, 
						NOW()::DATE - (to_char(cxp_facturas.fecha_vencimiento,''yyyy-mm-dd'')::DATE ) AS dias_vencidos,
						--cxp_facturas.saldo_factura,
						--cxp_facturas.tipo_cambio,
						(cxp_facturas.saldo_factura * tipo_cambio)as saldo_factura,

						(SELECT extract(week from now()::date))as samana_actual, 
						(SELECT EXTRACT(DOW FROM now()::date)) as dia_semana_actual, 
						(SELECT extract(week from fecha_vencimiento::date)) AS semana_vencimiento, 
						(SELECT EXTRACT(year FROM fecha_vencimiento::date)) as ano_vencimiento, 
						(SELECT EXTRACT(DOW FROM fecha_vencimiento::date)) as dia_semana_vencimiento




						FROM cxp_prov 
						JOIN cxp_facturas ON cxp_facturas.cxc_prov_id=cxp_prov.id
						JOIN gral_mon ON gral_mon.id = cxp_facturas.moneda_id
						WHERE cxp_facturas.empresa_id='||empresa_id||'
						order by proveedor asc , factura asc

					) AS sbt2 
			                WHERE (semana_vencimiento = samana_actual + '||num_semana::character varying||' AND dia_semana_vencimiento<6 ) 

			     ) as tb3


			     GROUP BY 
			     tb3.proveedor, 
			     tb3.factura, 
			     tb3.moneda_factura,
			     tb3.pesos,
			     tb3.samana_actual, 
			     tb3.dia_semana_actual,
			     tb3.fecha_vencimiento, 
			     tb3.semana_vencimiento, 
			     tb3.dia_semana_vencimiento,
			     tb3.lunes, 
			     tb3.martes, 
			     tb3.miercoles, 
			     tb3.jueves,
			     tb3.viernes 
			     order by proveedor asc, factura asc';
--and moneda_factura = ''USD''
--RAISE EXCEPTION '%',cadena_sql;
	
	FOR fila IN EXECUTE (cadena_sql) LOOP
		RETURN NEXT fila;
	END LOOP;


/*

select * from repprogramacionPagos_semanas_proximas('1',4) 
as foo(  proveedor character varying,  
         factura character varying ,  
         moneda_factura character varying,  
         pesos character varying ,  
         semana_actual double precision,  
         dia_semana_actual double precision,  
         fecha_vencimiento date,  
         semana_vencimiento double precision,  
         dia_semana_vencimiento double precision,  
         lunes double precision,  
         martes double precision,  
         miercoles double precision,  
         jueves double precision,  
         viernes double precision,  
         lunes_proximo text,  
         viernes_proximo text,  
         total double precision );
*/
END;

$_$;


--
-- Name: reppronostico_semanas_proximas(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.reppronostico_semanas_proximas(num_semana integer, empresa_id integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$

DECLARE
	cadena_sql text = '';
	cadena_fecha_lunesproximo text ='';
	cadena_fecha_viernesproximo text ='';
	
	
	fila record;

	lunes integer;
	martes integer;
	miercoles integer;
	jueves integer;
	viernes integer;
	sabado integer;
	domingo integer;
	
BEGIN	
lunes:=7;
martes:=6;
miercoles:=5;
jueves :=4;
viernes:=3;
sabado :=2;
domingo:=1;


	lunes := lunes +((num_semana - 1)*7);
	martes := martes +((num_semana - 1)*7);
	miercoles := miercoles + ((num_semana - 1)*7);
	jueves := jueves +((num_semana - 1)*7);--4 + ((4-1)* 7)
	viernes := viernes +((num_semana - 1)*7);
	sabado := sabado +((num_semana - 1)*7);
	domingo := domingo +((num_semana - 1)*7);
	

	cadena_fecha_lunesproximo='to_char( (	select trim(case  
					when to_char(current_date,''d'') = ''1'' then (select current_date + CAST('''||domingo||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''2'' then (select current_date + CAST('''||lunes||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''3'' then (select current_date + CAST('''||martes||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''4'' then (select current_date + CAST('''||miercoles||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''5'' then (select current_date + CAST('''||jueves||' days''AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''6'' then (select current_date + CAST('''||viernes||' days'' AS INTERVAL) as fecha)::text
					when to_char(current_date,''d'') = ''7'' then (select current_date + CAST('''||sabado||' days'' AS INTERVAL) as fecha)::text
					end)as fecha_lunes 
				   )::timestamp with time zone,''yyyy/mm/dd''  )as lunes_proximo';
	--EXECUTE (cadena_fecha_lunesproximo) into fecha_proxlunes;
	--RAISE EXCEPTION '%',cadena_fecha_lunesproximo;
	cadena_fecha_viernesproximo='to_char((select (
						select trim(case 
						when to_char(current_date,''d'') = ''1'' then (select current_date + CAST('''||domingo||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''2'' then (select current_date + CAST('''||lunes||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''3'' then (select current_date + CAST('''||martes||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''4'' then (select current_date + CAST('''||miercoles||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''5'' then (select current_date + CAST('''||jueves||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''6'' then (select current_date + CAST('''||viernes||' days'' AS INTERVAL) as fecha)::text 
						when to_char(current_date,''d'') = ''7'' then (select current_date + CAST('''||sabado||' days'' AS INTERVAL) as fecha)::text end)
				       )::timestamp with time zone + CAST(''4 days'' AS INTERVAL) as fecha_viernes
			       ) ,''yyyy/mm/dd'') as viernes_proximo';

	--EXECUTE (cadena_fecha_viernesproximo) into fecha_proxviernes;
	--RAISE EXCEPTION '%',cadena_fecha_viernesproximo;

	cadena_sql:= 'Select *,
			       '||cadena_fecha_lunesproximo||',
			       '||cadena_fecha_viernesproximo||', 
			      sum (lunes + martes+ miercoles + jueves + viernes)as total
 
		      from ( 
				 SELECT  numero_control,
				     cliente, 
				     factura, 
				     moneda_factura,
				     ''$''::character varying as pesos, 
				     samana_actual, 
				     dia_semana_actual, 
				     fecha_vencimiento, 
				     semana_vencimiento, 
				     dia_semana_vencimiento, 
				     (CASE WHEN dia_semana_vencimiento=0 OR dia_semana_vencimiento=1 OR dia_semana_vencimiento=6 THEN saldo_factura ELSE 0 END) AS lunes, 
				     (CASE WHEN dia_semana_vencimiento=2 THEN saldo_factura ELSE 0 END) AS martes, 
				     (CASE WHEN dia_semana_vencimiento=3 THEN saldo_factura ELSE 0 END) AS miercoles,
				     (CASE WHEN dia_semana_vencimiento=4 THEN saldo_factura ELSE 0 END) AS jueves, 
				     (CASE WHEN dia_semana_vencimiento=5 THEN saldo_factura ELSE 0 END) AS viernes
				     

				 FROM ( 
					SELECT    numero_control,
						 cliente, 
						 serie_folio as factura, 
						 (SELECT extract(week from now()::date))as samana_actual, 
						 (SELECT EXTRACT(DOW FROM now()::date)) as dia_semana_actual, 
						 fecha_vencimiento, 
						 (SELECT extract(week from fecha_vencimiento::date)) AS semana_vencimiento, 
						 (SELECT EXTRACT(year FROM fecha_vencimiento::date)) as ano_vencimiento, 
						 (SELECT EXTRACT(DOW FROM fecha_vencimiento::date)) as dia_semana_vencimiento,
						 moneda_factura, 
						 tipo_cambio,
						 (saldo_factura * tipo_cambio)as saldo_factura
					FROM 
					 ( SELECT  
						 cxc_clie.numero_control, 
						 cxc_clie.razon_social AS cliente, 
						 fac_docs.serie_folio, 
						 gral_mon.descripcion_abr AS moneda_factura, 
						 to_char(erp_h_facturas.momento_facturacion,''dd/mm/yyyy'') AS fecha_facturacion, 
						 cxc_clie_credias.dias AS dias_de_pago, 
						 to_char(erp_h_facturas.momento_facturacion,''yyyy-mm-dd'')::DATE + cxc_clie_credias.dias AS fecha_vencimiento, 
						 NOW()::DATE - (to_char(erp_h_facturas.momento_facturacion,''yyyy-mm-dd'')::DATE + cxc_clie_credias.dias) AS dias_vencidos, 
						 erp_h_facturas.saldo_factura ,
						 erp_h_facturas.tipo_cambio 
					 
					 
					 FROM fac_docs 
					 JOIN erp_proceso on erp_proceso.id= fac_docs.proceso_id
					 
					 JOIN erp_h_facturas ON erp_h_facturas.serie_folio = fac_docs.serie_folio 
					 JOIN cxc_clie ON cxc_clie.id = fac_docs.cxc_clie_id 
					 JOIN gral_mon ON gral_mon.id = fac_docs.moneda_id 
					 JOIN cxc_clie_credias ON cxc_clie_credias.id = fac_docs.terminos_id 
					 WHERE fac_docs.cancelado=false	 AND erp_h_facturas.pagado = FALSE 
					 AND erp_proceso.empresa_id ='||empresa_id||'
				)as stb 
			    ) AS sbt2 
			     WHERE semana_vencimiento = samana_actual + '||num_semana::character varying||' AND dia_semana_vencimiento<6 
			     order by cliente asc , factura asc)as tb3 
			     GROUP BY tb3.numero_control,
			     tb3.cliente, 
			     tb3.factura, 
			     tb3.moneda_factura,
			     tb3.pesos,
			     tb3.samana_actual, 
			     tb3.dia_semana_actual,
			     tb3.fecha_vencimiento, 
			     tb3.semana_vencimiento, 
			     tb3.dia_semana_vencimiento,
			     tb3.lunes, 
			     tb3.martes, 
			     tb3.miercoles, 
			     tb3.jueves,
			     tb3.viernes 
			     order by cliente asc, factura asc';
--and moneda_factura = ''USD''
--RAISE EXCEPTION '%',cadena_sql;
	
	FOR fila IN EXECUTE (cadena_sql) LOOP
		RETURN NEXT fila;
	END LOOP;


/*

select * from repPronostico_semanas_proximas('1',1) 
as foo(  numero_control character varying,  
         cliente character varying,  
         factura character varying ,  
         moneda_factura character varying,  
         pesos character varying ,  
         semana_actual double precision,  
         dia_semana_actual double precision,  
         fecha_vencimiento date,  
         semana_vencimiento double precision,  
         dia_semana_vencimiento double precision,  
         lunes double precision,  
         martes double precision,  
         miercoles double precision,  
         jueves double precision,  
         viernes double precision,  
         lunes_proximo text,  
         viernes_proximo text,  
         total double precision );
*/
END;

$_$;


--
-- Name: repventasnetasproductofactura(integer, character varying, character varying, character varying, character varying, integer, integer, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.repventasnetasproductofactura(tipo_reporte integer, cliente character varying, producto character varying, fecha_inicial character varying, fecha_final character varying, empresa_id integer, id_linea integer, id_marca integer, id_familia integer, id_subfamilia integer, tipo_costo integer, id_agente integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE
	cadena_sql text = '';
	cadena_where text ='';
	cadena_tipo_costo text ='';
	ordenado_por text ='';
	modo_ordenacion text ='';
	
	fila record;

BEGIN
	cadena_where:='';	
	--'||cadena_where||'
	IF  tipo_reporte = 1 THEN   --clientes
		--ordenado_por='cxc_clie.numero_control,fac_docs.momento_creacion ';
		ordenado_por='cxc_clie.razon_social asc ,moneda asc ,fac_docs.momento_creacion asc , inv_prod.sku,inv_prod_presentaciones.id';
		modo_ordenacion='asc';
	END IF;
	
	IF tipo_reporte = 2 THEN    --productos   select * from inv_prod
		ordenado_por='inv_prod.sku,moneda,unidad';
		modo_ordenacion='asc';
	END IF;

	IF tipo_reporte = 3 THEN   --  +producto
		ordenado_por='producto,cantidad';
		--modo_ordenacion='desc';
		modo_ordenacion='desc';
	END IF;

	IF tipo_reporte = 4 THEN    --- +cliete
		ordenado_por='razon_social,cantidad';
		--modo_ordenacion='desc';
		modo_ordenacion='desc';
	END IF;
	
	IF cliente != '%%' THEN
		cadena_where:= cadena_where ||' AND  cxc_clie.razon_social ilike  '''||replace(cliente, '%%', '%')||'''';
	END IF;

	if producto != '%%' THEN
		cadena_where:= cadena_where ||' AND  inv_prod.descripcion ilike  '''||producto||'''';
	END IF;
	

	if id_linea != 0 THEN
		cadena_where:= cadena_where ||' AND  inv_prod.inv_prod_linea_id = '||id_linea||'';
	END IF;
	if id_marca != 0 THEN
		cadena_where:= cadena_where ||' AND  inv_prod.inv_mar_id = '||id_marca||'';
	END IF;
	if id_familia != 0 THEN
		cadena_where:= cadena_where ||' AND  inv_prod.inv_prod_familia_id = '||id_familia||'';
	END IF;
	if id_subfamilia != 0 THEN
		cadena_where:= cadena_where ||' AND  inv_prod.subfamilia_id =  '||id_subfamilia||'';
	END IF;
	if id_agente != 0 THEN
		cadena_where:= cadena_where ||' AND  fac_docs.cxc_agen_id =  '||id_agente||'';
	END IF;
	if tipo_costo = 1 THEN
	----toma el mes de la fecha de la factura
	--incrementa := EXTRACT(MONTH FROM str_data[7]::timestamp with time zone)::integer
		--cadena_tipo_costo:= '(CASE WHEN fac_docs.moneda_id=1  THEN fac_docs_detalles.costo_promedio * fac_docs_detalles.cantidad
	        --                     ELSE fac_docs_detalles.costo_promedio  * fac_docs.tipo_cambio  * fac_docs_detalles.cantidad END) AS costo,';
		cadena_tipo_costo:= '(fac_docs_detalles.costo_promedio * fac_docs_detalles.cantidad ) AS costo,';
	END IF;
	if tipo_costo = 2 THEN
		cadena_tipo_costo:= '
		(CASE 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=1 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_1 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_1=1 THEN inv_prod_cost_prom.costo_ultimo_1 ELSE inv_prod_cost_prom.costo_ultimo_1 * (case when inv_prod_cost_prom.tipo_cambio_1=0 then 1 else inv_prod_cost_prom.tipo_cambio_1 end) END) + (CASE WHEN inv_prod_costos.costo_adic_1 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_1=1 THEN inv_prod_costos.costo_adic_1 ELSE inv_prod_costos.costo_adic_1 * (case when inv_prod_cost_prom.tipo_cambio_1=0 then 1 else inv_prod_cost_prom.tipo_cambio_1 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_1=1 THEN inv_prod_cost_prom.costo_ultimo_1 ELSE inv_prod_cost_prom.costo_ultimo_1 * (case when inv_prod_cost_prom.tipo_cambio_1=0 then 1 else inv_prod_cost_prom.tipo_cambio_1 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_1 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_1 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_1=1 THEN inv_prod_cost_prom.costo_ultimo_1 ELSE inv_prod_cost_prom.costo_ultimo_1 * (case when inv_prod_cost_prom.tipo_cambio_1=0 then 1 else inv_prod_cost_prom.tipo_cambio_1 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_1 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_1 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=2 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_2 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_2=1 THEN inv_prod_cost_prom.costo_ultimo_2 ELSE inv_prod_cost_prom.costo_ultimo_2 * (case when inv_prod_cost_prom.tipo_cambio_2=0 then 1 else inv_prod_cost_prom.tipo_cambio_2 end) END) + (CASE WHEN inv_prod_costos.costo_adic_2 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_2=1 THEN inv_prod_costos.costo_adic_2 ELSE inv_prod_costos.costo_adic_2 * (case when inv_prod_cost_prom.tipo_cambio_2=0 then 1 else inv_prod_cost_prom.tipo_cambio_2 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_2=1 THEN inv_prod_cost_prom.costo_ultimo_2 ELSE inv_prod_cost_prom.costo_ultimo_2 * (case when inv_prod_cost_prom.tipo_cambio_2=0 then 1 else inv_prod_cost_prom.tipo_cambio_2 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_2 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_2 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_2=1 THEN inv_prod_cost_prom.costo_ultimo_2 ELSE inv_prod_cost_prom.costo_ultimo_2 * (case when inv_prod_cost_prom.tipo_cambio_2=0 then 1 else inv_prod_cost_prom.tipo_cambio_2 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_2 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_2 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=3 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_3 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_3=1 THEN inv_prod_cost_prom.costo_ultimo_3 ELSE inv_prod_cost_prom.costo_ultimo_3 * (case when inv_prod_cost_prom.tipo_cambio_3=0 then 1 else inv_prod_cost_prom.tipo_cambio_3 end) END) + (CASE WHEN inv_prod_costos.costo_adic_3 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_3=1 THEN inv_prod_costos.costo_adic_3 ELSE inv_prod_costos.costo_adic_3 * (case when inv_prod_cost_prom.tipo_cambio_3=0 then 1 else inv_prod_cost_prom.tipo_cambio_3 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_3=1 THEN inv_prod_cost_prom.costo_ultimo_3 ELSE inv_prod_cost_prom.costo_ultimo_3 * (case when inv_prod_cost_prom.tipo_cambio_3=0 then 1 else inv_prod_cost_prom.tipo_cambio_3 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_3 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_3 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_3=1 THEN inv_prod_cost_prom.costo_ultimo_3 ELSE inv_prod_cost_prom.costo_ultimo_3 * (case when inv_prod_cost_prom.tipo_cambio_3=0 then 1 else inv_prod_cost_prom.tipo_cambio_3 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_3 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_3 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=4 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_4 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_4=1 THEN inv_prod_cost_prom.costo_ultimo_4 ELSE inv_prod_cost_prom.costo_ultimo_4 * (case when inv_prod_cost_prom.tipo_cambio_4=0 then 1 else inv_prod_cost_prom.tipo_cambio_4 end) END) + (CASE WHEN inv_prod_costos.costo_adic_4 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_4=1 THEN inv_prod_costos.costo_adic_4 ELSE inv_prod_costos.costo_adic_4 * (case when inv_prod_cost_prom.tipo_cambio_4=0 then 1 else inv_prod_cost_prom.tipo_cambio_4 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_4=1 THEN inv_prod_cost_prom.costo_ultimo_4 ELSE inv_prod_cost_prom.costo_ultimo_4 * (case when inv_prod_cost_prom.tipo_cambio_4=0 then 1 else inv_prod_cost_prom.tipo_cambio_4 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_4 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_4 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_4=1 THEN inv_prod_cost_prom.costo_ultimo_4 ELSE inv_prod_cost_prom.costo_ultimo_4 * (case when inv_prod_cost_prom.tipo_cambio_4=0 then 1 else inv_prod_cost_prom.tipo_cambio_4 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_4 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_4 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=5 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_5 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_5=1 THEN inv_prod_cost_prom.costo_ultimo_5 ELSE inv_prod_cost_prom.costo_ultimo_5 * (case when inv_prod_cost_prom.tipo_cambio_5=0 then 1 else inv_prod_cost_prom.tipo_cambio_5 end) END) + (CASE WHEN inv_prod_costos.costo_adic_5 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_5=1 THEN inv_prod_costos.costo_adic_5 ELSE inv_prod_costos.costo_adic_5 * (case when inv_prod_cost_prom.tipo_cambio_5=0 then 1 else inv_prod_cost_prom.tipo_cambio_5 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_5=1 THEN inv_prod_cost_prom.costo_ultimo_5 ELSE inv_prod_cost_prom.costo_ultimo_5 * (case when inv_prod_cost_prom.tipo_cambio_5=0 then 1 else inv_prod_cost_prom.tipo_cambio_5 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_5 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_5 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_5=1 THEN inv_prod_cost_prom.costo_ultimo_5 ELSE inv_prod_cost_prom.costo_ultimo_5 * (case when inv_prod_cost_prom.tipo_cambio_5=0 then 1 else inv_prod_cost_prom.tipo_cambio_5 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_5 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_5 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=6 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_6 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_6=1 THEN inv_prod_cost_prom.costo_ultimo_6 ELSE inv_prod_cost_prom.costo_ultimo_6 * (case when inv_prod_cost_prom.tipo_cambio_6=0 then 1 else inv_prod_cost_prom.tipo_cambio_6 end) END) + (CASE WHEN inv_prod_costos.costo_adic_6 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_6=1 THEN inv_prod_costos.costo_adic_6 ELSE inv_prod_costos.costo_adic_6 * (case when inv_prod_cost_prom.tipo_cambio_6=0 then 1 else inv_prod_cost_prom.tipo_cambio_6 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_6=1 THEN inv_prod_cost_prom.costo_ultimo_6 ELSE inv_prod_cost_prom.costo_ultimo_6 * (case when inv_prod_cost_prom.tipo_cambio_6=0 then 1 else inv_prod_cost_prom.tipo_cambio_6 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_6 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_6 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_6=1 THEN inv_prod_cost_prom.costo_ultimo_6 ELSE inv_prod_cost_prom.costo_ultimo_6 * (case when inv_prod_cost_prom.tipo_cambio_6=0 then 1 else inv_prod_cost_prom.tipo_cambio_6 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_6 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_6 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=7 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_7 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_7=1 THEN inv_prod_cost_prom.costo_ultimo_7 ELSE inv_prod_cost_prom.costo_ultimo_7 * (case when inv_prod_cost_prom.tipo_cambio_7=0 then 1 else inv_prod_cost_prom.tipo_cambio_7 end) END) + (CASE WHEN inv_prod_costos.costo_adic_7 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_7=1 THEN inv_prod_costos.costo_adic_7 ELSE inv_prod_costos.costo_adic_7 * (case when inv_prod_cost_prom.tipo_cambio_7=0 then 1 else inv_prod_cost_prom.tipo_cambio_7 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_7=1 THEN inv_prod_cost_prom.costo_ultimo_7 ELSE inv_prod_cost_prom.costo_ultimo_7 * (case when inv_prod_cost_prom.tipo_cambio_7=0 then 1 else inv_prod_cost_prom.tipo_cambio_7 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_7 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_7 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_7=1 THEN inv_prod_cost_prom.costo_ultimo_7 ELSE inv_prod_cost_prom.costo_ultimo_7 * (case when inv_prod_cost_prom.tipo_cambio_7=0 then 1 else inv_prod_cost_prom.tipo_cambio_7 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_7 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_7 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=8 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_8 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_8=1 THEN inv_prod_cost_prom.costo_ultimo_8 ELSE inv_prod_cost_prom.costo_ultimo_8 * (case when inv_prod_cost_prom.tipo_cambio_8=0 then 1 else inv_prod_cost_prom.tipo_cambio_8 end) END) + (CASE WHEN inv_prod_costos.costo_adic_8 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_8=1 THEN inv_prod_costos.costo_adic_8 ELSE inv_prod_costos.costo_adic_8 * (case when inv_prod_cost_prom.tipo_cambio_8=0 then 1 else inv_prod_cost_prom.tipo_cambio_8 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_8=1 THEN inv_prod_cost_prom.costo_ultimo_8 ELSE inv_prod_cost_prom.costo_ultimo_8 * (case when inv_prod_cost_prom.tipo_cambio_8=0 then 1 else inv_prod_cost_prom.tipo_cambio_8 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_8 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_8 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_8=1 THEN inv_prod_cost_prom.costo_ultimo_8 ELSE inv_prod_cost_prom.costo_ultimo_8 * (case when inv_prod_cost_prom.tipo_cambio_8=0 then 1 else inv_prod_cost_prom.tipo_cambio_8 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_8 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_8 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=9 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_9 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_9=1 THEN inv_prod_cost_prom.costo_ultimo_9 ELSE inv_prod_cost_prom.costo_ultimo_9 * (case when inv_prod_cost_prom.tipo_cambio_9=0 then 1 else inv_prod_cost_prom.tipo_cambio_9 end) END) + (CASE WHEN inv_prod_costos.costo_adic_9 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_9=1 THEN inv_prod_costos.costo_adic_9 ELSE inv_prod_costos.costo_adic_9 * (case when inv_prod_cost_prom.tipo_cambio_9=0 then 1 else inv_prod_cost_prom.tipo_cambio_9 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_9=1 THEN inv_prod_cost_prom.costo_ultimo_9 ELSE inv_prod_cost_prom.costo_ultimo_9 * (case when inv_prod_cost_prom.tipo_cambio_9=0 then 1 else inv_prod_cost_prom.tipo_cambio_9 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_9 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_9 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_9=1 THEN inv_prod_cost_prom.costo_ultimo_9 ELSE inv_prod_cost_prom.costo_ultimo_9 * (case when inv_prod_cost_prom.tipo_cambio_9=0 then 1 else inv_prod_cost_prom.tipo_cambio_9 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_9 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_9 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=10 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_10 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_10=1 THEN inv_prod_cost_prom.costo_ultimo_10 ELSE inv_prod_cost_prom.costo_ultimo_10 * (case when inv_prod_cost_prom.tipo_cambio_10=0 then 1 else inv_prod_cost_prom.tipo_cambio_10 end) END) + (CASE WHEN inv_prod_costos.costo_adic_10 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_10=1 THEN inv_prod_costos.costo_adic_10 ELSE inv_prod_costos.costo_adic_10 * (case when inv_prod_cost_prom.tipo_cambio_10=0 then 1 else inv_prod_cost_prom.tipo_cambio_10 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_10=1 THEN inv_prod_cost_prom.costo_ultimo_10 ELSE inv_prod_cost_prom.costo_ultimo_10 * (case when inv_prod_cost_prom.tipo_cambio_10=0 then 1 else inv_prod_cost_prom.tipo_cambio_10 end) END) * ((CASE WHEN inv_prod_costos.costo_imp_10 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_10 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_10=1 THEN inv_prod_cost_prom.costo_ultimo_10 ELSE inv_prod_cost_prom.costo_ultimo_10 * (case when inv_prod_cost_prom.tipo_cambio_10=0 then 1 else inv_prod_cost_prom.tipo_cambio_10 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_10 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_10 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=11 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_11 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_11=1 THEN inv_prod_cost_prom.costo_ultimo_11 ELSE inv_prod_cost_prom.costo_ultimo_11 * (case when inv_prod_cost_prom.tipo_cambio_11=0 then 1 else inv_prod_cost_prom.tipo_cambio_11 end) END) + (CASE WHEN inv_prod_costos.costo_adic_11 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_11=1 THEN inv_prod_costos.costo_adic_11 ELSE inv_prod_costos.costo_adic_11 * (case when inv_prod_cost_prom.tipo_cambio_11=0 then 1 else inv_prod_cost_prom.tipo_cambio_11 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_11=1 THEN inv_prod_cost_prom.costo_ultimo_11 ELSE inv_prod_cost_prom.costo_ultimo_11 * (case when inv_prod_cost_prom.tipo_cambio_11=0 then 1 else inv_prod_cost_prom.tipo_cambio_11 end) END) * ((CASE WHEN inv_prod_costos.costo_imp_11 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_11 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_11=1 THEN inv_prod_cost_prom.costo_ultimo_11 ELSE inv_prod_cost_prom.costo_ultimo_11 * (case when inv_prod_cost_prom.tipo_cambio_11=0 then 1 else inv_prod_cost_prom.tipo_cambio_11 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_11 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_11 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=12 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_12 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_12=1 THEN inv_prod_cost_prom.costo_ultimo_12 ELSE inv_prod_cost_prom.costo_ultimo_12 * (case when inv_prod_cost_prom.tipo_cambio_12=0 then 1 else inv_prod_cost_prom.tipo_cambio_12 end) END) + (CASE WHEN inv_prod_costos.costo_adic_12 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_12=1 THEN inv_prod_costos.costo_adic_12 ELSE inv_prod_costos.costo_adic_12 * (case when inv_prod_cost_prom.tipo_cambio_12=0 then 1 else inv_prod_cost_prom.tipo_cambio_12 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_12=1 THEN inv_prod_cost_prom.costo_ultimo_12 ELSE inv_prod_cost_prom.costo_ultimo_12 * (case when inv_prod_cost_prom.tipo_cambio_12=0 then 1 else inv_prod_cost_prom.tipo_cambio_12 end) END) * ((CASE WHEN inv_prod_costos.costo_imp_12 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_12 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_12=1 THEN inv_prod_cost_prom.costo_ultimo_12 ELSE inv_prod_cost_prom.costo_ultimo_12 * (case when inv_prod_cost_prom.tipo_cambio_12=0 then 1 else inv_prod_cost_prom.tipo_cambio_12 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_12 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_12 END) /100))) END) 
		ELSE 0 END)  * fac_docs_detalles.cantidad  AS costo,';
	END IF;
	
	--update inv_prod_cost_prom set costo_ultimo_1=100 
	--update inv_prod_costos set costo_imp_1=10 ,costo_dir_1=10
	
	cadena_sql:= '
			SELECT  DISTINCT
				cxc_clie.numero_control,
				cxc_clie.razon_social,  
				inv_prod.sku AS codigo,  
				inv_prod.descripcion AS producto,  
				fac_docs.serie_folio AS factura,  
				inv_prod_unidades.titulo_abr AS unidad, 
				fac_docs_detalles.cantidad,  
				fac_docs_detalles.precio_unitario,  
				(case when fac_docs.moneda_id = 1 then ''MN'' else ''USD''  end) AS moneda,  
				fac_docs.tipo_cambio AS tipo_cambio,  
				(CASE WHEN fac_docs.moneda_id=1  THEN fac_docs_detalles.precio_unitario * fac_docs_detalles.cantidad
				ELSE (fac_docs_detalles.precio_unitario * fac_docs_detalles.cantidad) * fac_docs.tipo_cambio END) AS venta_pesos,
				
				'||cadena_tipo_costo||'
				
				to_char(fac_docs.momento_creacion,''dd/mm/yyyy'') as fecha_factura,
				fac_docs.momento_creacion,
				
				inv_prod_presentaciones.id as id_presentacion,
				inv_prod_presentaciones.titulo as presentacion

			FROM fac_docs_detalles
			JOIN fac_docs ON fac_docs.id = fac_docs_detalles.fac_doc_id
			JOIN inv_prod ON inv_prod.id= fac_docs_detalles.inv_prod_id  
			JOIN inv_prod_unidades on inv_prod_unidades.id=fac_docs_detalles.inv_prod_unidad_id  
			JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id = fac_docs_detalles.inv_prod_presentacion_id 
			LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=fac_docs_detalles.inv_prod_id  AND inv_prod_costos.inv_prod_presentacion_id=fac_docs_detalles.inv_prod_presentacion_id AND inv_prod_costos.ano=EXTRACT(YEAR FROM fac_docs.momento_creacion)::integer )
			LEFT JOIN inv_prod_cost_prom ON (inv_prod_cost_prom.inv_prod_id = inv_prod.id AND inv_prod_cost_prom.ano=EXTRACT(YEAR FROM fac_docs.momento_creacion)::integer)
			JOIN cxc_clie ON cxc_clie.id = fac_docs.cxc_clie_id
			JOIN erp_proceso on erp_proceso.id= fac_docs.proceso_id 
			WHERE fac_docs.cancelado=false  and  tipo_cambio !=0 
			'||cadena_where||'   
			AND erp_proceso.empresa_id = '||empresa_id ||'
			AND to_char(fac_docs.momento_creacion,''yyyymmdd'')::integer between to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymmdd'')::integer AND to_char('''||fecha_final||'''::timestamp with time zone,''yyyymmdd'')::integer
			order by '||ordenado_por||' '||modo_ordenacion||'';
			
		--RAISE EXCEPTION '%',cadena_sql;
		
		FOR fila IN EXECUTE (cadena_sql) LOOP
			RETURN NEXT fila;
		END LOOP;


	/*
	select * from repventasnetasproductofactura(2,'','','2012-10-01','2012-12-31',1,0,0,0,0,1,5) as foo(
	numero_control character varying,         
	razon_social character varying, 
	codigo character varying, 
	producto character varying, 
	factura character varying , 
	unidad character varying , 
	cantidad double precision, 
	precio_unitario double precision, 
	moneda text, 
	tipo_cambio double precision,  
	venta_pesos double precision,  
	costo double precision,  
	fecha_factura text,

	id_presentacion Integer,
	presentacion character varying
	); 

	*/

END;

$$;


--
-- Name: repventasnetasproductofactura(integer, character varying, character varying, character varying, character varying, integer, integer, integer, integer, integer, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.repventasnetasproductofactura(tipo_reporte integer, cliente character varying, producto character varying, fecha_inicial character varying, fecha_final character varying, empresa_id integer, id_linea integer, id_marca integer, id_familia integer, id_subfamilia integer, tipo_costo integer, id_agente integer, id_segmento integer, id_mercado integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE
	cadena_sql text = '';
	cadena_where text ='';
	cadena_tipo_costo text ='';
	ordenado_por text ='';
	modo_ordenacion text ='';
	
	fila record;

BEGIN
	cadena_where:='';
	--'||cadena_where||'
	IF  tipo_reporte = 1 THEN   --clientes
		--ordenado_por='cxc_clie.numero_control,fac_docs.momento_creacion ';
		ordenado_por='cxc_clie.razon_social asc ,moneda asc ,fac_docs.momento_creacion asc , inv_prod.sku,inv_prod_presentaciones.id';
		modo_ordenacion='asc';
	END IF;
	
	IF tipo_reporte = 2 THEN    --productos   select * from inv_prod
		ordenado_por='inv_prod.sku,moneda,unidad';
		modo_ordenacion='asc';
	END IF;

	IF tipo_reporte = 3 THEN   --  +producto
		ordenado_por='producto,cantidad';
		--modo_ordenacion='desc';
		modo_ordenacion='desc';
	END IF;

	IF tipo_reporte = 4 THEN    --- +cliete
		ordenado_por='razon_social,cantidad';
		--modo_ordenacion='desc';
		modo_ordenacion='desc';
	END IF;
	
	IF trim(cliente) <> '%%' THEN
		cadena_where:= cadena_where ||' AND cxc_clie.razon_social ilike '''||replace(cliente, '%%', '%')||'''';
	END IF;

	if trim(producto) <> '%%' THEN
		cadena_where:= cadena_where ||' AND inv_prod.descripcion ilike '''||producto||'''';
	END IF;
	
	if id_linea > 0 THEN
		cadena_where:= cadena_where ||' AND inv_prod.inv_prod_linea_id='||id_linea||'';
	END IF;
	
	if id_marca > 0 THEN
		cadena_where:= cadena_where ||' AND inv_prod.inv_mar_id='||id_marca||'';
	END IF;
	
	if id_familia > 0 THEN
		cadena_where:= cadena_where ||' AND inv_prod.inv_prod_familia_id='||id_familia||'';
	END IF;
	
	if id_subfamilia > 0 THEN
		cadena_where:= cadena_where ||' AND inv_prod.subfamilia_id='||id_subfamilia||'';
	END IF;
	
	if id_agente > 0 THEN
		cadena_where:= cadena_where ||' AND fac_docs.cxc_agen_id='||id_agente||'';
	END IF;

	if id_segmento > 0 THEN
		cadena_where:= cadena_where ||' AND cxc_clie.clasif_1='||id_segmento||'';
	END IF;

	if id_mercado > 0 THEN
		cadena_where:= cadena_where ||' AND cxc_clie.clasif_2='||id_mercado||'';
	END IF;
	
	if tipo_costo = 1 THEN
	----toma el mes de la fecha de la factura
	--incrementa := EXTRACT(MONTH FROM str_data[7]::timestamp with time zone)::integer
		--cadena_tipo_costo:= '(CASE WHEN fac_docs.moneda_id=1  THEN fac_docs_detalles.costo_promedio * fac_docs_detalles.cantidad
	        --                     ELSE fac_docs_detalles.costo_promedio  * fac_docs.tipo_cambio  * fac_docs_detalles.cantidad END) AS costo,';
		cadena_tipo_costo:= '(fac_docs_detalles.costo_promedio * fac_docs_detalles.cantidad ) AS costo,';
	END IF;
	if tipo_costo = 2 THEN
		cadena_tipo_costo:= '
		(CASE 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=1 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_1 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_1=1 THEN inv_prod_cost_prom.costo_ultimo_1 ELSE inv_prod_cost_prom.costo_ultimo_1 * (case when inv_prod_cost_prom.tipo_cambio_1=0 then 1 else inv_prod_cost_prom.tipo_cambio_1 end) END) + (CASE WHEN inv_prod_costos.costo_adic_1 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_1=1 THEN inv_prod_costos.costo_adic_1 ELSE inv_prod_costos.costo_adic_1 * (case when inv_prod_cost_prom.tipo_cambio_1=0 then 1 else inv_prod_cost_prom.tipo_cambio_1 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_1=1 THEN inv_prod_cost_prom.costo_ultimo_1 ELSE inv_prod_cost_prom.costo_ultimo_1 * (case when inv_prod_cost_prom.tipo_cambio_1=0 then 1 else inv_prod_cost_prom.tipo_cambio_1 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_1 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_1 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_1=1 THEN inv_prod_cost_prom.costo_ultimo_1 ELSE inv_prod_cost_prom.costo_ultimo_1 * (case when inv_prod_cost_prom.tipo_cambio_1=0 then 1 else inv_prod_cost_prom.tipo_cambio_1 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_1 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_1 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=2 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_2 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_2=1 THEN inv_prod_cost_prom.costo_ultimo_2 ELSE inv_prod_cost_prom.costo_ultimo_2 * (case when inv_prod_cost_prom.tipo_cambio_2=0 then 1 else inv_prod_cost_prom.tipo_cambio_2 end) END) + (CASE WHEN inv_prod_costos.costo_adic_2 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_2=1 THEN inv_prod_costos.costo_adic_2 ELSE inv_prod_costos.costo_adic_2 * (case when inv_prod_cost_prom.tipo_cambio_2=0 then 1 else inv_prod_cost_prom.tipo_cambio_2 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_2=1 THEN inv_prod_cost_prom.costo_ultimo_2 ELSE inv_prod_cost_prom.costo_ultimo_2 * (case when inv_prod_cost_prom.tipo_cambio_2=0 then 1 else inv_prod_cost_prom.tipo_cambio_2 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_2 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_2 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_2=1 THEN inv_prod_cost_prom.costo_ultimo_2 ELSE inv_prod_cost_prom.costo_ultimo_2 * (case when inv_prod_cost_prom.tipo_cambio_2=0 then 1 else inv_prod_cost_prom.tipo_cambio_2 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_2 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_2 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=3 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_3 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_3=1 THEN inv_prod_cost_prom.costo_ultimo_3 ELSE inv_prod_cost_prom.costo_ultimo_3 * (case when inv_prod_cost_prom.tipo_cambio_3=0 then 1 else inv_prod_cost_prom.tipo_cambio_3 end) END) + (CASE WHEN inv_prod_costos.costo_adic_3 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_3=1 THEN inv_prod_costos.costo_adic_3 ELSE inv_prod_costos.costo_adic_3 * (case when inv_prod_cost_prom.tipo_cambio_3=0 then 1 else inv_prod_cost_prom.tipo_cambio_3 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_3=1 THEN inv_prod_cost_prom.costo_ultimo_3 ELSE inv_prod_cost_prom.costo_ultimo_3 * (case when inv_prod_cost_prom.tipo_cambio_3=0 then 1 else inv_prod_cost_prom.tipo_cambio_3 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_3 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_3 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_3=1 THEN inv_prod_cost_prom.costo_ultimo_3 ELSE inv_prod_cost_prom.costo_ultimo_3 * (case when inv_prod_cost_prom.tipo_cambio_3=0 then 1 else inv_prod_cost_prom.tipo_cambio_3 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_3 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_3 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=4 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_4 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_4=1 THEN inv_prod_cost_prom.costo_ultimo_4 ELSE inv_prod_cost_prom.costo_ultimo_4 * (case when inv_prod_cost_prom.tipo_cambio_4=0 then 1 else inv_prod_cost_prom.tipo_cambio_4 end) END) + (CASE WHEN inv_prod_costos.costo_adic_4 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_4=1 THEN inv_prod_costos.costo_adic_4 ELSE inv_prod_costos.costo_adic_4 * (case when inv_prod_cost_prom.tipo_cambio_4=0 then 1 else inv_prod_cost_prom.tipo_cambio_4 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_4=1 THEN inv_prod_cost_prom.costo_ultimo_4 ELSE inv_prod_cost_prom.costo_ultimo_4 * (case when inv_prod_cost_prom.tipo_cambio_4=0 then 1 else inv_prod_cost_prom.tipo_cambio_4 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_4 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_4 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_4=1 THEN inv_prod_cost_prom.costo_ultimo_4 ELSE inv_prod_cost_prom.costo_ultimo_4 * (case when inv_prod_cost_prom.tipo_cambio_4=0 then 1 else inv_prod_cost_prom.tipo_cambio_4 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_4 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_4 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=5 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_5 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_5=1 THEN inv_prod_cost_prom.costo_ultimo_5 ELSE inv_prod_cost_prom.costo_ultimo_5 * (case when inv_prod_cost_prom.tipo_cambio_5=0 then 1 else inv_prod_cost_prom.tipo_cambio_5 end) END) + (CASE WHEN inv_prod_costos.costo_adic_5 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_5=1 THEN inv_prod_costos.costo_adic_5 ELSE inv_prod_costos.costo_adic_5 * (case when inv_prod_cost_prom.tipo_cambio_5=0 then 1 else inv_prod_cost_prom.tipo_cambio_5 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_5=1 THEN inv_prod_cost_prom.costo_ultimo_5 ELSE inv_prod_cost_prom.costo_ultimo_5 * (case when inv_prod_cost_prom.tipo_cambio_5=0 then 1 else inv_prod_cost_prom.tipo_cambio_5 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_5 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_5 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_5=1 THEN inv_prod_cost_prom.costo_ultimo_5 ELSE inv_prod_cost_prom.costo_ultimo_5 * (case when inv_prod_cost_prom.tipo_cambio_5=0 then 1 else inv_prod_cost_prom.tipo_cambio_5 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_5 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_5 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=6 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_6 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_6=1 THEN inv_prod_cost_prom.costo_ultimo_6 ELSE inv_prod_cost_prom.costo_ultimo_6 * (case when inv_prod_cost_prom.tipo_cambio_6=0 then 1 else inv_prod_cost_prom.tipo_cambio_6 end) END) + (CASE WHEN inv_prod_costos.costo_adic_6 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_6=1 THEN inv_prod_costos.costo_adic_6 ELSE inv_prod_costos.costo_adic_6 * (case when inv_prod_cost_prom.tipo_cambio_6=0 then 1 else inv_prod_cost_prom.tipo_cambio_6 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_6=1 THEN inv_prod_cost_prom.costo_ultimo_6 ELSE inv_prod_cost_prom.costo_ultimo_6 * (case when inv_prod_cost_prom.tipo_cambio_6=0 then 1 else inv_prod_cost_prom.tipo_cambio_6 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_6 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_6 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_6=1 THEN inv_prod_cost_prom.costo_ultimo_6 ELSE inv_prod_cost_prom.costo_ultimo_6 * (case when inv_prod_cost_prom.tipo_cambio_6=0 then 1 else inv_prod_cost_prom.tipo_cambio_6 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_6 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_6 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=7 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_7 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_7=1 THEN inv_prod_cost_prom.costo_ultimo_7 ELSE inv_prod_cost_prom.costo_ultimo_7 * (case when inv_prod_cost_prom.tipo_cambio_7=0 then 1 else inv_prod_cost_prom.tipo_cambio_7 end) END) + (CASE WHEN inv_prod_costos.costo_adic_7 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_7=1 THEN inv_prod_costos.costo_adic_7 ELSE inv_prod_costos.costo_adic_7 * (case when inv_prod_cost_prom.tipo_cambio_7=0 then 1 else inv_prod_cost_prom.tipo_cambio_7 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_7=1 THEN inv_prod_cost_prom.costo_ultimo_7 ELSE inv_prod_cost_prom.costo_ultimo_7 * (case when inv_prod_cost_prom.tipo_cambio_7=0 then 1 else inv_prod_cost_prom.tipo_cambio_7 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_7 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_7 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_7=1 THEN inv_prod_cost_prom.costo_ultimo_7 ELSE inv_prod_cost_prom.costo_ultimo_7 * (case when inv_prod_cost_prom.tipo_cambio_7=0 then 1 else inv_prod_cost_prom.tipo_cambio_7 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_7 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_7 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=8 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_8 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_8=1 THEN inv_prod_cost_prom.costo_ultimo_8 ELSE inv_prod_cost_prom.costo_ultimo_8 * (case when inv_prod_cost_prom.tipo_cambio_8=0 then 1 else inv_prod_cost_prom.tipo_cambio_8 end) END) + (CASE WHEN inv_prod_costos.costo_adic_8 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_8=1 THEN inv_prod_costos.costo_adic_8 ELSE inv_prod_costos.costo_adic_8 * (case when inv_prod_cost_prom.tipo_cambio_8=0 then 1 else inv_prod_cost_prom.tipo_cambio_8 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_8=1 THEN inv_prod_cost_prom.costo_ultimo_8 ELSE inv_prod_cost_prom.costo_ultimo_8 * (case when inv_prod_cost_prom.tipo_cambio_8=0 then 1 else inv_prod_cost_prom.tipo_cambio_8 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_8 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_8 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_8=1 THEN inv_prod_cost_prom.costo_ultimo_8 ELSE inv_prod_cost_prom.costo_ultimo_8 * (case when inv_prod_cost_prom.tipo_cambio_8=0 then 1 else inv_prod_cost_prom.tipo_cambio_8 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_8 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_8 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=9 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_9 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_9=1 THEN inv_prod_cost_prom.costo_ultimo_9 ELSE inv_prod_cost_prom.costo_ultimo_9 * (case when inv_prod_cost_prom.tipo_cambio_9=0 then 1 else inv_prod_cost_prom.tipo_cambio_9 end) END) + (CASE WHEN inv_prod_costos.costo_adic_9 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_9=1 THEN inv_prod_costos.costo_adic_9 ELSE inv_prod_costos.costo_adic_9 * (case when inv_prod_cost_prom.tipo_cambio_9=0 then 1 else inv_prod_cost_prom.tipo_cambio_9 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_9=1 THEN inv_prod_cost_prom.costo_ultimo_9 ELSE inv_prod_cost_prom.costo_ultimo_9 * (case when inv_prod_cost_prom.tipo_cambio_9=0 then 1 else inv_prod_cost_prom.tipo_cambio_9 end) END) *  ((CASE WHEN inv_prod_costos.costo_imp_9 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_9 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_9=1 THEN inv_prod_cost_prom.costo_ultimo_9 ELSE inv_prod_cost_prom.costo_ultimo_9 * (case when inv_prod_cost_prom.tipo_cambio_9=0 then 1 else inv_prod_cost_prom.tipo_cambio_9 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_9 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_9 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=10 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_10 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_10=1 THEN inv_prod_cost_prom.costo_ultimo_10 ELSE inv_prod_cost_prom.costo_ultimo_10 * (case when inv_prod_cost_prom.tipo_cambio_10=0 then 1 else inv_prod_cost_prom.tipo_cambio_10 end) END) + (CASE WHEN inv_prod_costos.costo_adic_10 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_10=1 THEN inv_prod_costos.costo_adic_10 ELSE inv_prod_costos.costo_adic_10 * (case when inv_prod_cost_prom.tipo_cambio_10=0 then 1 else inv_prod_cost_prom.tipo_cambio_10 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_10=1 THEN inv_prod_cost_prom.costo_ultimo_10 ELSE inv_prod_cost_prom.costo_ultimo_10 * (case when inv_prod_cost_prom.tipo_cambio_10=0 then 1 else inv_prod_cost_prom.tipo_cambio_10 end) END) * ((CASE WHEN inv_prod_costos.costo_imp_10 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_10 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_10=1 THEN inv_prod_cost_prom.costo_ultimo_10 ELSE inv_prod_cost_prom.costo_ultimo_10 * (case when inv_prod_cost_prom.tipo_cambio_10=0 then 1 else inv_prod_cost_prom.tipo_cambio_10 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_10 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_10 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=11 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_11 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_11=1 THEN inv_prod_cost_prom.costo_ultimo_11 ELSE inv_prod_cost_prom.costo_ultimo_11 * (case when inv_prod_cost_prom.tipo_cambio_11=0 then 1 else inv_prod_cost_prom.tipo_cambio_11 end) END) + (CASE WHEN inv_prod_costos.costo_adic_11 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_11=1 THEN inv_prod_costos.costo_adic_11 ELSE inv_prod_costos.costo_adic_11 * (case when inv_prod_cost_prom.tipo_cambio_11=0 then 1 else inv_prod_cost_prom.tipo_cambio_11 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_11=1 THEN inv_prod_cost_prom.costo_ultimo_11 ELSE inv_prod_cost_prom.costo_ultimo_11 * (case when inv_prod_cost_prom.tipo_cambio_11=0 then 1 else inv_prod_cost_prom.tipo_cambio_11 end) END) * ((CASE WHEN inv_prod_costos.costo_imp_11 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_11 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_11=1 THEN inv_prod_cost_prom.costo_ultimo_11 ELSE inv_prod_cost_prom.costo_ultimo_11 * (case when inv_prod_cost_prom.tipo_cambio_11=0 then 1 else inv_prod_cost_prom.tipo_cambio_11 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_11 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_11 END) /100))) END) 
			WHEN EXTRACT(MONTH FROM fac_docs.momento_creacion)::integer=12 THEN (CASE WHEN inv_prod_cost_prom.costo_ultimo_12 IS NULL THEN 0 ELSE ((CASE WHEN inv_prod_cost_prom.gral_mon_id_12=1 THEN inv_prod_cost_prom.costo_ultimo_12 ELSE inv_prod_cost_prom.costo_ultimo_12 * (case when inv_prod_cost_prom.tipo_cambio_12=0 then 1 else inv_prod_cost_prom.tipo_cambio_12 end) END) + (CASE WHEN inv_prod_costos.costo_adic_12 IS NULL THEN 0 ELSE (CASE WHEN inv_prod_cost_prom.gral_mon_id_12=1 THEN inv_prod_costos.costo_adic_12 ELSE inv_prod_costos.costo_adic_12 * (case when inv_prod_cost_prom.tipo_cambio_12=0 then 1 else inv_prod_cost_prom.tipo_cambio_12 end) END) END) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_12=1 THEN inv_prod_cost_prom.costo_ultimo_12 ELSE inv_prod_cost_prom.costo_ultimo_12 * (case when inv_prod_cost_prom.tipo_cambio_12=0 then 1 else inv_prod_cost_prom.tipo_cambio_12 end) END) * ((CASE WHEN inv_prod_costos.costo_imp_12 IS NULL THEN 0 ELSE inv_prod_costos.costo_imp_12 END) /100)) + ((CASE WHEN inv_prod_cost_prom.gral_mon_id_12=1 THEN inv_prod_cost_prom.costo_ultimo_12 ELSE inv_prod_cost_prom.costo_ultimo_12 * (case when inv_prod_cost_prom.tipo_cambio_12=0 then 1 else inv_prod_cost_prom.tipo_cambio_12 end) END) *  ((CASE WHEN inv_prod_costos.costo_dir_12 IS NULL THEN 0 ELSE inv_prod_costos.costo_dir_12 END) /100))) END) 
		ELSE 0 END)  * fac_docs_detalles.cantidad  AS costo,';
	END IF;
	
	--update inv_prod_cost_prom set costo_ultimo_1=100 
	--update inv_prod_costos set costo_imp_1=10 ,costo_dir_1=10
	
	cadena_sql:= '
			SELECT  DISTINCT
				cxc_clie.numero_control,
				cxc_clie.razon_social,  
				inv_prod.sku AS codigo,  
				inv_prod.descripcion AS producto,  
				fac_docs.serie_folio AS factura,  
				inv_prod_unidades.titulo_abr AS unidad, 
				fac_docs_detalles.cantidad,  
				fac_docs_detalles.precio_unitario,  
				(case when fac_docs.moneda_id = 1 then ''MN'' else ''USD''  end) AS moneda,  
				fac_docs.tipo_cambio AS tipo_cambio,  
				(CASE WHEN fac_docs.moneda_id=1  THEN fac_docs_detalles.precio_unitario * fac_docs_detalles.cantidad
				ELSE (fac_docs_detalles.precio_unitario * fac_docs_detalles.cantidad) * fac_docs.tipo_cambio END) AS venta_pesos,
				
				'||cadena_tipo_costo||'
				
				to_char(fac_docs.momento_creacion,''dd/mm/yyyy'') as fecha_factura,
				fac_docs.momento_creacion,
				
				inv_prod_presentaciones.id as id_presentacion,
				inv_prod_presentaciones.titulo as presentacion

			FROM fac_docs_detalles
			JOIN fac_docs ON fac_docs.id = fac_docs_detalles.fac_doc_id
			JOIN inv_prod ON inv_prod.id= fac_docs_detalles.inv_prod_id  
			JOIN inv_prod_unidades on inv_prod_unidades.id=fac_docs_detalles.inv_prod_unidad_id  
			JOIN inv_prod_presentaciones ON inv_prod_presentaciones.id = fac_docs_detalles.inv_prod_presentacion_id 
			LEFT JOIN inv_prod_costos ON (inv_prod_costos.inv_prod_id=fac_docs_detalles.inv_prod_id  AND inv_prod_costos.inv_prod_presentacion_id=fac_docs_detalles.inv_prod_presentacion_id AND inv_prod_costos.ano=EXTRACT(YEAR FROM fac_docs.momento_creacion)::integer )
			LEFT JOIN inv_prod_cost_prom ON (inv_prod_cost_prom.inv_prod_id = inv_prod.id AND inv_prod_cost_prom.ano=EXTRACT(YEAR FROM fac_docs.momento_creacion)::integer)
			JOIN cxc_clie ON cxc_clie.id = fac_docs.cxc_clie_id
			JOIN erp_proceso on erp_proceso.id= fac_docs.proceso_id 
			WHERE fac_docs.cancelado=false  and  tipo_cambio !=0 
			'||cadena_where||'   
			AND erp_proceso.empresa_id = '||empresa_id ||'
			AND to_char(fac_docs.momento_creacion,''yyyymmdd'')::integer between to_char('''||fecha_inicial||'''::timestamp with time zone,''yyyymmdd'')::integer AND to_char('''||fecha_final||'''::timestamp with time zone,''yyyymmdd'')::integer
			order by '||ordenado_por||' '||modo_ordenacion||'';
			
		--RAISE EXCEPTION '%',cadena_sql;
		
		FOR fila IN EXECUTE (cadena_sql) LOOP
			RETURN NEXT fila;
		END LOOP;


	/*
	select * from repventasnetasproductofactura(2,'','','2012-10-01','2012-12-31',1,0,0,0,0,1,5,0,0) as foo(
	numero_control character varying,         
	razon_social character varying, 
	codigo character varying, 
	producto character varying, 
	factura character varying , 
	unidad character varying , 
	cantidad double precision, 
	precio_unitario double precision, 
	moneda text, 
	tipo_cambio double precision,  
	venta_pesos double precision,  
	costo double precision,  
	fecha_factura text,
	id_presentacion Integer,
	presentacion character varying
	); 

	*/

END;

$$;


SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: inv_alm_tipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_alm_tipos (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: TABLE inv_alm_tipos; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.inv_alm_tipos IS 'En esta tabla se agregan las posibles clasificaciones o tipos que un almacen podria ser';


--
-- Name: almacen_tipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.almacen_tipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: almacen_tipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.almacen_tipos_id_seq OWNED BY public.inv_alm_tipos.id;


--
-- Name: inv_alm; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_alm (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean,
    calle character varying,
    colonia character varying,
    numero character varying,
    codigo_postal character varying,
    almacen_tipo_id integer,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_pais_id integer,
    gral_edo_id integer,
    gral_mun_id integer,
    reporteo boolean DEFAULT false,
    ventas boolean DEFAULT false,
    compras boolean DEFAULT false,
    reabastecimiento boolean DEFAULT false,
    garantias boolean DEFAULT false,
    consignacion boolean DEFAULT false,
    recepcion_mat boolean DEFAULT false,
    explosion_mat boolean DEFAULT false,
    responsable character varying,
    responsable_email character varying,
    responsable_puesto character varying,
    tel_1_ext character varying,
    tel_2_ext character varying,
    tel_2 character varying,
    tel_1 character varying,
    traspaso boolean DEFAULT false
);


--
-- Name: TABLE inv_alm; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.inv_alm IS 'Tabla que define los almacenes que seran compartidos por una o mas sucursales';


--
-- Name: almacens_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.almacens_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: almacens_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.almacens_id_seq OWNED BY public.inv_alm.id;


--
-- Name: gral_rol; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_rol (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying,
    authority character varying NOT NULL,
    borrado_logico boolean DEFAULT false,
    gral_app_id integer DEFAULT 0
);


--
-- Name: TABLE gral_rol; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.gral_rol IS 'Tabla que relaciona al usuario y el rol que este juega en el sistema';


--
-- Name: gral_usr; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_usr (
    id integer NOT NULL,
    username character varying NOT NULL,
    password character varying NOT NULL,
    enabled boolean NOT NULL,
    nombre_pila character varying,
    email character varying,
    apellido_paterno character varying,
    apellido_materno character varying,
    ultimo_acceso timestamp with time zone,
    gral_empleados_id integer DEFAULT 0
);


--
-- Name: TABLE gral_usr; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.gral_usr IS 'Tabla que almacena los posibles usuarios que tendran acceso al sistema';


--
-- Name: gral_usr_rol; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_usr_rol (
    id integer NOT NULL,
    gral_usr_id integer NOT NULL,
    gral_rol_id integer NOT NULL
);


--
-- Name: authorities; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.authorities AS
 SELECT gral_usr.username,
    gral_rol.authority
   FROM ((public.gral_usr
     JOIN public.gral_usr_rol ON ((gral_usr_rol.gral_usr_id = gral_usr.id)))
     JOIN public.gral_rol ON ((gral_rol.id = gral_usr_rol.gral_rol_id)));


--
-- Name: erp_categorias_de_productos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_categorias_de_productos (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: categorias_de_formulaciones_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.categorias_de_formulaciones_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: categorias_de_formulaciones_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.categorias_de_formulaciones_id_seq OWNED BY public.erp_categorias_de_productos.id;


--
-- Name: cfdi_c_impuesto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cfdi_c_impuesto (
    id integer NOT NULL,
    clave character varying,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: cfdi_c_impuesto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cfdi_c_impuesto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cfdi_c_impuesto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cfdi_c_impuesto_id_seq OWNED BY public.cfdi_c_impuesto.id;


--
-- Name: cfdi_claveprodserv; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cfdi_claveprodserv (
    id integer NOT NULL,
    clave character varying,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    fecha_inicio_vigencia timestamp with time zone,
    fecha_fin_vigencia timestamp with time zone,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: cfdi_claveprodserv_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cfdi_claveprodserv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cfdi_claveprodserv_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cfdi_claveprodserv_id_seq OWNED BY public.cfdi_claveprodserv.id;


--
-- Name: cfdi_claveprodserv3; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cfdi_claveprodserv3 (
    id integer DEFAULT nextval('public.cfdi_claveprodserv_id_seq'::regclass) NOT NULL,
    clave character varying,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    fecha_inicio_vigencia timestamp with time zone,
    fecha_fin_vigencia timestamp with time zone,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: cfdi_claveunidad; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cfdi_claveunidad (
    id integer NOT NULL,
    clave character varying,
    nombre character varying DEFAULT ''::character varying NOT NULL,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    fecha_inicio_vigencia timestamp with time zone NOT NULL,
    fecha_fin_vigencia timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: cfdi_claveunidad_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cfdi_claveunidad_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cfdi_claveunidad_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cfdi_claveunidad_id_seq OWNED BY public.cfdi_claveunidad.id;


--
-- Name: cfdi_metodos_pago; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cfdi_metodos_pago (
    id integer NOT NULL,
    clave character varying,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    fecha_inicio_vigencia timestamp with time zone NOT NULL,
    fecha_fin_vigencia timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: cfdi_metodos_pago_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cfdi_metodos_pago_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cfdi_metodos_pago_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cfdi_metodos_pago_id_seq OWNED BY public.cfdi_metodos_pago.id;


--
-- Name: cfdi_regimenes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cfdi_regimenes (
    id integer NOT NULL,
    numero_control character varying,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    aplica_persona_fisica boolean DEFAULT true,
    aplica_persona_moral boolean DEFAULT true,
    fecha_inicio_vigencia timestamp with time zone NOT NULL,
    fecha_fin_vigencia timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: cfdi_regimenes_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cfdi_regimenes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cfdi_regimenes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cfdi_regimenes_id_seq OWNED BY public.cfdi_regimenes.id;


--
-- Name: cfdi_usos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cfdi_usos (
    id integer NOT NULL,
    numero_control character varying,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    aplica_persona_fisica boolean DEFAULT true,
    aplica_persona_moral boolean DEFAULT true,
    fecha_inicio_vigencia timestamp with time zone NOT NULL,
    fecha_fin_vigencia timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: cfdi_usos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cfdi_usos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cfdi_usos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cfdi_usos_id_seq OWNED BY public.cfdi_usos.id;


--
-- Name: erp_civils; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_civils (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: TABLE erp_civils; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.erp_civils IS '
';


--
-- Name: civils_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.civils_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: civils_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.civils_id_seq OWNED BY public.erp_civils.id;


--
-- Name: erp_clients_consignacions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_clients_consignacions (
    id integer NOT NULL,
    cliente_id integer NOT NULL,
    calle character varying NOT NULL,
    numero character varying NOT NULL,
    colonia character varying NOT NULL,
    pais character varying,
    entidad character varying,
    localidad character varying,
    cp character varying NOT NULL,
    localidad_alternativa character varying,
    telefono character varying,
    fax character varying,
    momento_creacion timestamp with time zone NOT NULL,
    pais_id integer,
    estado_id integer,
    municipio_id integer
);


--
-- Name: clients_consignacions_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.clients_consignacions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: clients_consignacions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.clients_consignacions_id_seq OWNED BY public.erp_clients_consignacions.id;


--
-- Name: cxc_clie2; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie2 (
    id integer NOT NULL,
    numero_control character varying NOT NULL,
    razon_social character varying NOT NULL,
    curp character varying,
    rfc character varying DEFAULT ''::character varying NOT NULL,
    clave_comercial character varying DEFAULT ''::character varying,
    clienttipo_id integer NOT NULL,
    pais character varying,
    entidad character varying,
    localidad character varying,
    calle character varying DEFAULT ''::character varying NOT NULL,
    numero character varying DEFAULT ''::character varying NOT NULL,
    colonia character varying DEFAULT ''::character varying NOT NULL,
    cp character varying DEFAULT ''::character varying NOT NULL,
    localidad_alternativa character varying DEFAULT ''::character varying,
    telefono character varying,
    fax character varying,
    comentarios text DEFAULT ''::text NOT NULL,
    moneda integer,
    correo_facturacion_electronica character varying,
    facturar_en boolean,
    descargarxml boolean DEFAULT false,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_baja timestamp with time zone,
    clasif_1 integer DEFAULT 0,
    contacto character varying DEFAULT ''::character varying,
    legacy_id integer,
    cxc_agen_id integer DEFAULT 0,
    terminos_id integer DEFAULT 0,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    pais_id integer,
    estado_id integer,
    municipio_id integer,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    zona_id integer,
    clasif_2 integer,
    clasif_3 integer,
    cxc_clie_grupo_id integer,
    limite_credito double precision,
    puesto_contacto_compras character varying,
    puesto_contacto_pagos character varying,
    contacto_pagos character varying,
    pais_contacto_pagos integer,
    estado_contacto_pagos integer,
    municipio_contacto_pagos integer,
    colonia_contacto_pagos character varying,
    id_aux integer,
    filial boolean DEFAULT false
);


--
-- Name: COLUMN cxc_clie2.cxc_agen_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxc_clie2.cxc_agen_id IS 'Aqui va el vendedor asignado a este cliente';


--
-- Name: COLUMN cxc_clie2.terminos_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxc_clie2.terminos_id IS 'Aqui va el id de los terminos de pago';


--
-- Name: clients_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.clients_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: clients_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.clients_id_seq OWNED BY public.cxc_clie2.id;


--
-- Name: cxc_clie_clases; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_clases (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean
);


--
-- Name: TABLE cxc_clie_clases; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.cxc_clie_clases IS 'Tabla que alberga todos los distintos tipos que existen de clientes';


--
-- Name: COLUMN cxc_clie_clases.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxc_clie_clases.id IS 'Indicador secuencial que identifica la fila, este  es autoincremental';


--
-- Name: clienttipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.clienttipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: clienttipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.clienttipos_id_seq OWNED BY public.cxc_clie_clases.id;


--
-- Name: com_doc_par; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_doc_par (
    inv_alm_id integer,
    gral_suc_id integer,
    permitir_articulos boolean,
    permitir_servicios boolean,
    permitir_activos_fijos boolean,
    cxp_mov_tipo_id integer,
    permitir_cambio_almacen boolean,
    maximo_partidas smallint DEFAULT 50,
    id integer NOT NULL
);


--
-- Name: com_doc_par_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_doc_par_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_doc_par_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_doc_par_id_seq OWNED BY public.com_doc_par.id;


--
-- Name: com_fac; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_fac (
    id integer NOT NULL,
    no_entrada character varying NOT NULL,
    proveedor_id integer,
    factura character varying,
    factura_fecha_expedicion date,
    numero_guia character varying,
    orden_de_compra character varying,
    moneda_id integer,
    tipo_de_cambio double precision,
    observaciones text DEFAULT ''::text,
    fletera_id integer,
    flete double precision DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    estado integer DEFAULT 1,
    inv_alm_id integer DEFAULT 0,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    tipo_documento integer DEFAULT 0,
    retencion double precision DEFAULT 0,
    subtotal double precision DEFAULT 0,
    iva double precision DEFAULT 0,
    total double precision DEFAULT 0,
    motivo_cancelacion text DEFAULT ''::text,
    cancelacion boolean DEFAULT false,
    momento_cancelacion timestamp with time zone,
    com_proceso_id integer DEFAULT 0,
    tasa_iva double precision DEFAULT 0,
    tasa_ret double precision DEFAULT 0,
    monto_ieps double precision DEFAULT 0,
    lab_destino boolean DEFAULT false NOT NULL
);


--
-- Name: com_fac_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_fac_detalle (
    id integer NOT NULL,
    no_partida integer,
    cantidad double precision,
    costo_unitario double precision,
    producto_id integer,
    tipo_de_impuesto_sobre_partida integer,
    pedimento_aduanal character varying DEFAULT ''::character varying,
    numero_lote character varying,
    presentacion_id integer,
    fecha_caducidad date DEFAULT '2999-12-31'::date NOT NULL,
    com_fac_id integer DEFAULT 0,
    valor_imp double precision DEFAULT 0,
    cantidad_devolucion double precision DEFAULT 0,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0
);


--
-- Name: COLUMN com_fac_detalle.cantidad_devolucion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.com_fac_detalle.cantidad_devolucion IS 'Suma de las devoluciones';


--
-- Name: com_fac_detalle_dev; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_fac_detalle_dev (
    id integer NOT NULL,
    id_cxp_nota_credito integer,
    id_com_fac_detalle integer,
    cant_dev double precision DEFAULT 0,
    tasa_imp double precision DEFAULT 0,
    presentacion_id integer DEFAULT 0,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0
);


--
-- Name: com_fac_detalle_dev_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_fac_detalle_dev_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_fac_detalle_dev_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_fac_detalle_dev_id_seq OWNED BY public.com_fac_detalle_dev.id;


--
-- Name: com_fac_oc; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_fac_oc (
    id integer NOT NULL,
    com_oc_id integer NOT NULL,
    com_oc_det_id integer NOT NULL,
    com_fac_det_id integer NOT NULL
);


--
-- Name: com_fac_oc_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_fac_oc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_fac_oc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_fac_oc_id_seq OWNED BY public.com_fac_oc.id;


--
-- Name: com_oc_req; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_oc_req (
    id integer NOT NULL,
    folio character varying,
    fecha_compromiso timestamp with time zone,
    observaciones text,
    status integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    cancelado boolean DEFAULT false NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    momento_autorizacion timestamp with time zone,
    momento_cancelacion timestamp without time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_usr_id_cancelacion integer,
    gral_usr_id_autoriza integer DEFAULT 0,
    gral_empleado_id integer DEFAULT 0,
    gral_depto_id integer DEFAULT 0,
    folio_pedido character varying DEFAULT ''::character varying,
    tipo smallint DEFAULT 1
);


--
-- Name: COLUMN com_oc_req.tipo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.com_oc_req.tipo IS 'Tipo 1=Requisiciones creadas manualmente, 2=Requisiciones generadas desde un pedido.';


--
-- Name: com_oc_req_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_oc_req_detalle (
    id integer NOT NULL,
    com_oc_req_id integer,
    inv_prod_id integer,
    presentacion_id integer,
    cantidad double precision,
    status boolean DEFAULT false NOT NULL,
    com_oc_det_id integer DEFAULT 0
);


--
-- Name: com_oc_req_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_oc_req_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_oc_req_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_oc_req_detalle_id_seq OWNED BY public.com_oc_req_detalle.id;


--
-- Name: com_oc_req_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_oc_req_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_oc_req_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_oc_req_id_seq OWNED BY public.com_oc_req.id;


--
-- Name: com_oc_requisicion; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_oc_requisicion (
    id integer NOT NULL,
    com_oc_req_id integer NOT NULL,
    com_oc_req_det_id integer NOT NULL,
    com_orden_compra_det_id integer NOT NULL
);


--
-- Name: com_oc_requisicion_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_oc_requisicion_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_oc_requisicion_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_oc_requisicion_id_seq OWNED BY public.com_oc_requisicion.id;


--
-- Name: com_orden_compra; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_orden_compra (
    id integer NOT NULL,
    folio character varying,
    tipo_orden_compra integer DEFAULT 0,
    proveedor_id integer,
    observaciones text,
    moneda_id integer DEFAULT 0 NOT NULL,
    tipo_cambio double precision DEFAULT 0 NOT NULL,
    grupo character varying,
    cxp_prov_credias_id integer,
    consignado_a character varying,
    tipo_embarque_id integer,
    subtotal double precision DEFAULT 0 NOT NULL,
    impuesto double precision DEFAULT 0 NOT NULL,
    monto_retencion double precision DEFAULT 0 NOT NULL,
    total double precision DEFAULT 0 NOT NULL,
    com_proceso_id integer DEFAULT 0 NOT NULL,
    status integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    cancelado boolean DEFAULT false NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    momento_autorizacion timestamp with time zone,
    momento_cancelacion timestamp without time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_usr_id_cancelacion integer,
    gral_usr_id_autoriza integer DEFAULT 0,
    fecha_entrega timestamp with time zone,
    anexa_documentos boolean DEFAULT false,
    lab_destino boolean DEFAULT false NOT NULL
);


--
-- Name: COLUMN com_orden_compra.anexa_documentos; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.com_orden_compra.anexa_documentos IS 'TRUE=Anexar Certificados de Calidad y Hojas de Seguridad';


--
-- Name: com_orden_compra_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_orden_compra_detalle (
    id integer NOT NULL,
    com_orden_compra_id integer,
    inv_prod_id integer,
    presentacion_id integer,
    cantidad double precision,
    precio_unitario double precision,
    gral_imp_id integer,
    valor_imp double precision,
    cant_surtido double precision DEFAULT 0,
    surtir boolean DEFAULT true NOT NULL,
    estatus integer DEFAULT 0 NOT NULL
);


--
-- Name: com_orden_compra_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_orden_compra_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_orden_compra_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_orden_compra_detalle_id_seq OWNED BY public.com_orden_compra_detalle.id;


--
-- Name: com_orden_compra_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_orden_compra_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_orden_compra_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_orden_compra_id_seq OWNED BY public.com_orden_compra.id;


--
-- Name: com_par; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_par (
    id integer NOT NULL,
    gral_emp_id integer,
    gral_suc_id integer NOT NULL,
    inv_alm_id integer NOT NULL,
    formato_oc smallint DEFAULT 1,
    captura_costo_ref boolean DEFAULT false NOT NULL,
    mon_prod_costo_precio boolean DEFAULT false NOT NULL,
    mostrar_lab boolean DEFAULT false NOT NULL,
    texto_lab character varying DEFAULT ''::character varying NOT NULL,
    CONSTRAINT chk_formato_oc CHECK ((formato_oc = ANY (ARRAY[1, 2])))
);


--
-- Name: TABLE com_par; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.com_par IS 'Parametros de Compras';


--
-- Name: COLUMN com_par.formato_oc; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.com_par.formato_oc IS '1=Formato(OTRO), 2=Formato(AGNUX)';


--
-- Name: COLUMN com_par.captura_costo_ref; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.com_par.captura_costo_ref IS 'Este parametro es para la Captura de Costo de Reposicion, FALSE=Solo permite captura de costo ultimo, TRUE=Permite captura de Impuestos para el costo de referencia.';


--
-- Name: com_par_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_par_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_par_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_par_id_seq OWNED BY public.com_par.id;


--
-- Name: com_proceso; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_proceso (
    id integer NOT NULL,
    com_proceso_flujo_id integer NOT NULL,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: com_proceso_flujo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.com_proceso_flujo (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: com_proceso_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.com_proceso_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: com_proceso_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.com_proceso_id_seq OWNED BY public.com_proceso.id;


--
-- Name: erp_consecutivos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_consecutivos (
    id integer NOT NULL,
    secuencia character varying NOT NULL,
    consecutivo character varying NOT NULL,
    momento_actualizacion timestamp with time zone NOT NULL
);


--
-- Name: consecutivos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.consecutivos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: consecutivos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.consecutivos_id_seq OWNED BY public.erp_consecutivos.id;


--
-- Name: costos_kemikal; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.costos_kemikal (
    id integer NOT NULL,
    codigo character varying DEFAULT ''::character varying,
    costo double precision,
    moneda_id integer,
    tc character varying DEFAULT ''::character varying,
    factura character varying DEFAULT ''::character varying,
    oc character varying DEFAULT ''::character varying,
    gi double precision DEFAULT 0,
    igi double precision DEFAULT 0,
    cit double precision DEFAULT 0,
    pmin double precision DEFAULT 0,
    empresa_id integer DEFAULT 0
);


--
-- Name: costos_kemikal_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.costos_kemikal_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: costos_kemikal_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.costos_kemikal_id_seq OWNED BY public.costos_kemikal.id;


--
-- Name: crm_calificaciones_llamadas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_calificaciones_llamadas (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    gral_emp_id integer DEFAULT 0
);


--
-- Name: crm_calificaciones_llamadas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_calificaciones_llamadas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_calificaciones_llamadas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_calificaciones_llamadas_id_seq OWNED BY public.crm_calificaciones_llamadas.id;


--
-- Name: crm_calificaciones_visita; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_calificaciones_visita (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    gral_emp_id integer DEFAULT 0
);


--
-- Name: crm_calificaciones_visita_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_calificaciones_visita_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_calificaciones_visita_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_calificaciones_visita_id_seq OWNED BY public.crm_calificaciones_visita.id;


--
-- Name: crm_clasificacion_prospecto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_clasificacion_prospecto (
    id integer NOT NULL,
    clasificacion character varying,
    clasificacion_abr character varying,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_clasificacion_prospecto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_clasificacion_prospecto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_clasificacion_prospecto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_clasificacion_prospecto_id_seq OWNED BY public.crm_clasificacion_prospecto.id;


--
-- Name: crm_config_consultas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_config_consultas (
    id integer NOT NULL,
    metas_visita boolean DEFAULT false NOT NULL,
    totales_visita boolean DEFAULT false NOT NULL,
    cumplido_visita boolean DEFAULT false NOT NULL,
    conexito_visita boolean DEFAULT false NOT NULL,
    conoportunidad_visita boolean DEFAULT false NOT NULL,
    seguimiento_visita boolean DEFAULT false NOT NULL,
    efectividad_visita boolean DEFAULT false NOT NULL,
    gestion_visita boolean DEFAULT false NOT NULL,
    avance_visita boolean DEFAULT false NOT NULL,
    metas_llamadas boolean DEFAULT false NOT NULL,
    total_llamadas boolean DEFAULT false NOT NULL,
    cumplido_llamadas boolean DEFAULT false NOT NULL,
    entrantes_llamadas boolean DEFAULT false NOT NULL,
    salientes_llamadas boolean DEFAULT false NOT NULL,
    planeadas_llamadas boolean DEFAULT false NOT NULL,
    con_exito_llamadas boolean DEFAULT false NOT NULL,
    con_cita_llamadas boolean DEFAULT false NOT NULL,
    conseguimiento_llamadas boolean DEFAULT false NOT NULL,
    efectividad_llamadas boolean DEFAULT false NOT NULL,
    gestion_llamadas boolean DEFAULT false NOT NULL,
    avance_llamadas boolean DEFAULT false NOT NULL,
    planeacion_llamadas boolean DEFAULT false NOT NULL,
    facturacion_casos boolean DEFAULT false NOT NULL,
    producto_casos boolean DEFAULT false NOT NULL,
    garantia_casos boolean DEFAULT false NOT NULL,
    distribucion_casos boolean DEFAULT false NOT NULL,
    danos_casos boolean DEFAULT false NOT NULL,
    devoluciones_casos boolean DEFAULT false,
    cobranza_casos boolean DEFAULT false NOT NULL,
    varios_casos boolean DEFAULT false NOT NULL,
    metas_oportunidades boolean DEFAULT false NOT NULL,
    total_metas_oportunidades boolean DEFAULT false NOT NULL,
    montos_meta_oportunidades boolean DEFAULT false NOT NULL,
    total_montos_oportunidades boolean DEFAULT false NOT NULL,
    metas_cumplidas_oportunidades boolean DEFAULT false NOT NULL,
    montos_cumplidas_oportunidades boolean DEFAULT false NOT NULL,
    inicial_oportunidades boolean DEFAULT false NOT NULL,
    seguimiento_oportunidades boolean DEFAULT false NOT NULL,
    visitas_oportunidades boolean DEFAULT false NOT NULL,
    cotizacion_oportunidades boolean DEFAULT false NOT NULL,
    negociacion_oportunidades boolean DEFAULT false NOT NULL,
    cierre_oportunidades boolean DEFAULT false NOT NULL,
    ganados_oportunidades boolean DEFAULT false NOT NULL,
    gral_emp_id integer DEFAULT 0 NOT NULL,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0 NOT NULL,
    gral_usr_id_actualizacion integer,
    gral_usr_id_baja integer DEFAULT 0 NOT NULL,
    gral_empleado_id integer DEFAULT 0 NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    perdidos_oportunidades boolean DEFAULT false NOT NULL
);


--
-- Name: crm_config_consultas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_config_consultas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_config_consultas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_config_consultas_id_seq OWNED BY public.crm_config_consultas.id;


--
-- Name: crm_contacto_cli; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_contacto_cli (
    id integer NOT NULL,
    cxc_clie_id integer DEFAULT 0 NOT NULL,
    crm_contactos_id integer DEFAULT 0 NOT NULL
);


--
-- Name: TABLE crm_contacto_cli; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.crm_contacto_cli IS 'guarda la relacion de contactos de clientes';


--
-- Name: crm_contacto_cli_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_contacto_cli_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_contacto_cli_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_contacto_cli_id_seq OWNED BY public.crm_contacto_cli.id;


--
-- Name: crm_contacto_pro; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_contacto_pro (
    id integer NOT NULL,
    crm_prospectos_id integer DEFAULT 0 NOT NULL,
    crm_contactos_id integer DEFAULT 0 NOT NULL
);


--
-- Name: TABLE crm_contacto_pro; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.crm_contacto_pro IS 'guarda la relacion de contactos de los prospectos';


--
-- Name: crm_contacto_pro_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_contacto_pro_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_contacto_pro_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_contacto_pro_id_seq OWNED BY public.crm_contacto_pro.id;


--
-- Name: crm_contactos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_contactos (
    id integer NOT NULL,
    folio character varying,
    nombre character varying DEFAULT ''::character varying NOT NULL,
    apellido_paterno character varying DEFAULT ''::character varying NOT NULL,
    apellido_materno character varying DEFAULT ''::character varying NOT NULL,
    telefono1 character varying DEFAULT ''::character varying,
    telefono2 character varying DEFAULT ''::character varying,
    fax character varying DEFAULT ''::character varying,
    telefono_directo character varying DEFAULT ''::character varying,
    email character varying DEFAULT ''::character varying,
    email2 character varying DEFAULT ''::character varying,
    tipo_contacto integer DEFAULT 0,
    observaciones text DEFAULT ''::text,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_creacion integer DEFAULT 0,
    gral_usr_actualizacion integer DEFAULT 0,
    gral_usr_baja integer DEFAULT 0,
    fecha_registro timestamp with time zone,
    celular character varying DEFAULT ''::character varying,
    gral_empleado_id integer DEFAULT 0,
    departamento character varying DEFAULT ''::character varying NOT NULL,
    puesto character varying DEFAULT ''::character varying NOT NULL,
    decisor boolean DEFAULT false NOT NULL
);


--
-- Name: crm_contactos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_contactos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_contactos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_contactos_id_seq OWNED BY public.crm_contactos.id;


--
-- Name: crm_etapas_prospecto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_etapas_prospecto (
    id integer NOT NULL,
    descripcion character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_etapas_prospecto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_etapas_prospecto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_etapas_prospecto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_etapas_prospecto_id_seq OWNED BY public.crm_etapas_prospecto.id;


--
-- Name: crm_etapas_venta; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_etapas_venta (
    id integer NOT NULL,
    descripcion character varying,
    etapa character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_etapas_venta_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_etapas_venta_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_etapas_venta_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_etapas_venta_id_seq OWNED BY public.crm_etapas_venta.id;


--
-- Name: crm_formas_contacto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_formas_contacto (
    id integer NOT NULL,
    folio_fc character varying NOT NULL,
    descripcion character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_formas_contacto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_formas_contacto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_formas_contacto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_formas_contacto_id_seq OWNED BY public.crm_formas_contacto.id;


--
-- Name: crm_metas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_metas (
    id integer NOT NULL,
    folio character varying NOT NULL,
    gral_empleado_id integer DEFAULT 0,
    ano smallint,
    mes smallint,
    cantidad_visitas integer DEFAULT 0 NOT NULL,
    cantidad_llamadas integer DEFAULT 0 NOT NULL,
    cantidad_prospectos integer DEFAULT 0 NOT NULL,
    cantidad_cotizaciones integer DEFAULT 0 NOT NULL,
    cantidad_oportunidades integer DEFAULT 0 NOT NULL,
    monto_cotizaciones double precision DEFAULT 0 NOT NULL,
    monto_oportunidades double precision DEFAULT 0 NOT NULL,
    ventas_prospectos integer DEFAULT 0 NOT NULL,
    cantidad_cotizaciones2 integer DEFAULT 0 NOT NULL,
    cantidad_oportunidades2 integer DEFAULT 0 NOT NULL,
    monto_cotizaciones2 double precision DEFAULT 0 NOT NULL,
    monto_oportunidades2 double precision DEFAULT 0 NOT NULL,
    ventas_clientes integer DEFAULT 0 NOT NULL,
    ventas_oportunidades_clientes integer DEFAULT 0 NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: COLUMN crm_metas.gral_empleado_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_metas.gral_empleado_id IS 'ID del agente de ventas(cxc_agen), este es el mismo ID del empleado';


--
-- Name: crm_metas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_metas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_metas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_metas_id_seq OWNED BY public.crm_metas.id;


--
-- Name: crm_motivos_llamada; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_motivos_llamada (
    id integer NOT NULL,
    folio_mll character varying NOT NULL,
    descripcion character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_motivos_llamada_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_motivos_llamada_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_motivos_llamada_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_motivos_llamada_id_seq OWNED BY public.crm_motivos_llamada.id;


--
-- Name: crm_motivos_visita; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_motivos_visita (
    id integer NOT NULL,
    folio_mv character varying NOT NULL,
    descripcion character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_motivos_visita_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_motivos_visita_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_motivos_visita_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_motivos_visita_id_seq OWNED BY public.crm_motivos_visita.id;


--
-- Name: crm_oportunidades; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_oportunidades (
    id integer NOT NULL,
    gral_emp_id integer DEFAULT 0 NOT NULL,
    fecha_oportunidad character varying DEFAULT ''::character varying NOT NULL,
    crm_contactos_id integer DEFAULT 0 NOT NULL,
    crm_tipos_oportunidad_id integer,
    monto double precision DEFAULT 0 NOT NULL,
    fecha_cotizar character varying DEFAULT ''::character varying NOT NULL,
    fecha_cierre character varying DEFAULT ''::character varying NOT NULL,
    crm_etapas_venta_id integer DEFAULT 0 NOT NULL,
    estatus boolean DEFAULT true NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0 NOT NULL,
    gral_usr_id_actualizacion integer DEFAULT 0 NOT NULL,
    gral_usr_id_baja integer DEFAULT 0 NOT NULL,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    gral_empleados_id integer DEFAULT 0 NOT NULL,
    cierre_oportunidad smallint DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN crm_oportunidades.estatus; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_oportunidades.estatus IS 'true=vigente, false=cancelado';


--
-- Name: COLUMN crm_oportunidades.cierre_oportunidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_oportunidades.cierre_oportunidad IS '0->habierta, 1->Ganada, 2->Perdida';


--
-- Name: crm_oportunidades_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_oportunidades_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_oportunidades_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_oportunidades_id_seq OWNED BY public.crm_oportunidades.id;


--
-- Name: crm_par; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_par (
    gral_emp_id integer NOT NULL,
    gral_suc_id integer NOT NULL,
    gral_depto_id integer NOT NULL
);


--
-- Name: COLUMN crm_par.gral_depto_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_par.gral_depto_id IS 'Id del departamento para mostrar los empleados en Registro de Proyectos.';


--
-- Name: crm_prospectos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_prospectos (
    id integer NOT NULL,
    numero_control character varying,
    estatus integer DEFAULT 0,
    crm_etapas_prospecto_id integer DEFAULT 0,
    tipo_prospecto_id integer DEFAULT 0,
    rfc character varying,
    razon_social character varying NOT NULL,
    calle character varying DEFAULT ''::character varying NOT NULL,
    numero character varying DEFAULT ''::character varying NOT NULL,
    entre_calles character varying DEFAULT ''::character varying NOT NULL,
    numero_exterior character varying DEFAULT ''::character varying NOT NULL,
    colonia character varying DEFAULT ''::character varying NOT NULL,
    cp character varying DEFAULT ''::character varying NOT NULL,
    pais_id integer DEFAULT 0,
    estado_id integer DEFAULT 0,
    municipio_id integer DEFAULT 0,
    localidad_alternativa character varying DEFAULT ''::character varying,
    email character varying DEFAULT ''::character varying,
    telefono1 character varying DEFAULT ''::character varying,
    extension1 character varying DEFAULT ''::character varying,
    fax character varying DEFAULT ''::character varying,
    telefono2 character varying DEFAULT ''::character varying,
    extension2 character varying DEFAULT ''::character varying,
    contacto character varying DEFAULT ''::character varying,
    clasificacion_id integer DEFAULT 0,
    tipo_industria_id integer DEFAULT 0,
    observaciones text,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_prospectos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_prospectos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_prospectos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_prospectos_id_seq OWNED BY public.crm_prospectos.id;


--
-- Name: crm_proyecto_estatus; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_proyecto_estatus (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    gral_emp_id integer DEFAULT 0
);


--
-- Name: crm_proyecto_estatus_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_proyecto_estatus_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_proyecto_estatus_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_proyecto_estatus_id_seq OWNED BY public.crm_proyecto_estatus.id;


--
-- Name: crm_registro_casos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_registro_casos (
    id integer NOT NULL,
    folio character varying,
    gral_empleado_id integer DEFAULT 0,
    estatus integer DEFAULT 0,
    prioridad integer DEFAULT 0,
    tipo integer DEFAULT 0,
    fecha_cierre timestamp with time zone,
    descripcion character varying,
    resolucion character varying,
    observacion_agente character varying,
    tipo_caso integer NOT NULL,
    borrado_logico boolean,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: COLUMN crm_registro_casos.gral_empleado_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_casos.gral_empleado_id IS 'ID del agente de ventas(cxc_agen), este es el mismo ID del empleado';


--
-- Name: COLUMN crm_registro_casos.estatus; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_casos.estatus IS '  0:ninguna 1:Muy urgente 2:Urgente 3:Importante 4:Normal 5:Baja ';


--
-- Name: COLUMN crm_registro_casos.tipo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_casos.tipo IS '     identifica el tipo 1:_ si el registro de un caso de clientes   y  2  si el registro del caso es de prospecto';


--
-- Name: COLUMN crm_registro_casos.tipo_caso; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_casos.tipo_caso IS ' 0:ninguno 2:Producto 3:Garantia 4:Distribucion 5:Da√±os 6:Devoluciones 7:Cobranza 8:Varios';


--
-- Name: crm_registro_casos_clie; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_registro_casos_clie (
    id integer NOT NULL,
    id_crm_registro_casos integer NOT NULL,
    id_cliente integer NOT NULL
);


--
-- Name: crm_registro_casos_clie_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_registro_casos_clie_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_registro_casos_clie_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_registro_casos_clie_id_seq OWNED BY public.crm_registro_casos_clie.id;


--
-- Name: crm_registro_casos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_registro_casos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_registro_casos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_registro_casos_id_seq OWNED BY public.crm_registro_casos.id;


--
-- Name: crm_registro_casos_prospectos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_registro_casos_prospectos (
    id integer NOT NULL,
    id_crm_registro_casos integer NOT NULL,
    id_prospecto integer NOT NULL
);


--
-- Name: crm_registro_casos_prospectos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_registro_casos_prospectos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_registro_casos_prospectos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_registro_casos_prospectos_id_seq OWNED BY public.crm_registro_casos_prospectos.id;


--
-- Name: crm_registro_llamadas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_registro_llamadas (
    id integer NOT NULL,
    folio character varying NOT NULL,
    gral_empleado_id integer DEFAULT 0,
    fecha date,
    hora time with time zone,
    duracion time with time zone,
    crm_motivos_llamda_id integer,
    crm_contacto_id integer,
    crm_calificacion_llamada_id integer,
    crm_tipos_seguimiento_llamada_id integer,
    deteccion_oportunidad smallint,
    resultado text,
    observaciones text,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    fecha_sig_llamada date,
    hora_sig_llamada time with time zone,
    comentarios_sig_llamada text,
    llamada_completada smallint DEFAULT 0 NOT NULL,
    tipo_llamada smallint DEFAULT 0 NOT NULL,
    llamada_planeada smallint DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN crm_registro_llamadas.gral_empleado_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_llamadas.gral_empleado_id IS 'ID del agente de ventas(cxc_agen), este es el mismo ID del empleado';


--
-- Name: COLUMN crm_registro_llamadas.duracion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_llamadas.duracion IS 'Hora  y mitad de Hora(1:30) indicando que la visita duro 1 hora y media. √âsta diraci√≥n incluye tiempo de traslado';


--
-- Name: COLUMN crm_registro_llamadas.deteccion_oportunidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_llamadas.deteccion_oportunidad IS '1=SI, 2=NO';


--
-- Name: COLUMN crm_registro_llamadas.llamada_planeada; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_llamadas.llamada_planeada IS 'SI  =1 , NO =2 ';


--
-- Name: crm_registro_llamadas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_registro_llamadas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_registro_llamadas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_registro_llamadas_id_seq OWNED BY public.crm_registro_llamadas.id;


--
-- Name: crm_registro_proyecto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_registro_proyecto (
    id integer NOT NULL,
    folio character varying NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    descripcion text DEFAULT ''::text NOT NULL,
    gral_empleado_id integer DEFAULT 0,
    crm_contacto_id integer DEFAULT 0 NOT NULL,
    cxp_prov_id integer DEFAULT 0 NOT NULL,
    fecha_inicio date,
    fecha_fin date,
    crm_proyecto_estatus_id integer DEFAULT 0 NOT NULL,
    prioridad smallint DEFAULT 0 NOT NULL,
    muestra smallint DEFAULT 0 NOT NULL,
    observaciones text DEFAULT ''::text NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    monto double precision DEFAULT 0 NOT NULL,
    gral_mon_id integer DEFAULT 0 NOT NULL,
    kg double precision DEFAULT 0 NOT NULL,
    periodicidad double precision DEFAULT 0 NOT NULL,
    cxc_clie_clas1_id integer DEFAULT 0 NOT NULL,
    cxc_clie_clas2_id integer DEFAULT 0 NOT NULL,
    precio double precision DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN crm_registro_proyecto.prioridad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_proyecto.prioridad IS '1=Baja, 2=Media, 3=Alta';


--
-- Name: COLUMN crm_registro_proyecto.muestra; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_proyecto.muestra IS '1=N/A, 2=Pendiente, 3=OK';


--
-- Name: COLUMN crm_registro_proyecto.monto; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_proyecto.monto IS 'Monto del Proyecto.';


--
-- Name: crm_registro_proyecto_competidor; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_registro_proyecto_competidor (
    id integer NOT NULL,
    crm_registro_proyecto_id integer DEFAULT 0 NOT NULL,
    nombre character varying DEFAULT ''::character varying NOT NULL,
    precio double precision DEFAULT 0 NOT NULL,
    proveedor character varying DEFAULT ''::character varying NOT NULL
);


--
-- Name: crm_registro_proyecto_competidor_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_registro_proyecto_competidor_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_registro_proyecto_competidor_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_registro_proyecto_competidor_id_seq OWNED BY public.crm_registro_proyecto_competidor.id;


--
-- Name: crm_registro_proyecto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_registro_proyecto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_registro_proyecto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_registro_proyecto_id_seq OWNED BY public.crm_registro_proyecto.id;


--
-- Name: crm_registro_visitas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_registro_visitas (
    id integer NOT NULL,
    folio character varying NOT NULL,
    gral_empleado_id integer DEFAULT 0,
    fecha date,
    hora time with time zone,
    duracion time with time zone,
    crm_motivos_visita_id integer,
    crm_contacto_id integer,
    crm_calificacion_visita_id integer,
    crm_tipos_seguimiento_visita_id integer,
    deteccion_oportunidad smallint,
    recursos_utilizados text,
    resultado text,
    observaciones text,
    comentarios_sig_visita text DEFAULT ''::text NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    fecha_sig_visita date DEFAULT '2999-12-31'::date NOT NULL,
    hora_sig_visita time with time zone DEFAULT '00:00:00-05'::time with time zone NOT NULL,
    productos text DEFAULT ''::text NOT NULL,
    comentarios_sig_llamada text DEFAULT ''::text NOT NULL,
    fecha_sig_llamada date DEFAULT '2999-12-31'::date NOT NULL,
    hora_sig_llamada time with time zone DEFAULT '00:00:00-05'::time with time zone NOT NULL
);


--
-- Name: COLUMN crm_registro_visitas.gral_empleado_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_visitas.gral_empleado_id IS 'ID del agente de ventas(cxc_agen), este es el mismo ID del empleado';


--
-- Name: COLUMN crm_registro_visitas.duracion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_visitas.duracion IS 'Hora  y mitad de Hora(1:30) indicando que la visita duro 1 hora y media. √âsta diraci√≥n incluye tiempo de traslado';


--
-- Name: COLUMN crm_registro_visitas.deteccion_oportunidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.crm_registro_visitas.deteccion_oportunidad IS '1=SI, 2=NO';


--
-- Name: crm_registro_visitas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_registro_visitas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_registro_visitas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_registro_visitas_id_seq OWNED BY public.crm_registro_visitas.id;


--
-- Name: crm_tipo_industria; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_tipo_industria (
    id integer NOT NULL,
    tipo_industria character varying,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_tipo_industria_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_tipo_industria_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_tipo_industria_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_tipo_industria_id_seq OWNED BY public.crm_tipo_industria.id;


--
-- Name: crm_tipo_prospecto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_tipo_prospecto (
    id integer NOT NULL,
    tipo_prospecto character varying,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_tipo_prospecto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_tipo_prospecto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_tipo_prospecto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_tipo_prospecto_id_seq OWNED BY public.crm_tipo_prospecto.id;


--
-- Name: crm_tipos_oportunidad; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_tipos_oportunidad (
    id integer NOT NULL,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL
);


--
-- Name: crm_tipos_oportunidad_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_tipos_oportunidad_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_tipos_oportunidad_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_tipos_oportunidad_id_seq OWNED BY public.crm_tipos_oportunidad.id;


--
-- Name: crm_tipos_seguimiento_llamadas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_tipos_seguimiento_llamadas (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    gral_emp_id integer DEFAULT 0
);


--
-- Name: crm_tipos_seguimiento_llamadas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_tipos_seguimiento_llamadas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_tipos_seguimiento_llamadas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_tipos_seguimiento_llamadas_id_seq OWNED BY public.crm_tipos_seguimiento_llamadas.id;


--
-- Name: crm_tipos_seguimiento_visita; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.crm_tipos_seguimiento_visita (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    gral_emp_id integer DEFAULT 0,
    momento_crea timestamp with time zone,
    momento_actualiza timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: crm_tipos_seguimiento_visita_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.crm_tipos_seguimiento_visita_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: crm_tipos_seguimiento_visita_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.crm_tipos_seguimiento_visita_id_seq OWNED BY public.crm_tipos_seguimiento_visita.id;


--
-- Name: ctb_sdo_cta; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_sdo_cta (
    id integer NOT NULL,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    ano integer DEFAULT 0 NOT NULL,
    mes smallint DEFAULT 0 NOT NULL,
    cta_mayor smallint DEFAULT 0 NOT NULL,
    clasifica smallint DEFAULT 0 NOT NULL,
    cta character varying DEFAULT ''::character varying,
    saldo_ini double precision DEFAULT 0 NOT NULL,
    debe double precision DEFAULT 0 NOT NULL,
    haber double precision DEFAULT 0 NOT NULL,
    saldo_fin double precision DEFAULT 0 NOT NULL
);


--
-- Name: ctb-sdo_cta_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public."ctb-sdo_cta_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb-sdo_cta_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public."ctb-sdo_cta_id_seq" OWNED BY public.ctb_sdo_cta.id;


--
-- Name: ctb_app; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_app (
    id integer NOT NULL,
    gral_app_id integer NOT NULL,
    titulo character varying NOT NULL,
    estatus boolean DEFAULT true NOT NULL,
    ctb_cta boolean DEFAULT false NOT NULL,
    ctb_tmov boolean DEFAULT false NOT NULL
);


--
-- Name: COLUMN ctb_app.ctb_cta; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.ctb_app.ctb_cta IS 'TRUE=Debe mostrarse en el Catalogo de Cuentas Contables.';


--
-- Name: COLUMN ctb_app.ctb_tmov; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.ctb_app.ctb_tmov IS 'TRUE=Debe mostrarse en el programa de Definicion de Asientos.';


--
-- Name: ctb_cc; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_cc (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    descripcion text,
    empresa_id integer DEFAULT 0,
    id_usuario_creacion integer DEFAULT 0,
    borrado_logico boolean DEFAULT false,
    momento_baja timestamp with time zone,
    id_usuario_baja integer DEFAULT 0,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    id_usuario_actualizacion integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0 NOT NULL
);


--
-- Name: ctb_cc_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_cc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_cc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_cc_id_seq OWNED BY public.ctb_cc.id;


--
-- Name: ctb_con; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_con (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    descripcion text,
    empresa_id integer DEFAULT 0,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: ctb_con_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_con_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_con_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_con_id_seq OWNED BY public.ctb_con.id;


--
-- Name: ctb_cta; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_cta (
    id integer NOT NULL,
    cuenta character varying(20) DEFAULT ''::character varying,
    cta integer DEFAULT 0,
    subcta integer DEFAULT 0,
    ssubcta integer DEFAULT 0,
    sssubcta integer DEFAULT 0,
    ssssubcta integer DEFAULT 0,
    cta_mayor smallint DEFAULT 0 NOT NULL,
    clasifica smallint DEFAULT 0 NOT NULL,
    detalle smallint DEFAULT 0 NOT NULL,
    descripcion character varying DEFAULT ''::character varying,
    descripcion_ing character varying DEFAULT ''::character varying,
    descripcion_otr character varying DEFAULT ''::character varying,
    nivel_cta smallint DEFAULT 0 NOT NULL,
    consolida smallint DEFAULT 0 NOT NULL,
    estatus smallint DEFAULT 1 NOT NULL,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0 NOT NULL,
    ctb_cc_id integer DEFAULT 0 NOT NULL,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    nivel integer DEFAULT 0 NOT NULL,
    tipo integer DEFAULT 0 NOT NULL,
    naturaleza integer DEFAULT 0 NOT NULL,
    ctb_app_id integer DEFAULT 0 NOT NULL,
    ctb_cta_sat_id integer DEFAULT 0 NOT NULL,
    CONSTRAINT ch_ctb_cta_cta CHECK (((cta >= 0) AND (cta <= 99999))),
    CONSTRAINT ch_ctb_cta_detalle CHECK (((detalle >= 0) AND (detalle <= 1))),
    CONSTRAINT ch_ctb_cta_estatus CHECK (((estatus >= 1) AND (estatus <= 2))),
    CONSTRAINT ch_ctb_cta_nivel_cta CHECK (((nivel_cta >= 1) AND (nivel_cta <= 5))),
    CONSTRAINT ch_ctb_cta_ssssubcta CHECK (((ssssubcta >= 0) AND (ssssubcta <= 99999))),
    CONSTRAINT ch_ctb_cta_sssubcta CHECK (((sssubcta >= 0) AND (sssubcta <= 99999))),
    CONSTRAINT ch_ctb_cta_ssubcta CHECK (((ssubcta >= 0) AND (ssubcta <= 99999))),
    CONSTRAINT ch_ctb_cta_subcta CHECK (((subcta >= 0) AND (subcta <= 99999)))
);


--
-- Name: COLUMN ctb_cta.nivel; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.ctb_cta.nivel IS '1=Auxiliar, 2=Mayor';


--
-- Name: COLUMN ctb_cta.tipo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.ctb_cta.tipo IS '1=Balance, 2=Resultados, 3=De orden';


--
-- Name: COLUMN ctb_cta.naturaleza; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.ctb_cta.naturaleza IS '1=Deudora, 2=Acreedora';


--
-- Name: COLUMN ctb_cta.ctb_app_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.ctb_cta.ctb_app_id IS '0=No agrupa nada, >0=Agrupa lo que indique en el numero de Aplicativo(Proveedores, Clientes, Productos, etc.) ';


--
-- Name: ctb_cta_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_cta_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_cta_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_cta_id_seq OWNED BY public.ctb_cta.id;


--
-- Name: ctb_cta_sat; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_cta_sat (
    id integer NOT NULL,
    nivel smallint DEFAULT 0 NOT NULL,
    codigo character varying NOT NULL,
    nombre character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL
);


--
-- Name: ctb_cta_sat_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_cta_sat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_cta_sat_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_cta_sat_id_seq OWNED BY public.ctb_cta_sat.id;


--
-- Name: ctb_cta_status; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_cta_status (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: ctb_may; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_may (
    id integer NOT NULL,
    ctb_may_clase_id integer,
    clasificacion smallint,
    descripcion character varying NOT NULL,
    descripcion_ing character varying,
    descripcion_otr character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    empresa_id integer DEFAULT 0,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: TABLE ctb_may; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.ctb_may IS 'Tabla para Clasificacion de Cuentas(Cuentas de Mayor)';


--
-- Name: ctb_may_clases; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_may_clases (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: ctb_may_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_may_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_may_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_may_id_seq OWNED BY public.ctb_may.id;


--
-- Name: ctb_par; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_par (
    id integer NOT NULL,
    gral_emp_id integer,
    gral_suc_id integer NOT NULL,
    gral_suc_id_cons integer NOT NULL,
    mes_actual integer NOT NULL,
    anio_actual integer NOT NULL,
    incluye_prefijo_clave_suc boolean DEFAULT true NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL
);


--
-- Name: ctb_par_er; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_par_er (
    id integer NOT NULL,
    gral_emp_id integer DEFAULT 0 NOT NULL,
    cta_mayor smallint DEFAULT 0 NOT NULL,
    clasifica smallint DEFAULT 0 NOT NULL,
    descripcion character varying DEFAULT ''::character varying,
    cta character varying DEFAULT ''::character varying,
    detalle boolean DEFAULT false NOT NULL,
    operacion smallint DEFAULT 0 NOT NULL,
    orden smallint DEFAULT 0 NOT NULL
);


--
-- Name: ctb_par_er_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_par_er_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_par_er_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_par_er_id_seq OWNED BY public.ctb_par_er.id;


--
-- Name: ctb_par_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_par_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_par_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_par_id_seq OWNED BY public.ctb_par.id;


--
-- Name: ctb_pol; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_pol (
    id integer NOT NULL,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    ano integer DEFAULT 0 NOT NULL,
    mes smallint DEFAULT 0 NOT NULL,
    poliza character varying DEFAULT ''::character varying NOT NULL,
    ctb_tpol_id integer DEFAULT 0 NOT NULL,
    tipo character varying DEFAULT ''::character varying NOT NULL,
    ctb_con_id integer DEFAULT 0 NOT NULL,
    concepto character varying DEFAULT ''::character varying NOT NULL,
    gral_mon_id integer DEFAULT 0 NOT NULL,
    moneda character varying DEFAULT ''::character varying NOT NULL,
    status smallint DEFAULT 0 NOT NULL,
    modulo_origen smallint DEFAULT 0 NOT NULL,
    gral_usr_id_cap integer DEFAULT 0,
    fecha_cap timestamp with time zone,
    gral_usr_id_afe integer DEFAULT 0,
    fecha_afe timestamp with time zone,
    gral_usr_id_daf integer DEFAULT 0,
    fecha_daf timestamp with time zone,
    gral_usr_id_mod integer DEFAULT 0,
    fecha_mod timestamp with time zone,
    gral_usr_id_can integer DEFAULT 0,
    fecha_can timestamp with time zone,
    borrado_logico boolean DEFAULT false,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    referencia character varying DEFAULT ''::character varying NOT NULL,
    fecha timestamp with time zone,
    CONSTRAINT ch_ctb_pol_ano CHECK (((ano >= 2000) AND (ano <= 2100))),
    CONSTRAINT ch_ctb_pol_mes CHECK (((mes >= 1) AND (mes <= 12)))
);


--
-- Name: ctb_pol_anios; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_pol_anios (
    id integer NOT NULL,
    gral_emp_id integer NOT NULL,
    anio integer NOT NULL,
    cerrado boolean DEFAULT false NOT NULL,
    fecha_cierre timestamp with time zone,
    glal_usr_id integer DEFAULT 0 NOT NULL
);


--
-- Name: ctb_pol_anios_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_pol_anios_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_pol_anios_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_pol_anios_id_seq OWNED BY public.ctb_pol_anios.id;


--
-- Name: ctb_pol_cons; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_pol_cons (
    id integer NOT NULL,
    gral_emp_id integer NOT NULL,
    gral_suc_id integer NOT NULL,
    anio integer NOT NULL,
    mes integer NOT NULL,
    consecutivo integer NOT NULL,
    no_digitos integer DEFAULT 0 NOT NULL,
    cerrado boolean DEFAULT false NOT NULL,
    fecha_cierre timestamp with time zone,
    glal_usr_id_cierre integer DEFAULT 0 NOT NULL
);


--
-- Name: ctb_pol_cons_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_pol_cons_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_pol_cons_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_pol_cons_id_seq OWNED BY public.ctb_pol_cons.id;


--
-- Name: ctb_pol_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_pol_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_pol_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_pol_id_seq OWNED BY public.ctb_pol.id;


--
-- Name: ctb_pol_mov; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_pol_mov (
    id integer NOT NULL,
    ctb_pol_id integer NOT NULL,
    ctb_tmov_id integer DEFAULT 0 NOT NULL,
    ctb_cc_id integer DEFAULT 0 NOT NULL,
    ctb_cta_id integer NOT NULL,
    cta character varying DEFAULT ''::character varying,
    tipo integer DEFAULT 0,
    cantidad double precision DEFAULT 0 NOT NULL
);


--
-- Name: ctb_pol_mov_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_pol_mov_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_pol_mov_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_pol_mov_id_seq OWNED BY public.ctb_pol_mov.id;


--
-- Name: ctb_tmov; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_tmov (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    momento_creacion timestamp with time zone,
    gral_emp_id integer NOT NULL,
    gral_suc_id integer NOT NULL,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    ctb_tpol_id integer DEFAULT 0 NOT NULL,
    folio character varying DEFAULT ''::character varying NOT NULL,
    fecha integer DEFAULT 1 NOT NULL,
    pol_num integer DEFAULT 1 NOT NULL,
    ctb_app_id integer DEFAULT 0 NOT NULL
);


--
-- Name: ctb_tmov_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_tmov_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_tmov_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_tmov_id_seq OWNED BY public.ctb_tmov.id;


--
-- Name: ctb_tpol; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_tpol (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    ctb_tpol_grupo_id integer,
    tipo integer,
    empresa_id integer NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    momento_creacion timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: ctb_tpol_grupos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ctb_tpol_grupos (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: ctb_tpol_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ctb_tpol_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ctb_tpol_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ctb_tpol_id_seq OWNED BY public.ctb_tpol.id;


--
-- Name: gral_empleados; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_empleados (
    id integer NOT NULL,
    clave character varying,
    nombre_pila character varying NOT NULL,
    apellido_paterno character varying,
    apellido_materno character varying,
    imss character varying,
    infonavit character varying,
    curp character varying,
    rfc character varying,
    fecha_nacimiento date,
    fecha_ingreso date,
    gral_escolaridad_id integer DEFAULT 0,
    gral_sexo_id integer DEFAULT 0,
    gral_civil_id integer DEFAULT 0,
    gral_religion_id integer DEFAULT 0,
    gral_sangretipo_id integer DEFAULT 0,
    gral_puesto_id integer DEFAULT 0,
    gral_categ_id integer DEFAULT 0,
    gral_suc_id_empleado integer DEFAULT 0,
    telefono character varying NOT NULL,
    telefono_movil character varying,
    correo_personal character varying,
    gral_pais_id integer DEFAULT 0,
    gral_edo_id integer DEFAULT 0,
    gral_mun_id integer DEFAULT 0,
    calle character varying,
    numero character varying,
    colonia character varying,
    cp character varying,
    contacto_emergencia character varying,
    telefono_emergencia character varying,
    enfermedades text,
    alergias text,
    comentarios text,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gralsuc_id integer DEFAULT 0,
    comision_agen double precision DEFAULT 0 NOT NULL,
    region_id_agen integer DEFAULT 0 NOT NULL,
    comision2_agen double precision DEFAULT 0 NOT NULL,
    comision3_agen double precision DEFAULT 0 NOT NULL,
    comision4_agen double precision DEFAULT 0 NOT NULL,
    dias_tope_comision double precision DEFAULT 0 NOT NULL,
    dias_tope_comision2 double precision DEFAULT 0 NOT NULL,
    dias_tope_comision3 double precision DEFAULT 0 NOT NULL,
    monto_tope_comision double precision DEFAULT 0,
    monto_tope_comision2 double precision DEFAULT 0,
    monto_tope_comision3 double precision DEFAULT 0,
    tipo_comision integer DEFAULT 1,
    correo_empresa character varying DEFAULT ''::character varying,
    no_int character varying DEFAULT ''::character varying,
    nom_regimen_contratacion_id integer DEFAULT 0,
    nom_periodicidad_pago_id integer DEFAULT 0,
    nom_riesgo_puesto_id integer DEFAULT 0,
    nom_tipo_contrato_id integer DEFAULT 0,
    nom_tipo_jornada_id integer DEFAULT 0,
    tes_ban_id integer DEFAULT 0,
    clabe character varying DEFAULT ''::character varying,
    salario_base double precision DEFAULT 0,
    salario_integrado double precision DEFAULT 0,
    registro_patronal character varying DEFAULT ''::character varying,
    genera_nomina boolean DEFAULT false NOT NULL,
    gral_depto_id integer DEFAULT 0
);


--
-- Name: COLUMN gral_empleados.correo_empresa; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_empleados.correo_empresa IS 'Correo institucionnal asignado por la empresa';


--
-- Name: cxc_agen; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.cxc_agen AS
 SELECT gral_empleados.id,
    (((((gral_empleados.nombre_pila)::text || ' '::text) || (gral_empleados.apellido_paterno)::text) || ' '::text) || (gral_empleados.apellido_materno)::text) AS nombre,
    gral_empleados.comision_agen AS comision,
    gral_empleados.region_id_agen AS gral_reg_id,
    gral_usr.id AS gral_usr_id,
    gral_empleados.borrado_logico,
    gral_empleados.momento_actualizacion,
    gral_empleados.momento_creacion,
    gral_empleados.momento_baja,
    gral_empleados.gral_usr_id_creacion,
    gral_empleados.gral_usr_id_actualizacion,
    gral_empleados.gral_usr_id_baja,
    gral_empleados.comision2_agen AS comision2,
    gral_empleados.comision3_agen AS comision3,
    gral_empleados.comision4_agen AS comision4,
    gral_empleados.dias_tope_comision,
    gral_empleados.dias_tope_comision2,
    gral_empleados.dias_tope_comision3,
    gral_empleados.monto_tope_comision,
    gral_empleados.monto_tope_comision2,
    gral_empleados.monto_tope_comision3
   FROM (public.gral_empleados
     JOIN public.gral_usr ON ((gral_usr.gral_empleados_id = gral_empleados.id)))
  WHERE ((gral_empleados.gral_puesto_id = ANY (ARRAY[2, 4])) AND (gral_empleados.borrado_logico = false));


--
-- Name: cxc_agen_borrar; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_agen_borrar (
    id integer NOT NULL,
    nombre character varying,
    comision double precision,
    gral_reg_id integer NOT NULL,
    gral_usr_id integer DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    comision2 double precision DEFAULT 0,
    comision3 double precision DEFAULT 0,
    comision4 double precision DEFAULT 0,
    dias_tope_comision double precision DEFAULT 0,
    dias_tope_comision2 double precision DEFAULT 0,
    dias_tope_comision3 double precision DEFAULT 0
);


--
-- Name: cxc_agen_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_agen_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_agen_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_agen_id_seq OWNED BY public.cxc_agen_borrar.id;


--
-- Name: cxc_ant; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_ant (
    id integer NOT NULL,
    numero_transaccion bigint DEFAULT 0,
    cliente_id integer NOT NULL,
    moneda_id integer,
    anticipo_inicial double precision NOT NULL,
    anticipo_actual double precision NOT NULL,
    fecha_anticipo_usuario timestamp with time zone,
    observaciones text DEFAULT ''::text,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    cancelado boolean DEFAULT false
);


--
-- Name: cxc_ant_borrar; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_ant_borrar (
    id integer NOT NULL,
    numero_transaccion character varying DEFAULT 0,
    cliente_id integer NOT NULL,
    moneda_id integer,
    cantidad double precision NOT NULL,
    aplicado double precision NOT NULL,
    fecha_anticipo_usuario timestamp with time zone,
    observaciones text DEFAULT ''::text,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0
);


--
-- Name: cxc_ant_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_ant_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_ant_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_ant_id_seq OWNED BY public.cxc_ant_borrar.id;


--
-- Name: cxc_clie; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie (
    id integer NOT NULL,
    numero_control character varying,
    rfc character varying DEFAULT ''::character varying NOT NULL,
    curp character varying DEFAULT ''::character varying,
    razon_social character varying DEFAULT ''::character varying NOT NULL,
    clave_comercial character varying DEFAULT ''::character varying,
    calle character varying DEFAULT ''::character varying NOT NULL,
    numero character varying DEFAULT ''::character varying NOT NULL,
    entre_calles character varying DEFAULT ''::character varying NOT NULL,
    numero_exterior character varying DEFAULT ''::character varying NOT NULL,
    colonia character varying DEFAULT ''::character varying NOT NULL,
    cp character varying DEFAULT ''::character varying NOT NULL,
    pais_id integer DEFAULT 0,
    estado_id integer DEFAULT 0,
    municipio_id integer DEFAULT 0,
    localidad_alternativa character varying DEFAULT ''::character varying,
    telefono1 character varying DEFAULT ''::character varying,
    extension1 character varying DEFAULT ''::character varying,
    fax character varying DEFAULT ''::character varying,
    telefono2 character varying DEFAULT ''::character varying,
    extension2 character varying DEFAULT ''::character varying,
    email character varying DEFAULT ''::character varying,
    cxc_agen_id integer DEFAULT 0,
    contacto character varying DEFAULT ''::character varying,
    zona_id integer DEFAULT 0,
    cxc_clie_grupo_id integer DEFAULT 0,
    clienttipo_id integer DEFAULT 0 NOT NULL,
    clasif_1 integer DEFAULT 0,
    clasif_2 integer DEFAULT 0,
    clasif_3 integer DEFAULT 0,
    moneda integer DEFAULT 0,
    filial boolean DEFAULT false,
    estatus boolean DEFAULT true,
    gral_imp_id integer DEFAULT 0,
    limite_credito double precision DEFAULT 0,
    dias_credito_id integer DEFAULT 0,
    credito_suspendido boolean DEFAULT false,
    credito_a_partir integer DEFAULT 0,
    cxp_prov_tipo_embarque_id integer DEFAULT 0,
    dias_caducidad_cotizacion integer DEFAULT 0,
    condiciones text DEFAULT ''::text,
    observaciones text DEFAULT ''::text,
    contacto_compras_nombre character varying DEFAULT ''::character varying,
    contacto_compras_puesto character varying DEFAULT ''::character varying,
    contacto_compras_calle character varying DEFAULT ''::character varying,
    contacto_compras_numero character varying DEFAULT ''::character varying,
    contacto_compras_colonia character varying DEFAULT ''::character varying,
    contacto_compras_cp character varying DEFAULT ''::character varying,
    contacto_compras_entre_calles character varying DEFAULT ''::character varying,
    contacto_compras_pais_id integer DEFAULT 0,
    contacto_compras_estado_id integer DEFAULT 0,
    contacto_compras_municipio_id integer DEFAULT 0,
    contacto_compras_telefono1 character varying DEFAULT ''::character varying,
    contacto_compras_extension1 character varying DEFAULT ''::character varying,
    contacto_compras_fax character varying DEFAULT ''::character varying,
    contacto_compras_telefono2 character varying DEFAULT ''::character varying,
    contacto_compras_extension2 character varying DEFAULT ''::character varying,
    contacto_compras_email character varying DEFAULT ''::character varying,
    contacto_pagos_nombre character varying DEFAULT ''::character varying,
    contacto_pagos_puesto character varying DEFAULT ''::character varying,
    contacto_pagos_calle character varying DEFAULT ''::character varying,
    contacto_pagos_numero character varying DEFAULT ''::character varying,
    contacto_pagos_colonia character varying DEFAULT ''::character varying,
    contacto_pagos_cp character varying DEFAULT ''::character varying,
    contacto_pagos_entre_calles character varying DEFAULT ''::character varying,
    contacto_pagos_pais_id integer DEFAULT 0,
    contacto_pagos_estado_id integer DEFAULT 0,
    contacto_pagos_municipio_id integer DEFAULT 0,
    contacto_pagos_telefono1 character varying DEFAULT ''::character varying,
    contacto_pagos_extension1 character varying DEFAULT ''::character varying,
    contacto_pagos_fax character varying DEFAULT ''::character varying,
    contacto_pagos_telefono2 character varying DEFAULT ''::character varying,
    contacto_pagos_extension2 character varying DEFAULT ''::character varying,
    contacto_pagos_email character varying DEFAULT ''::character varying,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    id_aux integer,
    empresa_immex boolean DEFAULT false,
    tasa_ret_immex double precision DEFAULT 0,
    dia_revision smallint DEFAULT 0,
    dia_pago smallint DEFAULT 0,
    cta_pago_mn character varying DEFAULT ''::character varying,
    cta_pago_usd character varying DEFAULT ''::character varying,
    ctb_cta_id_activo integer DEFAULT 0,
    ctb_cta_id_ingreso integer DEFAULT 0,
    ctb_cta_id_ietu integer DEFAULT 0,
    ctb_cta_id_comple integer DEFAULT 0,
    ctb_cta_id_activo_comple integer DEFAULT 0,
    lista_precio integer DEFAULT 0,
    fac_metodos_pago_id integer DEFAULT 0,
    cxc_clie_tipo_adenda_id integer DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN cxc_clie.ctb_cta_id_activo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxc_clie.ctb_cta_id_activo IS 'id de la Cuenta Contable para Activo';


--
-- Name: COLUMN cxc_clie.ctb_cta_id_ingreso; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxc_clie.ctb_cta_id_ingreso IS 'id de la Cuenta Contable para Ingresos';


--
-- Name: COLUMN cxc_clie.ctb_cta_id_ietu; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxc_clie.ctb_cta_id_ietu IS 'id de la Cuenta Contable para IETU';


--
-- Name: COLUMN cxc_clie.ctb_cta_id_comple; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxc_clie.ctb_cta_id_comple IS 'id de la Cuenta Contable para Complementeria';


--
-- Name: COLUMN cxc_clie.ctb_cta_id_activo_comple; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxc_clie.ctb_cta_id_activo_comple IS 'id de la Cuenta Contable para Activo Complementaria';


--
-- Name: cxc_clie_adenda_datos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_adenda_datos (
    id integer NOT NULL,
    cxc_clie_adenda_tipo integer NOT NULL,
    campo character varying DEFAULT ''::character varying NOT NULL,
    valor character varying DEFAULT ''::character varying NOT NULL,
    gral_emp_id integer DEFAULT 0 NOT NULL
);


--
-- Name: cxc_clie_adenda_datos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_adenda_datos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_adenda_datos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_adenda_datos_id_seq OWNED BY public.cxc_clie_adenda_datos.id;


--
-- Name: cxc_clie_adenda_tipo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_adenda_tipo (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL
);


--
-- Name: cxc_clie_clas1; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_clas1 (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: cxc_clie_clas1_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_clas1_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_clas1_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_clas1_id_seq OWNED BY public.cxc_clie_clas1.id;


--
-- Name: cxc_clie_clas2; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_clas2 (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: cxc_clie_clas2_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_clas2_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_clas2_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_clas2_id_seq OWNED BY public.cxc_clie_clas2.id;


--
-- Name: cxc_clie_clas3; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_clas3 (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: cxc_clie_clas3_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_clas3_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_clas3_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_clas3_id_seq OWNED BY public.cxc_clie_clas3.id;


--
-- Name: cxc_clie_creapar; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_creapar (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: cxc_clie_creapar_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_creapar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_creapar_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_creapar_id_seq OWNED BY public.cxc_clie_creapar.id;


--
-- Name: cxc_clie_credias; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_credias (
    id integer NOT NULL,
    descripcion text,
    dias integer,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    tipo_cambio double precision DEFAULT 0,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    sucursal_id integer DEFAULT 0
);


--
-- Name: cxc_clie_descto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_descto (
    id integer NOT NULL,
    cxc_clie_id integer NOT NULL,
    tipo integer DEFAULT 0 NOT NULL,
    valor double precision DEFAULT 0 NOT NULL,
    CONSTRAINT chk_cxc_clie_tipo CHECK ((tipo = 1)),
    CONSTRAINT chk_cxc_clie_valor CHECK ((valor >= (0)::double precision))
);


--
-- Name: cxc_clie_descto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_descto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_descto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_descto_id_seq OWNED BY public.cxc_clie_descto.id;


--
-- Name: cxc_clie_df; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_df (
    id integer NOT NULL,
    cxc_clie_id integer NOT NULL,
    calle character varying DEFAULT ''::character varying NOT NULL,
    numero_interior character varying DEFAULT ''::character varying NOT NULL,
    numero_exterior character varying DEFAULT ''::character varying NOT NULL,
    entre_calles character varying DEFAULT ''::character varying NOT NULL,
    colonia character varying DEFAULT ''::character varying NOT NULL,
    cp character varying DEFAULT ''::character varying NOT NULL,
    gral_pais_id integer DEFAULT 0,
    gral_edo_id integer DEFAULT 0,
    gral_mun_id integer DEFAULT 0,
    telefono1 character varying DEFAULT ''::character varying,
    extension1 character varying DEFAULT ''::character varying,
    telefono2 character varying DEFAULT ''::character varying,
    extension2 character varying DEFAULT ''::character varying,
    fax character varying DEFAULT ''::character varying,
    email character varying DEFAULT ''::character varying,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gra_usr_id_creacion integer DEFAULT 0,
    gra_usr_id_actualizacion integer DEFAULT 0,
    gra_usr_id_baja integer DEFAULT 0,
    contacto character varying DEFAULT ''::character varying
);


--
-- Name: TABLE cxc_clie_df; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.cxc_clie_df IS 'Tabla de direcciones fiscales de clientes. En √©sta tabla existe un registro con el ID=1. √âste registro es para  utilizarla como llave foranea en las tablas poc_pedidos, erp_prefacturas, fac_docs y fac_rems en el caso de que la direcci√≥n de Facturaci√≥n sea la DEFAULT, es decir, la direcci√≥n que se encuentra en la tabla de Clientes(cxc_clie)';


--
-- Name: cxc_clie_df_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_df_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_df_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_df_id_seq OWNED BY public.cxc_clie_df.id;


--
-- Name: cxc_clie_grupos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_grupos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean
);


--
-- Name: cxc_clie_grupos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_grupos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_grupos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_grupos_id_seq OWNED BY public.cxc_clie_grupos.id;


--
-- Name: cxc_clie_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_id_seq OWNED BY public.cxc_clie.id;


--
-- Name: cxc_clie_mensajes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_mensajes (
    id integer NOT NULL,
    cxc_mov_tipo_id integer NOT NULL,
    cxc_clie_id integer NOT NULL,
    msg_1 character varying
);


--
-- Name: cxc_clie_mensajes_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_mensajes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_mensajes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_mensajes_id_seq OWNED BY public.cxc_clie_mensajes.id;


--
-- Name: cxc_clie_tipos_embarque; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_tipos_embarque (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: cxc_clie_tipos_embarque_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_tipos_embarque_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_tipos_embarque_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_tipos_embarque_id_seq OWNED BY public.cxc_clie_tipos_embarque.id;


--
-- Name: cxc_clie_zonas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_clie_zonas (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean
);


--
-- Name: cxc_clie_zonas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_clie_zonas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_clie_zonas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_clie_zonas_id_seq OWNED BY public.cxc_clie_zonas.id;


--
-- Name: cxc_fac_rev_cob; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_fac_rev_cob (
    id integer NOT NULL,
    folio character varying NOT NULL,
    fecha_proceso timestamp with time zone,
    borrado_logico boolean DEFAULT false NOT NULL,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    actualizado boolean DEFAULT false
);


--
-- Name: cxc_fac_rev_cob_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_fac_rev_cob_detalle (
    id integer NOT NULL,
    cxc_fac_rev_cob_id integer,
    erp_h_facturas_id integer NOT NULL,
    revision_cobro character varying(1)
);


--
-- Name: COLUMN cxc_fac_rev_cob_detalle.revision_cobro; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxc_fac_rev_cob_detalle.revision_cobro IS 'R=Facturas a Revision, C=Facturas a Cobro';


--
-- Name: cxc_fac_rev_cob_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_fac_rev_cob_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_fac_rev_cob_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_fac_rev_cob_detalle_id_seq OWNED BY public.cxc_fac_rev_cob_detalle.id;


--
-- Name: cxc_fac_rev_cob_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_fac_rev_cob_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_fac_rev_cob_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_fac_rev_cob_id_seq OWNED BY public.cxc_fac_rev_cob.id;


--
-- Name: cxp_facturas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_facturas (
    id integer NOT NULL,
    cxc_prov_id integer NOT NULL,
    serie_folio character varying NOT NULL,
    monto_total double precision DEFAULT 0 NOT NULL,
    moneda_id integer NOT NULL,
    tipo_cambio double precision DEFAULT 0 NOT NULL,
    total_pagos double precision DEFAULT 0,
    total_pagos_cancelados double precision DEFAULT 0,
    saldo_factura double precision DEFAULT 0,
    total_notas_creditos double precision DEFAULT 0,
    total_saldoa_favor double precision DEFAULT 0,
    total_anticipos double precision DEFAULT 0,
    fecha_factura timestamp with time zone,
    pagado boolean DEFAULT false NOT NULL,
    cancelacion boolean DEFAULT false NOT NULL,
    momento_cancelacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_cancelacion integer DEFAULT 0,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    momento_creacion timestamp with time zone,
    subtotal double precision DEFAULT 0,
    iva double precision DEFAULT 0,
    flete double precision DEFAULT 0,
    retencion double precision DEFAULT 0,
    id_sai integer,
    numero_guia character varying DEFAULT ''::character varying,
    orden_compra character varying DEFAULT ''::character varying,
    observaciones text DEFAULT ''::text,
    fletera_id integer DEFAULT 0,
    dias_credito_id integer DEFAULT 0,
    fecha_vencimiento timestamp with time zone,
    tipo_factura_proveedor integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    motivo_cancelacion text DEFAULT ''::text,
    cxp_tipo_cancelacion_id integer DEFAULT 0,
    fecha_ultimo_pago timestamp with time zone,
    monto_ieps double precision DEFAULT 0,
    monto_ret_isr double precision DEFAULT 0,
    estatus smallint DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN cxp_facturas.estatus; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_facturas.estatus IS '0=Nuevo, 1=Pago Parcial, 2=Pagado, 3=Cancelado';


--
-- Name: cxc_facturas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_facturas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_facturas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_facturas_id_seq OWNED BY public.cxp_facturas.id;


--
-- Name: cxc_mov_tipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxc_mov_tipos (
    id integer NOT NULL,
    titulo character varying,
    moneda_id integer,
    descripcion character varying
);


--
-- Name: cxc_mov_tipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxc_mov_tipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxc_mov_tipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxc_mov_tipos_id_seq OWNED BY public.cxc_mov_tipos.id;


--
-- Name: cxp_ant_par; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_ant_par (
    id integer NOT NULL,
    gral_suc_id integer NOT NULL,
    cxp_mov_tipo_id integer NOT NULL,
    cxp_mov_tipo_id_apl_ant integer NOT NULL,
    cxp_mov_tipo_id_apl_fac integer NOT NULL,
    cxp_mov_tipo_id_can integer,
    id_documento integer,
    incluye_iva boolean DEFAULT true,
    oc_requerida boolean DEFAULT false,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer,
    gral_suc_id_consecutivo integer DEFAULT 0
);


--
-- Name: cxp_ant_par_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_ant_par_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_ant_par_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_ant_par_id_seq OWNED BY public.cxp_ant_par.id;


--
-- Name: cxp_facturas_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_facturas_detalle (
    id integer NOT NULL,
    cxp_facturas_id integer DEFAULT 0,
    codigo_producto character varying DEFAULT ''::character varying,
    descripcion character varying DEFAULT ''::character varying,
    unidad_medida character varying DEFAULT ''::character varying,
    presentacion character varying DEFAULT ''::character varying,
    cantidad double precision DEFAULT 0,
    costo_unitario double precision DEFAULT 0,
    gral_imp_id integer DEFAULT 0,
    pedimento_aduanal character varying DEFAULT ''::character varying,
    fecha_caducidad date DEFAULT '2999-12-31'::date NOT NULL,
    valor_imp double precision DEFAULT 0,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0
);


--
-- Name: cxp_facturas_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_facturas_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_facturas_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_facturas_detalle_id_seq OWNED BY public.cxp_facturas_detalle.id;


--
-- Name: cxp_facturas_tipos_cancelacion; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_facturas_tipos_cancelacion (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false
);


--
-- Name: cxp_facturas_tipos_cancelacion_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_facturas_tipos_cancelacion_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_facturas_tipos_cancelacion_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_facturas_tipos_cancelacion_id_seq OWNED BY public.cxp_facturas_tipos_cancelacion.id;


--
-- Name: cxp_mov_tipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_mov_tipos (
    id integer NOT NULL,
    titulo character varying,
    moneda_id integer,
    descripcion character varying,
    grupo integer,
    naturaleza integer,
    inv_mov_tipo_id integer,
    serie integer,
    acumula_compras boolean DEFAULT false,
    acumula_pagos boolean DEFAULT false,
    genera_cheque boolean DEFAULT false,
    saldar_cheque boolean DEFAULT false,
    referenciado boolean DEFAULT false,
    pago_parcial boolean DEFAULT false,
    sobre_pago boolean DEFAULT false,
    leyenda_singular character varying DEFAULT ''::character varying,
    leyenda_plural character varying DEFAULT ''::character varying,
    lenguaje integer,
    afecta_contabilidad boolean DEFAULT false,
    ctb_tpol_id integer,
    ctb_con_id integer,
    ctb_cc_id integer,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: cxp_mov_tipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_mov_tipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_mov_tipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_mov_tipos_id_seq OWNED BY public.cxp_mov_tipos.id;


--
-- Name: cxp_nota_credito; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_nota_credito (
    id integer NOT NULL,
    folio character varying,
    serie_folio character varying DEFAULT ''::character varying,
    fecha_expedicion date,
    cxp_prov_id integer NOT NULL,
    moneda_id integer,
    subtotal double precision DEFAULT 0,
    impuesto double precision DEFAULT 0,
    total double precision DEFAULT 0,
    gral_impto_id integer DEFAULT 0,
    valor_impuesto double precision DEFAULT 0,
    tipo_cambio double precision DEFAULT 0,
    concepto text DEFAULT ''::text,
    observaciones text DEFAULT ''::text,
    factura character varying DEFAULT ''::character varying,
    cancelado boolean DEFAULT false,
    motivo_cancelacion text DEFAULT ''::text,
    momento_creacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_cancelacion integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_app_id_creacion integer DEFAULT 0,
    tipo smallint,
    inv_mov_tipo_id integer DEFAULT 0,
    inv_alm_id integer DEFAULT 0,
    monto_ieps double precision DEFAULT 0
);


--
-- Name: COLUMN cxp_nota_credito.folio; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_nota_credito.folio IS 'Folio de registro de la Nota de credito';


--
-- Name: COLUMN cxp_nota_credito.serie_folio; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_nota_credito.serie_folio IS 'Numero de Nota de Credito del proveedor';


--
-- Name: COLUMN cxp_nota_credito.factura; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_nota_credito.factura IS 'Factura de proveedor que afecta esta nota de Credito';


--
-- Name: COLUMN cxp_nota_credito.gral_app_id_creacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_nota_credito.gral_app_id_creacion IS 'ID del aplicativo desde donde se genero la Nota de Credito, 101=Aplicativo Notas de Credito de proveedores';


--
-- Name: COLUMN cxp_nota_credito.tipo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_nota_credito.tipo IS '1=Bonificacion, 2=Descuento, 3=Devolucion de Mercancia';


--
-- Name: cxp_nota_credito_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_nota_credito_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_nota_credito_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_nota_credito_id_seq OWNED BY public.cxp_nota_credito.id;


--
-- Name: cxp_pagos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_pagos (
    id integer NOT NULL,
    numero_transaccion bigint,
    cxp_prov_id integer DEFAULT 0,
    moneda_id integer DEFAULT 0,
    cxp_mov_tipo_id integer DEFAULT 0,
    tes_mov_id integer DEFAULT 0,
    tes_mov_tipo_id integer DEFAULT 0,
    fecha_pago date,
    tipo_cambio double precision DEFAULT 0,
    tes_ban_id integer DEFAULT 0,
    tes_che_id integer DEFAULT 0,
    numero_cheque character varying DEFAULT ''::character varying,
    referencia character varying DEFAULT ''::character varying,
    numero_tarjeta character varying DEFAULT ''::character varying,
    monto_pago double precision DEFAULT 0,
    cxp_ant_id integer DEFAULT 0,
    pago_con_saldo_favor boolean DEFAULT false,
    observaciones text DEFAULT ''::text,
    momento_creacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    momento_cancelacion timestamp with time zone,
    cancelacion boolean DEFAULT false,
    motivo_cancelacion text DEFAULT ''::text,
    gral_usr_id_cancelacion integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: cxp_pagos_detalles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_pagos_detalles (
    id integer NOT NULL,
    cxp_pago_id integer DEFAULT 0 NOT NULL,
    serie_folio character varying,
    cantidad double precision DEFAULT 0,
    tipo_cambio double precision DEFAULT 0,
    cancelacion boolean DEFAULT false NOT NULL,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_cancelacion integer DEFAULT 0
);


--
-- Name: cxp_pagos_detalles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_pagos_detalles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_pagos_detalles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_pagos_detalles_id_seq OWNED BY public.cxp_pagos_detalles.id;


--
-- Name: cxp_pagos_formas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_pagos_formas (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean
);


--
-- Name: cxp_pagos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_pagos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_pagos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_pagos_id_seq OWNED BY public.cxp_pagos.id;


--
-- Name: cxp_pagos_tipo_movimiento; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_pagos_tipo_movimiento (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false
);


--
-- Name: cxp_pagos_tipo_movimiento_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_pagos_tipo_movimiento_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_pagos_tipo_movimiento_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_pagos_tipo_movimiento_id_seq OWNED BY public.cxp_pagos_tipo_movimiento.id;


--
-- Name: cxp_prov; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov (
    id integer NOT NULL,
    folio character varying,
    rfc character varying,
    curp character varying DEFAULT ''::character varying,
    razon_social character varying DEFAULT ''::character varying,
    clave_comercial character varying DEFAULT ''::character varying NOT NULL,
    calle character varying DEFAULT ''::character varying,
    numero character varying DEFAULT ''::character varying,
    colonia character varying DEFAULT ''::character varying,
    cp character varying DEFAULT ''::character varying,
    entre_calles character varying DEFAULT ''::character varying,
    pais_id integer DEFAULT 0,
    estado_id integer DEFAULT 0,
    municipio_id integer DEFAULT 0,
    localidad_alternativa character varying DEFAULT ''::character varying,
    telefono1 character varying DEFAULT ''::character varying,
    extension1 character varying DEFAULT ''::character varying,
    fax character varying DEFAULT ''::character varying,
    telefono2 character varying DEFAULT ''::character varying,
    extension2 character varying DEFAULT ''::character varying,
    correo_electronico character varying DEFAULT ''::character varying,
    web_site character varying DEFAULT ''::character varying,
    impuesto integer DEFAULT 0,
    cxp_prov_zona_id integer DEFAULT 0,
    grupo_id integer DEFAULT 0,
    proveedortipo_id integer DEFAULT 0,
    clasif_1 integer DEFAULT 0,
    clasif_2 integer DEFAULT 0,
    clasif_3 integer DEFAULT 0,
    moneda_id integer DEFAULT 0,
    tiempo_entrega_id integer DEFAULT 0,
    estatus boolean DEFAULT true,
    limite_credito double precision DEFAULT 0,
    dias_credito_id integer DEFAULT 0,
    descuento double precision DEFAULT 0,
    credito_a_partir integer DEFAULT 0,
    cxp_prov_tipo_embarque_id integer DEFAULT 0,
    flete_pagado boolean DEFAULT false,
    condiciones text DEFAULT ''::text,
    observaciones text DEFAULT ''::text,
    vent_contacto character varying DEFAULT ''::character varying,
    vent_puesto character varying DEFAULT ''::character varying,
    vent_calle character varying DEFAULT ''::character varying,
    vent_numero character varying DEFAULT ''::character varying,
    vent_colonia character varying DEFAULT ''::character varying,
    vent_cp character varying DEFAULT ''::character varying,
    vent_entre_calles character varying DEFAULT ''::character varying,
    vent_pais_id integer DEFAULT 0,
    vent_estado_id integer DEFAULT 0,
    vent_municipio_id integer DEFAULT 0,
    vent_telefono1 character varying DEFAULT ''::character varying,
    vent_extension1 character varying DEFAULT ''::character varying,
    vent_fax character varying DEFAULT ''::character varying,
    vent_telefono2 character varying DEFAULT ''::character varying,
    vent_extension2 character varying DEFAULT ''::character varying,
    vent_email character varying DEFAULT ''::character varying,
    cob_contacto character varying DEFAULT ''::character varying,
    cob_puesto character varying DEFAULT ''::character varying,
    cob_calle character varying DEFAULT ''::character varying,
    cob_numero character varying DEFAULT ''::character varying,
    cob_colonia character varying DEFAULT ''::character varying,
    cob_cp character varying DEFAULT ''::character varying,
    cob_entre_calles character varying DEFAULT ''::character varying,
    cob_pais_id integer DEFAULT 0,
    cob_estado_id integer DEFAULT 0,
    cob_municipio_id integer DEFAULT 0,
    cob_telefono1 character varying DEFAULT ''::character varying,
    cob_extension1 character varying DEFAULT ''::character varying,
    cob_fax character varying DEFAULT ''::character varying,
    cob_telefono2 character varying DEFAULT ''::character varying,
    cob_extension2 character varying DEFAULT ''::character varying,
    cob_email character varying DEFAULT ''::character varying,
    comentarios text DEFAULT ''::text,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    ctb_cta_id_pasivo integer DEFAULT 0,
    ctb_cta_id_egreso integer DEFAULT 0,
    ctb_cta_id_ietu integer DEFAULT 0,
    ctb_cta_id_comple integer DEFAULT 0,
    ctb_cta_id_pasivo_comple integer DEFAULT 0,
    transportista boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE cxp_prov; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.cxp_prov IS 'Alberga todos los proveedores requeridos en el modulo de cuentas por pagar';


--
-- Name: COLUMN cxp_prov.ctb_cta_id_pasivo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_prov.ctb_cta_id_pasivo IS 'id de la Cuenta Contable para Pasivos';


--
-- Name: COLUMN cxp_prov.ctb_cta_id_egreso; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_prov.ctb_cta_id_egreso IS 'id de la Cuenta Contable para Egresos';


--
-- Name: COLUMN cxp_prov.ctb_cta_id_ietu; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_prov.ctb_cta_id_ietu IS 'id de la Cuenta Contable para IETU';


--
-- Name: COLUMN cxp_prov.ctb_cta_id_comple; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_prov.ctb_cta_id_comple IS 'id de la Cuenta Contable para Complementeria';


--
-- Name: COLUMN cxp_prov.ctb_cta_id_pasivo_comple; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.cxp_prov.ctb_cta_id_pasivo_comple IS 'id de la Cuenta Contable para Pasivo Complementaria';


--
-- Name: cxp_prov2; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov2 (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    borrado_logico boolean,
    correo_electronico character varying,
    rfc character varying,
    razon_social character varying,
    calle character varying,
    numero character varying,
    colonia character varying,
    cp character varying,
    comentarios text,
    localidad_alternativa character varying,
    web_site character varying,
    folio character varying,
    folio_anterior character varying,
    proveedortipo_id integer DEFAULT 0 NOT NULL,
    telefono character varying,
    telefono_alternativo character varying,
    fax character varying,
    moneda_id integer,
    tiempo_entrega_id integer DEFAULT 0,
    pais_id integer,
    estado_id integer,
    municipio_id integer,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    cxp_prov_zona_id integer DEFAULT 1 NOT NULL,
    clasif_1 integer DEFAULT 1 NOT NULL,
    clasif_2 integer DEFAULT 1 NOT NULL,
    clasif_3 integer DEFAULT 1 NOT NULL,
    grupo_id integer DEFAULT 1 NOT NULL,
    dias_credito_id integer DEFAULT 1,
    limite_credito double precision DEFAULT 0,
    credito_a_partir integer DEFAULT 1
);


--
-- Name: cxp_prov_clas1; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_clas1 (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: cxp_prov_clas1_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_clas1_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_clas1_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_clas1_id_seq OWNED BY public.cxp_prov_clas1.id;


--
-- Name: cxp_prov_clas2; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_clas2 (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: cxp_prov_clas2_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_clas2_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_clas2_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_clas2_id_seq OWNED BY public.cxp_prov_clas2.id;


--
-- Name: cxp_prov_clas3; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_clas3 (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: cxp_prov_clas3_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_clas3_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_clas3_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_clas3_id_seq OWNED BY public.cxp_prov_clas3.id;


--
-- Name: cxp_prov_clases; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_clases (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: cxp_prov_contactos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_contactos (
    id integer NOT NULL,
    contacto character varying NOT NULL,
    proveedor_id integer NOT NULL,
    telefono character varying,
    email character varying,
    fax character varying
);


--
-- Name: cxp_prov_creapar; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_creapar (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: cxp_prov_creapar_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_creapar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_creapar_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_creapar_id_seq OWNED BY public.cxp_prov_creapar.id;


--
-- Name: cxp_prov_credias; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_credias (
    id integer NOT NULL,
    descripcion text,
    dias integer
);


--
-- Name: cxp_prov_credias_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_credias_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_credias_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_credias_id_seq OWNED BY public.cxp_prov_credias.id;


--
-- Name: cxp_prov_dir; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_dir (
    id integer NOT NULL,
    proveedor_id integer,
    calle character varying DEFAULT ''::character varying NOT NULL,
    numero character varying DEFAULT ''::character varying NOT NULL,
    entre_calles character varying DEFAULT ''::character varying NOT NULL,
    numero_interior character varying DEFAULT ''::character varying NOT NULL,
    numero_exterior character varying DEFAULT ''::character varying NOT NULL,
    colonia character varying DEFAULT ''::character varying NOT NULL,
    cp character varying DEFAULT ''::character varying NOT NULL,
    pais_id integer DEFAULT 0,
    estado_id integer DEFAULT 0,
    municipio_id integer DEFAULT 0,
    telefono1 character varying DEFAULT ''::character varying,
    extension1 character varying DEFAULT ''::character varying,
    fax character varying DEFAULT ''::character varying,
    telefono2 character varying DEFAULT ''::character varying,
    extension2 character varying DEFAULT ''::character varying,
    observaciones text DEFAULT ''::text,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: TABLE cxp_prov_dir; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.cxp_prov_dir IS 'Un proveedor del modulo cuentas por pagar, puede tener de UNA a N direcciones, en esta tabla se albergaran todas las direcciones adicionales si el proveedor tiene mas de una direccion. ';


--
-- Name: cxp_prov_dir_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_dir_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_dir_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_dir_id_seq OWNED BY public.cxp_prov_dir.id;


--
-- Name: cxp_prov_fleteras; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_fleteras (
    id integer NOT NULL,
    razon_social character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0
);


--
-- Name: cxp_prov_grupos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_grupos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean
);


--
-- Name: cxp_prov_grupos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_grupos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_grupos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_grupos_id_seq OWNED BY public.cxp_prov_grupos.id;


--
-- Name: cxp_prov_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_id_seq OWNED BY public.cxp_prov.id;


--
-- Name: cxp_prov_mensajes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_mensajes (
    id integer NOT NULL,
    cxp_mov_tipo_id integer NOT NULL,
    cxp_prov_id integer NOT NULL,
    msg_1 character varying
);


--
-- Name: cxp_prov_msg_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_msg_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_msg_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_msg_id_seq OWNED BY public.cxp_prov_mensajes.id;


--
-- Name: cxp_prov_tipos_embarque; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_tipos_embarque (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: cxp_prov_tipos_embarque_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_prov_tipos_embarque_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_prov_tipos_embarque_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_prov_tipos_embarque_id_seq OWNED BY public.cxp_prov_tipos_embarque.id;


--
-- Name: cxp_prov_zonas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.cxp_prov_zonas (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: cxp_zona_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.cxp_zona_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: cxp_zona_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.cxp_zona_id_seq OWNED BY public.cxp_prov_zonas.id;


--
-- Name: env_conf; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.env_conf (
    id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    inv_prod_presentacion_id integer NOT NULL,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0
);


--
-- Name: env_conf_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.env_conf_det (
    id integer NOT NULL,
    env_conf_id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    cantidad double precision DEFAULT 0
);


--
-- Name: COLUMN env_conf_det.inv_prod_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_conf_det.inv_prod_id IS 'ID del producto que compone el envase.';


--
-- Name: env_conf_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.env_conf_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: env_conf_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.env_conf_det_id_seq OWNED BY public.env_conf_det.id;


--
-- Name: env_conf_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.env_conf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: env_conf_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.env_conf_id_seq OWNED BY public.env_conf.id;


--
-- Name: env_env; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.env_env (
    inv_prod_id integer DEFAULT 0 NOT NULL,
    cantidad double precision DEFAULT 0 NOT NULL,
    merma double precision DEFAULT 0 NOT NULL,
    inv_prod_presentaciones_id integer DEFAULT 0 NOT NULL,
    pro_equipos_id integer DEFAULT 0 NOT NULL,
    gral_empleados_id integer DEFAULT 0 NOT NULL,
    id integer NOT NULL,
    gral_emp_id integer DEFAULT 0 NOT NULL,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0 NOT NULL,
    gral_usr_id_actualizacion integer DEFAULT 0 NOT NULL,
    gral_usr_id_baja integer DEFAULT 0 NOT NULL,
    fecha date,
    hora time with time zone,
    pro_orden_prod_id integer DEFAULT 0 NOT NULL,
    env_estatus_id integer DEFAULT 0 NOT NULL,
    inv_alm_id integer DEFAULT 0 NOT NULL,
    folio character varying DEFAULT ''::character varying NOT NULL
);


--
-- Name: TABLE env_env; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.env_env IS 'guarda los datos generales de el envasado';


--
-- Name: COLUMN env_env.inv_prod_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.inv_prod_id IS 'id de el producto que se va a envasar';


--
-- Name: COLUMN env_env.cantidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.cantidad IS 'cantidad en enbasar de acuerdo a la presentacion seleccionada';


--
-- Name: COLUMN env_env.merma; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.merma IS 'merma que se genera en el envasado, no debe pasar el 2 porciento';


--
-- Name: COLUMN env_env.inv_prod_presentaciones_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.inv_prod_presentaciones_id IS 'presentacion de el producto a envasar';


--
-- Name: COLUMN env_env.pro_equipos_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.pro_equipos_id IS 'id de el equipo que se utilizara para el envasado';


--
-- Name: COLUMN env_env.gral_empleados_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.gral_empleados_id IS 'id de el empleado, con puesto de operario que realizara el envasado';


--
-- Name: COLUMN env_env.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.id IS 'id de la tabla';


--
-- Name: COLUMN env_env.gral_emp_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.gral_emp_id IS 'id de la empresa a la que pertenece este registro';


--
-- Name: COLUMN env_env.gral_suc_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.gral_suc_id IS 'id de la sucursal a la que pertenece este registro';


--
-- Name: COLUMN env_env.momento_creacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.momento_creacion IS 'MOMENTO EN QUE SE CREO EL REGISTRO';


--
-- Name: COLUMN env_env.momento_actualizacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.momento_actualizacion IS 'MOMENTO EN QUE SE ACTUALIZO EL REGISTRO';


--
-- Name: COLUMN env_env.momento_baja; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.momento_baja IS 'MOMENTO EN QUE SE DIO DE BAJA EL REGISTRO';


--
-- Name: COLUMN env_env.gral_usr_id_creacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.gral_usr_id_creacion IS 'USUARIO QUE CREA EL REGISTRO';


--
-- Name: COLUMN env_env.gral_usr_id_actualizacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.gral_usr_id_actualizacion IS 'USUARIO QUE ACTUALIZO EL REGISTRO';


--
-- Name: COLUMN env_env.gral_usr_id_baja; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_env.gral_usr_id_baja IS 'USUARIO QUE DIO DE BAJA EL REGISTRO';


--
-- Name: env_env_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.env_env_det (
    id integer NOT NULL,
    env_env_id integer DEFAULT 0 NOT NULL,
    env_conf_id integer DEFAULT 0 NOT NULL,
    cantidad double precision DEFAULT 0 NOT NULL,
    inv_alm_id integer DEFAULT 0 NOT NULL,
    inv_alm_id_env integer DEFAULT 0 NOT NULL
);


--
-- Name: env_env_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.env_env_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: env_env_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.env_env_det_id_seq OWNED BY public.env_env_det.id;


--
-- Name: env_env_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.env_env_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: env_env_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.env_env_id_seq OWNED BY public.env_env.id;


--
-- Name: env_estatus; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.env_estatus (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying
);


--
-- Name: env_reenv; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.env_reenv (
    id integer NOT NULL,
    folio character varying DEFAULT ''::character varying NOT NULL,
    inv_prod_id integer DEFAULT 0 NOT NULL,
    inv_prod_presentacion_id integer DEFAULT 0 NOT NULL,
    inv_alm_id integer DEFAULT 0 NOT NULL,
    existencia double precision DEFAULT 0,
    fecha date,
    hora_inicio time with time zone,
    env_estatus_id integer DEFAULT 1,
    gral_empleado_id integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_cancela integer DEFAULT 0
);


--
-- Name: env_reenv_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.env_reenv_det (
    id integer NOT NULL,
    env_reenv_id integer DEFAULT 0 NOT NULL,
    env_conf_id integer DEFAULT 0 NOT NULL,
    inv_alm_id integer DEFAULT 0 NOT NULL,
    cantidad double precision DEFAULT 0,
    inv_alm_id_env integer DEFAULT 0
);


--
-- Name: COLUMN env_reenv_det.inv_alm_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_reenv_det.inv_alm_id IS 'Id del Almacen destino de lo Envasado';


--
-- Name: COLUMN env_reenv_det.inv_alm_id_env; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.env_reenv_det.inv_alm_id_env IS 'Id del Almacen Origen del Envase';


--
-- Name: env_reenv_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.env_reenv_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: env_reenv_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.env_reenv_det_id_seq OWNED BY public.env_reenv_det.id;


--
-- Name: env_reenv_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.env_reenv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: env_reenv_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.env_reenv_id_seq OWNED BY public.env_reenv.id;


--
-- Name: erp_anticipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_anticipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_anticipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_anticipos_id_seq OWNED BY public.cxc_ant.id;


--
-- Name: erp_bancos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_bancos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    clave character varying NOT NULL,
    momento_baja timestamp with time zone,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    borrado_logico boolean DEFAULT false
);


--
-- Name: erp_bancos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_bancos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_bancos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_bancos_id_seq OWNED BY public.erp_bancos.id;


--
-- Name: erp_cotizacions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_cotizacions (
    id integer NOT NULL,
    folio character varying NOT NULL,
    tipo_id integer,
    cliente_id integer NOT NULL,
    contacto character varying,
    status_id integer DEFAULT 1,
    usuario_id integer,
    observaciones text,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    proceso_id integer DEFAULT 0 NOT NULL,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0
);


--
-- Name: erp_cotizacions_detalles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_cotizacions_detalles (
    id integer NOT NULL,
    producto_id integer NOT NULL,
    presentacion_id integer NOT NULL,
    tipo_impuesto_id integer DEFAULT 0,
    cantidad double precision,
    precio_unitario double precision,
    momento_creacion timestamp with time zone,
    cotizacions_id integer,
    moneda_id integer
);


--
-- Name: erp_cotizacions_detalles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_cotizacions_detalles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_cotizacions_detalles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_cotizacions_detalles_id_seq OWNED BY public.erp_cotizacions_detalles.id;


--
-- Name: erp_cotizacions_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_cotizacions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_cotizacions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_cotizacions_id_seq OWNED BY public.erp_cotizacions.id;


--
-- Name: erp_cotizacions_status; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_cotizacions_status (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: erp_cotizacions_tipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_cotizacions_tipos (
    id integer NOT NULL,
    tipo character varying NOT NULL
);


--
-- Name: erp_cuentas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_cuentas (
    id integer NOT NULL,
    titulo character varying,
    numero_sucursal character varying,
    sucursal character varying,
    direccion_sucursal character varying,
    borrado_logico boolean,
    ejecutivo_cuenta character varying,
    correo_electronico character varying,
    telefono_ejecutivo character varying,
    banco_id integer NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    moneda_id integer,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    id_aux integer
);


--
-- Name: erp_cuentas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_cuentas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_cuentas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_cuentas_id_seq OWNED BY public.erp_cuentas.id;


--
-- Name: erp_emails; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_emails (
    id integer NOT NULL,
    titulo character varying,
    palabra_clave character varying,
    caducidad_activa boolean DEFAULT false NOT NULL,
    caducidad date,
    activo boolean DEFAULT true,
    empleado_id integer NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    borrado_logico boolean DEFAULT false
);


--
-- Name: erp_emails_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_emails_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_emails_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_emails_id_seq OWNED BY public.erp_emails.id;


--
-- Name: erp_empleados; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_empleados (
    id integer NOT NULL,
    nombre_pila character varying NOT NULL,
    apellido_paterno character varying NOT NULL,
    apellido_materno character varying NOT NULL,
    imss character varying,
    infonavit character varying,
    curp character varying,
    rfc character varying,
    fecha_nacimiento date,
    fecha_ingreso date,
    escolaridad_id integer,
    sexo boolean,
    civil_id integer,
    religion_id integer,
    telefono character varying NOT NULL,
    movil character varying,
    correo_personal character varying,
    pais character varying,
    entidad character varying,
    localidad character varying,
    calle character varying,
    numero character varying,
    colonia character varying,
    cp character varying,
    contacto_emergencia character varying,
    telefono_emergencia character varying,
    sangretipo_id integer,
    enfermedades text,
    alergias text,
    comentarios text,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    vendedor boolean DEFAULT false,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0
);


--
-- Name: erp_empleados_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_empleados_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_empleados_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_empleados_id_seq OWNED BY public.erp_empleados.id;


--
-- Name: erp_escolaridads; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_escolaridads (
    id integer NOT NULL,
    titulo character varying
);


--
-- Name: TABLE erp_escolaridads; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.erp_escolaridads IS 'Tabla de contiene las escolaridades que puede tener una persona';


--
-- Name: COLUMN erp_escolaridads.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_escolaridads.id IS 'Indicador secuencial que identifica la fila, este  es autoincremental';


--
-- Name: erp_estatus_ordencompra; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_estatus_ordencompra (
    id integer NOT NULL,
    descripcion character varying NOT NULL
);


--
-- Name: fac_cfds; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_cfds (
    id integer NOT NULL,
    rfc_cliente character varying,
    razon_social character varying,
    serie character varying,
    folio_del_comprobante_fiscal character varying,
    numero_de_aprobacion character varying,
    anoaprovacion character varying,
    monto_de_la_operacion double precision,
    monto_del_impuesto double precision,
    estado_del_comprobante character(1),
    nombre_archivo character varying,
    momento_expedicion character varying,
    tipo_comprobante character varying(15),
    proposito character varying(20),
    serie_folio character varying NOT NULL,
    conceptos text,
    impuestos_trasladados text,
    impuestos_retenidos text,
    efecto_de_comprobante character varying(1),
    addenda character varying,
    pedimento text,
    fecha_de_pedimento text,
    aduana text,
    descargado boolean DEFAULT false NOT NULL,
    pagado boolean DEFAULT false NOT NULL,
    momento_descarga timestamp with time zone,
    motivo_cancelacion text,
    momento_cancelacion timestamp with time zone,
    id_user_crea integer,
    id_user_cancela integer,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    id_aux integer,
    fac_docs_tipo_cancelacion_id integer,
    proceso_id integer,
    regimen_fiscal character varying DEFAULT ''::character varying,
    metodo_pago character varying DEFAULT ''::character varying,
    numero_cuenta character varying DEFAULT ''::character varying,
    lugar_expedicion character varying DEFAULT ''::character varying,
    gral_mon_id integer DEFAULT 1,
    tipo_de_cambio double precision DEFAULT 1
);


--
-- Name: TABLE fac_cfds; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.fac_cfds IS 'Tabla que alberga los datos requeridos de un Comprobantes Fiscal Digital Version 2.2 del SAT';


--
-- Name: erp_facturas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_facturas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_facturas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_facturas_id_seq OWNED BY public.fac_cfds.id;


--
-- Name: erp_h_facturas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_h_facturas (
    id integer NOT NULL,
    cliente_id integer NOT NULL,
    serie_folio character varying NOT NULL,
    monto_total double precision NOT NULL,
    moneda_id integer NOT NULL,
    tipo_cambio double precision NOT NULL,
    pagado boolean DEFAULT false NOT NULL,
    total_pagos double precision DEFAULT 0,
    total_pagos_cancelados double precision DEFAULT 0,
    saldo_factura double precision DEFAULT 0,
    total_notas_creditos double precision DEFAULT 0,
    total_saldoa_favor double precision DEFAULT 0,
    total_anticipos double precision DEFAULT 0,
    momento_facturacion timestamp with time zone,
    cancelacion boolean DEFAULT false NOT NULL,
    momento_cancelacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_cancelacion integer DEFAULT 0,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    cliente_id_aux integer,
    fac_docs_tipo_cancelacion_id integer,
    cxc_agen_id integer DEFAULT 0,
    fecha_vencimiento timestamp with time zone,
    estatus_revision smallint DEFAULT 0,
    orden_compra character varying DEFAULT ''::character varying,
    enviado boolean DEFAULT false,
    fecha_ultimo_pago date,
    subtotal double precision DEFAULT 0,
    impuesto double precision DEFAULT 0,
    retencion double precision DEFAULT 0,
    monto_ieps double precision DEFAULT 0
);


--
-- Name: COLUMN erp_h_facturas.estatus_revision; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_h_facturas.estatus_revision IS '0=Sin estatus, 1=Revision, 2=Cobro';


--
-- Name: COLUMN erp_h_facturas.enviado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_h_facturas.enviado IS 'Valor TRUE=Enviado a ruta para Revision o Cobro';


--
-- Name: COLUMN erp_h_facturas.fecha_ultimo_pago; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_h_facturas.fecha_ultimo_pago IS 'Esta es la fecha de deposito del ultimo pago';


--
-- Name: erp_h_facturas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_h_facturas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_h_facturas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_h_facturas_id_seq OWNED BY public.erp_h_facturas.id;


--
-- Name: erp_historico_traspasos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_historico_traspasos (
    id integer NOT NULL,
    folio character varying NOT NULL,
    tipo integer NOT NULL,
    almacen_id integer DEFAULT 0,
    observaciones text DEFAULT ''::text,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    prealmacen_entrada_id integer DEFAULT 0
);


--
-- Name: erp_historico_traspasos_detalles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_historico_traspasos_detalles (
    id integer NOT NULL,
    folio_traspaso character varying NOT NULL,
    numero_lote character varying NOT NULL,
    producto_id integer,
    presentacion_id integer,
    cantidad double precision NOT NULL,
    almacen_destino_id integer,
    ubicacion_fila character varying,
    ubicacion_columna character varying,
    ubicacion_anaquel character varying,
    disponible double precision,
    momento_creacion timestamp with time zone NOT NULL,
    historico_traspaso_id integer DEFAULT 0
);


--
-- Name: erp_historico_traspasos_detalles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_historico_traspasos_detalles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_historico_traspasos_detalles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_historico_traspasos_detalles_id_seq OWNED BY public.erp_historico_traspasos_detalles.id;


--
-- Name: erp_historico_traspasos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_historico_traspasos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_historico_traspasos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_historico_traspasos_id_seq OWNED BY public.erp_historico_traspasos.id;


--
-- Name: erp_ivatipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_ivatipos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    valor character varying,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    borrado_logico boolean DEFAULT false
);


--
-- Name: COLUMN erp_ivatipos.titulo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_ivatipos.titulo IS 'Nombre que recibira el tipo de iva';


--
-- Name: erp_listasprecios; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_listasprecios (
    id integer NOT NULL,
    titulo character varying,
    borrado_logico boolean NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_baja timestamp with time zone
);


--
-- Name: erp_listasprecios_detallada; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_listasprecios_detallada (
    id integer NOT NULL,
    listasprecios_id integer NOT NULL,
    precio double precision,
    codref character varying NOT NULL
);


--
-- Name: erp_mascaras_para_validaciones_por_app; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_mascaras_para_validaciones_por_app (
    app_id integer NOT NULL,
    mask_name character varying NOT NULL,
    mask_regex character varying,
    id integer NOT NULL
);


--
-- Name: erp_monedas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_monedas (
    id integer NOT NULL,
    descripcion character varying NOT NULL,
    descripcion_abr character varying DEFAULT ''::character varying,
    borrado_logico boolean DEFAULT false,
    simbolo character varying DEFAULT ''::character varying,
    iso_4217 character varying DEFAULT ''::character varying
);


--
-- Name: erp_monedavers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_monedavers (
    id integer NOT NULL,
    valor double precision NOT NULL,
    momento_creacion timestamp with time zone,
    moneda_id integer NOT NULL,
    version character varying NOT NULL
);


--
-- Name: TABLE erp_monedavers; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.erp_monedavers IS 'Tabla que alberga todos las versiones de un tipo de cambio especifico';


--
-- Name: COLUMN erp_monedavers.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_monedavers.id IS 'Indicador secuencial que identifica la fila, este  es autoincremental';


--
-- Name: COLUMN erp_monedavers.valor; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_monedavers.valor IS 'razon numerica que representa el valor que toma esta version de denominacion';


--
-- Name: COLUMN erp_monedavers.momento_creacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_monedavers.momento_creacion IS 'momento en el espacio tiempo, en que fue creada esta nueva version de denominacion';


--
-- Name: COLUMN erp_monedavers.moneda_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_monedavers.moneda_id IS 'Identificador que se√±ala a que denominacion pertenece esta version de denominacion';


--
-- Name: COLUMN erp_monedavers.version; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_monedavers.version IS 'cadena alfanumerica que representa la version del tipo de cambio generado';


--
-- Name: erp_notas_credito; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_notas_credito (
    id integer NOT NULL,
    serie_folio character varying,
    cliente_id integer,
    moneda_id integer,
    ivatipos_id integer,
    tipo_cambio double precision,
    monto_usd double precision,
    monto_pesos double precision,
    observaciones text,
    motivo_cancelacion text,
    cancelado boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_cancelacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    borrado_logico boolean DEFAULT false,
    sucursal_id integer DEFAULT 0,
    fac_cfd_id integer,
    empresa_id integer DEFAULT 0
);


--
-- Name: erp_notas_credito_detalles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_notas_credito_detalles (
    id integer NOT NULL,
    nota_credito_id integer,
    producto_id integer,
    presentacion_id integer,
    cantidad double precision DEFAULT 0,
    precio_unitario double precision DEFAULT 0,
    importe_mn double precision DEFAULT 0,
    importe_usd double precision DEFAULT 0,
    momento_creacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_cancelacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    borrado_logico boolean DEFAULT false,
    sucursal_id integer DEFAULT 0
);


--
-- Name: erp_notas_credito_detalles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_notas_credito_detalles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_notas_credito_detalles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_notas_credito_detalles_id_seq OWNED BY public.erp_notas_credito_detalles.id;


--
-- Name: erp_notas_credito_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_notas_credito_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_notas_credito_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_notas_credito_id_seq OWNED BY public.erp_notas_credito.id;


--
-- Name: erp_ordencompras; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_ordencompras (
    id integer NOT NULL,
    numpedido character varying NOT NULL,
    descripcion_pedido text,
    total double precision NOT NULL,
    moneda_id integer NOT NULL,
    estatus_oc_id integer NOT NULL,
    fecha_expira timestamp with time zone NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    borrado_logico boolean DEFAULT false NOT NULL,
    proveedor_id integer DEFAULT 1 NOT NULL
);


--
-- Name: erp_pagos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_pagos (
    id integer NOT NULL,
    numero_transaccion bigint,
    forma_pago_id integer DEFAULT 0,
    numero_cheque character varying DEFAULT ''::character varying,
    referencia character varying DEFAULT ''::character varying,
    numero_tarjeta character varying DEFAULT ''::character varying,
    monto_pago double precision,
    tipo_cambio double precision,
    cliente_id integer DEFAULT 0,
    moneda_id integer DEFAULT 0,
    banco_id integer DEFAULT 0,
    numerocuenta_id integer DEFAULT 0,
    movimiento character varying DEFAULT ''::character varying,
    bancokemikal_id integer DEFAULT 0,
    fecha_deposito timestamp with time zone,
    observaciones text DEFAULT ''::text,
    momento_creacion timestamp with time zone,
    id_usuario_pago integer DEFAULT 0,
    anticipo_id integer DEFAULT 0,
    aux_no_fac character varying,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    id_aux integer,
    cliente_id_aux integer,
    numero_cuenta_id_aux integer,
    banco_empresa_id_aux integer
);


--
-- Name: erp_pagos_cancelacion_detalles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_pagos_cancelacion_detalles (
    id integer NOT NULL,
    pagos_detalles_id integer NOT NULL,
    momento_creacion_usuario timestamp with time zone,
    observaciones text,
    id_usuario_creacion integer,
    momento_creacion timestamp with time zone,
    numero_transaccion bigint
);


--
-- Name: erp_pagos_cancelacion_detalles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_pagos_cancelacion_detalles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_pagos_cancelacion_detalles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_pagos_cancelacion_detalles_id_seq OWNED BY public.erp_pagos_cancelacion_detalles.id;


--
-- Name: erp_pagos_detalles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_pagos_detalles (
    id integer NOT NULL,
    pago_id integer DEFAULT 0 NOT NULL,
    serie_folio character varying,
    cantidad double precision,
    momento_pago timestamp with time zone,
    cancelacion boolean DEFAULT false NOT NULL,
    momento_cancelacion timestamp with time zone,
    aux_no_fac character varying,
    pago_id_aux integer,
    fac_moneda_id integer DEFAULT 0
);


--
-- Name: erp_pagos_detalles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_pagos_detalles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_pagos_detalles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_pagos_detalles_id_seq OWNED BY public.erp_pagos_detalles.id;


--
-- Name: erp_pagos_formas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_pagos_formas (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean,
    clave_sat character varying
);


--
-- Name: erp_pagos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_pagos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_pagos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_pagos_id_seq OWNED BY public.erp_pagos.id;


--
-- Name: erp_pagos_tipo_movimiento; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_pagos_tipo_movimiento (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean
);


--
-- Name: erp_pagosxaplicar; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_pagosxaplicar (
    id integer NOT NULL,
    cliente_id integer DEFAULT 0,
    monto_inicial double precision NOT NULL,
    monto_actual double precision NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    moneda_id integer DEFAULT 0
);


--
-- Name: erp_pagosxaplicar_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_pagosxaplicar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_pagosxaplicar_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_pagosxaplicar_id_seq OWNED BY public.erp_pagosxaplicar.id;


--
-- Name: erp_parametros_generales; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_parametros_generales (
    id integer NOT NULL,
    variable character varying NOT NULL,
    valor text NOT NULL,
    empresa_id integer NOT NULL
);


--
-- Name: erp_prealmacen_entradas_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_prealmacen_entradas_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_prealmacen_entradas_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_prealmacen_entradas_detalle_id_seq OWNED BY public.com_fac_detalle.id;


--
-- Name: erp_prealmacen_entradas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_prealmacen_entradas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_prealmacen_entradas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_prealmacen_entradas_id_seq OWNED BY public.com_fac.id;


--
-- Name: erp_prefacturas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_prefacturas (
    id integer NOT NULL,
    cliente_id integer NOT NULL,
    moneda_id integer,
    observaciones text,
    subtotal double precision,
    impuesto double precision,
    total double precision,
    proceso_id integer NOT NULL,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    tipo_cambio double precision DEFAULT 0,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    empleado_id integer DEFAULT 0,
    terminos_id integer DEFAULT 0,
    orden_compra character varying DEFAULT ''::character varying,
    factura_sai character varying DEFAULT ''::character varying,
    factura_id integer,
    id_aux integer,
    cliente_id_aux integer,
    proceso_id_aux integer,
    factura_id_aux integer,
    refacturar boolean DEFAULT false,
    fac_metodos_pago_id integer DEFAULT 0,
    no_cuenta character varying DEFAULT ''::character varying,
    tasa_retencion_immex double precision DEFAULT 0,
    monto_retencion double precision DEFAULT 0,
    tipo_documento smallint DEFAULT 0,
    folio_pedido character varying DEFAULT ''::character varying,
    enviar_ruta boolean DEFAULT false,
    inv_alm_id smallint DEFAULT 0,
    id_moneda_pedido integer DEFAULT 0,
    cxc_clie_df_id integer DEFAULT 0,
    fac_subtotal double precision DEFAULT 0 NOT NULL,
    fac_impuesto double precision DEFAULT 0 NOT NULL,
    fac_monto_retencion double precision DEFAULT 0 NOT NULL,
    fac_total double precision DEFAULT 0 NOT NULL,
    monto_ieps double precision DEFAULT 0,
    fac_monto_ieps double precision DEFAULT 0,
    monto_descto double precision DEFAULT 0 NOT NULL,
    fac_monto_descto double precision DEFAULT 0 NOT NULL,
    motivo_descto character varying DEFAULT ''::character varying,
    ctb_tmov_id integer DEFAULT 0 NOT NULL,
    cfdi_usos_id integer,
    cfdi_metodo_id integer
);


--
-- Name: COLUMN erp_prefacturas.tipo_documento; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.tipo_documento IS '1=Factura, 2=Remision, 3=Factura de Remision';


--
-- Name: COLUMN erp_prefacturas.enviar_ruta; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.enviar_ruta IS 'True=Debe aparecer en la busqueda de facturas para agregar a la ruta. False=No debe aparecer en la busqueda.';


--
-- Name: COLUMN erp_prefacturas.inv_alm_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.inv_alm_id IS 'Almacen de donde se le dara salida los productos al facturar';


--
-- Name: COLUMN erp_prefacturas.id_moneda_pedido; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.id_moneda_pedido IS 'Moneda original con el que se hizo el pedido, puede ser diferente a la moneda de la factura';


--
-- Name: COLUMN erp_prefacturas.cxc_clie_df_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.cxc_clie_df_id IS 'ID de la Direccion Fiscal(cxc_clie_df) para la Facturacion. Si el valor de este campo es 0, entonces por default toma la direccion de la tabla de Clientes (cxc_clie)';


--
-- Name: COLUMN erp_prefacturas.fac_subtotal; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.fac_subtotal IS 'Subtotal a Facturar o Remisionar, una vez finalizado en proceso este campo se queda en cero.';


--
-- Name: COLUMN erp_prefacturas.fac_impuesto; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.fac_impuesto IS 'Impuesto de la Factura o Remision, una vez finalizado en proceso este campo se queda en cero.';


--
-- Name: COLUMN erp_prefacturas.fac_monto_retencion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.fac_monto_retencion IS 'Monto de la retencion de la Factura o Remision, una vez finalizado en proceso este campo se queda en cero.';


--
-- Name: COLUMN erp_prefacturas.fac_total; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.fac_total IS 'Total de la Factura o Remision, una vez finalizado en proceso este campo se queda en cero.';


--
-- Name: COLUMN erp_prefacturas.cfdi_usos_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas.cfdi_usos_id IS '
';


--
-- Name: erp_prefacturas_detalles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_prefacturas_detalles (
    id integer NOT NULL,
    prefacturas_id integer NOT NULL,
    producto_id integer NOT NULL,
    presentacion_id integer NOT NULL,
    tipo_impuesto_id integer DEFAULT 0 NOT NULL,
    cantidad double precision DEFAULT 0 NOT NULL,
    precio_unitario double precision NOT NULL,
    momento_creacion timestamp with time zone,
    id_prefactura_aux integer,
    producto_id_aux integer,
    valor_imp double precision DEFAULT 0,
    costo_promedio double precision DEFAULT 0,
    reservado double precision DEFAULT 0,
    costo_referencia double precision DEFAULT 0,
    cant_facturado double precision DEFAULT 0 NOT NULL,
    facturado boolean DEFAULT false NOT NULL,
    cant_facturar double precision DEFAULT 0 NOT NULL,
    inv_prod_unidad_id integer DEFAULT 0 NOT NULL,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0,
    descto double precision DEFAULT 0,
    fac_rem_det_id integer DEFAULT 0,
    gral_imptos_ret_id integer DEFAULT 0 NOT NULL,
    tasa_ret double precision DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN erp_prefacturas_detalles.costo_promedio; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas_detalles.costo_promedio IS 'El costo promedio solo se guarda en esta tabla cuando la prefactura viene de una o varias Remisiones.';


--
-- Name: COLUMN erp_prefacturas_detalles.reservado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas_detalles.reservado IS 'Cantidad que se reservo en inv_exi al crear el pedido';


--
-- Name: COLUMN erp_prefacturas_detalles.costo_referencia; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas_detalles.costo_referencia IS 'El costo referencia solo se guarda en esta tabla cuando la prefactura viene de una o varias Remisiones.';


--
-- Name: COLUMN erp_prefacturas_detalles.cant_facturado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas_detalles.cant_facturado IS 'Cantidad que se ha facturado de esta partida';


--
-- Name: COLUMN erp_prefacturas_detalles.facturado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas_detalles.facturado IS 'Este campo indica cuando la partida ha sido facturado totalmente. TRUE=La partida esta facturada completamente, FALSE=La partida no se ha facturado en su totalidad.';


--
-- Name: COLUMN erp_prefacturas_detalles.cant_facturar; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas_detalles.cant_facturar IS 'Cantidad a Facturar o Remisionar, una vez realizado el proceso, este campo debe quedar en cero.';


--
-- Name: COLUMN erp_prefacturas_detalles.inv_prod_unidad_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_prefacturas_detalles.inv_prod_unidad_id IS 'Id de la unidad de medida de venta, puede ser diferente a la unidad de medida en el catalogo de productos.';


--
-- Name: erp_prefacturas_detalles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_prefacturas_detalles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_prefacturas_detalles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_prefacturas_detalles_id_seq OWNED BY public.erp_prefacturas_detalles.id;


--
-- Name: erp_prefacturas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_prefacturas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_prefacturas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_prefacturas_id_seq OWNED BY public.erp_prefacturas.id;


--
-- Name: erp_proceso; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_proceso (
    id integer NOT NULL,
    proceso_flujo_id integer NOT NULL,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    id_aux integer
);


--
-- Name: erp_proceso_flujo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_proceso_flujo (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: erp_proceso_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_proceso_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_proceso_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_proceso_id_seq OWNED BY public.erp_proceso.id;


--
-- Name: erp_proveedorcontactos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_proveedorcontactos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_proveedorcontactos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_proveedorcontactos_id_seq OWNED BY public.cxp_prov_contactos.id;


--
-- Name: erp_proveedoreswebusers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_proveedoreswebusers (
    email_login character varying NOT NULL,
    id integer NOT NULL,
    login_password character varying NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_creacion timestamp with time zone,
    momento_baja timestamp with time zone,
    pais character varying NOT NULL,
    entidad character varying NOT NULL,
    localidad character varying NOT NULL,
    localidad_alternativa character varying,
    departamento character varying,
    ubicacion character varying,
    nombre_pila character varying NOT NULL,
    apellido_paterno character varying NOT NULL,
    apellido_materno character varying NOT NULL,
    borrado_logico boolean,
    proveedor_id integer NOT NULL
);


--
-- Name: erp_proveedors_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_proveedors_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_proveedors_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_proveedors_id_seq OWNED BY public.cxp_prov2.id;


--
-- Name: erp_religions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_religions (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: TABLE erp_religions; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.erp_religions IS 'Tabla de contiene las religiones que puede tener una persona';


--
-- Name: COLUMN erp_religions.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_religions.id IS 'Indicador secuencial que identifica la fila, este  es autoincremental';


--
-- Name: erp_sangretipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_sangretipos (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: TABLE erp_sangretipos; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.erp_sangretipos IS 'Tabla de contiene los tipos de sangre que puede tener una persona';


--
-- Name: COLUMN erp_sangretipos.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.erp_sangretipos.id IS 'Indicador secuencial que identifica la fila, este  es autoincremental';


--
-- Name: erp_terminos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_terminos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_terminos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_terminos_id_seq OWNED BY public.cxc_clie_credias.id;


--
-- Name: erp_tiempos_entrega; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_tiempos_entrega (
    id integer NOT NULL,
    descripcion character varying NOT NULL
);


--
-- Name: erp_tiempos_entrega_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_tiempos_entrega_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_tiempos_entrega_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_tiempos_entrega_id_seq OWNED BY public.erp_tiempos_entrega.id;


--
-- Name: erp_tipos_de_producto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_tipos_de_producto (
    id integer NOT NULL,
    titulo character varying NOT NULL
);


--
-- Name: erp_tipos_de_traspaso; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.erp_tipos_de_traspaso (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying,
    descripcion character varying DEFAULT ''::character varying,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone
);


--
-- Name: erp_users_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.erp_users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: erp_users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.erp_users_id_seq OWNED BY public.gral_usr.id;


--
-- Name: estatus_ordencompra_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.estatus_ordencompra_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: estatus_ordencompra_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.estatus_ordencompra_id_seq OWNED BY public.erp_estatus_ordencompra.id;


--
-- Name: fac_cfdis; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_cfdis (
    id integer NOT NULL,
    tipo integer DEFAULT 0 NOT NULL,
    ref_id character varying DEFAULT ''::character varying NOT NULL,
    doc text,
    gral_emp_id integer DEFAULT 0 NOT NULL,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    fecha_crea timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0 NOT NULL,
    cancelado boolean DEFAULT false NOT NULL,
    fecha_cancela timestamp with time zone,
    gral_usr_id_cancela integer DEFAULT 0,
    CONSTRAINT chk_fac_cfdis_tipo CHECK ((tipo = ANY (ARRAY[1, 2, 3])))
);


--
-- Name: COLUMN fac_cfdis.tipo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfdis.tipo IS '1=Factura, 2=Nota de Credito, 3=Nomina CFDI';


--
-- Name: fac_cfdis_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_cfdis_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_cfdis_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_cfdis_id_seq OWNED BY public.fac_cfdis.id;


--
-- Name: fac_cfds_conf; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_cfds_conf (
    id integer NOT NULL,
    empresa_id integer NOT NULL,
    archivo_certificado character varying,
    numero_certificado character varying,
    archivo_llave character varying,
    password_llave character varying,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    archivo_xsl character varying DEFAULT ''::character varying,
    archivo_xsd_cfdi character varying DEFAULT ''::character varying,
    archivo_wsdl_timbrado_cfdi character varying DEFAULT ''::character varying,
    ws_pfx_cert character varying DEFAULT ''::character varying,
    passwd_ws_pfx character varying DEFAULT ''::character varying,
    javavm_dir character varying DEFAULT ''::character varying,
    archivo_xsl_cadena_timbre character varying DEFAULT ''::character varying,
    javavm_cacerts character varying DEFAULT ''::character varying,
    usuario character varying DEFAULT ''::character varying,
    contrasena character varying DEFAULT ''::character varying,
    archivo_xsl_cadena_ctas_contables character varying DEFAULT ''::character varying,
    archivo_xsd_ctas_contables character varying DEFAULT ''::character varying
);


--
-- Name: COLUMN fac_cfds_conf.archivo_certificado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.archivo_certificado IS 'Archivo de la llave p√∫blica del CSD que deber√° estar incluida en el archivo CFD y CFDI con Timbre Fiscal en el atributo "certificado" y codificada en base64. No aplica para CFDI con Conector Fiscal.';


--
-- Name: COLUMN fac_cfds_conf.numero_certificado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.numero_certificado IS 'Informaci√≥n del n√∫mero de certificado que se est√° utilizando para el firmado del comprobante CFD y  CFDI con Timbre Fiscal. No aplica para CFDI con Conector Fiscal.';


--
-- Name: COLUMN fac_cfds_conf.archivo_llave; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.archivo_llave IS 'Archivo de la llave privada del CSD que se utiliza para el firmado de la cadena original del CFD y  CFDI con Timbre Fiscal. No aplica para CFDI con Conector Fiscal.';


--
-- Name: COLUMN fac_cfds_conf.password_llave; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.password_llave IS 'Contrase√±a de la llave privada del CSD para el firmado de la cadena original del CFD y  CFDI con Timbre Fiscal. No aplica para CFDI con Conector Fiscal.';


--
-- Name: COLUMN fac_cfds_conf.archivo_xsl; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.archivo_xsl IS 'Hoja de estilos para el armado correcto de la cadena original del CFD y  CFDI con Timbre Fiscal. No aplica para CFDI con Conector Fiscal.';


--
-- Name: COLUMN fac_cfds_conf.archivo_xsd_cfdi; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.archivo_xsd_cfdi IS 'Archivo de esquema del CFDi 3.2. El esquema es para CFDI con Timbre Fiscal.';


--
-- Name: COLUMN fac_cfds_conf.archivo_wsdl_timbrado_cfdi; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.archivo_wsdl_timbrado_cfdi IS 'Archivo WSDL, contiene la definici√≥n del servicio web que deber√° invocar el desarrollo y as√≠ utilizar el servicio de timbre fiscal. Solo para facturacion con Timbre Fiscal.';


--
-- Name: COLUMN fac_cfds_conf.archivo_xsl_cadena_timbre; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.archivo_xsl_cadena_timbre IS 'Fichero xslt para obtener la cadena original del Complemento del Timbre Fiscal del CFDI';


--
-- Name: COLUMN fac_cfds_conf.usuario; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.usuario IS 'Nombre de Usuario para conexion a WS ServiSim';


--
-- Name: COLUMN fac_cfds_conf.contrasena; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.contrasena IS 'Contrase√±a de Usuario para conexion a WS ServiSim';


--
-- Name: COLUMN fac_cfds_conf.archivo_xsl_cadena_ctas_contables; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.archivo_xsl_cadena_ctas_contables IS 'Fichero xslt para obtener la cadena original del Xml de Cuentas COntables';


--
-- Name: COLUMN fac_cfds_conf.archivo_xsd_ctas_contables; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_cfds_conf.archivo_xsd_ctas_contables IS 'Fichero xsd para validar el Xml de Cuentas Contables';


--
-- Name: fac_cfds_conf_folios; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_cfds_conf_folios (
    id integer NOT NULL,
    no_aprobacion integer,
    ano_aprobacion smallint,
    serie character varying,
    folio_inicial integer,
    folio_final integer,
    fac_cfds_conf_id integer,
    proposito character(3),
    folio_actual integer
);


--
-- Name: fac_cfds_folios_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_cfds_folios_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_cfds_folios_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_cfds_folios_id_seq OWNED BY public.fac_cfds_conf_folios.id;


--
-- Name: fac_docs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_docs (
    id integer NOT NULL,
    cxc_clie_id integer NOT NULL,
    moneda_id integer,
    subtotal double precision,
    impuesto double precision,
    total double precision,
    tipo_cambio double precision DEFAULT 0,
    fac_cfd_id integer DEFAULT 0,
    proceso_id integer NOT NULL,
    cxc_agen_id integer DEFAULT 0,
    terminos_id integer DEFAULT 0,
    orden_compra character varying DEFAULT ''::character varying,
    observaciones text,
    cancelado boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_cancelacion integer DEFAULT 0,
    serie_folio character varying,
    motivo_cancelacion text DEFAULT ''::text,
    fac_docs_tipo_cancelacion_id integer,
    fac_metodos_pago_id integer DEFAULT 0,
    no_cuenta character varying DEFAULT ''::character varying,
    monto_retencion double precision DEFAULT 0,
    tasa_retencion_immex double precision DEFAULT 0,
    folio_pedido character varying DEFAULT ''::character varying,
    fecha_vencimiento timestamp with time zone,
    enviar_ruta boolean DEFAULT false,
    inv_alm_id smallint DEFAULT 0,
    cxc_clie_df_id integer DEFAULT 0,
    monto_ieps double precision DEFAULT 0,
    ref_id character varying DEFAULT ''::character varying NOT NULL,
    monto_descto double precision DEFAULT 0 NOT NULL,
    motivo_descto character varying DEFAULT ''::character varying,
    subtotal_sin_descto double precision DEFAULT 0,
    ctb_tmov_id integer DEFAULT 0 NOT NULL,
    procesado boolean DEFAULT false NOT NULL,
    ctb_tmov_id_cancelacion integer DEFAULT 0 NOT NULL,
    procesado_cancelacion boolean DEFAULT false NOT NULL,
    fecha_procesa_cancelacion timestamp with time zone,
    gral_usr_id_procesa_cancelacion integer DEFAULT 0 NOT NULL,
    fecha_procesa timestamp with time zone,
    gral_usr_id_procesa integer DEFAULT 0 NOT NULL
);


--
-- Name: TABLE fac_docs; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.fac_docs IS 'Tabla que alberga los encabezados de las Facturas';


--
-- Name: COLUMN fac_docs.enviar_ruta; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_docs.enviar_ruta IS 'True=Debe aparecer en la busqueda de facturas para agregar a la ruta. False=No debe aparecer en la busqueda.';


--
-- Name: COLUMN fac_docs.inv_alm_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_docs.inv_alm_id IS 'Almacen de donde se di√≥ salida los productos Facturados';


--
-- Name: COLUMN fac_docs.cxc_clie_df_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_docs.cxc_clie_df_id IS 'ID de la Direccion Fiscal(cxc_clie_df) para la Facturacion. Si el valor de este campo es 0, entonces por default toma la direccion de la tabla de Clientes (cxc_clie)';


--
-- Name: COLUMN fac_docs.procesado_cancelacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_docs.procesado_cancelacion IS 'TRUE=Se ha incluido en una Poliza Contable.';


--
-- Name: fac_docs_adenda; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_docs_adenda (
    id integer NOT NULL,
    prefactura_id integer NOT NULL,
    fac_docs_id integer DEFAULT 0 NOT NULL,
    cxc_clie_adenda_tipo_id integer NOT NULL,
    valor1 character varying DEFAULT ''::character varying,
    valor2 character varying DEFAULT ''::character varying,
    valor3 character varying DEFAULT ''::character varying,
    valor4 character varying DEFAULT ''::character varying,
    valor5 character varying DEFAULT ''::character varying,
    valor6 character varying DEFAULT ''::character varying,
    valor7 character varying DEFAULT ''::character varying,
    valor8 character varying DEFAULT ''::character varying,
    generado boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE fac_docs_adenda; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.fac_docs_adenda IS 'Tipo Adenda=1(valor1=NoEntrada, valor2=NoRemision, valor3=Consignacion, valor4=CentroCostos, valor5=FechaInicio, valor6=FechaFin, valor7=Orden Compra, valor8=Moneda)';


--
-- Name: COLUMN fac_docs_adenda.generado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_docs_adenda.generado IS 'TRUE=Indica que ya se agrego al xml de la factura';


--
-- Name: fac_docs_adenda_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_docs_adenda_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_docs_adenda_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_docs_adenda_id_seq OWNED BY public.fac_docs_adenda.id;


--
-- Name: fac_docs_detalles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_docs_detalles (
    id integer NOT NULL,
    fac_doc_id integer,
    inv_prod_id integer NOT NULL,
    inv_prod_presentacion_id integer NOT NULL,
    gral_imptos_id integer DEFAULT 0,
    cantidad double precision,
    precio_unitario double precision,
    momento_creacion timestamp with time zone,
    valor_imp double precision DEFAULT 0,
    enviado boolean DEFAULT false,
    cantidad_devolucion double precision DEFAULT 0,
    costo_promedio double precision DEFAULT 0,
    costo_referencia double precision DEFAULT 0,
    inv_prod_unidad_id integer DEFAULT 0 NOT NULL,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0,
    descto double precision DEFAULT 0,
    gral_imptos_ret_id integer DEFAULT 0 NOT NULL,
    tasa_ret double precision DEFAULT 0 NOT NULL
);


--
-- Name: TABLE fac_docs_detalles; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.fac_docs_detalles IS 'Tabla que alberga los detalles de una Factura;
Que productos lleva una factura, en que cantidad y precios ';


--
-- Name: COLUMN fac_docs_detalles.enviado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_docs_detalles.enviado IS 'Valor TRUE=Enviado a ruta para Entrega';


--
-- Name: COLUMN fac_docs_detalles.inv_prod_unidad_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_docs_detalles.inv_prod_unidad_id IS 'Id de la unidad de medida de venta, puede ser diferente a la unidad de medida en el catalogo de productos.';


--
-- Name: fac_docs_detalles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_docs_detalles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_docs_detalles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_docs_detalles_id_seq OWNED BY public.fac_docs_detalles.id;


--
-- Name: fac_docs_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_docs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_docs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_docs_id_seq OWNED BY public.fac_docs.id;


--
-- Name: fac_docs_tipos_cancelacion; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_docs_tipos_cancelacion (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false
);


--
-- Name: fac_docs_tipos_cancelacion_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_docs_tipos_cancelacion_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_docs_tipos_cancelacion_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_docs_tipos_cancelacion_id_seq OWNED BY public.fac_docs_tipos_cancelacion.id;


--
-- Name: fac_metodos_pago; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_metodos_pago (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false,
    clave_sat character varying DEFAULT ''::character varying NOT NULL,
    momento_creacion timestamp with time zone DEFAULT now() NOT NULL,
    momento_actualiza timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0
);


--
-- Name: fac_metodos_pago_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_metodos_pago_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_metodos_pago_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_metodos_pago_id_seq OWNED BY public.fac_metodos_pago.id;


--
-- Name: fac_namespaces; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_namespaces (
    id integer NOT NULL,
    key_xmlns character varying DEFAULT ''::character varying,
    xmlns character varying DEFAULT ''::character varying,
    schemalocation character varying DEFAULT ''::character varying,
    fac boolean DEFAULT false NOT NULL,
    fac_nomina boolean DEFAULT false NOT NULL,
    derogado boolean DEFAULT false NOT NULL,
    fecha_derogacion date
);


--
-- Name: fac_namespaces_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_namespaces_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_namespaces_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_namespaces_id_seq OWNED BY public.fac_namespaces.id;


--
-- Name: fac_nomina; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_nomina (
    id integer NOT NULL,
    tipo_comprobante character varying DEFAULT ''::character varying,
    forma_pago character varying DEFAULT ''::character varying,
    tipo_cambio double precision DEFAULT 0,
    no_cuenta character varying DEFAULT ''::character varying,
    fecha_pago date,
    fac_metodos_pago_id integer DEFAULT 0,
    gral_mon_id integer DEFAULT 0,
    nom_periodicidad_pago_id integer DEFAULT 0,
    nom_periodos_conf_det_id integer DEFAULT 0,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    status integer DEFAULT 0 NOT NULL,
    CONSTRAINT chk_fac_nomina_status CHECK ((status = ANY (ARRAY[0, 1, 2])))
);


--
-- Name: COLUMN fac_nomina.status; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_nomina.status IS '0=No se ha generado CFDI de ningun registro, 1=Se ha generado CFDI de por lo menos un registro, 2=Se han generado CFDI de todos los registros';


--
-- Name: fac_nomina_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_nomina_det (
    id integer NOT NULL,
    fac_nomina_id integer DEFAULT 0 NOT NULL,
    gral_empleado_id integer DEFAULT 0 NOT NULL,
    no_empleado character varying DEFAULT ''::character varying,
    rfc character varying DEFAULT ''::character varying,
    nombre character varying DEFAULT ''::character varying,
    curp character varying DEFAULT ''::character varying,
    gral_depto_id integer DEFAULT 0,
    gral_puesto_id integer DEFAULT 0,
    fecha_contrato date,
    antiguedad integer DEFAULT 0,
    nom_regimen_contratacion_id integer DEFAULT 0,
    nom_tipo_contrato_id integer DEFAULT 0,
    nom_tipo_jornada_id integer DEFAULT 0,
    nom_periodicidad_pago_id integer DEFAULT 0,
    clabe character varying DEFAULT ''::character varying,
    tes_ban_id integer DEFAULT 0,
    nom_riesgo_puesto_id integer DEFAULT 0,
    imss character varying DEFAULT ''::character varying,
    reg_patronal character varying DEFAULT ''::character varying,
    salario_base double precision DEFAULT 0,
    salario_integrado double precision DEFAULT 0,
    fecha_ini_pago date,
    fecha_fin_pago date,
    no_dias_pago integer DEFAULT 0,
    concepto_descripcion character varying DEFAULT ''::character varying,
    concepto_unidad character varying DEFAULT ''::character varying,
    concepto_cantidad double precision DEFAULT 0,
    concepto_valor_unitario double precision DEFAULT 0,
    concepto_importe double precision DEFAULT 0,
    descuento double precision DEFAULT 0,
    motivo_descuento character varying DEFAULT ''::character varying,
    gral_isr_id integer DEFAULT 0,
    importe_retencion double precision DEFAULT 0,
    comp_subtotal double precision DEFAULT 0,
    comp_descuento double precision DEFAULT 0,
    comp_retencion double precision DEFAULT 0,
    comp_total double precision DEFAULT 0,
    percep_total_gravado double precision DEFAULT 0,
    percep_total_excento double precision DEFAULT 0,
    deduc_total_gravado double precision DEFAULT 0,
    deduc_total_excento double precision DEFAULT 0,
    facturado boolean DEFAULT false NOT NULL,
    momento_facturacion timestamp with time zone,
    gral_usr_id_facturacion integer,
    validado boolean DEFAULT false NOT NULL,
    serie character varying DEFAULT ''::character varying NOT NULL,
    folio character varying DEFAULT ''::character varying NOT NULL,
    ref_id character varying DEFAULT ''::character varying NOT NULL,
    cancelado boolean DEFAULT false NOT NULL,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_cancela integer DEFAULT 0
);


--
-- Name: fac_nomina_det_deduc; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_nomina_det_deduc (
    id integer NOT NULL,
    fac_nomina_det_id integer NOT NULL,
    nom_deduc_id integer NOT NULL,
    gravado double precision,
    excento double precision
);


--
-- Name: fac_nomina_det_deduc_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_nomina_det_deduc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_nomina_det_deduc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_nomina_det_deduc_id_seq OWNED BY public.fac_nomina_det_deduc.id;


--
-- Name: fac_nomina_det_hrs_extra; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_nomina_det_hrs_extra (
    id integer NOT NULL,
    fac_nomina_det_id integer NOT NULL,
    nom_tipo_hrs_extra_id integer NOT NULL,
    no_dias double precision,
    no_hrs double precision,
    importe double precision
);


--
-- Name: fac_nomina_det_hrs_extra_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_nomina_det_hrs_extra_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_nomina_det_hrs_extra_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_nomina_det_hrs_extra_id_seq OWNED BY public.fac_nomina_det_hrs_extra.id;


--
-- Name: fac_nomina_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_nomina_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_nomina_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_nomina_det_id_seq OWNED BY public.fac_nomina_det.id;


--
-- Name: fac_nomina_det_incapa; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_nomina_det_incapa (
    id integer NOT NULL,
    fac_nomina_det_id integer NOT NULL,
    nom_tipo_incapacidad_id integer NOT NULL,
    no_dias double precision,
    importe double precision
);


--
-- Name: fac_nomina_det_incapa_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_nomina_det_incapa_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_nomina_det_incapa_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_nomina_det_incapa_id_seq OWNED BY public.fac_nomina_det_incapa.id;


--
-- Name: fac_nomina_det_percep; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_nomina_det_percep (
    id integer NOT NULL,
    fac_nomina_det_id integer NOT NULL,
    nom_percep_id integer NOT NULL,
    gravado double precision,
    excento double precision
);


--
-- Name: fac_nomina_det_percep_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_nomina_det_percep_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_nomina_det_percep_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_nomina_det_percep_id_seq OWNED BY public.fac_nomina_det_percep.id;


--
-- Name: fac_nomina_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_nomina_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_nomina_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_nomina_id_seq OWNED BY public.fac_nomina.id;


--
-- Name: fac_nomina_par; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_nomina_par (
    id integer NOT NULL,
    gral_emp_id integer NOT NULL,
    gral_suc_id integer NOT NULL,
    tipo_comprobante character varying DEFAULT ''::character varying,
    forma_pago character varying DEFAULT ''::character varying,
    no_cuenta_pago character varying DEFAULT ''::character varying,
    gral_mon_id integer DEFAULT 1 NOT NULL,
    gral_isr_id integer DEFAULT 0 NOT NULL,
    motivo_descuento character varying DEFAULT ''::character varying,
    concepto_unidad character varying DEFAULT ''::character varying,
    leyenda character varying DEFAULT ''::character varying
);


--
-- Name: COLUMN fac_nomina_par.gral_mon_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_nomina_par.gral_mon_id IS 'Moneda para la Nomina';


--
-- Name: COLUMN fac_nomina_par.concepto_unidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_nomina_par.concepto_unidad IS 'Unidad que se debe mostrar por default para el concepto';


--
-- Name: fac_nomina_par_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_nomina_par_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_nomina_par_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_nomina_par_id_seq OWNED BY public.fac_nomina_par.id;


--
-- Name: fac_nota_credito; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_nota_credito (
    id integer NOT NULL,
    serie_folio character varying DEFAULT ''::character varying,
    cxc_clie_id integer NOT NULL,
    cxc_agen_id integer DEFAULT 0,
    moneda_id integer,
    subtotal double precision DEFAULT 0,
    impuesto double precision DEFAULT 0,
    monto_retencion double precision DEFAULT 0,
    total double precision DEFAULT 0,
    valor_impuesto double precision DEFAULT 0,
    tasa_retencion_immex double precision DEFAULT 0,
    tipo_cambio double precision DEFAULT 0,
    concepto text DEFAULT ''::text,
    observaciones text DEFAULT ''::text,
    serie_folio_factura character varying DEFAULT ''::character varying,
    cancelado boolean DEFAULT false,
    motivo_cancelacion text DEFAULT ''::text,
    momento_creacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_cancelacion integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    momento_expedicion timestamp with time zone,
    gral_usr_id_expedicion integer DEFAULT 0,
    gral_app_id_creacion integer DEFAULT 0,
    cxc_clie_df_id integer DEFAULT 0,
    monto_ieps double precision DEFAULT 0,
    ref_id character varying DEFAULT ''::character varying NOT NULL,
    ctb_tmov_id integer DEFAULT 0 NOT NULL,
    procesado boolean DEFAULT false NOT NULL,
    fecha_procesa timestamp with time zone,
    gral_usr_id_procesa integer DEFAULT 0 NOT NULL,
    ctb_tmov_id_cancelacion integer DEFAULT 0 NOT NULL,
    procesado_cancelacion boolean DEFAULT false NOT NULL,
    fecha_procesa_cancelacion timestamp with time zone,
    gral_usr_id_procesa_cancelacion integer DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN fac_nota_credito.gral_app_id_creacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_nota_credito.gral_app_id_creacion IS 'ID del aplicativo desde donde se genero la Nota de Credito, 70=Aplicativo Notas de Credito: 76=Aplicativo Devolucion de Mercancia';


--
-- Name: COLUMN fac_nota_credito.procesado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_nota_credito.procesado IS 'TRUE=Se ha incluido en una Poliza Contable.';


--
-- Name: COLUMN fac_nota_credito.procesado_cancelacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_nota_credito.procesado_cancelacion IS 'TRUE=Se ha incluido en una Poliza Contable.';


--
-- Name: fac_nota_credito_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_nota_credito_det (
    id integer NOT NULL,
    fac_nota_credito_id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    inv_prod_presentacion_id integer DEFAULT 0 NOT NULL,
    cantidad double precision DEFAULT 0 NOT NULL,
    precio_unitario double precision DEFAULT 0 NOT NULL,
    gral_imptos_id integer DEFAULT 0,
    valor_imp double precision DEFAULT 0,
    cant_fac double precision DEFAULT 0,
    inv_prod_unidad_id integer DEFAULT 0 NOT NULL,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0
);


--
-- Name: COLUMN fac_nota_credito_det.inv_prod_unidad_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_nota_credito_det.inv_prod_unidad_id IS 'Id de la unidad de medida de venta, puede ser diferente a la unidad de medida en el catalogo de productos.';


--
-- Name: fac_nota_credito_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_nota_credito_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_nota_credito_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_nota_credito_det_id_seq OWNED BY public.fac_nota_credito_det.id;


--
-- Name: fac_nota_credito_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_nota_credito_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_nota_credito_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_nota_credito_id_seq OWNED BY public.fac_nota_credito.id;


--
-- Name: fac_par; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_par (
    id integer NOT NULL,
    gral_suc_id integer NOT NULL,
    cxc_mov_tipo_id integer NOT NULL,
    inv_alm_id integer NOT NULL,
    permitir_pedido boolean DEFAULT true,
    permitir_remision boolean DEFAULT true,
    permitir_cambio_almacen boolean DEFAULT true,
    permitir_servicios boolean DEFAULT true,
    permitir_articulos boolean DEFAULT true,
    permitir_kits boolean DEFAULT true,
    gral_suc_id_consecutivo integer NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer,
    formato_pedido smallint DEFAULT 1,
    formato_factura smallint DEFAULT 1,
    validar_pres_pedido boolean DEFAULT true,
    incluye_adenda boolean DEFAULT false NOT NULL,
    cambiar_unidad_medida boolean DEFAULT false NOT NULL,
    gral_emails_id_envio integer DEFAULT 0,
    gral_emails_id_cco integer DEFAULT 0,
    permitir_descto boolean DEFAULT false NOT NULL,
    permitir_req_com boolean DEFAULT false NOT NULL,
    aut_precio_menor_cot boolean DEFAULT false NOT NULL,
    aut_precio_menor_ped boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE fac_par; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.fac_par IS 'Aqui se definen los parametros para la facturacion. La definicion de parametros es por Sucursal.';


--
-- Name: COLUMN fac_par.gral_suc_id_consecutivo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_par.gral_suc_id_consecutivo IS 'Aqui se guarda el id de la sucursal del que se tomara el consecutivo para generar el folio del pedido.';


--
-- Name: COLUMN fac_par.formato_pedido; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_par.formato_pedido IS '1=Formato 1(Hoja completa), 2=Formato 2(Media hoja)';


--
-- Name: COLUMN fac_par.validar_pres_pedido; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_par.validar_pres_pedido IS 'TRUE=Validar Existencias de Presentaciones al Crear el Pedido, FALSE=No validar existencia de Presentaciones al crear y confirmar el pedido.';


--
-- Name: COLUMN fac_par.cambiar_unidad_medida; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_par.cambiar_unidad_medida IS 'Indica si se debe permitir al usuario cambiar la unidad de medida del producto al momento de crear el pedido.';


--
-- Name: fac_par_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_par_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_par_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_par_id_seq OWNED BY public.fac_par.id;


--
-- Name: fac_rem_doc_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_rem_doc_det (
    id integer NOT NULL,
    fac_doc_id integer NOT NULL,
    fac_doc_det_id integer NOT NULL,
    fac_rem_det_id integer NOT NULL
);


--
-- Name: fac_rem_doc_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_rem_doc_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_rem_doc_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_rem_doc_det_id_seq OWNED BY public.fac_rem_doc_det.id;


--
-- Name: fac_rems; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_rems (
    id integer NOT NULL,
    folio character varying,
    cxc_clie_id integer NOT NULL,
    moneda_id integer,
    subtotal double precision,
    impuesto double precision,
    monto_retencion double precision DEFAULT 0,
    total double precision,
    tasa_retencion_immex double precision DEFAULT 0,
    tipo_cambio double precision DEFAULT 0,
    proceso_id integer NOT NULL,
    cxc_agen_id integer DEFAULT 0,
    cxc_clie_credias_id integer DEFAULT 0,
    orden_compra character varying DEFAULT ''::character varying,
    observaciones text DEFAULT ''::text,
    cancelado boolean DEFAULT false,
    fac_docs_tipo_cancelacion_id integer,
    motivo_cancelacion text DEFAULT ''::text,
    momento_creacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_cancelacion integer DEFAULT 0,
    fac_metodos_pago_id smallint DEFAULT 0,
    no_cuenta character varying DEFAULT ''::character varying,
    facturado boolean DEFAULT false,
    folio_pedido character varying DEFAULT ''::character varying,
    estatus smallint DEFAULT 0,
    inv_alm_id smallint DEFAULT 0,
    cxc_clie_df_id integer DEFAULT 0,
    monto_ieps double precision DEFAULT 0,
    monto_descto double precision DEFAULT 0 NOT NULL,
    motivo_descto character varying DEFAULT ''::character varying
);


--
-- Name: COLUMN fac_rems.inv_alm_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_rems.inv_alm_id IS 'Almacen de donde se le dara salida los productos al Remisionar';


--
-- Name: COLUMN fac_rems.cxc_clie_df_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_rems.cxc_clie_df_id IS 'ID de la Direccion Fiscal(cxc_clie_df) para la Remision, esta se utilizara para Facturacion. Si el valor de este campo es 0, entonces por default toma la direccion de la tabla de Clientes (cxc_clie)';


--
-- Name: fac_rems_detalles; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_rems_detalles (
    id integer NOT NULL,
    fac_rems_id integer,
    inv_prod_id integer NOT NULL,
    inv_prod_presentacion_id integer NOT NULL,
    gral_imp_id integer DEFAULT 0,
    valor_imp double precision DEFAULT 0,
    cantidad double precision,
    precio_unitario double precision,
    costo_promedio double precision DEFAULT 0,
    inv_prod_unidad_id integer DEFAULT 0 NOT NULL,
    costo_referencia double precision DEFAULT 0,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0,
    descto double precision DEFAULT 0,
    gral_imptos_ret_id integer DEFAULT 0 NOT NULL,
    tasa_ret double precision DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN fac_rems_detalles.inv_prod_unidad_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.fac_rems_detalles.inv_prod_unidad_id IS 'Id de la unidad de medida de venta, puede ser diferente a la unidad de medida en el catalogo de productos.';


--
-- Name: fac_rems_detalles_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_rems_detalles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_rems_detalles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_rems_detalles_id_seq OWNED BY public.fac_rems_detalles.id;


--
-- Name: fac_rems_docs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.fac_rems_docs (
    id integer NOT NULL,
    fac_rem_id integer NOT NULL,
    erp_proceso_id integer DEFAULT 0
);


--
-- Name: fac_rems_docs_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_rems_docs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_rems_docs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_rems_docs_id_seq OWNED BY public.fac_rems_docs.id;


--
-- Name: fac_rems_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fac_rems_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fac_rems_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fac_rems_id_seq OWNED BY public.fac_rems.id;


--
-- Name: fleteras_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.fleteras_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: fleteras_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.fleteras_id_seq OWNED BY public.cxp_prov_fleteras.id;


--
-- Name: gral_ano_fiscal; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_ano_fiscal (
    id integer NOT NULL,
    sucursal_id integer,
    ano_contable smallint,
    contabilidad smallint,
    ano_inicio smallint,
    mes_inicio smallint,
    ano_final smallint,
    mes_final smallint,
    estatus boolean
);


--
-- Name: gral_ano_fis_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_ano_fis_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_ano_fis_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_ano_fis_id_seq OWNED BY public.gral_ano_fiscal.id;


--
-- Name: gral_app; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_app (
    id integer NOT NULL,
    descripcion character varying NOT NULL,
    nombre_app character varying,
    tipo smallint
);


--
-- Name: TABLE gral_app; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.gral_app IS 'Aqui estan dadas de alta, todas las aplicaciones de las cuales dispone actualmente el sistema. ';


--
-- Name: COLUMN gral_app.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_app.id IS 'Identificador de la aplicacion, cada aplicacion tiene un identificador unico representador por un entero';


--
-- Name: gral_categ; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_categ (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    sueldo_por_hora double precision NOT NULL,
    sueldo_por_horas_ext double precision NOT NULL,
    gral_puesto_id integer NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: COLUMN gral_categ.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_categ.id IS 'Llave primaria de Categorias';


--
-- Name: COLUMN gral_categ.titulo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_categ.titulo IS 'Nombre de la Categoria del Operario';


--
-- Name: COLUMN gral_categ.sueldo_por_hora; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_categ.sueldo_por_hora IS 'Sueldo por Hora Normal';


--
-- Name: COLUMN gral_categ.sueldo_por_horas_ext; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_categ.sueldo_por_horas_ext IS 'Sueldo por Hora de tiempo Extra';


--
-- Name: COLUMN gral_categ.gral_emp_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_categ.gral_emp_id IS 'Empresa a la que pertenece la Categoria';


--
-- Name: COLUMN gral_categ.gral_suc_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_categ.gral_suc_id IS 'Sucursal a la que pertenece';


--
-- Name: gral_categ_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_categ_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_categ_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_categ_id_seq OWNED BY public.gral_categ.id;


--
-- Name: gral_civils; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_civils (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL
);


--
-- Name: gral_civils_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_civils_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_civils_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_civils_id_seq OWNED BY public.gral_civils.id;


--
-- Name: gral_cons; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_cons (
    id integer NOT NULL,
    gral_emp_id integer NOT NULL,
    gral_suc_id integer NOT NULL,
    gral_cons_tipo_id integer NOT NULL,
    prefijo character varying DEFAULT ''::character varying,
    consecutivo bigint DEFAULT 0,
    borrado_logico boolean DEFAULT false
);


--
-- Name: gral_cons_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_cons_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_cons_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_cons_id_seq OWNED BY public.gral_cons.id;


--
-- Name: gral_cons_tipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_cons_tipos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false
);


--
-- Name: gral_cons_tipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_cons_tipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_cons_tipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_cons_tipos_id_seq OWNED BY public.gral_cons_tipos.id;


--
-- Name: gral_deptos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_deptos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    costo_prorrateo double precision,
    vigente boolean DEFAULT true NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: gral_deptos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_deptos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_deptos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_deptos_id_seq OWNED BY public.gral_deptos.id;


--
-- Name: gral_deptos_turnos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_deptos_turnos (
    id integer NOT NULL,
    gral_deptos_id integer NOT NULL,
    turno integer NOT NULL,
    hora_ini time with time zone NOT NULL,
    hora_fin time with time zone NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: TABLE gral_deptos_turnos; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.gral_deptos_turnos IS 'Turnos por Departamento';


--
-- Name: COLUMN gral_deptos_turnos.id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_deptos_turnos.id IS 'llave primaria ID de la tabla';


--
-- Name: COLUMN gral_deptos_turnos.gral_deptos_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_deptos_turnos.gral_deptos_id IS 'num de departamento';


--
-- Name: COLUMN gral_deptos_turnos.turno; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_deptos_turnos.turno IS 'numero de turno';


--
-- Name: COLUMN gral_deptos_turnos.hora_ini; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_deptos_turnos.hora_ini IS 'hora inicial del turno';


--
-- Name: COLUMN gral_deptos_turnos.hora_fin; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_deptos_turnos.hora_fin IS 'hora final del turno';


--
-- Name: gral_deptos_turnos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_deptos_turnos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_deptos_turnos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_deptos_turnos_id_seq OWNED BY public.gral_deptos_turnos.id;


--
-- Name: gral_dias_no_laborables; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_dias_no_laborables (
    id integer NOT NULL,
    fecha_no_laborable date,
    descripcion character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: gral_dias_no_laborables_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_dias_no_laborables_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_dias_no_laborables_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_dias_no_laborables_id_seq OWNED BY public.gral_dias_no_laborables.id;


--
-- Name: gral_docs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_docs (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    gral_app_id integer,
    gral_emp_id integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    momento_actualizacion timestamp with time zone
);


--
-- Name: gral_docs_conf; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_docs_conf (
    id integer NOT NULL,
    gral_doc_id integer,
    campo character varying,
    valor character varying NOT NULL
);


--
-- Name: gral_docs_conf_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_docs_conf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_docs_conf_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_docs_conf_id_seq OWNED BY public.gral_docs_conf.id;


--
-- Name: gral_docs_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_docs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_docs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_docs_id_seq OWNED BY public.gral_docs.id;


--
-- Name: gral_edo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_edo (
    id integer NOT NULL,
    titulo character varying,
    abreviacion character varying,
    pais_id integer NOT NULL
);


--
-- Name: TABLE gral_edo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.gral_edo IS 'Estados que pueden ser seleccionados en los aplicativos del sistema, en funcion del pais seleccionado previamente en estos aplicativos';


--
-- Name: gral_edo_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_edo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_edo_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_edo_id_seq OWNED BY public.gral_edo.id;


--
-- Name: gral_emails; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_emails (
    id integer NOT NULL,
    gral_emp_id integer DEFAULT 0 NOT NULL,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    email character varying DEFAULT ''::character varying,
    passwd character varying DEFAULT ''::character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    port character varying DEFAULT ''::character varying,
    host character varying DEFAULT ''::character varying
);


--
-- Name: gral_emails_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_emails_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_emails_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_emails_id_seq OWNED BY public.gral_emails.id;


--
-- Name: gral_emp; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_emp (
    id integer NOT NULL,
    titulo character varying(60),
    colonia character varying(60),
    cp character varying(6),
    calle character varying(60),
    rfc character varying(15),
    numero_interior character varying(10),
    numero_exterior character varying(10),
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    telefono character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    estado_id integer,
    municipio_id integer,
    pais_id integer,
    regimen_fiscal character varying NOT NULL,
    pagina_web character varying DEFAULT ''::character varying,
    incluye_produccion boolean DEFAULT false,
    email_compras character varying DEFAULT ''::character varying,
    pass_email_compras character varying DEFAULT ''::character varying,
    incluye_contabilidad boolean DEFAULT false,
    nivel_cta smallint DEFAULT 3,
    incluye_crm boolean DEFAULT false NOT NULL,
    encluye_envasado boolean DEFAULT false,
    gral_impto_id integer DEFAULT 1 NOT NULL,
    control_exis_pres boolean DEFAULT false,
    lista_precio_clientes boolean DEFAULT false NOT NULL,
    cubeta_facturacion character varying DEFAULT ''::character varying NOT NULL,
    pac_facturacion integer DEFAULT 0 NOT NULL,
    ambiente_facturacion boolean DEFAULT false NOT NULL,
    transportista boolean DEFAULT false NOT NULL,
    tasa_retencion double precision DEFAULT 0 NOT NULL,
    nomina boolean DEFAULT false NOT NULL,
    no_id integer DEFAULT 0 NOT NULL,
    incluye_log boolean DEFAULT false NOT NULL,
    gral_tc_url_id integer DEFAULT 0 NOT NULL,
    CONSTRAINT chk_ambiente_facturacion CHECK (((ambiente_facturacion = true) OR (ambiente_facturacion = false))),
    CONSTRAINT chk_gral_impto_id CHECK ((gral_impto_id > 0)),
    CONSTRAINT chk_lista_precio CHECK (((lista_precio_clientes = true) OR (lista_precio_clientes = false))),
    CONSTRAINT chk_pac CHECK ((pac_facturacion = ANY (ARRAY[0, 1, 2]))),
    CONSTRAINT chk_tipo_facturacion CHECK ((((tipo_facturacion)::text = 'cfd'::text) OR ((tipo_facturacion)::text = 'cfdi'::text) OR ((tipo_facturacion)::text = 'cfditf'::text)))
);


--
-- Name: TABLE gral_emp; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.gral_emp IS 'Tabla que alberga las empresas que manejara el Sistema';


--
-- Name: COLUMN gral_emp.gral_impto_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_emp.gral_impto_id IS 'IVA general';


--
-- Name: COLUMN gral_emp.control_exis_pres; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_emp.control_exis_pres IS 'TRUE=Controla existencias por Presentaciones, FALSE=No Controla existencias por Presentaciones ';


--
-- Name: COLUMN gral_emp.lista_precio_clientes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_emp.lista_precio_clientes IS 'TRUE=Es obligatorio asignar una Lista de Precio a todos los Clientes. FALSE=Permite dejar un Cliente sin Lista de Precio.';


--
-- Name: COLUMN gral_emp.tipo_facturacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_emp.tipo_facturacion IS 'cfd, cfdi(Conector Fiscal), cfditf(Timbrado Fiscal)';


--
-- Name: COLUMN gral_emp.pac_facturacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_emp.pac_facturacion IS '0=No hay Pac(CFD), 1=Diverza(CFDI, CFDITF), 2=SERVISIM(CFDITF)';


--
-- Name: COLUMN gral_emp.ambiente_facturacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_emp.ambiente_facturacion IS 'Ambiente de Facturacion, TRUE=produccion, FALSE=prueba, solo aplica para Facturacion por Timbre Fiscal';


--
-- Name: gral_emp_consecutivos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_emp_consecutivos (
    id integer NOT NULL,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    folio_entrada_mercancia bigint DEFAULT 0,
    numero_lote bigint DEFAULT 0,
    folio_cotizacion bigint DEFAULT 0,
    numero_control_cliente bigint DEFAULT 0,
    folio_proveedor bigint DEFAULT 0,
    sku_producto bigint DEFAULT 0,
    numero_transaccion_cobranza bigint DEFAULT 0,
    numero_transaccion_pagos bigint DEFAULT 0,
    folio_orden_subensamble bigint DEFAULT 0
);


--
-- Name: gral_emp_consecutivos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_emp_consecutivos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_emp_consecutivos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_emp_consecutivos_id_seq OWNED BY public.gral_emp_consecutivos.id;


--
-- Name: gral_emp_leyenda; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_emp_leyenda (
    id integer NOT NULL,
    leyenda character varying NOT NULL,
    gral_emp_id integer NOT NULL
);


--
-- Name: gral_emp_leyenda_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_emp_leyenda_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_emp_leyenda_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_emp_leyenda_id_seq OWNED BY public.gral_emp_leyenda.id;


--
-- Name: gral_empleado_deduc; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_empleado_deduc (
    id integer NOT NULL,
    gral_empleado_id integer NOT NULL,
    nom_deduc_id integer NOT NULL
);


--
-- Name: gral_empleado_deduc_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_empleado_deduc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_empleado_deduc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_empleado_deduc_id_seq OWNED BY public.gral_empleado_deduc.id;


--
-- Name: gral_empleado_percep; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_empleado_percep (
    id integer NOT NULL,
    gral_empleado_id integer NOT NULL,
    nom_percep_id integer NOT NULL
);


--
-- Name: gral_empleado_percep_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_empleado_percep_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_empleado_percep_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_empleado_percep_id_seq OWNED BY public.gral_empleado_percep.id;


--
-- Name: gral_empleados_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_empleados_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_empleados_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_empleados_id_seq OWNED BY public.gral_empleados.id;


--
-- Name: gral_escolaridads; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_escolaridads (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: gral_escolaridads_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_escolaridads_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_escolaridads_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_escolaridads_id_seq OWNED BY public.gral_escolaridads.id;


--
-- Name: gral_ieps; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_ieps (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    descripcion character varying NOT NULL,
    tasa double precision DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_cancela integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    cfdi_c_impuesto integer
);


--
-- Name: COLUMN gral_ieps.cfdi_c_impuesto; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_ieps.cfdi_c_impuesto IS 'Llave foranea para claves del SAT';


--
-- Name: gral_ieps_cta; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_ieps_cta (
    id integer NOT NULL,
    gral_ieps_id integer NOT NULL,
    ctb_cta_id integer NOT NULL,
    momento_actualiza timestamp with time zone,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0 NOT NULL
);


--
-- Name: gral_ieps_cta_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_ieps_cta_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_ieps_cta_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_ieps_cta_id_seq OWNED BY public.gral_ieps_cta.id;


--
-- Name: gral_ieps_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_ieps_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_ieps_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_ieps_id_seq OWNED BY public.gral_ieps.id;


--
-- Name: gral_impto_cta; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_impto_cta (
    id integer NOT NULL,
    gral_impto_id integer NOT NULL,
    ctb_cta_id integer NOT NULL,
    momento_actualiza timestamp with time zone,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0 NOT NULL
);


--
-- Name: gral_impto_cta_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_impto_cta_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_impto_cta_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_impto_cta_id_seq OWNED BY public.gral_impto_cta.id;


--
-- Name: gral_impto_ret_cta; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_impto_ret_cta (
    id integer NOT NULL,
    gral_impto_ret_id integer NOT NULL,
    ctb_cta_id integer NOT NULL,
    momento_actualiza timestamp with time zone,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0 NOT NULL
);


--
-- Name: gral_impto_ret_cta_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_impto_ret_cta_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_impto_ret_cta_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_impto_ret_cta_id_seq OWNED BY public.gral_impto_ret_cta.id;


--
-- Name: gral_imptos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_imptos (
    id integer NOT NULL,
    descripcion character varying NOT NULL,
    iva_1 double precision DEFAULT 0,
    momento_baja timestamp with time zone,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    borrado_logico boolean DEFAULT false NOT NULL,
    iva_2 double precision,
    ieps_1 double precision,
    ieps_2 double precision,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_cancela integer DEFAULT 0,
    cfdi_c_impuesto integer
);


--
-- Name: COLUMN gral_imptos.cfdi_c_impuesto; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_imptos.cfdi_c_impuesto IS 'Llave foranea para claves del SAT';


--
-- Name: gral_imptos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_imptos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_imptos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_imptos_id_seq OWNED BY public.gral_imptos.id;


--
-- Name: gral_imptos_ret; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_imptos_ret (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    descripcion character varying DEFAULT ''::character varying NOT NULL,
    tasa double precision DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_cancela integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: gral_imptos_ret_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_imptos_ret_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_imptos_ret_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_imptos_ret_id_seq OWNED BY public.gral_imptos_ret.id;


--
-- Name: gral_isr; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_isr (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    descripcion character varying NOT NULL,
    tasa double precision DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_cancela integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: gral_isr_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_isr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_isr_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_isr_id_seq OWNED BY public.gral_isr.id;


--
-- Name: gral_mon; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_mon (
    id integer NOT NULL,
    descripcion character varying NOT NULL,
    descripcion_abr character varying DEFAULT ''::character varying,
    borrado_logico boolean DEFAULT false,
    simbolo character varying DEFAULT ''::character varying,
    iso_4217 character varying DEFAULT ''::character varying,
    compras boolean DEFAULT false,
    ventas boolean DEFAULT false,
    iso_4217_anterior character varying DEFAULT ''::character varying
);


--
-- Name: COLUMN gral_mon.compras; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_mon.compras IS 'TRUE=Permitir utilizar en compras';


--
-- Name: COLUMN gral_mon.ventas; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.gral_mon.ventas IS 'TRUE=Permitir utilizar en ventas';


--
-- Name: gral_mon_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_mon_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_mon_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_mon_id_seq OWNED BY public.gral_mon.id;


--
-- Name: gral_mun; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_mun (
    id integer NOT NULL,
    titulo character varying,
    estado_id integer,
    pais_id integer
);


--
-- Name: TABLE gral_mun; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.gral_mun IS 'Tabla que alberga los municipios que pueden ser seleccionados en los aplicativos de el sistema , en base al pais y estado que se seleccione sobre el aplicativo en curso';


--
-- Name: gral_pais; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_pais (
    id integer NOT NULL,
    titulo character varying,
    abreviacion character varying
);


--
-- Name: TABLE gral_pais; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.gral_pais IS 'Tabla que alberga los paises que pueden ser seleccionados en los aplicativos del sistema';


--
-- Name: gral_pais_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_pais_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_pais_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_pais_id_seq OWNED BY public.gral_pais.id;


--
-- Name: gral_plazas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_plazas (
    titulo character varying NOT NULL,
    descripcion character varying NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    borrado_logico boolean,
    id integer NOT NULL,
    empresa_id integer,
    inv_zonas_id integer,
    estatus boolean DEFAULT true
);


--
-- Name: gral_plazas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_plazas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_plazas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_plazas_id_seq OWNED BY public.gral_plazas.id;


--
-- Name: gral_puestos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_puestos (
    id integer NOT NULL,
    titulo character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: gral_puestos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_puestos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_puestos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_puestos_id_seq OWNED BY public.gral_puestos.id;


--
-- Name: gral_reg; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_reg (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean
);


--
-- Name: gral_reg_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_reg_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_reg_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_reg_id_seq OWNED BY public.gral_reg.id;


--
-- Name: gral_religions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_religions (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: gral_religions_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_religions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_religions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_religions_id_seq OWNED BY public.gral_religions.id;


--
-- Name: gral_rol_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_rol_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_rol_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_rol_id_seq OWNED BY public.gral_rol.id;


--
-- Name: gral_sangretipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_sangretipos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: gral_sangretipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_sangretipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_sangretipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_sangretipos_id_seq OWNED BY public.gral_sangretipos.id;


--
-- Name: gral_sexos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_sexos (
    id integer NOT NULL,
    titulo character varying,
    borrado_logico boolean DEFAULT false NOT NULL
);


--
-- Name: gral_sexos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_sexos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_sexos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_sexos_id_seq OWNED BY public.gral_sexos.id;


--
-- Name: gral_sis_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_sis_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_sis_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_sis_id_seq OWNED BY public.gral_emp.id;


--
-- Name: gral_suc; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_suc (
    id integer NOT NULL,
    titulo character varying(20) NOT NULL,
    cp character varying(6) NOT NULL,
    colonia character varying(60) NOT NULL,
    calle character varying NOT NULL,
    numero_interior character varying(10),
    numero_exterior character varying(10),
    borrado_logico boolean DEFAULT false NOT NULL,
    empresa_id integer NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_pais_id integer,
    gral_edo_id integer,
    gral_mun_id integer,
    gral_impto_id integer DEFAULT 1 NOT NULL,
    email character varying DEFAULT ''::character varying,
    clave character varying DEFAULT ''::character varying NOT NULL,
    CONSTRAINT chk_gral_impto_id CHECK ((gral_impto_id > 0))
);


--
-- Name: TABLE gral_suc; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.gral_suc IS 'Tabla que alberga todas las sucursales que maneja determinada empresa';


--
-- Name: gral_suc_pza; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_suc_pza (
    id integer NOT NULL,
    plaza_id integer NOT NULL,
    sucursal_id integer NOT NULL
);


--
-- Name: gral_suc_pza_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_suc_pza_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_suc_pza_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_suc_pza_id_seq OWNED BY public.gral_suc_pza.id;


--
-- Name: gral_sucursales_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_sucursales_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_sucursales_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_sucursales_id_seq OWNED BY public.gral_suc.id;


--
-- Name: gral_tc_url; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_tc_url (
    id integer NOT NULL,
    url character varying NOT NULL,
    institucion character varying DEFAULT ''::character varying NOT NULL
);


--
-- Name: gral_usr_rol_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_usr_rol_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_usr_rol_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_usr_rol_id_seq OWNED BY public.gral_usr_rol.id;


--
-- Name: gral_usr_suc; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.gral_usr_suc (
    id integer NOT NULL,
    gral_usr_id integer NOT NULL,
    gral_suc_id integer NOT NULL
);


--
-- Name: gral_usr_suc_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.gral_usr_suc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: gral_usr_suc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.gral_usr_suc_id_seq OWNED BY public.gral_usr_suc.id;


--
-- Name: inv_prod_sust; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_sust (
    id integer NOT NULL,
    producto_original_id integer,
    producto_sustituto_id integer,
    vigencia_inicial date,
    vigencia_final date
);


--
-- Name: inv_art_sust_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_art_sust_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_art_sust_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_art_sust_id_seq OWNED BY public.inv_prod_sust.id;


--
-- Name: inv_clas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_clas (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    stock_seguridad double precision,
    factor_maximo double precision,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    descripcion character varying DEFAULT ''::character varying
);


--
-- Name: inv_clas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_clas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_clas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_clas_id_seq OWNED BY public.inv_clas.id;


--
-- Name: inv_com; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_com (
    id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    limite_inferior double precision,
    limite_superior double precision,
    comision double precision,
    comision_valor double precision,
    borrado_logico boolean NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_baja timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    nivel smallint DEFAULT 1 NOT NULL,
    escala smallint DEFAULT 0 NOT NULL
);


--
-- Name: inv_com_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_com_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_com_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_com_id_seq OWNED BY public.inv_com.id;


--
-- Name: inv_com_tipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_com_tipos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone
);


--
-- Name: inv_com_tipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_com_tipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_com_tipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_com_tipos_id_seq OWNED BY public.inv_com_tipos.id;


--
-- Name: inv_etiqueta_medidas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_etiqueta_medidas (
    id integer NOT NULL,
    titulo character varying,
    largo double precision,
    alto double precision,
    modelo_impresora character varying
);


--
-- Name: inv_etiqueta_medidas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_etiqueta_medidas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_etiqueta_medidas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_etiqueta_medidas_id_seq OWNED BY public.inv_etiqueta_medidas.id;


--
-- Name: inv_etiquetas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_etiquetas (
    id integer NOT NULL,
    folio character varying,
    folio_origen character varying,
    tipo_origen integer,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0
);


--
-- Name: inv_etiquetas_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_etiquetas_detalle (
    id integer NOT NULL,
    inv_etiquetas_id integer,
    lote_interno character varying,
    cantidad integer,
    inv_prod_id integer,
    inv_lote_id integer,
    cantidad_produccion double precision,
    inv_etiqueta_medidas_id integer DEFAULT 0 NOT NULL
);


--
-- Name: inv_etiquetas_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_etiquetas_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_etiquetas_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_etiquetas_detalle_id_seq OWNED BY public.inv_etiquetas_detalle.id;


--
-- Name: inv_etiquetas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_etiquetas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_etiquetas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_etiquetas_id_seq OWNED BY public.inv_etiquetas.id;


--
-- Name: inv_exi; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_exi (
    id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    inv_alm_id integer NOT NULL,
    ano smallint NOT NULL,
    transito double precision DEFAULT 0 NOT NULL,
    exi_inicial double precision DEFAULT 0 NOT NULL,
    entradas_1 double precision DEFAULT 0 NOT NULL,
    salidas_1 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_1 double precision DEFAULT 0 NOT NULL,
    entradas_2 double precision DEFAULT 0 NOT NULL,
    salidas_2 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_2 double precision DEFAULT 0 NOT NULL,
    entradas_3 double precision DEFAULT 0 NOT NULL,
    salidas_3 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_3 double precision DEFAULT 0 NOT NULL,
    entradas_4 double precision DEFAULT 0 NOT NULL,
    salidas_4 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_4 double precision DEFAULT 0 NOT NULL,
    entradas_5 double precision DEFAULT 0 NOT NULL,
    salidas_5 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_5 double precision DEFAULT 0 NOT NULL,
    entradas_6 double precision DEFAULT 0 NOT NULL,
    salidas_6 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_6 double precision DEFAULT 0 NOT NULL,
    entradas_7 double precision DEFAULT 0 NOT NULL,
    salidas_7 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_7 double precision DEFAULT 0 NOT NULL,
    entradas_8 double precision DEFAULT 0 NOT NULL,
    salidas_8 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_8 double precision DEFAULT 0 NOT NULL,
    entradas_9 double precision DEFAULT 0 NOT NULL,
    salidas_9 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_9 double precision DEFAULT 0 NOT NULL,
    entradas_10 double precision DEFAULT 0 NOT NULL,
    salidas_10 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_10 double precision DEFAULT 0 NOT NULL,
    entradas_11 double precision DEFAULT 0 NOT NULL,
    salidas_11 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_11 double precision DEFAULT 0 NOT NULL,
    entradas_12 double precision DEFAULT 0 NOT NULL,
    salidas_12 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_12 double precision DEFAULT 0 NOT NULL,
    momento_entrada_1 timestamp with time zone,
    momento_salida_1 timestamp with time zone,
    momento_entrada_2 timestamp with time zone,
    momento_salida_2 timestamp with time zone,
    momento_entrada_3 timestamp with time zone,
    momento_salida_3 timestamp with time zone,
    momento_entrada_4 timestamp with time zone,
    momento_salida_4 timestamp with time zone,
    momento_entrada_5 timestamp with time zone,
    momento_salida_5 timestamp with time zone,
    momento_entrada_6 timestamp with time zone,
    momento_salida_6 timestamp with time zone,
    momento_entrada_7 timestamp with time zone,
    momento_salida_7 timestamp with time zone,
    momento_entrada_8 timestamp with time zone,
    momento_salida_8 timestamp with time zone,
    momento_entrada_9 timestamp with time zone,
    momento_salida_9 timestamp with time zone,
    momento_entrada_10 timestamp with time zone,
    momento_salida_10 timestamp with time zone,
    momento_entrada_11 timestamp with time zone,
    momento_salida_11 timestamp with time zone,
    momento_entrada_12 timestamp with time zone,
    momento_salida_12 timestamp with time zone,
    reservado double precision DEFAULT 0
);


--
-- Name: inv_exi_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_exi_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_exi_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_exi_id_seq OWNED BY public.inv_exi.id;


--
-- Name: inv_exi_pres; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_exi_pres (
    id integer NOT NULL,
    inv_alm_id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    inv_prod_presentacion_id integer NOT NULL,
    inicial double precision DEFAULT 0 NOT NULL,
    reservado double precision DEFAULT 0,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    entradas double precision DEFAULT 0,
    salidas double precision DEFAULT 0
);


--
-- Name: COLUMN inv_exi_pres.inicial; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_exi_pres.inicial IS 'Existencia inicial';


--
-- Name: COLUMN inv_exi_pres.entradas; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_exi_pres.entradas IS 'Acumula todas las Entradas';


--
-- Name: COLUMN inv_exi_pres.salidas; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_exi_pres.salidas IS 'Acumula todas las Salidas';


--
-- Name: inv_exi_pres_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_exi_pres_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_exi_pres_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_exi_pres_id_seq OWNED BY public.inv_exi_pres.id;


--
-- Name: inv_exi_tmp; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_exi_tmp (
    id integer NOT NULL,
    emp_id integer NOT NULL,
    prod_id integer NOT NULL,
    codigo character varying NOT NULL,
    alm_id integer NOT NULL,
    fecha timestamp with time zone NOT NULL,
    exi double precision DEFAULT 0 NOT NULL,
    estatus boolean DEFAULT false
);


--
-- Name: inv_exi_tmp_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_exi_tmp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_exi_tmp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_exi_tmp_id_seq OWNED BY public.inv_exi_tmp.id;


--
-- Name: inv_existencia_inicial; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_existencia_inicial (
    id integer NOT NULL,
    inv_prod_id integer,
    sku character varying,
    inv_alm_id integer,
    cantidad double precision
);


--
-- Name: inv_existencia_inicial_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_existencia_inicial_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_existencia_inicial_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_existencia_inicial_id_seq OWNED BY public.inv_existencia_inicial.id;


--
-- Name: inv_existencia_inicial_kathion; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_existencia_inicial_kathion (
    id integer NOT NULL,
    inv_prod_id integer,
    sku character varying,
    inv_alm_id integer,
    cantidad double precision
);


--
-- Name: inv_existencia_inicial_kathion_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_existencia_inicial_kathion_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_existencia_inicial_kathion_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_existencia_inicial_kathion_id_seq OWNED BY public.inv_existencia_inicial_kathion.id;


--
-- Name: inv_fac; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_fac (
    id integer NOT NULL,
    fac_doc_id integer DEFAULT 0 NOT NULL,
    observaciones character varying DEFAULT ''::character varying NOT NULL,
    momento_crea timestamp with time zone NOT NULL,
    momento_actualiza timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: TABLE inv_fac; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.inv_fac IS 'Tabla header para etiquetas de salida';


--
-- Name: inv_fac_etiqueta; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_fac_etiqueta (
    id integer NOT NULL,
    inv_fac_id integer DEFAULT 0 NOT NULL,
    fac_doc_det_id integer DEFAULT 0 NOT NULL,
    inv_prod_id integer DEFAULT 0 NOT NULL,
    inv_prod_pres_id integer DEFAULT 0 NOT NULL,
    orden_compra character varying DEFAULT ''::character varying NOT NULL,
    lote character varying DEFAULT ''::character varying NOT NULL,
    caducidad date,
    cantidad double precision DEFAULT 0,
    codigo2 character varying DEFAULT ''::character varying NOT NULL,
    imprimir boolean DEFAULT false NOT NULL
);


--
-- Name: TABLE inv_fac_etiqueta; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.inv_fac_etiqueta IS 'Tabla que almacena la informacion del programa de impresion de etiquetas. Las etiquetas son por cada producto de la factura.';


--
-- Name: COLUMN inv_fac_etiqueta.codigo2; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_fac_etiqueta.codigo2 IS 'Codigo del producto utilizado por el cliente.';


--
-- Name: inv_fac_etiqueta_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_fac_etiqueta_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_fac_etiqueta_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_fac_etiqueta_id_seq OWNED BY public.inv_fac_etiqueta.id;


--
-- Name: inv_fac_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_fac_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_fac_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_fac_id_seq OWNED BY public.inv_fac.id;


--
-- Name: inv_kat_kem_sep2013; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_kat_kem_sep2013 (
    id integer NOT NULL,
    codigo text,
    producto text,
    inv_teorico text,
    inv_fisico text,
    diferencia text,
    cant_lote text,
    id_pres text,
    presentacion text,
    lote text,
    cant_pres text,
    id_empresa text
);


--
-- Name: inv_kat_kem_sep2013_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_kat_kem_sep2013_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_kat_kem_sep2013_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_kat_kem_sep2013_id_seq OWNED BY public.inv_kat_kem_sep2013.id;


--
-- Name: inv_kit; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_kit (
    id integer NOT NULL,
    producto_kit_id integer NOT NULL,
    cantidad double precision,
    producto_elemento_id integer
);


--
-- Name: inv_kit_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_kit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_kit_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_kit_id_seq OWNED BY public.inv_kit.id;


--
-- Name: inv_lm; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_lm (
    id integer NOT NULL,
    inv_prod_linea_id integer,
    inv_mar_id integer
);


--
-- Name: inv_lm_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_lm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_lm_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_lm_id_seq OWNED BY public.inv_lm.id;


--
-- Name: inv_lote; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_lote (
    id integer NOT NULL,
    inv_oent_detalle_id integer DEFAULT 0,
    inv_prod_id integer NOT NULL,
    inv_alm_id integer NOT NULL,
    lote_int character varying DEFAULT ''::character varying NOT NULL,
    lote_prov character varying DEFAULT ''::character varying NOT NULL,
    inicial double precision DEFAULT 0 NOT NULL,
    salidas double precision DEFAULT 0 NOT NULL,
    entradas double precision DEFAULT 0 NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    caducidad date,
    pedimento character varying DEFAULT ''::character varying,
    reservado double precision DEFAULT 0
);


--
-- Name: inv_lote_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_lote_detalle (
    id integer NOT NULL,
    inv_lote_id integer,
    inv_osal_detalle_id integer,
    cantidad_sal double precision DEFAULT 0 NOT NULL,
    cantidad_dev double precision DEFAULT 0
);


--
-- Name: inv_lote_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_lote_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_lote_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_lote_detalle_id_seq OWNED BY public.inv_lote_detalle.id;


--
-- Name: inv_lote_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_lote_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_lote_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_lote_id_seq OWNED BY public.inv_lote.id;


--
-- Name: inv_lote_mov; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_lote_mov (
    id integer NOT NULL,
    id_referencia integer,
    referencia character varying,
    inv_mov_tipo_id integer,
    fecha_mov timestamp with time zone,
    observacion text,
    gral_usr_id integer,
    gral_app_id integer
);


--
-- Name: inv_lote_mov_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_lote_mov_det (
    id integer NOT NULL,
    inv_lote_mov_id integer,
    inv_alm_origen_id integer,
    inv_alm_destino_id integer,
    inv_lote_id integer,
    cantidad double precision,
    referencia_det_id integer
);


--
-- Name: inv_lote_mov_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_lote_mov_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_lote_mov_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_lote_mov_det_id_seq OWNED BY public.inv_lote_mov_det.id;


--
-- Name: inv_lote_mov_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_lote_mov_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_lote_mov_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_lote_mov_id_seq OWNED BY public.inv_lote_mov.id;


--
-- Name: inv_lote_tmp; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_lote_tmp (
    id integer NOT NULL,
    emp_id integer NOT NULL,
    prod_id integer NOT NULL,
    codigo character varying NOT NULL,
    alm_id integer NOT NULL,
    lote_int character varying DEFAULT ''::character varying NOT NULL,
    lote_prov character varying DEFAULT ''::character varying NOT NULL,
    exi double precision DEFAULT 0 NOT NULL,
    fecha timestamp with time zone NOT NULL,
    estatus boolean DEFAULT false
);


--
-- Name: inv_lote_tmp_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_lote_tmp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_lote_tmp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_lote_tmp_id_seq OWNED BY public.inv_lote_tmp.id;


--
-- Name: inv_mar; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_mar (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    url character varying,
    estatus boolean DEFAULT true,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0
);


--
-- Name: inv_mar_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_mar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_mar_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_mar_id_seq OWNED BY public.inv_mar.id;


--
-- Name: inv_mov; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_mov (
    id integer NOT NULL,
    observacion text,
    momento_creacion timestamp with time zone NOT NULL,
    gral_usr_id integer NOT NULL,
    gral_app_id integer NOT NULL,
    inv_mov_tipo_id integer,
    referencia character varying,
    fecha_mov timestamp with time zone
);


--
-- Name: inv_mov_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_mov_detalle (
    id integer NOT NULL,
    producto_id integer,
    alm_origen_id integer,
    alm_destino_id integer,
    cantidad double precision,
    inv_mov_id integer,
    costo double precision DEFAULT 0,
    inv_prod_presentacion_id integer DEFAULT 0
);


--
-- Name: COLUMN inv_mov_detalle.costo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_mov_detalle.costo IS 'Para una entrada este costo es el costo unitario de Compra, para venta es el costo Promedio al momento de la venta';


--
-- Name: inv_mov_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_mov_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_mov_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_mov_detalle_id_seq OWNED BY public.inv_mov_detalle.id;


--
-- Name: inv_mov_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_mov_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_mov_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_mov_id_seq OWNED BY public.inv_mov.id;


--
-- Name: inv_mov_tipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_mov_tipos (
    id integer NOT NULL,
    titulo character varying,
    descripcion character varying,
    momento_creacion timestamp with time zone,
    momento_baja timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    borrado_logico boolean DEFAULT false,
    grupo smallint DEFAULT 0 NOT NULL,
    afecta_compras boolean DEFAULT false NOT NULL,
    afecta_ventas boolean DEFAULT false NOT NULL,
    considera_consumo boolean DEFAULT false NOT NULL,
    tipo_costo smallint,
    ajuste boolean DEFAULT false NOT NULL
);


--
-- Name: COLUMN inv_mov_tipos.grupo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_mov_tipos.grupo IS '0=Entradas, 1=Existencia Inicial, 2=Salidas, 3=Traspasos';


--
-- Name: COLUMN inv_mov_tipos.tipo_costo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_mov_tipos.tipo_costo IS '0=Alimentado, 1=Promedio, 2=Ultima Entrada';


--
-- Name: inv_mov_tipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_mov_tipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_mov_tipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_mov_tipos_id_seq OWNED BY public.inv_mov_tipos.id;


--
-- Name: inv_odev; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_odev (
    id integer NOT NULL,
    folio character varying NOT NULL,
    estatus smallint DEFAULT 0 NOT NULL,
    erp_proceso_id integer DEFAULT 0,
    inv_mov_tipo_id integer NOT NULL,
    tipo_documento integer DEFAULT 0 NOT NULL,
    folio_documento character varying,
    fecha_exp date,
    cxc_clie_id integer DEFAULT 0,
    inv_alm_id integer DEFAULT 0,
    moneda_id integer DEFAULT 0,
    observaciones text DEFAULT ''::text,
    momento_confirmacion timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    gral_usr_id_confirmacion integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    folio_ncto character varying DEFAULT ''::character varying,
    cancelacion boolean DEFAULT false NOT NULL
);


--
-- Name: COLUMN inv_odev.estatus; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_odev.estatus IS '0=No se ha tocado por el personal de Almacen, 1=Ya se ha ingresado cantidaddes a devolver a los lotes, 2=Confirmado(ya se le regreso la existencia al lote)';


--
-- Name: COLUMN inv_odev.tipo_documento; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_odev.tipo_documento IS '1=Factura, 2=Remision';


--
-- Name: COLUMN inv_odev.folio_documento; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_odev.folio_documento IS 'Folio de la Factura o Remision';


--
-- Name: COLUMN inv_odev.inv_alm_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_odev.inv_alm_id IS 'Almacen Destino de la mercancia en devolucion';


--
-- Name: COLUMN inv_odev.folio_ncto; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_odev.folio_ncto IS 'Serie y folio de la nota de credito de la nota de credito que gener√≥ la devolucion.';


--
-- Name: inv_odev_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_odev_detalle (
    id integer NOT NULL,
    inv_odev_id integer NOT NULL,
    inv_osal_detalle_id integer NOT NULL,
    inv_lote_id integer NOT NULL,
    cant_fac_lote double precision DEFAULT 0 NOT NULL,
    cant_dev_lote double precision DEFAULT 0 NOT NULL,
    inv_prod_unidad_id integer DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN inv_odev_detalle.cant_fac_lote; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_odev_detalle.cant_fac_lote IS 'Esta cantidad que se factur√≥ del lote.';


--
-- Name: COLUMN inv_odev_detalle.cant_dev_lote; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_odev_detalle.cant_dev_lote IS 'Esta es la cantidad que se devuelve al lote.';


--
-- Name: COLUMN inv_odev_detalle.inv_prod_unidad_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_odev_detalle.inv_prod_unidad_id IS 'Id de la unidad de medida de venta, puede ser diferente a la unidad de medida en el catalogo de productos.';


--
-- Name: inv_odev_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_odev_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_odev_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_odev_detalle_id_seq OWNED BY public.inv_odev_detalle.id;


--
-- Name: inv_odev_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_odev_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_odev_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_odev_id_seq OWNED BY public.inv_odev.id;


--
-- Name: inv_oent; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_oent (
    id integer NOT NULL,
    folio character varying NOT NULL,
    estatus smallint DEFAULT 0,
    com_proceso_id integer DEFAULT 0,
    inv_mov_tipo_id integer,
    tipo_documento integer DEFAULT 0,
    folio_documento character varying,
    fecha_exp date,
    gral_app_id integer DEFAULT 0,
    cxp_prov_id integer DEFAULT 0,
    cxc_clie_id integer DEFAULT 0,
    inv_alm_id integer,
    subtotal double precision DEFAULT 0,
    monto_iva double precision DEFAULT 0,
    monto_retencion double precision DEFAULT 0,
    monto_total double precision DEFAULT 0,
    tasa_iva double precision DEFAULT 0,
    tasa_retencion double precision DEFAULT 0,
    numero_guia character varying,
    orden_de_compra character varying,
    moneda_id integer,
    tipo_de_cambio double precision,
    observaciones text DEFAULT ''::text,
    tipo_mov_oc_id integer,
    referencia_oc character varying,
    motivo_cancelacion text DEFAULT ''::text,
    cancelacion boolean DEFAULT false,
    momento_cancelacion timestamp with time zone,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    monto_flete double precision DEFAULT 0,
    monto_ieps double precision DEFAULT 0
);


--
-- Name: COLUMN inv_oent.estatus; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_oent.estatus IS '0=No se ha tocado por el personal de Almacen, 1=Ya se ha ingresado cantidaddes, lotes, pedimentos y fechas de caducidad';


--
-- Name: COLUMN inv_oent.tipo_documento; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_oent.tipo_documento IS '1=Factura, 2=Remision, 3=Ajuste, 4=Produccion ';


--
-- Name: COLUMN inv_oent.folio_documento; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_oent.folio_documento IS 'Folio de la Factura o Remision';


--
-- Name: COLUMN inv_oent.inv_alm_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_oent.inv_alm_id IS 'Almacen Destino';


--
-- Name: inv_oent_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_oent_detalle (
    id integer NOT NULL,
    inv_oent_id integer DEFAULT 0,
    cantidad double precision DEFAULT 0,
    costo_unitario double precision DEFAULT 0,
    inv_prod_id integer DEFAULT 0,
    inv_prod_presentacion_id integer DEFAULT 0,
    gral_imp_id integer DEFAULT 0,
    valor_imp double precision DEFAULT 0,
    cantidad_rec double precision DEFAULT 0,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0
);


--
-- Name: COLUMN inv_oent_detalle.cantidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_oent_detalle.cantidad IS 'Esta cantidad es de la captura de la factura';


--
-- Name: COLUMN inv_oent_detalle.cantidad_rec; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_oent_detalle.cantidad_rec IS 'Esta cantidad es capturada por la persona que recibe en almacen';


--
-- Name: inv_oent_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_oent_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_oent_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_oent_detalle_id_seq OWNED BY public.inv_oent_detalle.id;


--
-- Name: inv_oent_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_oent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_oent_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_oent_id_seq OWNED BY public.inv_oent.id;


--
-- Name: inv_ord_subensamble; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_ord_subensamble (
    id integer NOT NULL,
    folio character varying NOT NULL,
    comentarios character varying,
    proceso_id integer,
    estatus smallint,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_confirmacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_confirmacion integer DEFAULT 0,
    gral_usr_id_cancelacion integer DEFAULT 0,
    inv_alm_id integer DEFAULT 0
);


--
-- Name: inv_ord_subensamble_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_ord_subensamble_detalle (
    id integer NOT NULL,
    cantidad double precision,
    inv_prod_id_subensamble integer DEFAULT 0 NOT NULL,
    inv_ord_subensamble_id integer DEFAULT 0 NOT NULL,
    inv_prod_presentacion_id integer DEFAULT 0 NOT NULL,
    inv_prod_unidad_id integer DEFAULT 0 NOT NULL,
    densidad double precision DEFAULT 0 NOT NULL,
    costo double precision DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN inv_ord_subensamble_detalle.cantidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_ord_subensamble_detalle.cantidad IS 'Esta cantidad es en Kilo';


--
-- Name: COLUMN inv_ord_subensamble_detalle.inv_prod_id_subensamble; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_ord_subensamble_detalle.inv_prod_id_subensamble IS 'Id del Producto formulado';


--
-- Name: COLUMN inv_ord_subensamble_detalle.inv_prod_presentacion_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_ord_subensamble_detalle.inv_prod_presentacion_id IS 'Presentacion del producto formulado';


--
-- Name: COLUMN inv_ord_subensamble_detalle.inv_prod_unidad_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_ord_subensamble_detalle.inv_prod_unidad_id IS 'Unidad de Medida del producto formulado';


--
-- Name: COLUMN inv_ord_subensamble_detalle.densidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_ord_subensamble_detalle.densidad IS 'Densidad del producto formulado';


--
-- Name: COLUMN inv_ord_subensamble_detalle.costo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_ord_subensamble_detalle.costo IS 'Costo de produccion por Kilo';


--
-- Name: inv_ord_subensamble_detalle_formula; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_ord_subensamble_detalle_formula (
    id integer NOT NULL,
    inv_ord_subensamble_id integer DEFAULT 0 NOT NULL,
    inv_ord_subensamble_detalle_id integer DEFAULT 0 NOT NULL,
    inv_prod_id integer DEFAULT 0 NOT NULL,
    inv_prod_presentacion_id integer DEFAULT 0 NOT NULL,
    densidad double precision DEFAULT 0 NOT NULL,
    cantidad_kg double precision DEFAULT 0 NOT NULL,
    costo_unitario_kg double precision DEFAULT 0 NOT NULL
);


--
-- Name: inv_ord_subensamble_detalle_formula_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_ord_subensamble_detalle_formula_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_ord_subensamble_detalle_formula_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_ord_subensamble_detalle_formula_id_seq OWNED BY public.inv_ord_subensamble_detalle_formula.id;


--
-- Name: inv_ord_subensamble_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_ord_subensamble_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_ord_subensamble_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_ord_subensamble_detalle_id_seq OWNED BY public.inv_ord_subensamble_detalle.id;


--
-- Name: inv_ord_subensamble_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_ord_subensamble_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_ord_subensamble_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_ord_subensamble_id_seq OWNED BY public.inv_ord_subensamble.id;


--
-- Name: inv_osal; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_osal (
    id integer NOT NULL,
    folio character varying NOT NULL,
    estatus smallint DEFAULT 0,
    erp_proceso_id integer DEFAULT 0,
    inv_mov_tipo_id integer,
    tipo_documento integer DEFAULT 0,
    folio_documento character varying,
    fecha_exp date,
    gral_app_id integer DEFAULT 0,
    cxp_prov_id integer DEFAULT 0,
    cxc_clie_id integer DEFAULT 0,
    inv_alm_id integer DEFAULT 0,
    subtotal double precision DEFAULT 0,
    monto_iva double precision DEFAULT 0,
    monto_retencion double precision DEFAULT 0,
    monto_total double precision DEFAULT 0,
    orden_compra character varying,
    moneda_id integer,
    tipo_cambio double precision,
    observaciones text DEFAULT ''::text,
    motivo_cancelacion text DEFAULT ''::text,
    cancelacion boolean DEFAULT false,
    momento_cancelacion timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    folio_pedido character varying DEFAULT ''::character varying,
    momento_confirmacion timestamp with time zone,
    gral_usr_id_confirmacion integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    monto_ieps double precision DEFAULT 0
);


--
-- Name: COLUMN inv_osal.estatus; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_osal.estatus IS '0=No se ha tocado por el personal de Almacen, 1=Ya se ha ingresado cantidaddes, lotes, pedimentos y fechas de caducidad, 2=Confirmado(ya se le dio salida)';


--
-- Name: COLUMN inv_osal.tipo_documento; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_osal.tipo_documento IS '1=Factura, 2=Remision, 3=Ajuste, 4=Requisicion, 5=Nota de Credito(Devolucion a Proveedor)';


--
-- Name: COLUMN inv_osal.folio_documento; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_osal.folio_documento IS 'Folio de la Factura, Remision, Ajuste, Requisicion, Nota de Credito de proveedor';


--
-- Name: COLUMN inv_osal.inv_alm_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_osal.inv_alm_id IS 'Almacen origen';


--
-- Name: inv_osal_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_osal_detalle (
    id integer NOT NULL,
    inv_osal_id integer DEFAULT 0,
    cantidad double precision DEFAULT 0,
    precio_unitario double precision DEFAULT 0,
    inv_prod_id integer DEFAULT 0,
    inv_prod_presentacion_id integer DEFAULT 0,
    cantidad_sur double precision DEFAULT 0,
    cant_dev double precision DEFAULT 0,
    inv_prod_unidad_id integer DEFAULT 0 NOT NULL,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0
);


--
-- Name: COLUMN inv_osal_detalle.cantidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_osal_detalle.cantidad IS 'Esta cantidad es de la factura';


--
-- Name: COLUMN inv_osal_detalle.cantidad_sur; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_osal_detalle.cantidad_sur IS 'Esta cantidad es capturada por la persona que le da salida en almacen';


--
-- Name: COLUMN inv_osal_detalle.cant_dev; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_osal_detalle.cant_dev IS 'Cantidad devolucion';


--
-- Name: COLUMN inv_osal_detalle.inv_prod_unidad_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_osal_detalle.inv_prod_unidad_id IS 'Id de la unidad de medida de venta, puede ser diferente a la unidad de medida en el catalogo de productos.';


--
-- Name: inv_osal_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_osal_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_osal_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_osal_detalle_id_seq OWNED BY public.inv_osal_detalle.id;


--
-- Name: inv_osal_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_osal_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_osal_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_osal_id_seq OWNED BY public.inv_osal.id;


--
-- Name: inv_otras; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_otras (
    id integer NOT NULL,
    folio character varying NOT NULL,
    fecha date,
    estatus smallint DEFAULT 0,
    gral_suc_id_origen integer DEFAULT 0,
    inv_alm_id_origen integer,
    gral_suc_id_destino integer DEFAULT 0,
    inv_alm_id_destino integer,
    observaciones text DEFAULT ''::text,
    motivo_cancelacion text DEFAULT ''::text,
    cancelacion boolean DEFAULT false,
    momento_cancelacion timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_cancelacion integer DEFAULT 0,
    inv_tras_id integer DEFAULT 0
);


--
-- Name: TABLE inv_otras; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.inv_otras IS 'Tabla header de Ordenes de Traspaso';


--
-- Name: COLUMN inv_otras.estatus; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_otras.estatus IS '0=No ha sido tocado por personal de almacen, 1=Ya se le dio salida del lote';


--
-- Name: COLUMN inv_otras.inv_tras_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_otras.inv_tras_id IS 'Id del Traspaso que genero la Orden de Traspaso';


--
-- Name: inv_otras_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_otras_det (
    id integer NOT NULL,
    inv_otras_id integer DEFAULT 0,
    inv_prod_id integer DEFAULT 0,
    cantidad_tras double precision DEFAULT 0,
    inv_prod_presentacion_id integer DEFAULT 0
);


--
-- Name: inv_otras_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_otras_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_otras_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_otras_det_id_seq OWNED BY public.inv_otras_det.id;


--
-- Name: inv_otras_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_otras_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_otras_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_otras_id_seq OWNED BY public.inv_otras.id;


--
-- Name: inv_pre; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_pre (
    id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    precio_1 double precision,
    precio_2 double precision,
    precio_3 double precision,
    precio_4 double precision,
    precio_5 double precision,
    precio_6 double precision,
    precio_7 double precision,
    precio_8 double precision,
    precio_9 double precision,
    precio_10 double precision,
    descuento_1 double precision,
    descuento_2 double precision,
    descuento_3 double precision,
    descuento_4 double precision,
    descuento_5 double precision,
    descuento_6 double precision,
    descuento_7 double precision,
    descuento_8 double precision,
    descuento_9 double precision,
    descuento_10 double precision,
    base_precio_1 integer,
    base_precio_2 integer,
    base_precio_3 integer,
    base_precio_4 integer,
    base_precio_5 integer,
    base_precio_6 integer,
    base_precio_7 integer,
    base_precio_8 integer,
    base_precio_9 integer,
    base_precio_10 integer,
    default_precio_1 double precision,
    default_precio_2 double precision,
    default_precio_3 double precision,
    default_precio_4 double precision,
    default_precio_5 double precision,
    default_precio_6 double precision,
    default_precio_7 double precision,
    default_precio_8 double precision,
    default_precio_9 double precision,
    default_precio_10 double precision,
    operacion_precio_1 integer,
    operacion_precio_2 integer,
    operacion_precio_3 integer,
    operacion_precio_4 integer,
    operacion_precio_5 integer,
    operacion_precio_6 integer,
    operacion_precio_7 integer,
    operacion_precio_8 integer,
    operacion_precio_9 integer,
    operacion_precio_10 integer,
    calculo_precio_1 integer,
    calculo_precio_2 integer,
    calculo_precio_3 integer,
    calculo_precio_4 integer,
    calculo_precio_5 integer,
    calculo_precio_6 integer,
    calculo_precio_7 integer,
    calculo_precio_8 integer,
    calculo_precio_9 integer,
    calculo_precio_10 integer,
    redondeo_precio_1 integer,
    redondeo_precio_2 integer,
    redondeo_precio_3 integer,
    redondeo_precio_4 integer,
    redondeo_precio_5 integer,
    redondeo_precio_6 integer,
    redondeo_precio_7 integer,
    redondeo_precio_8 integer,
    redondeo_precio_9 integer,
    redondeo_precio_10 integer,
    gral_emp_id integer,
    borrado_logico boolean NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_baja timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_mon_id_pre1 integer DEFAULT 0 NOT NULL,
    gral_mon_id_pre2 integer DEFAULT 0 NOT NULL,
    gral_mon_id_pre3 integer DEFAULT 0 NOT NULL,
    gral_mon_id_pre4 integer DEFAULT 0 NOT NULL,
    gral_mon_id_pre5 integer DEFAULT 0 NOT NULL,
    gral_mon_id_pre6 integer DEFAULT 0 NOT NULL,
    gral_mon_id_pre7 integer DEFAULT 0 NOT NULL,
    gral_mon_id_pre8 integer DEFAULT 0 NOT NULL,
    gral_mon_id_pre9 integer DEFAULT 0 NOT NULL,
    gral_mon_id_pre10 integer DEFAULT 0 NOT NULL,
    inv_prod_presentacion_id integer DEFAULT 0
);


--
-- Name: inv_pre_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_pre_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_pre_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_pre_id_seq OWNED BY public.inv_pre.id;


--
-- Name: inv_pre_ofe; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_pre_ofe (
    inv_prod_id integer NOT NULL,
    precio_oferta double precision DEFAULT 0,
    descto_max double precision,
    criterio_oferta boolean DEFAULT true,
    precio_lista_1 boolean DEFAULT true,
    precio_lista_2 boolean DEFAULT true,
    precio_lista_3 boolean DEFAULT true,
    precio_lista_4 boolean DEFAULT true,
    precio_lista_5 boolean DEFAULT true,
    precio_lista_6 boolean DEFAULT true,
    precio_lista_7 boolean DEFAULT true,
    precio_lista_8 boolean DEFAULT true,
    precio_lista_9 boolean DEFAULT true,
    precio_lista_10 boolean DEFAULT true,
    fecha_inicial date NOT NULL,
    fecha_final date NOT NULL,
    tipo_descto_precio boolean NOT NULL,
    id integer NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    borrado_logico boolean DEFAULT false NOT NULL
);


--
-- Name: inv_pre_ofe_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_pre_ofe_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_pre_ofe_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_pre_ofe_id_seq OWNED BY public.inv_pre_ofe.id;


--
-- Name: inv_pre_par; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_pre_par (
    id integer NOT NULL,
    gral_emp_id integer,
    gral_suc_id integer NOT NULL,
    margen_l1 double precision,
    margen_l2 double precision,
    margen_l3 double precision,
    margen_l4 double precision,
    margen_l5 double precision,
    margen_l6 double precision,
    margen_l7 double precision,
    margen_l8 double precision,
    margen_l9 double precision,
    margen_l10 double precision,
    calculo_automatico boolean DEFAULT false NOT NULL,
    momento_crea timestamp with time zone NOT NULL,
    momento_actualiza timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    CONSTRAINT chk_margen_l1 CHECK ((margen_l1 >= (0)::double precision)),
    CONSTRAINT chk_margen_l10 CHECK ((margen_l10 >= (0)::double precision)),
    CONSTRAINT chk_margen_l2 CHECK ((margen_l2 >= (0)::double precision)),
    CONSTRAINT chk_margen_l3 CHECK ((margen_l3 >= (0)::double precision)),
    CONSTRAINT chk_margen_l4 CHECK ((margen_l4 >= (0)::double precision)),
    CONSTRAINT chk_margen_l5 CHECK ((margen_l5 >= (0)::double precision)),
    CONSTRAINT chk_margen_l6 CHECK ((margen_l6 >= (0)::double precision)),
    CONSTRAINT chk_margen_l7 CHECK ((margen_l7 >= (0)::double precision)),
    CONSTRAINT chk_margen_l8 CHECK ((margen_l8 >= (0)::double precision)),
    CONSTRAINT chk_margen_l9 CHECK ((margen_l9 >= (0)::double precision))
);


--
-- Name: inv_pre_par_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_pre_par_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_pre_par_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_pre_par_id_seq OWNED BY public.inv_pre_par.id;


--
-- Name: inv_proceso; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_proceso (
    id integer NOT NULL,
    proceso_flujo_id integer NOT NULL,
    empresa_id integer DEFAULT 0,
    sucursal_id integer DEFAULT 0
);


--
-- Name: inv_proceso_flujo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_proceso_flujo (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false
);


--
-- Name: inv_proceso_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_proceso_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_proceso_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_proceso_id_seq OWNED BY public.inv_proceso.id;


--
-- Name: inv_prod; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod (
    id integer NOT NULL,
    sku character varying DEFAULT ''::character varying,
    descripcion character varying NOT NULL,
    codigo_barras character varying DEFAULT ''::character varying,
    tentrega integer DEFAULT 0,
    inv_clas_id integer DEFAULT 0,
    inv_stock_clasif_id integer DEFAULT 0,
    estatus boolean DEFAULT true,
    inv_prod_familia_id integer DEFAULT 0,
    subfamilia_id integer DEFAULT 0,
    inv_prod_grupo_id integer DEFAULT 0,
    ieps integer DEFAULT 0,
    meta_impuesto character varying DEFAULT ''::character varying,
    inv_prod_linea_id integer DEFAULT 0,
    inv_mar_id integer DEFAULT 0,
    tipo_de_producto_id integer DEFAULT 0,
    inv_seccion_id integer DEFAULT 0,
    unidad_id integer DEFAULT 0,
    requiere_numero_serie boolean DEFAULT false,
    requiere_numero_lote boolean DEFAULT false,
    requiere_pedimento boolean DEFAULT false,
    permitir_stock boolean DEFAULT false,
    venta_moneda_extranjera boolean DEFAULT false,
    compra_moneda_extranjera boolean DEFAULT false,
    requiere_nom boolean DEFAULT false,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    empresa_id integer DEFAULT 0,
    cxp_prov_id integer DEFAULT 0,
    sku_aux character varying DEFAULT ''::character varying,
    id_aux integer DEFAULT 0,
    densidad double precision DEFAULT 0,
    valor_maximo double precision DEFAULT 0,
    valor_minimo double precision DEFAULT 0,
    punto_reorden double precision DEFAULT 0,
    gral_impto_id integer DEFAULT 0,
    ctb_cta_id_gasto integer DEFAULT 0,
    ctb_cta_id_costo_venta integer DEFAULT 0,
    ctb_cta_id_venta integer DEFAULT 0,
    descripcion_corta text,
    descripcion_larga text,
    archivo_img character varying DEFAULT ''::character varying,
    archivo_pdf character varying DEFAULT ''::character varying,
    inv_prod_presentacion_id integer DEFAULT 0,
    flete boolean DEFAULT false NOT NULL,
    no_clie character varying DEFAULT ''::character varying NOT NULL,
    gral_mon_id integer DEFAULT 0 NOT NULL,
    gral_imptos_ret_id integer DEFAULT 0 NOT NULL,
    cfdi_prodserv_id integer
);


--
-- Name: COLUMN inv_prod.gral_impto_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_prod.gral_impto_id IS 'Impuesto especifico para el Producto';


--
-- Name: COLUMN inv_prod.ctb_cta_id_gasto; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_prod.ctb_cta_id_gasto IS 'id de la Cuenta Contable para Gastos';


--
-- Name: COLUMN inv_prod.ctb_cta_id_costo_venta; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_prod.ctb_cta_id_costo_venta IS 'id de la Cuenta Contable para Costo de Venta';


--
-- Name: COLUMN inv_prod.ctb_cta_id_venta; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_prod.ctb_cta_id_venta IS 'id de la Cuenta Contable para Ventas';


--
-- Name: COLUMN inv_prod.inv_prod_presentacion_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_prod.inv_prod_presentacion_id IS 'Id de la Presentacion DEFAULT. Esta presentacion debera ser Equivalente a la Unidad de Medida del Producto.';


--
-- Name: COLUMN inv_prod.flete; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_prod.flete IS 'Indica que el producto es un flete y debe retener impuesto cuando la empresa sea transportista.';


--
-- Name: inv_prod2_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod2_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod2_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_prod2_id_seq OWNED BY public.inv_prod.id;


--
-- Name: inv_prod_anterior; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_anterior (
    id integer NOT NULL,
    sku character varying NOT NULL,
    titulo_en character varying NOT NULL,
    titulo_es character varying NOT NULL,
    unidad_id integer NOT NULL,
    tipo_de_producto_id integer NOT NULL,
    productolinea_id integer NOT NULL,
    descripcion_en text,
    descripcion_es text,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    backorder integer DEFAULT 0,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0,
    sucursal_id integer DEFAULT 0,
    productogrupo_id integer,
    productofamilia_id integer,
    empresa_id integer DEFAULT 0,
    sku_aux character varying DEFAULT ''::character varying,
    id_aux integer DEFAULT 0,
    pedimento boolean DEFAULT false,
    requiere_numero_serie boolean DEFAULT false,
    requiere_numero_lote boolean DEFAULT false,
    meta_impuesto character varying
);


--
-- Name: inv_prod_cost_prom; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_cost_prom (
    id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    ano smallint NOT NULL,
    costo_promedio_1 double precision DEFAULT 0 NOT NULL,
    costo_promedio_2 double precision DEFAULT 0 NOT NULL,
    costo_promedio_3 double precision DEFAULT 0 NOT NULL,
    costo_promedio_4 double precision DEFAULT 0 NOT NULL,
    costo_promedio_5 double precision DEFAULT 0 NOT NULL,
    costo_promedio_6 double precision DEFAULT 0 NOT NULL,
    costo_promedio_7 double precision DEFAULT 0 NOT NULL,
    costo_promedio_8 double precision DEFAULT 0 NOT NULL,
    costo_promedio_9 double precision DEFAULT 0 NOT NULL,
    costo_promedio_10 double precision DEFAULT 0 NOT NULL,
    costo_promedio_11 double precision DEFAULT 0 NOT NULL,
    costo_promedio_12 double precision DEFAULT 0 NOT NULL,
    costo_ultimo_1 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_1 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_1 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_2 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_2 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_2 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_3 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_3 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_3 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_4 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_4 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_4 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_5 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_5 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_5 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_6 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_6 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_6 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_7 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_7 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_7 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_8 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_8 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_8 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_9 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_9 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_9 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_10 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_10 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_10 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_11 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_11 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_11 smallint DEFAULT 0 NOT NULL,
    costo_ultimo_12 double precision DEFAULT 0 NOT NULL,
    tipo_cambio_12 double precision DEFAULT 0 NOT NULL,
    gral_mon_id_12 smallint DEFAULT 0 NOT NULL,
    actualizacion_1 timestamp with time zone,
    actualizacion_2 timestamp with time zone,
    actualizacion_3 timestamp with time zone,
    actualizacion_4 timestamp with time zone,
    actualizacion_5 timestamp with time zone,
    actualizacion_6 timestamp with time zone,
    actualizacion_7 timestamp with time zone,
    actualizacion_8 timestamp with time zone,
    actualizacion_9 timestamp with time zone,
    actualizacion_10 timestamp with time zone,
    actualizacion_11 timestamp with time zone,
    actualizacion_12 timestamp with time zone,
    factura_ultima_1 character varying DEFAULT ''::character varying,
    oc_ultima_1 character varying DEFAULT ''::character varying,
    factura_ultima_2 character varying DEFAULT ''::character varying,
    oc_ultima_2 character varying DEFAULT ''::character varying,
    factura_ultima_3 character varying DEFAULT ''::character varying,
    oc_ultima_3 character varying DEFAULT ''::character varying,
    factura_ultima_4 character varying DEFAULT ''::character varying,
    oc_ultima_4 character varying DEFAULT ''::character varying,
    factura_ultima_5 character varying DEFAULT ''::character varying,
    oc_ultima_5 character varying DEFAULT ''::character varying,
    factura_ultima_6 character varying DEFAULT ''::character varying,
    oc_ultima_6 character varying DEFAULT ''::character varying,
    factura_ultima_7 character varying DEFAULT ''::character varying,
    oc_ultima_7 character varying DEFAULT ''::character varying,
    factura_ultima_8 character varying DEFAULT ''::character varying,
    oc_ultima_8 character varying DEFAULT ''::character varying,
    factura_ultima_9 character varying DEFAULT ''::character varying,
    oc_ultima_9 character varying DEFAULT ''::character varying,
    factura_ultima_10 character varying DEFAULT ''::character varying,
    oc_ultima_10 character varying DEFAULT ''::character varying,
    factura_ultima_11 character varying DEFAULT ''::character varying,
    oc_ultima_11 character varying DEFAULT ''::character varying,
    factura_ultima_12 character varying DEFAULT ''::character varying,
    oc_ultima_12 character varying DEFAULT ''::character varying
);


--
-- Name: TABLE inv_prod_cost_prom; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.inv_prod_cost_prom IS 'Los costos son en pesos(M.N.)';


--
-- Name: inv_prod_cost_prom_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod_cost_prom_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod_cost_prom_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_prod_cost_prom_id_seq OWNED BY public.inv_prod_cost_prom.id;


--
-- Name: inv_prod_costos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_costos (
    id integer NOT NULL,
    ano smallint DEFAULT 0,
    inv_prod_id integer DEFAULT 0,
    inv_prod_presentacion_id integer DEFAULT 0,
    costo_imp_1 double precision DEFAULT 0,
    costo_dir_1 double precision DEFAULT 0,
    precio_min_1 double precision DEFAULT 0,
    actualizacion_1 timestamp with time zone,
    usr_id_actualiza_1 integer DEFAULT 0,
    costo_imp_2 double precision DEFAULT 0,
    costo_dir_2 double precision DEFAULT 0,
    precio_min_2 double precision DEFAULT 0,
    actualizacion_2 timestamp with time zone,
    usr_id_actualiza_2 integer DEFAULT 0,
    costo_imp_3 double precision DEFAULT 0,
    costo_dir_3 double precision DEFAULT 0,
    precio_min_3 double precision DEFAULT 0,
    actualizacion_3 timestamp with time zone,
    usr_id_actualiza_3 integer DEFAULT 0,
    costo_imp_4 double precision DEFAULT 0,
    costo_dir_4 double precision DEFAULT 0,
    precio_min_4 double precision DEFAULT 0,
    actualizacion_4 timestamp with time zone,
    usr_id_actualiza_4 integer DEFAULT 0,
    costo_imp_5 double precision DEFAULT 0,
    costo_dir_5 double precision DEFAULT 0,
    precio_min_5 double precision DEFAULT 0,
    actualizacion_5 timestamp with time zone,
    usr_id_actualiza_5 integer DEFAULT 0,
    costo_imp_6 double precision DEFAULT 0,
    costo_dir_6 double precision DEFAULT 0,
    precio_min_6 double precision DEFAULT 0,
    actualizacion_6 timestamp with time zone,
    usr_id_actualiza_6 integer DEFAULT 0,
    costo_imp_7 double precision DEFAULT 0,
    costo_dir_7 double precision DEFAULT 0,
    precio_min_7 double precision DEFAULT 0,
    actualizacion_7 timestamp with time zone,
    usr_id_actualiza_7 integer DEFAULT 0,
    costo_imp_8 double precision DEFAULT 0,
    costo_dir_8 double precision DEFAULT 0,
    precio_min_8 double precision DEFAULT 0,
    actualizacion_8 timestamp with time zone,
    usr_id_actualiza_8 integer DEFAULT 0,
    costo_imp_9 double precision DEFAULT 0,
    costo_dir_9 double precision DEFAULT 0,
    precio_min_9 double precision DEFAULT 0,
    actualizacion_9 timestamp with time zone,
    usr_id_actualiza_9 integer DEFAULT 0,
    costo_imp_10 double precision DEFAULT 0,
    costo_dir_10 double precision DEFAULT 0,
    precio_min_10 double precision DEFAULT 0,
    actualizacion_10 timestamp with time zone,
    usr_id_actualiza_10 integer DEFAULT 0,
    costo_imp_11 double precision DEFAULT 0,
    costo_dir_11 double precision DEFAULT 0,
    precio_min_11 double precision DEFAULT 0,
    actualizacion_11 timestamp with time zone,
    usr_id_actualiza_11 integer DEFAULT 0,
    costo_imp_12 double precision DEFAULT 0,
    costo_dir_12 double precision DEFAULT 0,
    precio_min_12 double precision DEFAULT 0,
    actualizacion_12 timestamp with time zone,
    usr_id_actualiza_12 integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    costo_adic_1 double precision DEFAULT 0,
    costo_adic_2 double precision DEFAULT 0,
    costo_adic_3 double precision DEFAULT 0,
    costo_adic_4 double precision DEFAULT 0,
    costo_adic_5 double precision DEFAULT 0,
    costo_adic_6 double precision DEFAULT 0,
    costo_adic_7 double precision DEFAULT 0,
    costo_adic_8 double precision DEFAULT 0,
    costo_adic_9 double precision DEFAULT 0,
    costo_adic_10 double precision DEFAULT 0,
    costo_adic_11 double precision DEFAULT 0,
    costo_adic_12 double precision
);


--
-- Name: inv_prod_costos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod_costos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod_costos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_prod_costos_id_seq OWNED BY public.inv_prod_costos.id;


--
-- Name: inv_prod_equiv; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_equiv (
    id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    inv_prod_id_equiv integer NOT NULL,
    observaciones character varying
);


--
-- Name: inv_prod_equiv_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod_equiv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod_equiv_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_prod_equiv_id_seq OWNED BY public.inv_prod_equiv.id;


--
-- Name: inv_prod_familias; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_familias (
    id integer NOT NULL,
    identificador_familia_padre integer,
    titulo character varying NOT NULL,
    descripcion text NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    inv_prod_tipo_id integer DEFAULT 0
);


--
-- Name: inv_prod_familias_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod_familias_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod_familias_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_prod_familias_id_seq OWNED BY public.inv_prod_familias.id;


--
-- Name: inv_prod_grupos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_grupos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    descripcion text NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0
);


--
-- Name: inv_prod_grupos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod_grupos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod_grupos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_prod_grupos_id_seq OWNED BY public.inv_prod_grupos.id;


--
-- Name: inv_prod_lineas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_lineas (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    descripcion text NOT NULL,
    inv_seccion_id integer,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_creacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0
);


--
-- Name: inv_prod_lineas2_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod_lineas2_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod_lineas2_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_prod_lineas2_id_seq OWNED BY public.inv_prod_lineas.id;


--
-- Name: inv_prod_pres_x_prod; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_pres_x_prod (
    id integer NOT NULL,
    producto_id integer,
    presentacion_id integer,
    producto_id_aux integer
);


--
-- Name: inv_prod_presentaciones_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod_presentaciones_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod_presentaciones; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_presentaciones (
    id integer DEFAULT nextval('public.inv_prod_presentaciones_id_seq'::regclass) NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    cantidad double precision DEFAULT 0
);


--
-- Name: COLUMN inv_prod_presentaciones.cantidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_prod_presentaciones.cantidad IS 'Equivalencia de la presentacion en Cantidad de acuerdo a la Unidad de Medida definida.';


--
-- Name: inv_prod_tipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_tipos (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false,
    cfdi_prodserv_id integer
);


--
-- Name: COLUMN inv_prod_tipos.cfdi_prodserv_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_prod_tipos.cfdi_prodserv_id IS 'Llave foranea para claves del SAT';


--
-- Name: inv_prod_tipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod_tipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod_tipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_prod_tipos_id_seq OWNED BY public.inv_prod_tipos.id;


--
-- Name: inv_prod_unidades; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_prod_unidades (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    titulo_abr character varying DEFAULT ''::character varying,
    decimales integer,
    cfdi_unidad_id integer NOT NULL
);


--
-- Name: COLUMN inv_prod_unidades.cfdi_unidad_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.inv_prod_unidades.cfdi_unidad_id IS 'Llave foranea para lidiar con claves del sat con respecto a unidades';


--
-- Name: inv_prod_unidades_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_prod_unidades_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_prod_unidades_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_prod_unidades_id_seq OWNED BY public.inv_prod_unidades.id;


--
-- Name: inv_secciones; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_secciones (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    borrado_logico boolean,
    activa boolean,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    descripcion character varying,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0
);


--
-- Name: inv_secciones_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_secciones_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_secciones_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_secciones_id_seq OWNED BY public.inv_secciones.id;


--
-- Name: inv_stock_clasificaciones; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_stock_clasificaciones (
    id integer NOT NULL,
    titulo character varying,
    descripcion character varying,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp without time zone,
    momento_actualizacion timestamp without time zone,
    momento_baja timestamp without time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0
);


--
-- Name: inv_stock_clasificaciones_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_stock_clasificaciones_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_stock_clasificaciones_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_stock_clasificaciones_id_seq OWNED BY public.inv_stock_clasificaciones.id;


--
-- Name: inv_suc_alm; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_suc_alm (
    id integer NOT NULL,
    almacen_id integer NOT NULL,
    sucursal_id integer NOT NULL
);


--
-- Name: inv_suc_alm_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_suc_alm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_suc_alm_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_suc_alm_id_seq OWNED BY public.inv_suc_alm.id;


--
-- Name: inv_tras; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_tras (
    id integer NOT NULL,
    folio character varying NOT NULL,
    fecha_traspaso date,
    gral_suc_id_origen integer DEFAULT 0,
    inv_alm_id_origen integer,
    gral_suc_id_destino integer DEFAULT 0,
    inv_alm_id_destino integer,
    observaciones text DEFAULT ''::text,
    motivo_cancelacion text DEFAULT ''::text,
    cancelacion boolean DEFAULT false,
    momento_cancelacion timestamp with time zone,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_cancelacion integer DEFAULT 0
);


--
-- Name: TABLE inv_tras; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.inv_tras IS 'Tabla de Traspasos';


--
-- Name: inv_tras_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_tras_det (
    id integer NOT NULL,
    inv_tras_id integer DEFAULT 0,
    inv_prod_id integer DEFAULT 0,
    cantidad_tras double precision DEFAULT 0,
    inv_prod_presentacion_id integer DEFAULT 0
);


--
-- Name: TABLE inv_tras_det; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.inv_tras_det IS 'Tabla Detalles de Orden de Traspaso';


--
-- Name: inv_tras_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_tras_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_tras_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_tras_det_id_seq OWNED BY public.inv_tras_det.id;


--
-- Name: inv_tras_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_tras_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_tras_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_tras_id_seq OWNED BY public.inv_tras.id;


--
-- Name: inv_zonas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.inv_zonas (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    descripcion character varying NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    estatus boolean
);


--
-- Name: inv_zonas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.inv_zonas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: inv_zonas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.inv_zonas_id_seq OWNED BY public.inv_zonas.id;


--
-- Name: ivatipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ivatipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ivatipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ivatipos_id_seq OWNED BY public.erp_ivatipos.id;


--
-- Name: listasprecios_detallada_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.listasprecios_detallada_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: listasprecios_detallada_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.listasprecios_detallada_id_seq OWNED BY public.erp_listasprecios_detallada.id;


--
-- Name: listasprecios_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.listasprecios_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: listasprecios_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.listasprecios_id_seq OWNED BY public.erp_listasprecios.id;


--
-- Name: log_choferes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.log_choferes (
    id integer NOT NULL,
    clave character varying DEFAULT ''::character varying,
    nombre character varying DEFAULT ''::character varying NOT NULL,
    apellido_paterno character varying DEFAULT ''::character varying,
    apellido_materno character varying DEFAULT ''::character varying,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: log_choferes_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.log_choferes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: log_choferes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.log_choferes_id_seq OWNED BY public.log_choferes.id;


--
-- Name: log_rutas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.log_rutas (
    id integer NOT NULL,
    folio character varying NOT NULL,
    log_chofer_id integer NOT NULL,
    log_vehiculo_id integer NOT NULL,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    confirmado boolean DEFAULT false
);


--
-- Name: COLUMN log_rutas.confirmado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.log_rutas.confirmado IS 'False=Todavia se puede agregar facturas a la ruta, True=No se puede agregar mas facturas';


--
-- Name: log_rutas_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.log_rutas_detalle (
    id integer NOT NULL,
    log_ruta_id integer NOT NULL,
    fac_docs_id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    envase character varying NOT NULL
);


--
-- Name: log_rutas_detalle_cobro; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.log_rutas_detalle_cobro (
    id integer NOT NULL,
    log_ruta_id integer,
    cxc_fac_rev_cob_detalle_id integer
);


--
-- Name: log_rutas_detalle_cobro_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.log_rutas_detalle_cobro_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: log_rutas_detalle_cobro_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.log_rutas_detalle_cobro_id_seq OWNED BY public.log_rutas_detalle_cobro.id;


--
-- Name: log_rutas_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.log_rutas_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: log_rutas_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.log_rutas_detalle_id_seq OWNED BY public.log_rutas_detalle.id;


--
-- Name: log_rutas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.log_rutas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: log_rutas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.log_rutas_id_seq OWNED BY public.log_rutas.id;


--
-- Name: log_vehiculos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.log_vehiculos (
    id integer NOT NULL,
    placa character varying DEFAULT ''::character varying,
    numero_serie character varying DEFAULT ''::character varying,
    modelo character varying DEFAULT ''::character varying,
    color character varying DEFAULT ''::character varying,
    marca character varying DEFAULT ''::character varying,
    numero_economico character varying DEFAULT ''::character varying,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone NOT NULL,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    id_usuario_creacion integer DEFAULT 0,
    id_usuario_actualizacion integer DEFAULT 0,
    id_usuario_baja integer DEFAULT 0
);


--
-- Name: log_vehiculos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.log_vehiculos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: log_vehiculos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.log_vehiculos_id_seq OWNED BY public.log_vehiculos.id;


--
-- Name: mascaras_para_validaciones_por_app_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.mascaras_para_validaciones_por_app_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: mascaras_para_validaciones_por_app_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.mascaras_para_validaciones_por_app_id_seq OWNED BY public.erp_mascaras_para_validaciones_por_app.id;


--
-- Name: moneda_vers_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.moneda_vers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: moneda_vers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.moneda_vers_id_seq OWNED BY public.erp_monedavers.id;


--
-- Name: monedas_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.monedas_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: monedas_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.monedas_id_seq OWNED BY public.erp_monedas.id;


--
-- Name: nom_deduc; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_deduc (
    id integer NOT NULL,
    clave character varying DEFAULT ''::character varying NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    nom_deduc_tipo_id integer DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualiza timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_cancela integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: nom_deduc_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_deduc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_deduc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_deduc_id_seq OWNED BY public.nom_deduc.id;


--
-- Name: nom_deduc_tipo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_deduc_tipo (
    id integer NOT NULL,
    clave character varying DEFAULT ''::character varying NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL
);


--
-- Name: nom_deduc_tipo_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_deduc_tipo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_deduc_tipo_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_deduc_tipo_id_seq OWNED BY public.nom_deduc_tipo.id;


--
-- Name: nom_percep; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_percep (
    id integer NOT NULL,
    clave character varying DEFAULT ''::character varying NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    nom_percep_tipo_id integer DEFAULT 0,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualiza timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_cancela integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: nom_percep_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_percep_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_percep_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_percep_id_seq OWNED BY public.nom_percep.id;


--
-- Name: nom_percep_tipo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_percep_tipo (
    id integer NOT NULL,
    clave character varying DEFAULT ''::character varying NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL
);


--
-- Name: nom_percep_tipo_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_percep_tipo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_percep_tipo_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_percep_tipo_id_seq OWNED BY public.nom_percep_tipo.id;


--
-- Name: nom_periodicidad_pago; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_periodicidad_pago (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    no_periodos integer DEFAULT 0,
    activo boolean DEFAULT true NOT NULL,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualiza timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: nom_periodicidad_pago_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_periodicidad_pago_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_periodicidad_pago_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_periodicidad_pago_id_seq OWNED BY public.nom_periodicidad_pago.id;


--
-- Name: nom_periodos_conf; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_periodos_conf (
    id integer NOT NULL,
    ano integer DEFAULT 0 NOT NULL,
    nom_periodicidad_pago_id integer,
    prefijo character varying DEFAULT ''::character varying,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualiza timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_crea integer DEFAULT 0,
    gral_usr_id_actualiza integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: nom_periodos_conf_det; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_periodos_conf_det (
    id integer NOT NULL,
    nom_periodos_conf_id integer NOT NULL,
    folio character varying DEFAULT ''::character varying,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    fecha_ini date,
    fecha_fin date,
    estatus boolean DEFAULT false
);


--
-- Name: nom_periodos_conf_det_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_periodos_conf_det_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_periodos_conf_det_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_periodos_conf_det_id_seq OWNED BY public.nom_periodos_conf_det.id;


--
-- Name: nom_periodos_conf_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_periodos_conf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_periodos_conf_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_periodos_conf_id_seq OWNED BY public.nom_periodos_conf.id;


--
-- Name: nom_regimen_contratacion; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_regimen_contratacion (
    id integer NOT NULL,
    clave character varying DEFAULT ''::character varying NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL
);


--
-- Name: nom_regimen_contratacion_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_regimen_contratacion_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_regimen_contratacion_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_regimen_contratacion_id_seq OWNED BY public.nom_regimen_contratacion.id;


--
-- Name: nom_riesgo_puesto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_riesgo_puesto (
    id integer NOT NULL,
    clave character varying DEFAULT ''::character varying NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL
);


--
-- Name: nom_riesgo_puesto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_riesgo_puesto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_riesgo_puesto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_riesgo_puesto_id_seq OWNED BY public.nom_riesgo_puesto.id;


--
-- Name: nom_tipo_contrato; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_tipo_contrato (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL
);


--
-- Name: nom_tipo_contrato_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_tipo_contrato_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_tipo_contrato_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_tipo_contrato_id_seq OWNED BY public.nom_tipo_contrato.id;


--
-- Name: nom_tipo_hrs_extra; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_tipo_hrs_extra (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL
);


--
-- Name: nom_tipo_hrs_extra_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_tipo_hrs_extra_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_tipo_hrs_extra_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_tipo_hrs_extra_id_seq OWNED BY public.nom_tipo_hrs_extra.id;


--
-- Name: nom_tipo_incapacidad; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_tipo_incapacidad (
    id integer NOT NULL,
    clave character varying DEFAULT ''::character varying NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL
);


--
-- Name: nom_tipo_incapacidad_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_tipo_incapacidad_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_tipo_incapacidad_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_tipo_incapacidad_id_seq OWNED BY public.nom_tipo_incapacidad.id;


--
-- Name: nom_tipo_jornada; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.nom_tipo_jornada (
    id integer NOT NULL,
    titulo character varying DEFAULT ''::character varying NOT NULL,
    activo boolean DEFAULT true NOT NULL
);


--
-- Name: nom_tipo_jornada_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.nom_tipo_jornada_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: nom_tipo_jornada_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.nom_tipo_jornada_id_seq OWNED BY public.nom_tipo_jornada.id;


--
-- Name: ordencompras_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ordencompras_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ordencompras_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.ordencompras_id_seq OWNED BY public.erp_ordencompras.id;


--
-- Name: pagos; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.pagos AS
 SELECT erp_pagos.numero_transaccion,
    gral_emp.cp AS lugar_expedicion,
    gral_emp.rfc,
    gral_emp.titulo AS nombre,
    gral_emp.regimen_fiscal,
    cxc_clie.rfc AS rfc_receptor,
    cxc_clie.razon_social AS nombre_receptor,
    gral_mon.descripcion AS moneda_fac,
    gral_mon.simbolo AS simbolo_moneda_fac,
    erp_pagos_detalles.serie_folio,
    fac_cfdis.doc AS id_documento,
    erp_pagos.fecha_deposito AS fecha_pago,
    erp_pagos_formas.clave_sat AS forma_de_pago_p,
        CASE
            WHEN (erp_pagos.moneda_id = 1) THEN 'MXN'::text
            WHEN (erp_pagos.moneda_id = 2) THEN 'USD'::text
            ELSE NULL::text
        END AS moneda_p,
    erp_pagos.tipo_cambio AS tipo_cambio_p,
    gral_mon.iso_4217 AS moneda_dr,
    erp_h_facturas.moneda_id,
    erp_pagos.numero_cheque AS pago_cheque,
    erp_pagos.referencia AS pago_transferencia,
    erp_pagos.numero_tarjeta AS pago_tarjeta,
    public.calcula_monto_aplicado(erp_h_facturas.moneda_id, erp_pagos.moneda_id, erp_pagos.tipo_cambio, erp_pagos_detalles.cantidad, (0.00)::double precision) AS monto_aplicado_mn,
    (erp_h_facturas.saldo_factura + erp_h_facturas.total_pagos) AS imp_saldo_ant,
    erp_pagos_detalles.cantidad AS imp_pagado,
    public.calcula_insoluto(erp_h_facturas.saldo_factura, erp_h_facturas.total_pagos, erp_pagos_detalles.cantidad, (0.00)::double precision) AS imp_saldo_insoluto,
    erp_pagos_detalles.cantidad AS importe_pagado,
    public.calcula_importe_facturado(erp_pagos_detalles.cantidad, erp_pagos.tipo_cambio, (0.00)::double precision) AS importe_facturado,
    public.calcula_tc_dr(erp_pagos_detalles.cantidad, (erp_pagos_detalles.cantidad * erp_pagos.tipo_cambio), (0.00000000)::double precision) AS xxx,
        CASE
            WHEN (erp_pagos_detalles.cancelacion = true) THEN 'CANCELADO'::text
            ELSE ''::text
        END AS estado
   FROM ((((((((public.erp_pagos
     LEFT JOIN public.erp_pagos_detalles ON ((erp_pagos_detalles.pago_id = erp_pagos.id)))
     LEFT JOIN public.erp_h_facturas ON (((erp_h_facturas.serie_folio)::text = (erp_pagos_detalles.serie_folio)::text)))
     LEFT JOIN public.fac_docs ON (((fac_docs.serie_folio)::text = (erp_pagos_detalles.serie_folio)::text)))
     LEFT JOIN public.fac_cfdis ON (((fac_cfdis.ref_id)::text = (fac_docs.ref_id)::text)))
     LEFT JOIN public.gral_mon ON ((gral_mon.id = erp_h_facturas.moneda_id)))
     LEFT JOIN public.erp_pagos_formas ON ((erp_pagos_formas.id = erp_pagos.forma_pago_id)))
     LEFT JOIN public.gral_emp ON ((gral_emp.id = erp_pagos.empresa_id)))
     LEFT JOIN public.cxc_clie ON ((cxc_clie.id = erp_pagos.cliente_id)))
  ORDER BY erp_pagos.numero_transaccion;


--
-- Name: poc_cot; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_cot (
    id integer NOT NULL,
    folio character varying NOT NULL,
    tipo integer,
    gral_usr_id_creacion integer,
    observaciones text,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    proceso_id integer DEFAULT 1 NOT NULL,
    gral_usr_id_actualizacion integer DEFAULT 0,
    incluye_img_desc boolean DEFAULT false,
    gral_usr_id_baja integer DEFAULT 0,
    tipo_cambio double precision DEFAULT 0,
    gral_mon_id integer DEFAULT 0,
    fecha date,
    cxc_agen_id integer DEFAULT 0,
    incluye_iva boolean DEFAULT false,
    subtotal double precision DEFAULT 0,
    impuesto double precision DEFAULT 0,
    total double precision DEFAULT 0,
    dias_vigencia smallint DEFAULT 0,
    tc_usd double precision DEFAULT 0 NOT NULL
);


--
-- Name: TABLE poc_cot; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.poc_cot IS 'Tabla header de cotizaciones';


--
-- Name: COLUMN poc_cot.tipo; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_cot.tipo IS 'Tipo 1=Cotizacion para Cliente, 2=Cotizacion para Prospecto';


--
-- Name: poc_cot_clie; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_cot_clie (
    id integer NOT NULL,
    poc_cot_id integer NOT NULL,
    cxc_clie_id integer NOT NULL
);


--
-- Name: TABLE poc_cot_clie; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.poc_cot_clie IS 'Tabla que relaciona la cotizacion con un Cliente';


--
-- Name: poc_cot_clie_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_cot_clie_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_cot_clie_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_cot_clie_id_seq OWNED BY public.poc_cot_clie.id;


--
-- Name: poc_cot_condiciones_com; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_cot_condiciones_com (
    id integer NOT NULL,
    descripcion text DEFAULT ''::text,
    borrado_logico boolean DEFAULT false,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: TABLE poc_cot_condiciones_com; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.poc_cot_condiciones_com IS 'Tabla para las condiciones comerciales que se mostrara en la Cotizacion.';


--
-- Name: poc_cot_condiciones_com_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_cot_condiciones_com_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_cot_condiciones_com_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_cot_condiciones_com_id_seq OWNED BY public.poc_cot_condiciones_com.id;


--
-- Name: poc_cot_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_cot_detalle (
    id integer NOT NULL,
    inv_prod_id integer NOT NULL,
    inv_presentacion_id integer NOT NULL,
    cantidad double precision DEFAULT 0 NOT NULL,
    precio_unitario double precision DEFAULT 0,
    poc_cot_id integer NOT NULL,
    gral_mon_id integer DEFAULT 0,
    gral_impto_id integer DEFAULT 0,
    valor_imp double precision DEFAULT 0,
    inv_prod_unidad_id integer DEFAULT 0 NOT NULL,
    requiere_aut boolean DEFAULT false NOT NULL,
    autorizado boolean DEFAULT false NOT NULL,
    precio_aut double precision DEFAULT 0 NOT NULL,
    gral_usr_id_aut integer DEFAULT 0 NOT NULL
);


--
-- Name: poc_cot_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_cot_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_cot_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_cot_detalle_id_seq OWNED BY public.poc_cot_detalle.id;


--
-- Name: poc_cot_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_cot_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_cot_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_cot_id_seq OWNED BY public.poc_cot.id;


--
-- Name: poc_cot_incoterm_x_cot; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_cot_incoterm_x_cot (
    id integer NOT NULL,
    poc_cot_id integer NOT NULL,
    poc_cot_incoterms_id integer NOT NULL
);


--
-- Name: poc_cot_incoterm_x_cot_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_cot_incoterm_x_cot_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_cot_incoterm_x_cot_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_cot_incoterm_x_cot_id_seq OWNED BY public.poc_cot_incoterm_x_cot.id;


--
-- Name: poc_cot_incoterms; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_cot_incoterms (
    id integer NOT NULL,
    nombre character varying DEFAULT ''::character varying,
    descripcion_esp character varying DEFAULT ''::character varying,
    descripcion_ing character varying DEFAULT ''::character varying,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: poc_cot_incoterms_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_cot_incoterms_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_cot_incoterms_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_cot_incoterms_id_seq OWNED BY public.poc_cot_incoterms.id;


--
-- Name: poc_cot_politicas_pago; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_cot_politicas_pago (
    id integer NOT NULL,
    descripcion text DEFAULT ''::text,
    borrado_logico boolean DEFAULT false,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: TABLE poc_cot_politicas_pago; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.poc_cot_politicas_pago IS 'Tabla para las Politicas de Pago que se Mostrara en la Cotizacion.';


--
-- Name: poc_cot_politicas_pago_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_cot_politicas_pago_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_cot_politicas_pago_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_cot_politicas_pago_id_seq OWNED BY public.poc_cot_politicas_pago.id;


--
-- Name: poc_cot_prospecto; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_cot_prospecto (
    id integer NOT NULL,
    poc_cot_id integer NOT NULL,
    crm_prospecto_id integer NOT NULL
);


--
-- Name: TABLE poc_cot_prospecto; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.poc_cot_prospecto IS 'Tabla que relaciona la cotizacion con un Prospecto';


--
-- Name: poc_cot_prospecto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_cot_prospecto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_cot_prospecto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_cot_prospecto_id_seq OWNED BY public.poc_cot_prospecto.id;


--
-- Name: poc_cot_saludo_despedida; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_cot_saludo_despedida (
    id integer NOT NULL,
    tipo character varying(9),
    titulo text DEFAULT ''::text,
    status boolean DEFAULT false,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    momento_actualizacion timestamp with time zone,
    gral_usr_id_actualizacion integer DEFAULT 0
);


--
-- Name: COLUMN poc_cot_saludo_despedida.status; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_cot_saludo_despedida.status IS 'TRUE=Activo, FALSE=Inactivo';


--
-- Name: poc_cot_saludo_despedida_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_cot_saludo_despedida_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_cot_saludo_despedida_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_cot_saludo_despedida_id_seq OWNED BY public.poc_cot_saludo_despedida.id;


--
-- Name: poc_ped_bo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_ped_bo (
    id integer NOT NULL,
    folio character varying NOT NULL,
    poc_ped_detalle_id integer,
    inv_prod_id integer DEFAULT 0,
    cantidad double precision DEFAULT 0,
    cantidad_surtida double precision DEFAULT 0,
    inv_alm_id integer,
    inv_mov_tipo_id integer,
    estatus smallint DEFAULT 0,
    cxc_clie_id integer,
    orden_compra character varying DEFAULT ''::character varying,
    observaciones text,
    cancelado boolean DEFAULT false,
    fecha_vencimiento date,
    autorizado boolean DEFAULT false,
    momento_autorizacion timestamp with time zone,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_autoriza integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_cancelacion integer DEFAULT 0,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0
);


--
-- Name: COLUMN poc_ped_bo.estatus; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_ped_bo.estatus IS '0=No ha sido tocado por Modulo de Producci√≥n, 1=Ya ha sido tocado por Modulo de Producci√≥n';


--
-- Name: poc_ped_bo_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_ped_bo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_ped_bo_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_ped_bo_id_seq OWNED BY public.poc_ped_bo.id;


--
-- Name: poc_ped_cot; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_ped_cot (
    id integer NOT NULL,
    poc_ped_id integer NOT NULL,
    poc_cot_id integer NOT NULL,
    poc_ped_det_id integer NOT NULL,
    poc_cot_det_id integer NOT NULL
);


--
-- Name: poc_ped_cot_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_ped_cot_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_ped_cot_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_ped_cot_id_seq OWNED BY public.poc_ped_cot.id;


--
-- Name: poc_pedidos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_pedidos (
    id integer NOT NULL,
    folio character varying DEFAULT ''::character varying,
    cxc_clie_id integer NOT NULL,
    moneda_id integer,
    observaciones text,
    subtotal double precision,
    impuesto double precision,
    monto_retencion double precision DEFAULT 0,
    total double precision,
    tasa_retencion_immex double precision DEFAULT 0,
    tipo_cambio double precision DEFAULT 0,
    cxc_agen_id integer DEFAULT 0,
    cxp_prov_credias_id integer DEFAULT 0,
    orden_compra character varying DEFAULT ''::character varying,
    proceso_id integer NOT NULL,
    fecha_compromiso date,
    lugar_entrega character varying DEFAULT ''::character varying,
    transporte character varying DEFAULT ''::character varying,
    cancelado boolean DEFAULT false,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_cancelacion timestamp with time zone,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_cancelacion integer DEFAULT 0,
    tipo_documento integer DEFAULT 0,
    gral_usr_id_autoriza integer DEFAULT 0,
    momento_autorizacion timestamp with time zone,
    fac_metodos_pago_id integer DEFAULT 0,
    no_cuenta character varying DEFAULT ''::character varying,
    enviar_ruta boolean DEFAULT false,
    inv_alm_id smallint DEFAULT 0,
    cxc_clie_df_id integer DEFAULT 0,
    enviar_obser_fac boolean DEFAULT false,
    flete boolean DEFAULT false NOT NULL,
    monto_ieps double precision DEFAULT 0,
    monto_descto double precision DEFAULT 0 NOT NULL,
    motivo_descto character varying DEFAULT ''::character varying,
    porcentaje_descto double precision DEFAULT 0,
    folio_cot character varying DEFAULT ''::character varying,
    cfdi_usos_id integer,
    cfdi_metodo_id integer
);


--
-- Name: COLUMN poc_pedidos.enviar_ruta; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_pedidos.enviar_ruta IS 'True=Despues de facturar el pedido debe aparecer en la busqueda de facturas para agregar a la ruta. False=No debe aparecer en la busqueda.';


--
-- Name: COLUMN poc_pedidos.inv_alm_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_pedidos.inv_alm_id IS 'Almacen de donde se toma los productos y se reserva para el pedido';


--
-- Name: COLUMN poc_pedidos.cxc_clie_df_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_pedidos.cxc_clie_df_id IS 'ID de la Direccion Fiscal(cxc_clie_df) para la Facturacion del Pedido. Si el valor de este campo es 0, entonces por default toma la direccion de la tabla de Clientes (cxc_clie)';


--
-- Name: COLUMN poc_pedidos.enviar_obser_fac; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_pedidos.enviar_obser_fac IS 'TRUE=Indica que las observaciones capturadas en el pedido se enviaran a la Facturacion';


--
-- Name: poc_pedidos_detalle; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.poc_pedidos_detalle (
    id integer NOT NULL,
    poc_pedido_id integer,
    inv_prod_id integer NOT NULL,
    presentacion_id integer NOT NULL,
    cantidad double precision,
    precio_unitario double precision,
    gral_imp_id integer DEFAULT 0,
    valor_imp double precision DEFAULT 0,
    facturado boolean DEFAULT false,
    reservado double precision DEFAULT 0,
    backorder boolean DEFAULT false,
    inv_prod_unidad_id integer DEFAULT 0 NOT NULL,
    gral_ieps_id integer DEFAULT 0,
    valor_ieps double precision DEFAULT 0,
    descto double precision DEFAULT 0,
    requisicion boolean DEFAULT false,
    requiere_aut boolean DEFAULT false NOT NULL,
    autorizado boolean DEFAULT false NOT NULL,
    precio_aut double precision DEFAULT 0 NOT NULL,
    gral_usr_id_aut integer DEFAULT 0 NOT NULL,
    gral_imptos_ret_id integer DEFAULT 0 NOT NULL,
    tasa_ret double precision DEFAULT 0 NOT NULL
);


--
-- Name: COLUMN poc_pedidos_detalle.reservado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_pedidos_detalle.reservado IS 'Almacena la cantidad que reserv√≥ en inv_exi';


--
-- Name: COLUMN poc_pedidos_detalle.backorder; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_pedidos_detalle.backorder IS 'TRUE=Gener√≥ BackOrder, FALSE=No gener√≥ BackOrder';


--
-- Name: COLUMN poc_pedidos_detalle.inv_prod_unidad_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_pedidos_detalle.inv_prod_unidad_id IS 'Id de la unidad de medida de venta, puede ser diferente a la unidad de medida en el catalogo de productos.';


--
-- Name: COLUMN poc_pedidos_detalle.requisicion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.poc_pedidos_detalle.requisicion IS 'TRUE=Indica si genero una orden de requision de compra';


--
-- Name: poc_pedidos_detalle_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_pedidos_detalle_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_pedidos_detalle_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_pedidos_detalle_id_seq OWNED BY public.poc_pedidos_detalle.id;


--
-- Name: poc_pedidos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.poc_pedidos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: poc_pedidos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.poc_pedidos_id_seq OWNED BY public.poc_pedidos.id;


--
-- Name: presentaciones_producto_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.presentaciones_producto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: presentaciones_producto_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.presentaciones_producto_id_seq OWNED BY public.inv_prod_pres_x_prod.id;


--
-- Name: pro_orden_prod; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.pro_orden_prod (
    id integer NOT NULL,
    gral_emp_id integer DEFAULT 0 NOT NULL,
    gral_suc_id integer DEFAULT 0 NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    borrado_logico boolean DEFAULT false NOT NULL,
    pro_orden_tipos_id integer DEFAULT 0 NOT NULL,
    folio character varying DEFAULT ''::character varying NOT NULL,
    observaciones text DEFAULT ''::text NOT NULL,
    id_usuario_creacion integer DEFAULT 0 NOT NULL,
    id_usuario_actualizacion integer DEFAULT 0 NOT NULL,
    id_usuario_baja integer DEFAULT 0 NOT NULL,
    fecha_elavorar date,
    pro_proceso_id integer DEFAULT 0 NOT NULL,
    hora_elavorar time with time zone,
    pro_preorden_prod_id integer,
    lote character varying DEFAULT ''::character varying NOT NULL,
    pro_estruc_id integer,
    costo_ultimo double precision DEFAULT 0 NOT NULL,
    env_estatus_id integer DEFAULT 0 NOT NULL,
    solicitante character varying DEFAULT ''::character varying,
    vendedor character varying DEFAULT ''::character varying,
    status_calidad smallint DEFAULT 0 NOT NULL,
    comentarios_calidad text DEFAULT ''::text,
    momento_actualizacion_calidad timestamp with time zone,
    gral_usar_id_actualiza_calidad integer DEFAULT 0
);


--
-- Name: pro_orden_prod_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.pro_orden_prod_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pro_orden_prod_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.pro_orden_prod_id_seq OWNED BY public.pro_orden_prod.id;


--
-- Name: pro_ordenprod_invosal; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.pro_ordenprod_invosal (
    id integer NOT NULL,
    pro_orden_prod_id integer DEFAULT 0 NOT NULL,
    inv_osal_id integer DEFAULT 0 NOT NULL
);


--
-- Name: pro_ordenprod_invosal_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.pro_ordenprod_invosal_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pro_ordenprod_invosal_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.pro_ordenprod_invosal_id_seq OWNED BY public.pro_ordenprod_invosal.id;


--
-- Name: pro_par; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.pro_par (
    id integer NOT NULL,
    inv_alm_id integer NOT NULL,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_suc_id integer NOT NULL,
    gral_emp_id integer
);


--
-- Name: TABLE pro_par; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON TABLE public.pro_par IS 'Aqui se definen los parametros para la Produccion. La definicion de parametros es por Sucursal.';


--
-- Name: COLUMN pro_par.inv_alm_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.pro_par.inv_alm_id IS 'Aqui se guarda el id de el almacen de el que se tomara la materi prima para produccion.';


--
-- Name: pro_par_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.pro_par_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: pro_par_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.pro_par_id_seq OWNED BY public.pro_par.id;


--
-- Name: productos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.productos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: productos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.productos_id_seq OWNED BY public.inv_prod_anterior.id;


--
-- Name: proveedoreswebusers_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.proveedoreswebusers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: proveedoreswebusers_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.proveedoreswebusers_id_seq OWNED BY public.erp_proveedoreswebusers.id;


--
-- Name: proveedortipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.proveedortipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: proveedortipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.proveedortipos_id_seq OWNED BY public.cxp_prov_clases.id;


--
-- Name: religions_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.religions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: religions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.religions_id_seq OWNED BY public.erp_religions.id;


--
-- Name: sangre_tipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.sangre_tipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: sangre_tipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.sangre_tipos_id_seq OWNED BY public.erp_sangretipos.id;


--
-- Name: tes_ban; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tes_ban (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    descripcion character varying NOT NULL,
    borrado_logico boolean DEFAULT false,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    id_aux_banco_kemikal integer,
    clave character varying DEFAULT ''::character varying
);


--
-- Name: COLUMN tes_ban.clave; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_ban.clave IS 'Clave del catalogo de bancos del SAT';


--
-- Name: tes_ban_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.tes_ban_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: tes_ban_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.tes_ban_id_seq OWNED BY public.tes_ban.id;


--
-- Name: tes_che; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tes_che (
    id integer NOT NULL,
    titulo character varying,
    aut_modif_consecutivo boolean,
    aut_modif_fecha boolean,
    aut_modif_cheque boolean,
    gral_pais_id integer,
    gral_mun_id integer,
    gral_edo_id integer,
    moneda_id integer,
    tes_ban_id integer,
    imp_cheque_ingles boolean DEFAULT false NOT NULL,
    calle character varying,
    numero character varying,
    colonia character varying,
    clabe character varying,
    num_contrato character varying,
    num_sucursal integer,
    nombre_sucursal character varying,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    borrado_logico boolean,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0,
    gral_emp_id integer,
    gral_suc_id integer,
    id_aux integer,
    codigo_postal character varying DEFAULT ''::character varying,
    telefono1 character varying DEFAULT ''::character varying,
    extencion1 character varying DEFAULT ''::character varying,
    telefono2 character varying DEFAULT ''::character varying,
    extencion2 character varying DEFAULT ''::character varying,
    fax character varying DEFAULT ''::character varying,
    gerente character varying DEFAULT ''::character varying,
    ejecutivo character varying DEFAULT ''::character varying,
    email character varying DEFAULT ''::character varying,
    ctb_cta_id_activo integer DEFAULT 0
);


--
-- Name: tes_che_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.tes_che_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: tes_che_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.tes_che_id_seq OWNED BY public.tes_che.id;


--
-- Name: tes_con; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tes_con (
    id integer NOT NULL,
    titulo character varying NOT NULL,
    descripcion character varying NOT NULL,
    tipo boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    borrado_logico boolean DEFAULT false,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0
);


--
-- Name: tes_con_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.tes_con_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: tes_con_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.tes_con_id_seq OWNED BY public.tes_con.id;


--
-- Name: tes_mov; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tes_mov (
    id integer NOT NULL,
    tes_che_id integer DEFAULT 0,
    ano integer,
    mes smallint,
    consecutivo_cheque integer,
    tes_mov_tipo_id integer,
    tes_con_id integer,
    gral_suc_id integer,
    beneficiario_id integer,
    nombre_beneficiario character varying,
    tipo_beneficiario smallint,
    cantidad double precision,
    observacion text,
    referencia character varying,
    fecha_emision timestamp with time zone,
    cancelado boolean DEFAULT false,
    retenido boolean DEFAULT false,
    no_operado boolean DEFAULT true,
    conciliado boolean DEFAULT true,
    cant_letra text,
    fecha_conciliado timestamp with time zone,
    sucursal_ctb integer,
    poliza integer DEFAULT 0,
    ref_num integer,
    gral_usr_id_captura integer DEFAULT 0,
    gral_usr_id_cancela integer DEFAULT 0,
    fecha_captura timestamp with time zone,
    fecha_cancela timestamp with time zone,
    gral_mod_id integer DEFAULT 0,
    anticipo_proveedor boolean DEFAULT false,
    anticipo_cliente boolean DEFAULT false,
    obs_retenido text,
    referencia_transfer character varying,
    obs_conciliado text,
    obs_cancela text,
    es_traspaso boolean DEFAULT false,
    cancelado_x_proc boolean
);


--
-- Name: COLUMN tes_mov.tes_che_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.tes_che_id IS 'Referencia al id de la tabla tes_che, tabla de chequeras.';


--
-- Name: COLUMN tes_mov.ano; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.ano IS 'Es el a√±o actual y contable';


--
-- Name: COLUMN tes_mov.mes; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.mes IS 'Es el mes actual y contable';


--
-- Name: COLUMN tes_mov.consecutivo_cheque; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.consecutivo_cheque IS 'Obtener de la Tabla de Consecutivos tes_num_cheq. Es el nuevo numero de cheque.';


--
-- Name: COLUMN tes_mov.tes_mov_tipo_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.tes_mov_tipo_id IS 'Referencia a la tabla tes_mov_tipos(Cheque,Transf Banc), debe de ser seleccionado en el proceso de pagos';


--
-- Name: COLUMN tes_mov.tes_con_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.tes_con_id IS 'Referencia a la tabla de tes_con(Conceptos Bancarios), es lo que va en la p√≥liza.';


--
-- Name: COLUMN tes_mov.gral_suc_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.gral_suc_id IS 'Es la sucursal del usuario';


--
-- Name: COLUMN tes_mov.beneficiario_id; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.beneficiario_id IS 'Referencia al id de la tabla de cxp_prov, cxp_clie segun el tipo de beneficiario.';


--
-- Name: COLUMN tes_mov.nombre_beneficiario; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.nombre_beneficiario IS 'Nombre completo del proveedor /cliente/trabajador.';


--
-- Name: COLUMN tes_mov.tipo_beneficiario; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.tipo_beneficiario IS 'Proveedor=1 ,Cliente=2 ,  Trabajador = 3';


--
-- Name: COLUMN tes_mov.cantidad; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.cantidad IS 'Importe del Cheque';


--
-- Name: COLUMN tes_mov.observacion; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.observacion IS 'Capturada en el proceso de pagos';


--
-- Name: COLUMN tes_mov.referencia; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.referencia IS 'Solo para Transferencia Bancaria, debe de ser capturada en el proceso de pagos.';


--
-- Name: COLUMN tes_mov.fecha_emision; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.fecha_emision IS 'Fecha de emisi√≥n del cheque';


--
-- Name: COLUMN tes_mov.cancelado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.cancelado IS 'True, False Default FALSE';


--
-- Name: COLUMN tes_mov.retenido; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.retenido IS '(True /False)   solo para cheques Default  FALSE';


--
-- Name: COLUMN tes_mov.no_operado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.no_operado IS '(True/False)  Default  TRUE';


--
-- Name: COLUMN tes_mov.conciliado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.conciliado IS 'True/False)   Default  TRUE';


--
-- Name: COLUMN tes_mov.cant_letra; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.cant_letra IS 'Monto del Cheque en Letras';


--
-- Name: COLUMN tes_mov.fecha_conciliado; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.fecha_conciliado IS 'Default misma fecha  de emisi√≥n';


--
-- Name: COLUMN tes_mov.poliza; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.poliza IS 'Numero de p√≥liza de contabilidad , Default=0 ';


--
-- Name: COLUMN tes_mov.ref_num; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.ref_num IS 'Es el n√∫m. de cheque si es cheque';


--
-- Name: COLUMN tes_mov.gral_usr_id_captura; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.gral_usr_id_captura IS 'Id del usuario que captura';


--
-- Name: COLUMN tes_mov.gral_usr_id_cancela; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.gral_usr_id_cancela IS 'Id del usuario que cancela';


--
-- Name: COLUMN tes_mov.fecha_captura; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.fecha_captura IS 'Fecha en que se guarda el registo de la emision del cheque';


--
-- Name: COLUMN tes_mov.fecha_cancela; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.fecha_cancela IS 'Fecha de Cancelaci√≥n del Cheque';


--
-- Name: COLUMN tes_mov.anticipo_proveedor; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.anticipo_proveedor IS '(True/False)	Default  False ,   si viene el modulo de anticipos es TRUE';


--
-- Name: COLUMN tes_mov.anticipo_cliente; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.anticipo_cliente IS '(True/False)  Default  FALSE, si viene del modulo de anticipos es TRUE';


--
-- Name: COLUMN tes_mov.obs_retenido; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.obs_retenido IS 'Observaciones del proceso retenci√≥n';


--
-- Name: COLUMN tes_mov.referencia_transfer; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.referencia_transfer IS 'Aqu√≠ va el n√∫mero de referencia si es Transferencia Bancaria';


--
-- Name: COLUMN tes_mov.obs_cancela; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.obs_cancela IS 'Observaciones capturadas en el proceso de Cancelaci√≥n';


--
-- Name: COLUMN tes_mov.es_traspaso; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.es_traspaso IS '(True/False)	Default es FALSE,  si el TIPO_MOV es traspaso es TRUE';


--
-- Name: COLUMN tes_mov.cancelado_x_proc; Type: COMMENT; Schema: public; Owner: -
--

COMMENT ON COLUMN public.tes_mov.cancelado_x_proc IS '(True/False)    Default FALSE';


--
-- Name: tes_mov_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.tes_mov_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: tes_mov_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.tes_mov_id_seq OWNED BY public.tes_mov.id;


--
-- Name: tes_mov_tipos; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tes_mov_tipos (
    id integer NOT NULL,
    titulo character varying,
    descripcion character varying,
    tipo boolean DEFAULT false NOT NULL,
    grupo smallint,
    consecutivo boolean,
    conciliacion boolean,
    borrado_logico boolean DEFAULT false NOT NULL,
    momento_creacion timestamp with time zone,
    momento_actualizacion timestamp with time zone,
    momento_baja timestamp with time zone,
    gral_emp_id integer DEFAULT 0,
    gral_suc_id integer DEFAULT 0,
    gral_usr_id_creacion integer DEFAULT 0,
    gral_usr_id_actualizacion integer DEFAULT 0,
    gral_usr_id_baja integer DEFAULT 0
);


--
-- Name: tes_mov_tipos_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.tes_mov_tipos_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: tes_mov_tipos_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.tes_mov_tipos_id_seq OWNED BY public.tes_mov_tipos.id;


--
-- Name: tes_num_che; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tes_num_che (
    id integer NOT NULL,
    tes_che_id integer,
    consecutivo integer,
    consecutivo_inicial integer,
    consecutivo_final integer
);


--
-- Name: tes_num_che_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.tes_num_che_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: tes_num_che_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.tes_num_che_id_seq OWNED BY public.tes_num_che.id;


--
-- Name: tipos_de_traspaso_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.tipos_de_traspaso_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: tipos_de_traspaso_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.tipos_de_traspaso_id_seq OWNED BY public.erp_tipos_de_traspaso.id;


--
-- Name: users; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.users AS
 SELECT gral_usr.username,
    gral_usr.password,
    gral_usr.enabled
   FROM public.gral_usr;


--
-- Name: cfdi_c_impuesto id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_c_impuesto ALTER COLUMN id SET DEFAULT nextval('public.cfdi_c_impuesto_id_seq'::regclass);


--
-- Name: cfdi_claveprodserv id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_claveprodserv ALTER COLUMN id SET DEFAULT nextval('public.cfdi_claveprodserv_id_seq'::regclass);


--
-- Name: cfdi_claveunidad id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_claveunidad ALTER COLUMN id SET DEFAULT nextval('public.cfdi_claveunidad_id_seq'::regclass);


--
-- Name: cfdi_metodos_pago id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_metodos_pago ALTER COLUMN id SET DEFAULT nextval('public.cfdi_metodos_pago_id_seq'::regclass);


--
-- Name: cfdi_regimenes id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_regimenes ALTER COLUMN id SET DEFAULT nextval('public.cfdi_regimenes_id_seq'::regclass);


--
-- Name: cfdi_usos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_usos ALTER COLUMN id SET DEFAULT nextval('public.cfdi_usos_id_seq'::regclass);


--
-- Name: com_doc_par id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_doc_par ALTER COLUMN id SET DEFAULT nextval('public.com_doc_par_id_seq'::regclass);


--
-- Name: com_fac id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_fac ALTER COLUMN id SET DEFAULT nextval('public.erp_prealmacen_entradas_id_seq'::regclass);


--
-- Name: com_fac_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_fac_detalle ALTER COLUMN id SET DEFAULT nextval('public.erp_prealmacen_entradas_detalle_id_seq'::regclass);


--
-- Name: com_fac_detalle_dev id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_fac_detalle_dev ALTER COLUMN id SET DEFAULT nextval('public.com_fac_detalle_dev_id_seq'::regclass);


--
-- Name: com_fac_oc id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_fac_oc ALTER COLUMN id SET DEFAULT nextval('public.com_fac_oc_id_seq'::regclass);


--
-- Name: com_oc_req id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_oc_req ALTER COLUMN id SET DEFAULT nextval('public.com_oc_req_id_seq'::regclass);


--
-- Name: com_oc_req_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_oc_req_detalle ALTER COLUMN id SET DEFAULT nextval('public.com_oc_req_detalle_id_seq'::regclass);


--
-- Name: com_oc_requisicion id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_oc_requisicion ALTER COLUMN id SET DEFAULT nextval('public.com_oc_requisicion_id_seq'::regclass);


--
-- Name: com_orden_compra id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_orden_compra ALTER COLUMN id SET DEFAULT nextval('public.com_orden_compra_id_seq'::regclass);


--
-- Name: com_orden_compra_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_orden_compra_detalle ALTER COLUMN id SET DEFAULT nextval('public.com_orden_compra_detalle_id_seq'::regclass);


--
-- Name: com_par id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_par ALTER COLUMN id SET DEFAULT nextval('public.com_par_id_seq'::regclass);


--
-- Name: com_proceso id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_proceso ALTER COLUMN id SET DEFAULT nextval('public.com_proceso_id_seq'::regclass);


--
-- Name: costos_kemikal id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.costos_kemikal ALTER COLUMN id SET DEFAULT nextval('public.costos_kemikal_id_seq'::regclass);


--
-- Name: crm_calificaciones_llamadas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_calificaciones_llamadas ALTER COLUMN id SET DEFAULT nextval('public.crm_calificaciones_llamadas_id_seq'::regclass);


--
-- Name: crm_calificaciones_visita id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_calificaciones_visita ALTER COLUMN id SET DEFAULT nextval('public.crm_calificaciones_visita_id_seq'::regclass);


--
-- Name: crm_clasificacion_prospecto id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_clasificacion_prospecto ALTER COLUMN id SET DEFAULT nextval('public.crm_clasificacion_prospecto_id_seq'::regclass);


--
-- Name: crm_config_consultas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_config_consultas ALTER COLUMN id SET DEFAULT nextval('public.crm_config_consultas_id_seq'::regclass);


--
-- Name: crm_contacto_cli id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_contacto_cli ALTER COLUMN id SET DEFAULT nextval('public.crm_contacto_cli_id_seq'::regclass);


--
-- Name: crm_contacto_pro id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_contacto_pro ALTER COLUMN id SET DEFAULT nextval('public.crm_contacto_pro_id_seq'::regclass);


--
-- Name: crm_contactos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_contactos ALTER COLUMN id SET DEFAULT nextval('public.crm_contactos_id_seq'::regclass);


--
-- Name: crm_etapas_prospecto id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_etapas_prospecto ALTER COLUMN id SET DEFAULT nextval('public.crm_etapas_prospecto_id_seq'::regclass);


--
-- Name: crm_etapas_venta id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_etapas_venta ALTER COLUMN id SET DEFAULT nextval('public.crm_etapas_venta_id_seq'::regclass);


--
-- Name: crm_formas_contacto id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_formas_contacto ALTER COLUMN id SET DEFAULT nextval('public.crm_formas_contacto_id_seq'::regclass);


--
-- Name: crm_metas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_metas ALTER COLUMN id SET DEFAULT nextval('public.crm_metas_id_seq'::regclass);


--
-- Name: crm_motivos_llamada id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_motivos_llamada ALTER COLUMN id SET DEFAULT nextval('public.crm_motivos_llamada_id_seq'::regclass);


--
-- Name: crm_motivos_visita id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_motivos_visita ALTER COLUMN id SET DEFAULT nextval('public.crm_motivos_visita_id_seq'::regclass);


--
-- Name: crm_oportunidades id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_oportunidades ALTER COLUMN id SET DEFAULT nextval('public.crm_oportunidades_id_seq'::regclass);


--
-- Name: crm_prospectos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_prospectos ALTER COLUMN id SET DEFAULT nextval('public.crm_prospectos_id_seq'::regclass);


--
-- Name: crm_proyecto_estatus id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_proyecto_estatus ALTER COLUMN id SET DEFAULT nextval('public.crm_proyecto_estatus_id_seq'::regclass);


--
-- Name: crm_registro_casos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_casos ALTER COLUMN id SET DEFAULT nextval('public.crm_registro_casos_id_seq'::regclass);


--
-- Name: crm_registro_casos_clie id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_casos_clie ALTER COLUMN id SET DEFAULT nextval('public.crm_registro_casos_clie_id_seq'::regclass);


--
-- Name: crm_registro_casos_prospectos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_casos_prospectos ALTER COLUMN id SET DEFAULT nextval('public.crm_registro_casos_prospectos_id_seq'::regclass);


--
-- Name: crm_registro_llamadas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_llamadas ALTER COLUMN id SET DEFAULT nextval('public.crm_registro_llamadas_id_seq'::regclass);


--
-- Name: crm_registro_proyecto id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_proyecto ALTER COLUMN id SET DEFAULT nextval('public.crm_registro_proyecto_id_seq'::regclass);


--
-- Name: crm_registro_proyecto_competidor id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_proyecto_competidor ALTER COLUMN id SET DEFAULT nextval('public.crm_registro_proyecto_competidor_id_seq'::regclass);


--
-- Name: crm_registro_visitas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_visitas ALTER COLUMN id SET DEFAULT nextval('public.crm_registro_visitas_id_seq'::regclass);


--
-- Name: crm_tipo_industria id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipo_industria ALTER COLUMN id SET DEFAULT nextval('public.crm_tipo_industria_id_seq'::regclass);


--
-- Name: crm_tipo_prospecto id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipo_prospecto ALTER COLUMN id SET DEFAULT nextval('public.crm_tipo_prospecto_id_seq'::regclass);


--
-- Name: crm_tipos_oportunidad id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipos_oportunidad ALTER COLUMN id SET DEFAULT nextval('public.crm_tipos_oportunidad_id_seq'::regclass);


--
-- Name: crm_tipos_seguimiento_llamadas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipos_seguimiento_llamadas ALTER COLUMN id SET DEFAULT nextval('public.crm_tipos_seguimiento_llamadas_id_seq'::regclass);


--
-- Name: crm_tipos_seguimiento_visita id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipos_seguimiento_visita ALTER COLUMN id SET DEFAULT nextval('public.crm_tipos_seguimiento_visita_id_seq'::regclass);


--
-- Name: ctb_cc id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_cc ALTER COLUMN id SET DEFAULT nextval('public.ctb_cc_id_seq'::regclass);


--
-- Name: ctb_con id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_con ALTER COLUMN id SET DEFAULT nextval('public.ctb_con_id_seq'::regclass);


--
-- Name: ctb_cta id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_cta ALTER COLUMN id SET DEFAULT nextval('public.ctb_cta_id_seq'::regclass);


--
-- Name: ctb_cta_sat id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_cta_sat ALTER COLUMN id SET DEFAULT nextval('public.ctb_cta_sat_id_seq'::regclass);


--
-- Name: ctb_may id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_may ALTER COLUMN id SET DEFAULT nextval('public.ctb_may_id_seq'::regclass);


--
-- Name: ctb_par id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_par ALTER COLUMN id SET DEFAULT nextval('public.ctb_par_id_seq'::regclass);


--
-- Name: ctb_par_er id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_par_er ALTER COLUMN id SET DEFAULT nextval('public.ctb_par_er_id_seq'::regclass);


--
-- Name: ctb_pol id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol ALTER COLUMN id SET DEFAULT nextval('public.ctb_pol_id_seq'::regclass);


--
-- Name: ctb_pol_anios id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_anios ALTER COLUMN id SET DEFAULT nextval('public.ctb_pol_anios_id_seq'::regclass);


--
-- Name: ctb_pol_cons id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_cons ALTER COLUMN id SET DEFAULT nextval('public.ctb_pol_cons_id_seq'::regclass);


--
-- Name: ctb_pol_mov id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_mov ALTER COLUMN id SET DEFAULT nextval('public.ctb_pol_mov_id_seq'::regclass);


--
-- Name: ctb_sdo_cta id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_sdo_cta ALTER COLUMN id SET DEFAULT nextval('public."ctb-sdo_cta_id_seq"'::regclass);


--
-- Name: ctb_tmov id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_tmov ALTER COLUMN id SET DEFAULT nextval('public.ctb_tmov_id_seq'::regclass);


--
-- Name: ctb_tpol id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_tpol ALTER COLUMN id SET DEFAULT nextval('public.ctb_tpol_id_seq'::regclass);


--
-- Name: cxc_agen_borrar id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_agen_borrar ALTER COLUMN id SET DEFAULT nextval('public.cxc_agen_id_seq'::regclass);


--
-- Name: cxc_ant id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_ant ALTER COLUMN id SET DEFAULT nextval('public.erp_anticipos_id_seq'::regclass);


--
-- Name: cxc_ant_borrar id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_ant_borrar ALTER COLUMN id SET DEFAULT nextval('public.cxc_ant_id_seq'::regclass);


--
-- Name: cxc_clie id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_id_seq'::regclass);


--
-- Name: cxc_clie2 id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie2 ALTER COLUMN id SET DEFAULT nextval('public.clients_id_seq'::regclass);


--
-- Name: cxc_clie_adenda_datos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_adenda_datos ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_adenda_datos_id_seq'::regclass);


--
-- Name: cxc_clie_clas1 id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_clas1 ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_clas1_id_seq'::regclass);


--
-- Name: cxc_clie_clas2 id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_clas2 ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_clas2_id_seq'::regclass);


--
-- Name: cxc_clie_clas3 id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_clas3 ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_clas3_id_seq'::regclass);


--
-- Name: cxc_clie_clases id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_clases ALTER COLUMN id SET DEFAULT nextval('public.clienttipos_id_seq'::regclass);


--
-- Name: cxc_clie_creapar id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_creapar ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_creapar_id_seq'::regclass);


--
-- Name: cxc_clie_credias id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_credias ALTER COLUMN id SET DEFAULT nextval('public.erp_terminos_id_seq'::regclass);


--
-- Name: cxc_clie_descto id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_descto ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_descto_id_seq'::regclass);


--
-- Name: cxc_clie_df id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_df ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_df_id_seq'::regclass);


--
-- Name: cxc_clie_grupos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_grupos ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_grupos_id_seq'::regclass);


--
-- Name: cxc_clie_mensajes id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_mensajes ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_mensajes_id_seq'::regclass);


--
-- Name: cxc_clie_tipos_embarque id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_tipos_embarque ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_tipos_embarque_id_seq'::regclass);


--
-- Name: cxc_clie_zonas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_zonas ALTER COLUMN id SET DEFAULT nextval('public.cxc_clie_zonas_id_seq'::regclass);


--
-- Name: cxc_fac_rev_cob id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_fac_rev_cob ALTER COLUMN id SET DEFAULT nextval('public.cxc_fac_rev_cob_id_seq'::regclass);


--
-- Name: cxc_fac_rev_cob_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_fac_rev_cob_detalle ALTER COLUMN id SET DEFAULT nextval('public.cxc_fac_rev_cob_detalle_id_seq'::regclass);


--
-- Name: cxc_mov_tipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_mov_tipos ALTER COLUMN id SET DEFAULT nextval('public.cxc_mov_tipos_id_seq'::regclass);


--
-- Name: cxp_ant_par id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_ant_par ALTER COLUMN id SET DEFAULT nextval('public.cxp_ant_par_id_seq'::regclass);


--
-- Name: cxp_facturas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_facturas ALTER COLUMN id SET DEFAULT nextval('public.cxc_facturas_id_seq'::regclass);


--
-- Name: cxp_facturas_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_facturas_detalle ALTER COLUMN id SET DEFAULT nextval('public.cxp_facturas_detalle_id_seq'::regclass);


--
-- Name: cxp_facturas_tipos_cancelacion id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_facturas_tipos_cancelacion ALTER COLUMN id SET DEFAULT nextval('public.cxp_facturas_tipos_cancelacion_id_seq'::regclass);


--
-- Name: cxp_mov_tipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_mov_tipos ALTER COLUMN id SET DEFAULT nextval('public.cxp_mov_tipos_id_seq'::regclass);


--
-- Name: cxp_nota_credito id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_nota_credito ALTER COLUMN id SET DEFAULT nextval('public.cxp_nota_credito_id_seq'::regclass);


--
-- Name: cxp_pagos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_pagos ALTER COLUMN id SET DEFAULT nextval('public.cxp_pagos_id_seq'::regclass);


--
-- Name: cxp_pagos_detalles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_pagos_detalles ALTER COLUMN id SET DEFAULT nextval('public.cxp_pagos_detalles_id_seq'::regclass);


--
-- Name: cxp_pagos_tipo_movimiento id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_pagos_tipo_movimiento ALTER COLUMN id SET DEFAULT nextval('public.cxp_pagos_tipo_movimiento_id_seq'::regclass);


--
-- Name: cxp_prov id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_id_seq'::regclass);


--
-- Name: cxp_prov2 id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov2 ALTER COLUMN id SET DEFAULT nextval('public.erp_proveedors_id_seq'::regclass);


--
-- Name: cxp_prov_clas1 id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_clas1 ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_clas1_id_seq'::regclass);


--
-- Name: cxp_prov_clas2 id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_clas2 ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_clas2_id_seq'::regclass);


--
-- Name: cxp_prov_clas3 id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_clas3 ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_clas3_id_seq'::regclass);


--
-- Name: cxp_prov_clases id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_clases ALTER COLUMN id SET DEFAULT nextval('public.proveedortipos_id_seq'::regclass);


--
-- Name: cxp_prov_contactos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_contactos ALTER COLUMN id SET DEFAULT nextval('public.erp_proveedorcontactos_id_seq'::regclass);


--
-- Name: cxp_prov_creapar id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_creapar ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_creapar_id_seq'::regclass);


--
-- Name: cxp_prov_credias id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_credias ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_credias_id_seq'::regclass);


--
-- Name: cxp_prov_dir id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_dir ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_dir_id_seq'::regclass);


--
-- Name: cxp_prov_fleteras id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_fleteras ALTER COLUMN id SET DEFAULT nextval('public.fleteras_id_seq'::regclass);


--
-- Name: cxp_prov_grupos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_grupos ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_grupos_id_seq'::regclass);


--
-- Name: cxp_prov_mensajes id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_mensajes ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_msg_id_seq'::regclass);


--
-- Name: cxp_prov_tipos_embarque id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_tipos_embarque ALTER COLUMN id SET DEFAULT nextval('public.cxp_prov_tipos_embarque_id_seq'::regclass);


--
-- Name: cxp_prov_zonas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_zonas ALTER COLUMN id SET DEFAULT nextval('public.cxp_zona_id_seq'::regclass);


--
-- Name: env_conf id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_conf ALTER COLUMN id SET DEFAULT nextval('public.env_conf_id_seq'::regclass);


--
-- Name: env_conf_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_conf_det ALTER COLUMN id SET DEFAULT nextval('public.env_conf_det_id_seq'::regclass);


--
-- Name: env_env id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_env ALTER COLUMN id SET DEFAULT nextval('public.env_env_id_seq'::regclass);


--
-- Name: env_env_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_env_det ALTER COLUMN id SET DEFAULT nextval('public.env_env_det_id_seq'::regclass);


--
-- Name: env_reenv id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_reenv ALTER COLUMN id SET DEFAULT nextval('public.env_reenv_id_seq'::regclass);


--
-- Name: env_reenv_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_reenv_det ALTER COLUMN id SET DEFAULT nextval('public.env_reenv_det_id_seq'::regclass);


--
-- Name: erp_bancos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_bancos ALTER COLUMN id SET DEFAULT nextval('public.erp_bancos_id_seq'::regclass);


--
-- Name: erp_categorias_de_productos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_categorias_de_productos ALTER COLUMN id SET DEFAULT nextval('public.categorias_de_formulaciones_id_seq'::regclass);


--
-- Name: erp_civils id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_civils ALTER COLUMN id SET DEFAULT nextval('public.civils_id_seq'::regclass);


--
-- Name: erp_clients_consignacions id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_clients_consignacions ALTER COLUMN id SET DEFAULT nextval('public.clients_consignacions_id_seq'::regclass);


--
-- Name: erp_consecutivos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_consecutivos ALTER COLUMN id SET DEFAULT nextval('public.consecutivos_id_seq'::regclass);


--
-- Name: erp_cotizacions id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_cotizacions ALTER COLUMN id SET DEFAULT nextval('public.erp_cotizacions_id_seq'::regclass);


--
-- Name: erp_cotizacions_detalles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_cotizacions_detalles ALTER COLUMN id SET DEFAULT nextval('public.erp_cotizacions_detalles_id_seq'::regclass);


--
-- Name: erp_cuentas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_cuentas ALTER COLUMN id SET DEFAULT nextval('public.erp_cuentas_id_seq'::regclass);


--
-- Name: erp_emails id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_emails ALTER COLUMN id SET DEFAULT nextval('public.erp_emails_id_seq'::regclass);


--
-- Name: erp_empleados id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_empleados ALTER COLUMN id SET DEFAULT nextval('public.erp_empleados_id_seq'::regclass);


--
-- Name: erp_estatus_ordencompra id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_estatus_ordencompra ALTER COLUMN id SET DEFAULT nextval('public.estatus_ordencompra_id_seq'::regclass);


--
-- Name: erp_h_facturas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_h_facturas ALTER COLUMN id SET DEFAULT nextval('public.erp_h_facturas_id_seq'::regclass);


--
-- Name: erp_historico_traspasos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_historico_traspasos ALTER COLUMN id SET DEFAULT nextval('public.erp_historico_traspasos_id_seq'::regclass);


--
-- Name: erp_historico_traspasos_detalles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_historico_traspasos_detalles ALTER COLUMN id SET DEFAULT nextval('public.erp_historico_traspasos_detalles_id_seq'::regclass);


--
-- Name: erp_ivatipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_ivatipos ALTER COLUMN id SET DEFAULT nextval('public.ivatipos_id_seq'::regclass);


--
-- Name: erp_listasprecios id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_listasprecios ALTER COLUMN id SET DEFAULT nextval('public.listasprecios_id_seq'::regclass);


--
-- Name: erp_listasprecios_detallada id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_listasprecios_detallada ALTER COLUMN id SET DEFAULT nextval('public.listasprecios_detallada_id_seq'::regclass);


--
-- Name: erp_mascaras_para_validaciones_por_app id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_mascaras_para_validaciones_por_app ALTER COLUMN id SET DEFAULT nextval('public.mascaras_para_validaciones_por_app_id_seq'::regclass);


--
-- Name: erp_monedas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_monedas ALTER COLUMN id SET DEFAULT nextval('public.monedas_id_seq'::regclass);


--
-- Name: erp_monedavers id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_monedavers ALTER COLUMN id SET DEFAULT nextval('public.moneda_vers_id_seq'::regclass);


--
-- Name: erp_notas_credito id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_notas_credito ALTER COLUMN id SET DEFAULT nextval('public.erp_notas_credito_id_seq'::regclass);


--
-- Name: erp_notas_credito_detalles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_notas_credito_detalles ALTER COLUMN id SET DEFAULT nextval('public.erp_notas_credito_detalles_id_seq'::regclass);


--
-- Name: erp_ordencompras id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_ordencompras ALTER COLUMN id SET DEFAULT nextval('public.ordencompras_id_seq'::regclass);


--
-- Name: erp_pagos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagos ALTER COLUMN id SET DEFAULT nextval('public.erp_pagos_id_seq'::regclass);


--
-- Name: erp_pagos_cancelacion_detalles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagos_cancelacion_detalles ALTER COLUMN id SET DEFAULT nextval('public.erp_pagos_cancelacion_detalles_id_seq'::regclass);


--
-- Name: erp_pagos_detalles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagos_detalles ALTER COLUMN id SET DEFAULT nextval('public.erp_pagos_detalles_id_seq'::regclass);


--
-- Name: erp_pagosxaplicar id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagosxaplicar ALTER COLUMN id SET DEFAULT nextval('public.erp_pagosxaplicar_id_seq'::regclass);


--
-- Name: erp_prefacturas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_prefacturas ALTER COLUMN id SET DEFAULT nextval('public.erp_prefacturas_id_seq'::regclass);


--
-- Name: erp_prefacturas_detalles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_prefacturas_detalles ALTER COLUMN id SET DEFAULT nextval('public.erp_prefacturas_detalles_id_seq'::regclass);


--
-- Name: erp_proceso id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_proceso ALTER COLUMN id SET DEFAULT nextval('public.erp_proceso_id_seq'::regclass);


--
-- Name: erp_proveedoreswebusers id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_proveedoreswebusers ALTER COLUMN id SET DEFAULT nextval('public.proveedoreswebusers_id_seq'::regclass);


--
-- Name: erp_religions id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_religions ALTER COLUMN id SET DEFAULT nextval('public.religions_id_seq'::regclass);


--
-- Name: erp_sangretipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_sangretipos ALTER COLUMN id SET DEFAULT nextval('public.sangre_tipos_id_seq'::regclass);


--
-- Name: erp_tiempos_entrega id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_tiempos_entrega ALTER COLUMN id SET DEFAULT nextval('public.erp_tiempos_entrega_id_seq'::regclass);


--
-- Name: erp_tipos_de_traspaso id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_tipos_de_traspaso ALTER COLUMN id SET DEFAULT nextval('public.tipos_de_traspaso_id_seq'::regclass);


--
-- Name: fac_cfdis id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_cfdis ALTER COLUMN id SET DEFAULT nextval('public.fac_cfdis_id_seq'::regclass);


--
-- Name: fac_cfds id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_cfds ALTER COLUMN id SET DEFAULT nextval('public.erp_facturas_id_seq'::regclass);


--
-- Name: fac_docs id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_docs ALTER COLUMN id SET DEFAULT nextval('public.fac_docs_id_seq'::regclass);


--
-- Name: fac_docs_adenda id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_docs_adenda ALTER COLUMN id SET DEFAULT nextval('public.fac_docs_adenda_id_seq'::regclass);


--
-- Name: fac_docs_detalles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_docs_detalles ALTER COLUMN id SET DEFAULT nextval('public.fac_docs_detalles_id_seq'::regclass);


--
-- Name: fac_docs_tipos_cancelacion id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_docs_tipos_cancelacion ALTER COLUMN id SET DEFAULT nextval('public.fac_docs_tipos_cancelacion_id_seq'::regclass);


--
-- Name: fac_metodos_pago id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_metodos_pago ALTER COLUMN id SET DEFAULT nextval('public.fac_metodos_pago_id_seq'::regclass);


--
-- Name: fac_namespaces id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_namespaces ALTER COLUMN id SET DEFAULT nextval('public.fac_namespaces_id_seq'::regclass);


--
-- Name: fac_nomina id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina ALTER COLUMN id SET DEFAULT nextval('public.fac_nomina_id_seq'::regclass);


--
-- Name: fac_nomina_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det ALTER COLUMN id SET DEFAULT nextval('public.fac_nomina_det_id_seq'::regclass);


--
-- Name: fac_nomina_det_deduc id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det_deduc ALTER COLUMN id SET DEFAULT nextval('public.fac_nomina_det_deduc_id_seq'::regclass);


--
-- Name: fac_nomina_det_hrs_extra id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det_hrs_extra ALTER COLUMN id SET DEFAULT nextval('public.fac_nomina_det_hrs_extra_id_seq'::regclass);


--
-- Name: fac_nomina_det_incapa id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det_incapa ALTER COLUMN id SET DEFAULT nextval('public.fac_nomina_det_incapa_id_seq'::regclass);


--
-- Name: fac_nomina_det_percep id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det_percep ALTER COLUMN id SET DEFAULT nextval('public.fac_nomina_det_percep_id_seq'::regclass);


--
-- Name: fac_nomina_par id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_par ALTER COLUMN id SET DEFAULT nextval('public.fac_nomina_par_id_seq'::regclass);


--
-- Name: fac_nota_credito id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nota_credito ALTER COLUMN id SET DEFAULT nextval('public.fac_nota_credito_id_seq'::regclass);


--
-- Name: fac_nota_credito_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nota_credito_det ALTER COLUMN id SET DEFAULT nextval('public.fac_nota_credito_det_id_seq'::regclass);


--
-- Name: fac_par id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_par ALTER COLUMN id SET DEFAULT nextval('public.fac_par_id_seq'::regclass);


--
-- Name: fac_rem_doc_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_rem_doc_det ALTER COLUMN id SET DEFAULT nextval('public.fac_rem_doc_det_id_seq'::regclass);


--
-- Name: fac_rems id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_rems ALTER COLUMN id SET DEFAULT nextval('public.fac_rems_id_seq'::regclass);


--
-- Name: fac_rems_detalles id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_rems_detalles ALTER COLUMN id SET DEFAULT nextval('public.fac_rems_detalles_id_seq'::regclass);


--
-- Name: fac_rems_docs id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_rems_docs ALTER COLUMN id SET DEFAULT nextval('public.fac_rems_docs_id_seq'::regclass);


--
-- Name: gral_ano_fiscal id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_ano_fiscal ALTER COLUMN id SET DEFAULT nextval('public.gral_ano_fis_id_seq'::regclass);


--
-- Name: gral_categ id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_categ ALTER COLUMN id SET DEFAULT nextval('public.gral_categ_id_seq'::regclass);


--
-- Name: gral_civils id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_civils ALTER COLUMN id SET DEFAULT nextval('public.gral_civils_id_seq'::regclass);


--
-- Name: gral_cons id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_cons ALTER COLUMN id SET DEFAULT nextval('public.gral_cons_id_seq'::regclass);


--
-- Name: gral_cons_tipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_cons_tipos ALTER COLUMN id SET DEFAULT nextval('public.gral_cons_tipos_id_seq'::regclass);


--
-- Name: gral_deptos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_deptos ALTER COLUMN id SET DEFAULT nextval('public.gral_deptos_id_seq'::regclass);


--
-- Name: gral_deptos_turnos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_deptos_turnos ALTER COLUMN id SET DEFAULT nextval('public.gral_deptos_turnos_id_seq'::regclass);


--
-- Name: gral_dias_no_laborables id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_dias_no_laborables ALTER COLUMN id SET DEFAULT nextval('public.gral_dias_no_laborables_id_seq'::regclass);


--
-- Name: gral_docs id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_docs ALTER COLUMN id SET DEFAULT nextval('public.gral_docs_id_seq'::regclass);


--
-- Name: gral_docs_conf id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_docs_conf ALTER COLUMN id SET DEFAULT nextval('public.gral_docs_conf_id_seq'::regclass);


--
-- Name: gral_edo id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_edo ALTER COLUMN id SET DEFAULT nextval('public.gral_edo_id_seq'::regclass);


--
-- Name: gral_emails id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emails ALTER COLUMN id SET DEFAULT nextval('public.gral_emails_id_seq'::regclass);


--
-- Name: gral_emp id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp ALTER COLUMN id SET DEFAULT nextval('public.gral_sis_id_seq'::regclass);


--
-- Name: gral_emp_consecutivos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp_consecutivos ALTER COLUMN id SET DEFAULT nextval('public.gral_emp_consecutivos_id_seq'::regclass);


--
-- Name: gral_emp_leyenda id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp_leyenda ALTER COLUMN id SET DEFAULT nextval('public.gral_emp_leyenda_id_seq'::regclass);


--
-- Name: gral_empleado_deduc id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_deduc ALTER COLUMN id SET DEFAULT nextval('public.gral_empleado_deduc_id_seq'::regclass);


--
-- Name: gral_empleado_percep id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_percep ALTER COLUMN id SET DEFAULT nextval('public.gral_empleado_percep_id_seq'::regclass);


--
-- Name: gral_empleados id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleados ALTER COLUMN id SET DEFAULT nextval('public.gral_empleados_id_seq'::regclass);


--
-- Name: gral_escolaridads id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_escolaridads ALTER COLUMN id SET DEFAULT nextval('public.gral_escolaridads_id_seq'::regclass);


--
-- Name: gral_ieps id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_ieps ALTER COLUMN id SET DEFAULT nextval('public.gral_ieps_id_seq'::regclass);


--
-- Name: gral_ieps_cta id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_ieps_cta ALTER COLUMN id SET DEFAULT nextval('public.gral_ieps_cta_id_seq'::regclass);


--
-- Name: gral_impto_cta id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_impto_cta ALTER COLUMN id SET DEFAULT nextval('public.gral_impto_cta_id_seq'::regclass);


--
-- Name: gral_impto_ret_cta id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_impto_ret_cta ALTER COLUMN id SET DEFAULT nextval('public.gral_impto_ret_cta_id_seq'::regclass);


--
-- Name: gral_imptos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_imptos ALTER COLUMN id SET DEFAULT nextval('public.gral_imptos_id_seq'::regclass);


--
-- Name: gral_imptos_ret id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_imptos_ret ALTER COLUMN id SET DEFAULT nextval('public.gral_imptos_ret_id_seq'::regclass);


--
-- Name: gral_isr id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_isr ALTER COLUMN id SET DEFAULT nextval('public.gral_isr_id_seq'::regclass);


--
-- Name: gral_mon id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_mon ALTER COLUMN id SET DEFAULT nextval('public.gral_mon_id_seq'::regclass);


--
-- Name: gral_pais id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_pais ALTER COLUMN id SET DEFAULT nextval('public.gral_pais_id_seq'::regclass);


--
-- Name: gral_plazas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_plazas ALTER COLUMN id SET DEFAULT nextval('public.gral_plazas_id_seq'::regclass);


--
-- Name: gral_puestos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_puestos ALTER COLUMN id SET DEFAULT nextval('public.gral_puestos_id_seq'::regclass);


--
-- Name: gral_reg id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_reg ALTER COLUMN id SET DEFAULT nextval('public.gral_reg_id_seq'::regclass);


--
-- Name: gral_religions id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_religions ALTER COLUMN id SET DEFAULT nextval('public.gral_religions_id_seq'::regclass);


--
-- Name: gral_rol id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_rol ALTER COLUMN id SET DEFAULT nextval('public.gral_rol_id_seq'::regclass);


--
-- Name: gral_sangretipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_sangretipos ALTER COLUMN id SET DEFAULT nextval('public.gral_sangretipos_id_seq'::regclass);


--
-- Name: gral_sexos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_sexos ALTER COLUMN id SET DEFAULT nextval('public.gral_sexos_id_seq'::regclass);


--
-- Name: gral_suc id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc ALTER COLUMN id SET DEFAULT nextval('public.gral_sucursales_id_seq'::regclass);


--
-- Name: gral_suc_pza id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc_pza ALTER COLUMN id SET DEFAULT nextval('public.gral_suc_pza_id_seq'::regclass);


--
-- Name: gral_usr id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr ALTER COLUMN id SET DEFAULT nextval('public.erp_users_id_seq'::regclass);


--
-- Name: gral_usr_rol id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr_rol ALTER COLUMN id SET DEFAULT nextval('public.gral_usr_rol_id_seq'::regclass);


--
-- Name: gral_usr_suc id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr_suc ALTER COLUMN id SET DEFAULT nextval('public.gral_usr_suc_id_seq'::regclass);


--
-- Name: inv_alm id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_alm ALTER COLUMN id SET DEFAULT nextval('public.almacens_id_seq'::regclass);


--
-- Name: inv_alm_tipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_alm_tipos ALTER COLUMN id SET DEFAULT nextval('public.almacen_tipos_id_seq'::regclass);


--
-- Name: inv_clas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_clas ALTER COLUMN id SET DEFAULT nextval('public.inv_clas_id_seq'::regclass);


--
-- Name: inv_com id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_com ALTER COLUMN id SET DEFAULT nextval('public.inv_com_id_seq'::regclass);


--
-- Name: inv_com_tipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_com_tipos ALTER COLUMN id SET DEFAULT nextval('public.inv_com_tipos_id_seq'::regclass);


--
-- Name: inv_etiqueta_medidas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_etiqueta_medidas ALTER COLUMN id SET DEFAULT nextval('public.inv_etiqueta_medidas_id_seq'::regclass);


--
-- Name: inv_etiquetas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_etiquetas ALTER COLUMN id SET DEFAULT nextval('public.inv_etiquetas_id_seq'::regclass);


--
-- Name: inv_etiquetas_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_etiquetas_detalle ALTER COLUMN id SET DEFAULT nextval('public.inv_etiquetas_detalle_id_seq'::regclass);


--
-- Name: inv_exi id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi ALTER COLUMN id SET DEFAULT nextval('public.inv_exi_id_seq'::regclass);


--
-- Name: inv_exi_pres id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi_pres ALTER COLUMN id SET DEFAULT nextval('public.inv_exi_pres_id_seq'::regclass);


--
-- Name: inv_exi_tmp id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi_tmp ALTER COLUMN id SET DEFAULT nextval('public.inv_exi_tmp_id_seq'::regclass);


--
-- Name: inv_existencia_inicial id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_existencia_inicial ALTER COLUMN id SET DEFAULT nextval('public.inv_existencia_inicial_id_seq'::regclass);


--
-- Name: inv_existencia_inicial_kathion id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_existencia_inicial_kathion ALTER COLUMN id SET DEFAULT nextval('public.inv_existencia_inicial_kathion_id_seq'::regclass);


--
-- Name: inv_fac id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_fac ALTER COLUMN id SET DEFAULT nextval('public.inv_fac_id_seq'::regclass);


--
-- Name: inv_fac_etiqueta id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_fac_etiqueta ALTER COLUMN id SET DEFAULT nextval('public.inv_fac_etiqueta_id_seq'::regclass);


--
-- Name: inv_kat_kem_sep2013 id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_kat_kem_sep2013 ALTER COLUMN id SET DEFAULT nextval('public.inv_kat_kem_sep2013_id_seq'::regclass);


--
-- Name: inv_kit id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_kit ALTER COLUMN id SET DEFAULT nextval('public.inv_kit_id_seq'::regclass);


--
-- Name: inv_lm id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lm ALTER COLUMN id SET DEFAULT nextval('public.inv_lm_id_seq'::regclass);


--
-- Name: inv_lote id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote ALTER COLUMN id SET DEFAULT nextval('public.inv_lote_id_seq'::regclass);


--
-- Name: inv_lote_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_detalle ALTER COLUMN id SET DEFAULT nextval('public.inv_lote_detalle_id_seq'::regclass);


--
-- Name: inv_lote_mov id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_mov ALTER COLUMN id SET DEFAULT nextval('public.inv_lote_mov_id_seq'::regclass);


--
-- Name: inv_lote_mov_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_mov_det ALTER COLUMN id SET DEFAULT nextval('public.inv_lote_mov_det_id_seq'::regclass);


--
-- Name: inv_lote_tmp id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_tmp ALTER COLUMN id SET DEFAULT nextval('public.inv_lote_tmp_id_seq'::regclass);


--
-- Name: inv_mar id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mar ALTER COLUMN id SET DEFAULT nextval('public.inv_mar_id_seq'::regclass);


--
-- Name: inv_mov id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mov ALTER COLUMN id SET DEFAULT nextval('public.inv_mov_id_seq'::regclass);


--
-- Name: inv_mov_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mov_detalle ALTER COLUMN id SET DEFAULT nextval('public.inv_mov_detalle_id_seq'::regclass);


--
-- Name: inv_mov_tipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mov_tipos ALTER COLUMN id SET DEFAULT nextval('public.inv_mov_tipos_id_seq'::regclass);


--
-- Name: inv_odev id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_odev ALTER COLUMN id SET DEFAULT nextval('public.inv_odev_id_seq'::regclass);


--
-- Name: inv_odev_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_odev_detalle ALTER COLUMN id SET DEFAULT nextval('public.inv_odev_detalle_id_seq'::regclass);


--
-- Name: inv_oent id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_oent ALTER COLUMN id SET DEFAULT nextval('public.inv_oent_id_seq'::regclass);


--
-- Name: inv_oent_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_oent_detalle ALTER COLUMN id SET DEFAULT nextval('public.inv_oent_detalle_id_seq'::regclass);


--
-- Name: inv_ord_subensamble id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_ord_subensamble ALTER COLUMN id SET DEFAULT nextval('public.inv_ord_subensamble_id_seq'::regclass);


--
-- Name: inv_ord_subensamble_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_ord_subensamble_detalle ALTER COLUMN id SET DEFAULT nextval('public.inv_ord_subensamble_detalle_id_seq'::regclass);


--
-- Name: inv_ord_subensamble_detalle_formula id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_ord_subensamble_detalle_formula ALTER COLUMN id SET DEFAULT nextval('public.inv_ord_subensamble_detalle_formula_id_seq'::regclass);


--
-- Name: inv_osal id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_osal ALTER COLUMN id SET DEFAULT nextval('public.inv_osal_id_seq'::regclass);


--
-- Name: inv_osal_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_osal_detalle ALTER COLUMN id SET DEFAULT nextval('public.inv_osal_detalle_id_seq'::regclass);


--
-- Name: inv_otras id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_otras ALTER COLUMN id SET DEFAULT nextval('public.inv_otras_id_seq'::regclass);


--
-- Name: inv_otras_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_otras_det ALTER COLUMN id SET DEFAULT nextval('public.inv_otras_det_id_seq'::regclass);


--
-- Name: inv_pre id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_pre ALTER COLUMN id SET DEFAULT nextval('public.inv_pre_id_seq'::regclass);


--
-- Name: inv_pre_ofe id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_pre_ofe ALTER COLUMN id SET DEFAULT nextval('public.inv_pre_ofe_id_seq'::regclass);


--
-- Name: inv_pre_par id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_pre_par ALTER COLUMN id SET DEFAULT nextval('public.inv_pre_par_id_seq'::regclass);


--
-- Name: inv_proceso id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_proceso ALTER COLUMN id SET DEFAULT nextval('public.inv_proceso_id_seq'::regclass);


--
-- Name: inv_prod id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod ALTER COLUMN id SET DEFAULT nextval('public.inv_prod2_id_seq'::regclass);


--
-- Name: inv_prod_anterior id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_anterior ALTER COLUMN id SET DEFAULT nextval('public.productos_id_seq'::regclass);


--
-- Name: inv_prod_cost_prom id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_cost_prom ALTER COLUMN id SET DEFAULT nextval('public.inv_prod_cost_prom_id_seq'::regclass);


--
-- Name: inv_prod_costos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_costos ALTER COLUMN id SET DEFAULT nextval('public.inv_prod_costos_id_seq'::regclass);


--
-- Name: inv_prod_equiv id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_equiv ALTER COLUMN id SET DEFAULT nextval('public.inv_prod_equiv_id_seq'::regclass);


--
-- Name: inv_prod_familias id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_familias ALTER COLUMN id SET DEFAULT nextval('public.inv_prod_familias_id_seq'::regclass);


--
-- Name: inv_prod_grupos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_grupos ALTER COLUMN id SET DEFAULT nextval('public.inv_prod_grupos_id_seq'::regclass);


--
-- Name: inv_prod_lineas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_lineas ALTER COLUMN id SET DEFAULT nextval('public.inv_prod_lineas2_id_seq'::regclass);


--
-- Name: inv_prod_pres_x_prod id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_pres_x_prod ALTER COLUMN id SET DEFAULT nextval('public.presentaciones_producto_id_seq'::regclass);


--
-- Name: inv_prod_sust id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_sust ALTER COLUMN id SET DEFAULT nextval('public.inv_art_sust_id_seq'::regclass);


--
-- Name: inv_prod_tipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_tipos ALTER COLUMN id SET DEFAULT nextval('public.inv_prod_tipos_id_seq'::regclass);


--
-- Name: inv_prod_unidades id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_unidades ALTER COLUMN id SET DEFAULT nextval('public.inv_prod_unidades_id_seq'::regclass);


--
-- Name: inv_secciones id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_secciones ALTER COLUMN id SET DEFAULT nextval('public.inv_secciones_id_seq'::regclass);


--
-- Name: inv_stock_clasificaciones id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_stock_clasificaciones ALTER COLUMN id SET DEFAULT nextval('public.inv_stock_clasificaciones_id_seq'::regclass);


--
-- Name: inv_suc_alm id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_suc_alm ALTER COLUMN id SET DEFAULT nextval('public.inv_suc_alm_id_seq'::regclass);


--
-- Name: inv_tras id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_tras ALTER COLUMN id SET DEFAULT nextval('public.inv_tras_id_seq'::regclass);


--
-- Name: inv_tras_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_tras_det ALTER COLUMN id SET DEFAULT nextval('public.inv_tras_det_id_seq'::regclass);


--
-- Name: inv_zonas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_zonas ALTER COLUMN id SET DEFAULT nextval('public.inv_zonas_id_seq'::regclass);


--
-- Name: log_choferes id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_choferes ALTER COLUMN id SET DEFAULT nextval('public.log_choferes_id_seq'::regclass);


--
-- Name: log_rutas id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_rutas ALTER COLUMN id SET DEFAULT nextval('public.log_rutas_id_seq'::regclass);


--
-- Name: log_rutas_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_rutas_detalle ALTER COLUMN id SET DEFAULT nextval('public.log_rutas_detalle_id_seq'::regclass);


--
-- Name: log_rutas_detalle_cobro id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_rutas_detalle_cobro ALTER COLUMN id SET DEFAULT nextval('public.log_rutas_detalle_cobro_id_seq'::regclass);


--
-- Name: log_vehiculos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_vehiculos ALTER COLUMN id SET DEFAULT nextval('public.log_vehiculos_id_seq'::regclass);


--
-- Name: nom_deduc id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_deduc ALTER COLUMN id SET DEFAULT nextval('public.nom_deduc_id_seq'::regclass);


--
-- Name: nom_deduc_tipo id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_deduc_tipo ALTER COLUMN id SET DEFAULT nextval('public.nom_deduc_tipo_id_seq'::regclass);


--
-- Name: nom_percep id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_percep ALTER COLUMN id SET DEFAULT nextval('public.nom_percep_id_seq'::regclass);


--
-- Name: nom_percep_tipo id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_percep_tipo ALTER COLUMN id SET DEFAULT nextval('public.nom_percep_tipo_id_seq'::regclass);


--
-- Name: nom_periodicidad_pago id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_periodicidad_pago ALTER COLUMN id SET DEFAULT nextval('public.nom_periodicidad_pago_id_seq'::regclass);


--
-- Name: nom_periodos_conf id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_periodos_conf ALTER COLUMN id SET DEFAULT nextval('public.nom_periodos_conf_id_seq'::regclass);


--
-- Name: nom_periodos_conf_det id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_periodos_conf_det ALTER COLUMN id SET DEFAULT nextval('public.nom_periodos_conf_det_id_seq'::regclass);


--
-- Name: nom_regimen_contratacion id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_regimen_contratacion ALTER COLUMN id SET DEFAULT nextval('public.nom_regimen_contratacion_id_seq'::regclass);


--
-- Name: nom_riesgo_puesto id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_riesgo_puesto ALTER COLUMN id SET DEFAULT nextval('public.nom_riesgo_puesto_id_seq'::regclass);


--
-- Name: nom_tipo_contrato id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_tipo_contrato ALTER COLUMN id SET DEFAULT nextval('public.nom_tipo_contrato_id_seq'::regclass);


--
-- Name: nom_tipo_hrs_extra id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_tipo_hrs_extra ALTER COLUMN id SET DEFAULT nextval('public.nom_tipo_hrs_extra_id_seq'::regclass);


--
-- Name: nom_tipo_incapacidad id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_tipo_incapacidad ALTER COLUMN id SET DEFAULT nextval('public.nom_tipo_incapacidad_id_seq'::regclass);


--
-- Name: nom_tipo_jornada id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_tipo_jornada ALTER COLUMN id SET DEFAULT nextval('public.nom_tipo_jornada_id_seq'::regclass);


--
-- Name: poc_cot id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot ALTER COLUMN id SET DEFAULT nextval('public.poc_cot_id_seq'::regclass);


--
-- Name: poc_cot_clie id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_clie ALTER COLUMN id SET DEFAULT nextval('public.poc_cot_clie_id_seq'::regclass);


--
-- Name: poc_cot_condiciones_com id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_condiciones_com ALTER COLUMN id SET DEFAULT nextval('public.poc_cot_condiciones_com_id_seq'::regclass);


--
-- Name: poc_cot_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_detalle ALTER COLUMN id SET DEFAULT nextval('public.poc_cot_detalle_id_seq'::regclass);


--
-- Name: poc_cot_incoterm_x_cot id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_incoterm_x_cot ALTER COLUMN id SET DEFAULT nextval('public.poc_cot_incoterm_x_cot_id_seq'::regclass);


--
-- Name: poc_cot_incoterms id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_incoterms ALTER COLUMN id SET DEFAULT nextval('public.poc_cot_incoterms_id_seq'::regclass);


--
-- Name: poc_cot_politicas_pago id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_politicas_pago ALTER COLUMN id SET DEFAULT nextval('public.poc_cot_politicas_pago_id_seq'::regclass);


--
-- Name: poc_cot_prospecto id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_prospecto ALTER COLUMN id SET DEFAULT nextval('public.poc_cot_prospecto_id_seq'::regclass);


--
-- Name: poc_cot_saludo_despedida id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_saludo_despedida ALTER COLUMN id SET DEFAULT nextval('public.poc_cot_saludo_despedida_id_seq'::regclass);


--
-- Name: poc_ped_bo id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_ped_bo ALTER COLUMN id SET DEFAULT nextval('public.poc_ped_bo_id_seq'::regclass);


--
-- Name: poc_ped_cot id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_ped_cot ALTER COLUMN id SET DEFAULT nextval('public.poc_ped_cot_id_seq'::regclass);


--
-- Name: poc_pedidos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_pedidos ALTER COLUMN id SET DEFAULT nextval('public.poc_pedidos_id_seq'::regclass);


--
-- Name: poc_pedidos_detalle id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_pedidos_detalle ALTER COLUMN id SET DEFAULT nextval('public.poc_pedidos_detalle_id_seq'::regclass);


--
-- Name: pro_orden_prod id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pro_orden_prod ALTER COLUMN id SET DEFAULT nextval('public.pro_orden_prod_id_seq'::regclass);


--
-- Name: pro_ordenprod_invosal id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pro_ordenprod_invosal ALTER COLUMN id SET DEFAULT nextval('public.pro_ordenprod_invosal_id_seq'::regclass);


--
-- Name: pro_par id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pro_par ALTER COLUMN id SET DEFAULT nextval('public.pro_par_id_seq'::regclass);


--
-- Name: tes_ban id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_ban ALTER COLUMN id SET DEFAULT nextval('public.tes_ban_id_seq'::regclass);


--
-- Name: tes_che id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_che ALTER COLUMN id SET DEFAULT nextval('public.tes_che_id_seq'::regclass);


--
-- Name: tes_con id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_con ALTER COLUMN id SET DEFAULT nextval('public.tes_con_id_seq'::regclass);


--
-- Name: tes_mov id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_mov ALTER COLUMN id SET DEFAULT nextval('public.tes_mov_id_seq'::regclass);


--
-- Name: tes_mov_tipos id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_mov_tipos ALTER COLUMN id SET DEFAULT nextval('public.tes_mov_tipos_id_seq'::regclass);


--
-- Name: tes_num_che id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_num_che ALTER COLUMN id SET DEFAULT nextval('public.tes_num_che_id_seq'::regclass);


--
-- Name: com_par UNIKE_EMP_SUC; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_par
    ADD CONSTRAINT "UNIKE_EMP_SUC" UNIQUE (gral_emp_id, gral_suc_id);


--
-- Name: inv_pre_par UNIKE_inv_pre_par_emp_suc; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_pre_par
    ADD CONSTRAINT "UNIKE_inv_pre_par_emp_suc" UNIQUE (gral_emp_id, gral_suc_id);


--
-- Name: inv_alm_tipos almacen_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_alm_tipos
    ADD CONSTRAINT almacen_tipos_pkey PRIMARY KEY (id);


--
-- Name: inv_alm almacens_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_alm
    ADD CONSTRAINT almacens_pkey PRIMARY KEY (id);


--
-- Name: inv_alm almacens_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_alm
    ADD CONSTRAINT almacens_titulo_key UNIQUE (titulo);


--
-- Name: erp_bancos bancos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_bancos
    ADD CONSTRAINT bancos_pkey PRIMARY KEY (id);


--
-- Name: erp_categorias_de_productos categorias_de_producto_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_categorias_de_productos
    ADD CONSTRAINT categorias_de_producto_titulo_key UNIQUE (titulo);


--
-- Name: erp_categorias_de_productos categorias_de_productos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_categorias_de_productos
    ADD CONSTRAINT categorias_de_productos_pkey PRIMARY KEY (id);


--
-- Name: cfdi_c_impuesto cfdi_c_impuesto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_c_impuesto
    ADD CONSTRAINT cfdi_c_impuesto_pkey PRIMARY KEY (id);


--
-- Name: cfdi_claveprodserv cfdi_claveprodserv_2_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_claveprodserv
    ADD CONSTRAINT cfdi_claveprodserv_2_pkey PRIMARY KEY (id);


--
-- Name: cfdi_claveprodserv3 cfdi_claveprodserv_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_claveprodserv3
    ADD CONSTRAINT cfdi_claveprodserv_pkey PRIMARY KEY (id);


--
-- Name: cfdi_claveunidad cfdi_claveunidad_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_claveunidad
    ADD CONSTRAINT cfdi_claveunidad_pkey PRIMARY KEY (id);


--
-- Name: cfdi_metodos_pago cfdi_metodos_pago_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_metodos_pago
    ADD CONSTRAINT cfdi_metodos_pago_pkey PRIMARY KEY (id);


--
-- Name: cfdi_regimenes cfdi_regimenes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_regimenes
    ADD CONSTRAINT cfdi_regimenes_pkey PRIMARY KEY (id);


--
-- Name: cfdi_usos cfdi_usos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cfdi_usos
    ADD CONSTRAINT cfdi_usos_pkey PRIMARY KEY (id);


--
-- Name: log_choferes choferes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_choferes
    ADD CONSTRAINT choferes_pkey PRIMARY KEY (id);


--
-- Name: erp_civils civils_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_civils
    ADD CONSTRAINT civils_pkey PRIMARY KEY (id);


--
-- Name: erp_civils civils_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_civils
    ADD CONSTRAINT civils_titulo_key UNIQUE (titulo);


--
-- Name: cxc_clie_clases client_tipos_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_clases
    ADD CONSTRAINT client_tipos_titulo_key UNIQUE (titulo);


--
-- Name: cxc_clie_clases cliente_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_clases
    ADD CONSTRAINT cliente_tipos_pkey PRIMARY KEY (id);


--
-- Name: erp_clients_consignacions clients_consignacions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_clients_consignacions
    ADD CONSTRAINT clients_consignacions_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie2 clients_numero_control_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie2
    ADD CONSTRAINT clients_numero_control_key UNIQUE (numero_control);


--
-- Name: com_doc_par com_doc_par_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_doc_par
    ADD CONSTRAINT com_doc_par_pkey PRIMARY KEY (id);


--
-- Name: com_fac_detalle_dev com_fac_detalle_dev_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_fac_detalle_dev
    ADD CONSTRAINT com_fac_detalle_dev_pkey PRIMARY KEY (id);


--
-- Name: com_fac_oc com_fac_oc_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_fac_oc
    ADD CONSTRAINT com_fac_oc_pkey PRIMARY KEY (id);


--
-- Name: com_oc_req_detalle com_oc_req_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_oc_req_detalle
    ADD CONSTRAINT com_oc_req_detalle_pkey PRIMARY KEY (id);


--
-- Name: com_oc_req com_oc_req_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_oc_req
    ADD CONSTRAINT com_oc_req_pkey PRIMARY KEY (id);


--
-- Name: com_oc_requisicion com_oc_requisicion_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_oc_requisicion
    ADD CONSTRAINT com_oc_requisicion_pkey PRIMARY KEY (id);


--
-- Name: com_orden_compra_detalle com_orden_compra_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_orden_compra_detalle
    ADD CONSTRAINT com_orden_compra_detalle_pkey PRIMARY KEY (id);


--
-- Name: com_par com_par_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_par
    ADD CONSTRAINT com_par_pkey PRIMARY KEY (id);


--
-- Name: com_proceso_flujo com_proceso_flujo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_proceso_flujo
    ADD CONSTRAINT com_proceso_flujo_pkey PRIMARY KEY (id);


--
-- Name: com_proceso com_proceso_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_proceso
    ADD CONSTRAINT com_proceso_pkey PRIMARY KEY (id);


--
-- Name: com_orden_compra comorden_compra_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_orden_compra
    ADD CONSTRAINT comorden_compra_pkey PRIMARY KEY (id);


--
-- Name: erp_consecutivos consecutivos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_consecutivos
    ADD CONSTRAINT consecutivos_pkey PRIMARY KEY (id);


--
-- Name: costos_kemikal costos_kemikal_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.costos_kemikal
    ADD CONSTRAINT costos_kemikal_pkey PRIMARY KEY (id);


--
-- Name: erp_cotizacions_status cotizacions_status_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_cotizacions_status
    ADD CONSTRAINT cotizacions_status_pkey PRIMARY KEY (id);


--
-- Name: crm_calificaciones_llamadas crm_calificaciones_llamadas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_calificaciones_llamadas
    ADD CONSTRAINT crm_calificaciones_llamadas_pkey PRIMARY KEY (id);


--
-- Name: crm_calificaciones_visita crm_calificaciones_visita_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_calificaciones_visita
    ADD CONSTRAINT crm_calificaciones_visita_pkey PRIMARY KEY (id);


--
-- Name: crm_clasificacion_prospecto crm_clasificacion_prospecto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_clasificacion_prospecto
    ADD CONSTRAINT crm_clasificacion_prospecto_pkey PRIMARY KEY (id);


--
-- Name: crm_config_consultas crm_config_consultas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_config_consultas
    ADD CONSTRAINT crm_config_consultas_pkey PRIMARY KEY (id);


--
-- Name: crm_contacto_cli crm_contacto_cli_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_contacto_cli
    ADD CONSTRAINT crm_contacto_cli_pkey PRIMARY KEY (id);


--
-- Name: crm_contacto_pro crm_contacto_pro_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_contacto_pro
    ADD CONSTRAINT crm_contacto_pro_pkey PRIMARY KEY (id);


--
-- Name: crm_contactos crm_contactos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_contactos
    ADD CONSTRAINT crm_contactos_pkey PRIMARY KEY (id);


--
-- Name: crm_etapas_prospecto crm_etapas_prospecto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_etapas_prospecto
    ADD CONSTRAINT crm_etapas_prospecto_pkey PRIMARY KEY (id);


--
-- Name: crm_etapas_venta crm_etapas_venta_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_etapas_venta
    ADD CONSTRAINT crm_etapas_venta_pkey PRIMARY KEY (id);


--
-- Name: crm_formas_contacto crm_formas_contacto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_formas_contacto
    ADD CONSTRAINT crm_formas_contacto_pkey PRIMARY KEY (id);


--
-- Name: crm_metas crm_metas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_metas
    ADD CONSTRAINT crm_metas_pkey PRIMARY KEY (id);


--
-- Name: crm_motivos_llamada crm_motivos_llamada_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_motivos_llamada
    ADD CONSTRAINT crm_motivos_llamada_pkey PRIMARY KEY (id);


--
-- Name: crm_motivos_visita crm_motivos_visita_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_motivos_visita
    ADD CONSTRAINT crm_motivos_visita_pkey PRIMARY KEY (id);


--
-- Name: crm_oportunidades crm_oportunidades_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_oportunidades
    ADD CONSTRAINT crm_oportunidades_pkey PRIMARY KEY (id);


--
-- Name: crm_prospectos crm_prospectos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_prospectos
    ADD CONSTRAINT crm_prospectos_pkey PRIMARY KEY (id);


--
-- Name: crm_proyecto_estatus crm_proyecto_estatus_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_proyecto_estatus
    ADD CONSTRAINT crm_proyecto_estatus_pkey PRIMARY KEY (id);


--
-- Name: crm_registro_casos_clie crm_registro_casos_clie_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_casos_clie
    ADD CONSTRAINT crm_registro_casos_clie_pkey PRIMARY KEY (id);


--
-- Name: crm_registro_casos crm_registro_casos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_casos
    ADD CONSTRAINT crm_registro_casos_pkey PRIMARY KEY (id);


--
-- Name: crm_registro_casos_prospectos crm_registro_casos_prospectos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_casos_prospectos
    ADD CONSTRAINT crm_registro_casos_prospectos_pkey PRIMARY KEY (id);


--
-- Name: crm_registro_llamadas crm_registro_llamadas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_llamadas
    ADD CONSTRAINT crm_registro_llamadas_pkey PRIMARY KEY (id);


--
-- Name: crm_registro_proyecto crm_registro_proyecto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_proyecto
    ADD CONSTRAINT crm_registro_proyecto_pkey PRIMARY KEY (id);


--
-- Name: crm_registro_visitas crm_registro_visitas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_visitas
    ADD CONSTRAINT crm_registro_visitas_pkey PRIMARY KEY (id);


--
-- Name: crm_tipo_industria crm_tipo_industria_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipo_industria
    ADD CONSTRAINT crm_tipo_industria_pkey PRIMARY KEY (id);


--
-- Name: crm_tipo_prospecto crm_tipo_prospecto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipo_prospecto
    ADD CONSTRAINT crm_tipo_prospecto_pkey PRIMARY KEY (id);


--
-- Name: crm_tipos_oportunidad crm_tipos_oportunidad_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipos_oportunidad
    ADD CONSTRAINT crm_tipos_oportunidad_pkey PRIMARY KEY (id);


--
-- Name: crm_tipos_seguimiento_llamadas crm_tipos_seguimiento_llamadas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipos_seguimiento_llamadas
    ADD CONSTRAINT crm_tipos_seguimiento_llamadas_pkey PRIMARY KEY (id);


--
-- Name: crm_tipos_seguimiento_visita crm_tipos_seguimiento_visita_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_tipos_seguimiento_visita
    ADD CONSTRAINT crm_tipos_seguimiento_visita_pkey PRIMARY KEY (id);


--
-- Name: ctb_app ctb_app_gral_app_id_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_app
    ADD CONSTRAINT ctb_app_gral_app_id_key UNIQUE (gral_app_id);


--
-- Name: ctb_app ctb_app_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_app
    ADD CONSTRAINT ctb_app_pkey PRIMARY KEY (id);


--
-- Name: ctb_app ctb_app_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_app
    ADD CONSTRAINT ctb_app_titulo_key UNIQUE (titulo);


--
-- Name: ctb_cc ctb_cc_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_cc
    ADD CONSTRAINT ctb_cc_pkey PRIMARY KEY (id);


--
-- Name: ctb_con ctb_con_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_con
    ADD CONSTRAINT ctb_con_pkey PRIMARY KEY (id);


--
-- Name: ctb_cta_status ctb_cta_estados_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_cta_status
    ADD CONSTRAINT ctb_cta_estados_pkey PRIMARY KEY (id);


--
-- Name: ctb_cta_status ctb_cta_estados_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_cta_status
    ADD CONSTRAINT ctb_cta_estados_titulo_key UNIQUE (titulo);


--
-- Name: ctb_cta ctb_cta_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_cta
    ADD CONSTRAINT ctb_cta_pkey PRIMARY KEY (id);


--
-- Name: ctb_may_clases ctb_may_clases_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_may_clases
    ADD CONSTRAINT ctb_may_clases_pkey PRIMARY KEY (id);


--
-- Name: ctb_may_clases ctb_may_clases_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_may_clases
    ADD CONSTRAINT ctb_may_clases_titulo_key UNIQUE (titulo);


--
-- Name: ctb_may ctb_may_ctb_may_clase_id_clasificacion_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_may
    ADD CONSTRAINT ctb_may_ctb_may_clase_id_clasificacion_key UNIQUE (empresa_id, ctb_may_clase_id, clasificacion);


--
-- Name: ctb_may ctb_may_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_may
    ADD CONSTRAINT ctb_may_pkey PRIMARY KEY (id);


--
-- Name: ctb_par_er ctb_par_er_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_par_er
    ADD CONSTRAINT ctb_par_er_pkey PRIMARY KEY (id);


--
-- Name: ctb_par ctb_par_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_par
    ADD CONSTRAINT ctb_par_pkey PRIMARY KEY (id);


--
-- Name: ctb_pol_anios ctb_pol_anios_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_anios
    ADD CONSTRAINT ctb_pol_anios_pkey PRIMARY KEY (id);


--
-- Name: ctb_pol_cons ctb_pol_cons_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_cons
    ADD CONSTRAINT ctb_pol_cons_pkey PRIMARY KEY (id);


--
-- Name: ctb_pol_mov ctb_pol_mov_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_mov
    ADD CONSTRAINT ctb_pol_mov_pkey PRIMARY KEY (id);


--
-- Name: ctb_pol ctb_pol_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol
    ADD CONSTRAINT ctb_pol_pkey PRIMARY KEY (id);


--
-- Name: ctb_sdo_cta ctb_sdo_cta_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_sdo_cta
    ADD CONSTRAINT ctb_sdo_cta_pkey PRIMARY KEY (id);


--
-- Name: ctb_tmov ctb_tmov_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_tmov
    ADD CONSTRAINT ctb_tmov_pkey PRIMARY KEY (id);


--
-- Name: ctb_tpol_grupos ctb_tpol_clases_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_tpol_grupos
    ADD CONSTRAINT ctb_tpol_clases_pkey PRIMARY KEY (id);


--
-- Name: ctb_tpol_grupos ctb_tpol_clases_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_tpol_grupos
    ADD CONSTRAINT ctb_tpol_clases_titulo_key UNIQUE (titulo);


--
-- Name: ctb_tpol ctb_tpol_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_tpol
    ADD CONSTRAINT ctb_tpol_pkey PRIMARY KEY (id);


--
-- Name: erp_cuentas cuentas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_cuentas
    ADD CONSTRAINT cuentas_pkey PRIMARY KEY (id);


--
-- Name: cxc_agen_borrar cxc_agen_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_agen_borrar
    ADD CONSTRAINT cxc_agen_pkey PRIMARY KEY (id);


--
-- Name: cxc_ant_borrar cxc_ant_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_ant_borrar
    ADD CONSTRAINT cxc_ant_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_adenda_datos cxc_clie_adenda_datos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_adenda_datos
    ADD CONSTRAINT cxc_clie_adenda_datos_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_clas1 cxc_clie_clas1_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_clas1
    ADD CONSTRAINT cxc_clie_clas1_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_clas2 cxc_clie_clas2_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_clas2
    ADD CONSTRAINT cxc_clie_clas2_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_clas3 cxc_clie_clas3_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_clas3
    ADD CONSTRAINT cxc_clie_clas3_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_creapar cxc_clie_creapar_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_creapar
    ADD CONSTRAINT cxc_clie_creapar_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_df cxc_clie_df_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_df
    ADD CONSTRAINT cxc_clie_df_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_grupos cxc_clie_grupos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_grupos
    ADD CONSTRAINT cxc_clie_grupos_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_grupos cxc_clie_grupos_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_grupos
    ADD CONSTRAINT cxc_clie_grupos_titulo_key UNIQUE (titulo);


--
-- Name: cxc_clie_mensajes cxc_clie_mensajes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_mensajes
    ADD CONSTRAINT cxc_clie_mensajes_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie cxc_clie_numero_control_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie
    ADD CONSTRAINT cxc_clie_numero_control_key UNIQUE (numero_control);


--
-- Name: cxc_clie cxc_clie_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie
    ADD CONSTRAINT cxc_clie_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_adenda_tipo cxc_clie_tipos_adenda_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_adenda_tipo
    ADD CONSTRAINT cxc_clie_tipos_adenda_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_tipos_embarque cxc_clie_tipos_embarque_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_tipos_embarque
    ADD CONSTRAINT cxc_clie_tipos_embarque_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_zonas cxc_clie_zonas_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_zonas
    ADD CONSTRAINT cxc_clie_zonas_key UNIQUE (titulo);


--
-- Name: cxc_clie_zonas cxc_clie_zonas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_zonas
    ADD CONSTRAINT cxc_clie_zonas_pkey PRIMARY KEY (id);


--
-- Name: cxc_fac_rev_cob_detalle cxc_fac_rev_cob_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_fac_rev_cob_detalle
    ADD CONSTRAINT cxc_fac_rev_cob_detalle_pkey PRIMARY KEY (id);


--
-- Name: cxc_fac_rev_cob cxc_fac_rev_cob_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_fac_rev_cob
    ADD CONSTRAINT cxc_fac_rev_cob_pkey PRIMARY KEY (id);


--
-- Name: cxp_facturas cxc_facturas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_facturas
    ADD CONSTRAINT cxc_facturas_pkey PRIMARY KEY (id);


--
-- Name: cxc_mov_tipos cxc_mov_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_mov_tipos
    ADD CONSTRAINT cxc_mov_tipos_pkey PRIMARY KEY (id);


--
-- Name: cxp_ant_par cxp_ant_par_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_ant_par
    ADD CONSTRAINT cxp_ant_par_pkey PRIMARY KEY (id);


--
-- Name: cxp_facturas_detalle cxp_facturas_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_facturas_detalle
    ADD CONSTRAINT cxp_facturas_detalle_pkey PRIMARY KEY (id);


--
-- Name: cxp_mov_tipos cxp_mov_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_mov_tipos
    ADD CONSTRAINT cxp_mov_tipos_pkey PRIMARY KEY (id);


--
-- Name: cxp_nota_credito cxp_nota_credito_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_nota_credito
    ADD CONSTRAINT cxp_nota_credito_pkey PRIMARY KEY (id);


--
-- Name: cxp_pagos_detalles cxp_pagos_detalles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_pagos_detalles
    ADD CONSTRAINT cxp_pagos_detalles_pkey PRIMARY KEY (id);


--
-- Name: cxp_pagos_formas cxp_pagos_formas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_pagos_formas
    ADD CONSTRAINT cxp_pagos_formas_pkey PRIMARY KEY (id);


--
-- Name: cxp_pagos cxp_pagos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_pagos
    ADD CONSTRAINT cxp_pagos_pkey PRIMARY KEY (id);


--
-- Name: cxp_pagos_tipo_movimiento cxp_pagos_tipo_movimiento_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_pagos_tipo_movimiento
    ADD CONSTRAINT cxp_pagos_tipo_movimiento_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_clas1 cxp_prov_clas1_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_clas1
    ADD CONSTRAINT cxp_prov_clas1_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_clas2 cxp_prov_clas2_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_clas2
    ADD CONSTRAINT cxp_prov_clas2_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_clas3 cxp_prov_clas3_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_clas3
    ADD CONSTRAINT cxp_prov_clas3_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_creapar cxp_prov_creapar_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_creapar
    ADD CONSTRAINT cxp_prov_creapar_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_credias cxp_prov_credias_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_credias
    ADD CONSTRAINT cxp_prov_credias_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_dir cxp_prov_dir_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_dir
    ADD CONSTRAINT cxp_prov_dir_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_grupos cxp_prov_grupos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_grupos
    ADD CONSTRAINT cxp_prov_grupos_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_grupos cxp_prov_grupos_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_grupos
    ADD CONSTRAINT cxp_prov_grupos_titulo_key UNIQUE (titulo);


--
-- Name: cxp_prov_mensajes cxp_prov_mensajes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_mensajes
    ADD CONSTRAINT cxp_prov_mensajes_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov cxp_prov_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov
    ADD CONSTRAINT cxp_prov_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_tipos_embarque cxp_prov_tipos_embarque_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_tipos_embarque
    ADD CONSTRAINT cxp_prov_tipos_embarque_pkey PRIMARY KEY (id);


--
-- Name: cxp_facturas_tipos_cancelacion cxp_tipos_cancelacion_factura_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_facturas_tipos_cancelacion
    ADD CONSTRAINT cxp_tipos_cancelacion_factura_key UNIQUE (titulo);


--
-- Name: cxp_facturas_tipos_cancelacion cxp_tipos_cancelacion_factura_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_facturas_tipos_cancelacion
    ADD CONSTRAINT cxp_tipos_cancelacion_factura_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_zonas cxp_zonas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_zonas
    ADD CONSTRAINT cxp_zonas_pkey PRIMARY KEY (id);


--
-- Name: erp_monedavers denominacion_vers_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_monedavers
    ADD CONSTRAINT denominacion_vers_pkey PRIMARY KEY (id);


--
-- Name: erp_emails emails_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_emails
    ADD CONSTRAINT emails_pkey PRIMARY KEY (id);


--
-- Name: erp_emails emails_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_emails
    ADD CONSTRAINT emails_titulo_key UNIQUE (titulo);


--
-- Name: erp_empleados empleados_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_empleados
    ADD CONSTRAINT empleados_pkey PRIMARY KEY (id);


--
-- Name: env_conf_det env_conf_det_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_conf_det
    ADD CONSTRAINT env_conf_det_pkey PRIMARY KEY (id);


--
-- Name: env_conf env_conf_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_conf
    ADD CONSTRAINT env_conf_pkey PRIMARY KEY (id);


--
-- Name: env_env env_envasado_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_env
    ADD CONSTRAINT env_envasado_pkey PRIMARY KEY (id);


--
-- Name: env_env_det env_envdetalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_env_det
    ADD CONSTRAINT env_envdetalle_pkey PRIMARY KEY (id);


--
-- Name: env_estatus env_estatus_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_estatus
    ADD CONSTRAINT env_estatus_pkey PRIMARY KEY (id);


--
-- Name: env_reenv_det env_reenv_det_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_reenv_det
    ADD CONSTRAINT env_reenv_det_pkey PRIMARY KEY (id);


--
-- Name: env_reenv env_reenv_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.env_reenv
    ADD CONSTRAINT env_reenv_pkey PRIMARY KEY (id);


--
-- Name: cxc_ant erp_anticipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_ant
    ADD CONSTRAINT erp_anticipos_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie2 erp_clientes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie2
    ADD CONSTRAINT erp_clientes_pkey PRIMARY KEY (id);


--
-- Name: erp_cotizacions_detalles erp_cotizacions_detalles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_cotizacions_detalles
    ADD CONSTRAINT erp_cotizacions_detalles_pkey PRIMARY KEY (id);


--
-- Name: erp_proceso_flujo erp_cotizacions_flujo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_proceso_flujo
    ADD CONSTRAINT erp_cotizacions_flujo_pkey PRIMARY KEY (id);


--
-- Name: erp_cotizacions erp_cotizacions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_cotizacions
    ADD CONSTRAINT erp_cotizacions_pkey PRIMARY KEY (id);


--
-- Name: fac_cfds erp_facturas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_cfds
    ADD CONSTRAINT erp_facturas_pkey PRIMARY KEY (id);


--
-- Name: erp_historico_traspasos_detalles erp_historico_traspasos_detalles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_historico_traspasos_detalles
    ADD CONSTRAINT erp_historico_traspasos_detalles_pkey PRIMARY KEY (id);


--
-- Name: erp_historico_traspasos erp_historico_traspasos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_historico_traspasos
    ADD CONSTRAINT erp_historico_traspasos_pkey PRIMARY KEY (id);


--
-- Name: erp_notas_credito_detalles erp_notas_credito_detalles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_notas_credito_detalles
    ADD CONSTRAINT erp_notas_credito_detalles_pkey PRIMARY KEY (id);


--
-- Name: erp_notas_credito erp_notas_credito_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_notas_credito
    ADD CONSTRAINT erp_notas_credito_pkey PRIMARY KEY (id);


--
-- Name: erp_pagos_cancelacion_detalles erp_pagos_cancelacion_detalles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagos_cancelacion_detalles
    ADD CONSTRAINT erp_pagos_cancelacion_detalles_pkey PRIMARY KEY (id);


--
-- Name: erp_pagos_detalles erp_pagos_detalles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagos_detalles
    ADD CONSTRAINT erp_pagos_detalles_pkey PRIMARY KEY (id);


--
-- Name: erp_pagos_formas erp_pagos_formas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagos_formas
    ADD CONSTRAINT erp_pagos_formas_pkey PRIMARY KEY (id);


--
-- Name: erp_pagos erp_pagos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagos
    ADD CONSTRAINT erp_pagos_pkey PRIMARY KEY (id);


--
-- Name: erp_pagos_tipo_movimiento erp_pagos_tipo_movimiento_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagos_tipo_movimiento
    ADD CONSTRAINT erp_pagos_tipo_movimiento_pkey PRIMARY KEY (id);


--
-- Name: erp_pagosxaplicar erp_pagosxaplicar_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_pagosxaplicar
    ADD CONSTRAINT erp_pagosxaplicar_pkey PRIMARY KEY (id);


--
-- Name: com_fac_detalle erp_prealmacen_entradas_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_fac_detalle
    ADD CONSTRAINT erp_prealmacen_entradas_detalle_pkey PRIMARY KEY (id);


--
-- Name: com_fac erp_prealmacen_entradas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_fac
    ADD CONSTRAINT erp_prealmacen_entradas_pkey PRIMARY KEY (id);


--
-- Name: erp_prefacturas_detalles erp_prefacturas_detalles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_prefacturas_detalles
    ADD CONSTRAINT erp_prefacturas_detalles_pkey PRIMARY KEY (id);


--
-- Name: erp_prefacturas erp_prefacturas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_prefacturas
    ADD CONSTRAINT erp_prefacturas_pkey PRIMARY KEY (id);


--
-- Name: erp_proceso erp_proceso_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_proceso
    ADD CONSTRAINT erp_proceso_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_credias erp_terminos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_credias
    ADD CONSTRAINT erp_terminos_pkey PRIMARY KEY (id);


--
-- Name: erp_tiempos_entrega erp_tiempos_entrega_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_tiempos_entrega
    ADD CONSTRAINT erp_tiempos_entrega_pkey PRIMARY KEY (id);


--
-- Name: gral_usr erp_users_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr
    ADD CONSTRAINT erp_users_pkey PRIMARY KEY (id);


--
-- Name: erp_escolaridads escolaridads_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_escolaridads
    ADD CONSTRAINT escolaridads_pkey PRIMARY KEY (id);


--
-- Name: erp_estatus_ordencompra estatus_compraordenes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_estatus_ordencompra
    ADD CONSTRAINT estatus_compraordenes_pkey PRIMARY KEY (id);


--
-- Name: fac_cfdis fac_cfdis_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_cfdis
    ADD CONSTRAINT fac_cfdis_pkey PRIMARY KEY (id);


--
-- Name: fac_cfds_conf_folios fac_cfds_folios_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_cfds_conf_folios
    ADD CONSTRAINT fac_cfds_folios_pkey PRIMARY KEY (id);


--
-- Name: fac_docs_adenda fac_docs_adenda_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_docs_adenda
    ADD CONSTRAINT fac_docs_adenda_pkey PRIMARY KEY (id);


--
-- Name: fac_docs_detalles fac_docs_detalles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_docs_detalles
    ADD CONSTRAINT fac_docs_detalles_pkey PRIMARY KEY (id);


--
-- Name: fac_docs fac_docs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_docs
    ADD CONSTRAINT fac_docs_pkey PRIMARY KEY (id);


--
-- Name: fac_docs_tipos_cancelacion fac_docs_tipos_cancelacion_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_docs_tipos_cancelacion
    ADD CONSTRAINT fac_docs_tipos_cancelacion_key UNIQUE (titulo);


--
-- Name: fac_docs_tipos_cancelacion fac_docs_tipos_cancelacion_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_docs_tipos_cancelacion
    ADD CONSTRAINT fac_docs_tipos_cancelacion_pkey PRIMARY KEY (id);


--
-- Name: fac_metodos_pago fac_metodos_pago_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_metodos_pago
    ADD CONSTRAINT fac_metodos_pago_pkey PRIMARY KEY (id);


--
-- Name: fac_namespaces fac_namespaces_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_namespaces
    ADD CONSTRAINT fac_namespaces_pkey PRIMARY KEY (id);


--
-- Name: fac_nomina_det_deduc fac_nomina_det_deduc_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det_deduc
    ADD CONSTRAINT fac_nomina_det_deduc_pkey PRIMARY KEY (id);


--
-- Name: fac_nomina_det_hrs_extra fac_nomina_det_hrs_extra_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det_hrs_extra
    ADD CONSTRAINT fac_nomina_det_hrs_extra_pkey PRIMARY KEY (id);


--
-- Name: fac_nomina_det_incapa fac_nomina_det_incapa_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det_incapa
    ADD CONSTRAINT fac_nomina_det_incapa_pkey PRIMARY KEY (id);


--
-- Name: fac_nomina_det_percep fac_nomina_det_percep_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det_percep
    ADD CONSTRAINT fac_nomina_det_percep_pkey PRIMARY KEY (id);


--
-- Name: fac_nomina_det fac_nomina_det_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det
    ADD CONSTRAINT fac_nomina_det_pkey PRIMARY KEY (id);


--
-- Name: fac_nomina_par fac_nomina_par_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_par
    ADD CONSTRAINT fac_nomina_par_pkey PRIMARY KEY (id);


--
-- Name: fac_nomina fac_nomina_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina
    ADD CONSTRAINT fac_nomina_pkey PRIMARY KEY (id);


--
-- Name: fac_nota_credito_det fac_nota_credito_det_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nota_credito_det
    ADD CONSTRAINT fac_nota_credito_det_pkey PRIMARY KEY (id);


--
-- Name: fac_nota_credito fac_nota_credito_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nota_credito
    ADD CONSTRAINT fac_nota_credito_pkey PRIMARY KEY (id);


--
-- Name: fac_par fac_par_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_par
    ADD CONSTRAINT fac_par_pkey PRIMARY KEY (id);


--
-- Name: fac_rem_doc_det fac_rem_doc_det_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_rem_doc_det
    ADD CONSTRAINT fac_rem_doc_det_pkey PRIMARY KEY (id);


--
-- Name: fac_rems_detalles fac_rems_detalles_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_rems_detalles
    ADD CONSTRAINT fac_rems_detalles_pkey PRIMARY KEY (id);


--
-- Name: fac_rems_docs fac_rems_docs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_rems_docs
    ADD CONSTRAINT fac_rems_docs_pkey PRIMARY KEY (id);


--
-- Name: fac_rems fac_rems_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_rems
    ADD CONSTRAINT fac_rems_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_fleteras fleteras_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_fleteras
    ADD CONSTRAINT fleteras_pkey PRIMARY KEY (id);


--
-- Name: gral_ano_fiscal gral_ano_fis_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_ano_fiscal
    ADD CONSTRAINT gral_ano_fis_pkey PRIMARY KEY (id);


--
-- Name: gral_app gral_app_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_app
    ADD CONSTRAINT gral_app_pkey PRIMARY KEY (id);


--
-- Name: gral_app gral_app_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_app
    ADD CONSTRAINT gral_app_titulo_key UNIQUE (descripcion);


--
-- Name: gral_categ gral_categ_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_categ
    ADD CONSTRAINT gral_categ_pkey PRIMARY KEY (id);


--
-- Name: gral_civils gral_civils_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_civils
    ADD CONSTRAINT gral_civils_pkey PRIMARY KEY (id);


--
-- Name: gral_cons gral_cons_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_cons
    ADD CONSTRAINT gral_cons_pkey PRIMARY KEY (id);


--
-- Name: gral_cons_tipos gral_cons_tipos_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_cons_tipos
    ADD CONSTRAINT gral_cons_tipos_key UNIQUE (titulo);


--
-- Name: gral_cons_tipos gral_cons_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_cons_tipos
    ADD CONSTRAINT gral_cons_tipos_pkey PRIMARY KEY (id);


--
-- Name: gral_deptos gral_deptos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_deptos
    ADD CONSTRAINT gral_deptos_pkey PRIMARY KEY (id);


--
-- Name: gral_deptos_turnos gral_deptos_turnos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_deptos_turnos
    ADD CONSTRAINT gral_deptos_turnos_pkey PRIMARY KEY (id);


--
-- Name: gral_dias_no_laborables gral_dias_no_laborables_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_dias_no_laborables
    ADD CONSTRAINT gral_dias_no_laborables_pkey PRIMARY KEY (id);


--
-- Name: gral_docs_conf gral_docs_conf_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_docs_conf
    ADD CONSTRAINT gral_docs_conf_pkey PRIMARY KEY (id);


--
-- Name: gral_docs gral_docs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_docs
    ADD CONSTRAINT gral_docs_pkey PRIMARY KEY (id);


--
-- Name: gral_edo gral_edo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_edo
    ADD CONSTRAINT gral_edo_pkey PRIMARY KEY (id);


--
-- Name: gral_emails gral_emails_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emails
    ADD CONSTRAINT gral_emails_pkey PRIMARY KEY (id);


--
-- Name: gral_emp_consecutivos gral_emp_consecutivos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp_consecutivos
    ADD CONSTRAINT gral_emp_consecutivos_pkey PRIMARY KEY (id);


--
-- Name: fac_cfds_conf gral_emp_fe_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_cfds_conf
    ADD CONSTRAINT gral_emp_fe_pkey PRIMARY KEY (id);


--
-- Name: gral_emp_leyenda gral_emp_leyenda_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp_leyenda
    ADD CONSTRAINT gral_emp_leyenda_pkey PRIMARY KEY (id);


--
-- Name: gral_empleado_deduc gral_empleado_deduc_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_deduc
    ADD CONSTRAINT gral_empleado_deduc_pkey PRIMARY KEY (id);


--
-- Name: gral_empleado_percep gral_empleado_percep_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_percep
    ADD CONSTRAINT gral_empleado_percep_pkey PRIMARY KEY (id);


--
-- Name: gral_empleados gral_empleados_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleados
    ADD CONSTRAINT gral_empleados_pkey PRIMARY KEY (id);


--
-- Name: gral_escolaridads gral_escolaridads_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_escolaridads
    ADD CONSTRAINT gral_escolaridads_pkey PRIMARY KEY (id);


--
-- Name: gral_ieps_cta gral_ieps_cta_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_ieps_cta
    ADD CONSTRAINT gral_ieps_cta_pkey PRIMARY KEY (id);


--
-- Name: gral_ieps gral_ieps_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_ieps
    ADD CONSTRAINT gral_ieps_pkey PRIMARY KEY (id);


--
-- Name: gral_impto_cta gral_impto_cta_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_impto_cta
    ADD CONSTRAINT gral_impto_cta_pkey PRIMARY KEY (id);


--
-- Name: gral_impto_ret_cta gral_impto_ret_cta_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_impto_ret_cta
    ADD CONSTRAINT gral_impto_ret_cta_pkey PRIMARY KEY (id);


--
-- Name: gral_imptos gral_imptos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_imptos
    ADD CONSTRAINT gral_imptos_pkey PRIMARY KEY (id);


--
-- Name: gral_imptos_ret gral_imptos_ret_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_imptos_ret
    ADD CONSTRAINT gral_imptos_ret_pkey PRIMARY KEY (id);


--
-- Name: gral_isr gral_isr_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_isr
    ADD CONSTRAINT gral_isr_pkey PRIMARY KEY (id);


--
-- Name: gral_mon gral_mon_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_mon
    ADD CONSTRAINT gral_mon_pkey PRIMARY KEY (id);


--
-- Name: gral_mun gral_mun_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_mun
    ADD CONSTRAINT gral_mun_pkey PRIMARY KEY (id);


--
-- Name: gral_pais gral_pais_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_pais
    ADD CONSTRAINT gral_pais_pkey PRIMARY KEY (id);


--
-- Name: gral_pais gral_pais_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_pais
    ADD CONSTRAINT gral_pais_titulo_key UNIQUE (titulo);


--
-- Name: gral_plazas gral_plazas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_plazas
    ADD CONSTRAINT gral_plazas_pkey PRIMARY KEY (id);


--
-- Name: gral_puestos gral_puestos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_puestos
    ADD CONSTRAINT gral_puestos_pkey PRIMARY KEY (id);


--
-- Name: gral_reg gral_reg_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_reg
    ADD CONSTRAINT gral_reg_pkey PRIMARY KEY (id);


--
-- Name: gral_reg gral_reg_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_reg
    ADD CONSTRAINT gral_reg_titulo_key UNIQUE (titulo);


--
-- Name: gral_religions gral_religions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_religions
    ADD CONSTRAINT gral_religions_pkey PRIMARY KEY (id);


--
-- Name: gral_rol gral_rols_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_rol
    ADD CONSTRAINT gral_rols_pkey PRIMARY KEY (id);


--
-- Name: gral_sangretipos gral_sangretipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_sangretipos
    ADD CONSTRAINT gral_sangretipos_pkey PRIMARY KEY (id);


--
-- Name: gral_sexos gral_sexos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_sexos
    ADD CONSTRAINT gral_sexos_pkey PRIMARY KEY (id);


--
-- Name: gral_emp gral_sis_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp
    ADD CONSTRAINT gral_sis_pkey PRIMARY KEY (id);


--
-- Name: gral_emp gral_sis_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp
    ADD CONSTRAINT gral_sis_titulo_key UNIQUE (titulo);


--
-- Name: gral_suc_pza gral_suc_pza_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc_pza
    ADD CONSTRAINT gral_suc_pza_pkey PRIMARY KEY (id);


--
-- Name: gral_suc gral_suc_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc
    ADD CONSTRAINT gral_suc_titulo_key UNIQUE (titulo);


--
-- Name: gral_suc gral_sucursales_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc
    ADD CONSTRAINT gral_sucursales_pkey PRIMARY KEY (id);


--
-- Name: gral_tc_url gral_tc_url_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_tc_url
    ADD CONSTRAINT gral_tc_url_key UNIQUE (url);


--
-- Name: gral_tc_url gral_tc_url_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_tc_url
    ADD CONSTRAINT gral_tc_url_pkey PRIMARY KEY (id);


--
-- Name: gral_usr_rol gral_usr_rol_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr_rol
    ADD CONSTRAINT gral_usr_rol_pkey PRIMARY KEY (id);


--
-- Name: gral_usr_suc gral_usr_suc_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr_suc
    ADD CONSTRAINT gral_usr_suc_pkey PRIMARY KEY (id);


--
-- Name: erp_h_facturas h_facturas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_h_facturas
    ADD CONSTRAINT h_facturas_pkey PRIMARY KEY (id);


--
-- Name: erp_proveedoreswebusers id; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_proveedoreswebusers
    ADD CONSTRAINT id PRIMARY KEY (id);


--
-- Name: inv_prod_sust inv_art_sust_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_sust
    ADD CONSTRAINT inv_art_sust_pkey PRIMARY KEY (id);


--
-- Name: inv_clas inv_clas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_clas
    ADD CONSTRAINT inv_clas_pkey PRIMARY KEY (id);


--
-- Name: inv_com_tipos inv_com_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_com_tipos
    ADD CONSTRAINT inv_com_tipos_pkey PRIMARY KEY (id);


--
-- Name: cxc_clie_descto inv_cxc_clie_descto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_descto
    ADD CONSTRAINT inv_cxc_clie_descto_pkey PRIMARY KEY (id);


--
-- Name: inv_etiqueta_medidas inv_etiqueta_medidas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_etiqueta_medidas
    ADD CONSTRAINT inv_etiqueta_medidas_pkey PRIMARY KEY (id);


--
-- Name: inv_etiquetas_detalle inv_etiquetas_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_etiquetas_detalle
    ADD CONSTRAINT inv_etiquetas_detalle_pkey PRIMARY KEY (id);


--
-- Name: inv_etiquetas inv_etiquetas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_etiquetas
    ADD CONSTRAINT inv_etiquetas_pkey PRIMARY KEY (id);


--
-- Name: inv_exi inv_exi_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi
    ADD CONSTRAINT inv_exi_pkey PRIMARY KEY (id);


--
-- Name: inv_exi_pres inv_exi_pres_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi_pres
    ADD CONSTRAINT inv_exi_pres_pkey PRIMARY KEY (id);


--
-- Name: inv_exi_tmp inv_exi_tmp_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi_tmp
    ADD CONSTRAINT inv_exi_tmp_pkey PRIMARY KEY (id);


--
-- Name: inv_existencia_inicial_kathion inv_existencia_inicial_kathion_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_existencia_inicial_kathion
    ADD CONSTRAINT inv_existencia_inicial_kathion_pkey PRIMARY KEY (id);


--
-- Name: inv_existencia_inicial inv_existencia_inicial_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_existencia_inicial
    ADD CONSTRAINT inv_existencia_inicial_pkey PRIMARY KEY (id);


--
-- Name: inv_fac_etiqueta inv_fac_etiqueta_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_fac_etiqueta
    ADD CONSTRAINT inv_fac_etiqueta_pkey PRIMARY KEY (id);


--
-- Name: inv_fac inv_fac_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_fac
    ADD CONSTRAINT inv_fac_pkey PRIMARY KEY (id);


--
-- Name: inv_kat_kem_sep2013 inv_kat_kem_sep2013_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_kat_kem_sep2013
    ADD CONSTRAINT inv_kat_kem_sep2013_pkey PRIMARY KEY (id);


--
-- Name: inv_kit inv_kit_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_kit
    ADD CONSTRAINT inv_kit_pkey PRIMARY KEY (id);


--
-- Name: inv_lm inv_lm_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lm
    ADD CONSTRAINT inv_lm_pkey PRIMARY KEY (id);


--
-- Name: inv_lote_detalle inv_lote_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_detalle
    ADD CONSTRAINT inv_lote_detalle_pkey PRIMARY KEY (id);


--
-- Name: inv_lote_mov_det inv_lote_mov_det_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_mov_det
    ADD CONSTRAINT inv_lote_mov_det_pkey PRIMARY KEY (id);


--
-- Name: inv_lote_mov inv_lote_mov_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_mov
    ADD CONSTRAINT inv_lote_mov_pkey PRIMARY KEY (id);


--
-- Name: inv_lote inv_lote_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote
    ADD CONSTRAINT inv_lote_pkey PRIMARY KEY (id);


--
-- Name: inv_lote_tmp inv_lote_tmp_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_tmp
    ADD CONSTRAINT inv_lote_tmp_pkey PRIMARY KEY (id);


--
-- Name: inv_mar inv_mar_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mar
    ADD CONSTRAINT inv_mar_pkey PRIMARY KEY (id);


--
-- Name: inv_mov_detalle inv_mov_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mov_detalle
    ADD CONSTRAINT inv_mov_detalle_pkey PRIMARY KEY (id);


--
-- Name: inv_mov inv_mov_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mov
    ADD CONSTRAINT inv_mov_pkey PRIMARY KEY (id);


--
-- Name: inv_mov_tipos inv_mov_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mov_tipos
    ADD CONSTRAINT inv_mov_tipos_pkey PRIMARY KEY (id);


--
-- Name: inv_odev_detalle inv_odev_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_odev_detalle
    ADD CONSTRAINT inv_odev_detalle_pkey PRIMARY KEY (id);


--
-- Name: inv_odev inv_odev_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_odev
    ADD CONSTRAINT inv_odev_pkey PRIMARY KEY (id);


--
-- Name: inv_oent_detalle inv_oent_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_oent_detalle
    ADD CONSTRAINT inv_oent_detalle_pkey PRIMARY KEY (id);


--
-- Name: inv_oent inv_oent_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_oent
    ADD CONSTRAINT inv_oent_pkey PRIMARY KEY (id);


--
-- Name: inv_ord_subensamble_detalle_formula inv_ord_subensamble_detalle_formula_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_ord_subensamble_detalle_formula
    ADD CONSTRAINT inv_ord_subensamble_detalle_formula_pkey PRIMARY KEY (id);


--
-- Name: inv_ord_subensamble_detalle inv_ord_subensamble_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_ord_subensamble_detalle
    ADD CONSTRAINT inv_ord_subensamble_detalle_pkey PRIMARY KEY (id);


--
-- Name: inv_ord_subensamble inv_ord_subensamble_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_ord_subensamble
    ADD CONSTRAINT inv_ord_subensamble_pkey PRIMARY KEY (id);


--
-- Name: inv_osal_detalle inv_osal_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_osal_detalle
    ADD CONSTRAINT inv_osal_detalle_pkey PRIMARY KEY (id);


--
-- Name: inv_osal inv_osal_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_osal
    ADD CONSTRAINT inv_osal_pkey PRIMARY KEY (id);


--
-- Name: inv_otras_det inv_otras_det_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_otras_det
    ADD CONSTRAINT inv_otras_det_pkey PRIMARY KEY (id);


--
-- Name: inv_otras inv_otras_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_otras
    ADD CONSTRAINT inv_otras_pkey PRIMARY KEY (id);


--
-- Name: inv_pre_par inv_pre_par_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_pre_par
    ADD CONSTRAINT inv_pre_par_pkey PRIMARY KEY (id);


--
-- Name: inv_pre inv_pre_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_pre
    ADD CONSTRAINT inv_pre_pkey PRIMARY KEY (id);


--
-- Name: inv_proceso_flujo inv_proceso_flujo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_proceso_flujo
    ADD CONSTRAINT inv_proceso_flujo_pkey PRIMARY KEY (id);


--
-- Name: inv_proceso inv_proceso_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_proceso
    ADD CONSTRAINT inv_proceso_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_cost_prom inv_prod_cost_prom_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_cost_prom
    ADD CONSTRAINT inv_prod_cost_prom_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_costos inv_prod_costo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_costos
    ADD CONSTRAINT inv_prod_costo_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_equiv inv_prod_equiv_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_equiv
    ADD CONSTRAINT inv_prod_equiv_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_familias inv_prod_familias_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_familias
    ADD CONSTRAINT inv_prod_familias_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_lineas inv_prod_lineas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_lineas
    ADD CONSTRAINT inv_prod_lineas_pkey PRIMARY KEY (id);


--
-- Name: inv_prod inv_prod_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod
    ADD CONSTRAINT inv_prod_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_tipos inv_prod_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_tipos
    ADD CONSTRAINT inv_prod_tipos_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_unidades inv_prod_unidades_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_unidades
    ADD CONSTRAINT inv_prod_unidades_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_unidades inv_prod_unidades_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_unidades
    ADD CONSTRAINT inv_prod_unidades_titulo_key UNIQUE (titulo);


--
-- Name: inv_secciones inv_secciones_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_secciones
    ADD CONSTRAINT inv_secciones_pkey PRIMARY KEY (id);


--
-- Name: inv_stock_clasificaciones inv_stock_clasificaciones_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_stock_clasificaciones
    ADD CONSTRAINT inv_stock_clasificaciones_pkey PRIMARY KEY (id);


--
-- Name: inv_suc_alm inv_suc_alm_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_suc_alm
    ADD CONSTRAINT inv_suc_alm_pkey PRIMARY KEY (id);


--
-- Name: inv_tras_det inv_tras_det_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_tras_det
    ADD CONSTRAINT inv_tras_det_pkey PRIMARY KEY (id);


--
-- Name: inv_tras inv_tras_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_tras
    ADD CONSTRAINT inv_tras_pkey PRIMARY KEY (id);


--
-- Name: inv_zonas inv_zonas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_zonas
    ADD CONSTRAINT inv_zonas_pkey PRIMARY KEY (id);


--
-- Name: erp_ivatipos iva_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_ivatipos
    ADD CONSTRAINT iva_tipos_pkey PRIMARY KEY (id);


--
-- Name: erp_ivatipos iva_tipos_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_ivatipos
    ADD CONSTRAINT iva_tipos_titulo_key UNIQUE (titulo);


--
-- Name: erp_listasprecios_detallada listasprecios_detalladas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_listasprecios_detallada
    ADD CONSTRAINT listasprecios_detalladas_pkey PRIMARY KEY (id);


--
-- Name: erp_listasprecios listasprecios_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_listasprecios
    ADD CONSTRAINT listasprecios_pkey PRIMARY KEY (id);


--
-- Name: erp_listasprecios listasprecios_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_listasprecios
    ADD CONSTRAINT listasprecios_titulo_key UNIQUE (titulo);


--
-- Name: log_rutas_detalle_cobro log_rutas_detalle_cobro_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_rutas_detalle_cobro
    ADD CONSTRAINT log_rutas_detalle_cobro_pkey PRIMARY KEY (id);


--
-- Name: log_vehiculos log_vehiculos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_vehiculos
    ADD CONSTRAINT log_vehiculos_pkey PRIMARY KEY (id);


--
-- Name: erp_mascaras_para_validaciones_por_app mascaras_para_validaciones_por_app_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_mascaras_para_validaciones_por_app
    ADD CONSTRAINT mascaras_para_validaciones_por_app_pkey PRIMARY KEY (id);


--
-- Name: erp_monedas monedas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_monedas
    ADD CONSTRAINT monedas_pkey PRIMARY KEY (id);


--
-- Name: nom_periodos_conf nom_conf_periodo_pago_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_periodos_conf
    ADD CONSTRAINT nom_conf_periodo_pago_pkey PRIMARY KEY (id);


--
-- Name: nom_deduc nom_deduc_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_deduc
    ADD CONSTRAINT nom_deduc_pkey PRIMARY KEY (id);


--
-- Name: nom_deduc_tipo nom_deduc_tipo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_deduc_tipo
    ADD CONSTRAINT nom_deduc_tipo_pkey PRIMARY KEY (id);


--
-- Name: nom_percep nom_percep_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_percep
    ADD CONSTRAINT nom_percep_pkey PRIMARY KEY (id);


--
-- Name: nom_percep_tipo nom_percep_tipo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_percep_tipo
    ADD CONSTRAINT nom_percep_tipo_pkey PRIMARY KEY (id);


--
-- Name: nom_periodicidad_pago nom_periodicidad_pago_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_periodicidad_pago
    ADD CONSTRAINT nom_periodicidad_pago_pkey PRIMARY KEY (id);


--
-- Name: nom_periodos_conf_det nom_periodos_conf_det_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_periodos_conf_det
    ADD CONSTRAINT nom_periodos_conf_det_pkey PRIMARY KEY (id);


--
-- Name: nom_regimen_contratacion nom_regimen_contratacion_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_regimen_contratacion
    ADD CONSTRAINT nom_regimen_contratacion_pkey PRIMARY KEY (id);


--
-- Name: nom_riesgo_puesto nom_riesgo_puesto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_riesgo_puesto
    ADD CONSTRAINT nom_riesgo_puesto_pkey PRIMARY KEY (id);


--
-- Name: nom_tipo_contrato nom_tipo_contrato_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_tipo_contrato
    ADD CONSTRAINT nom_tipo_contrato_pkey PRIMARY KEY (id);


--
-- Name: nom_tipo_hrs_extra nom_tipo_hrs_extra_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_tipo_hrs_extra
    ADD CONSTRAINT nom_tipo_hrs_extra_pkey PRIMARY KEY (id);


--
-- Name: nom_tipo_incapacidad nom_tipo_incapacidad_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_tipo_incapacidad
    ADD CONSTRAINT nom_tipo_incapacidad_pkey PRIMARY KEY (id);


--
-- Name: nom_tipo_jornada nom_tipo_jornada_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_tipo_jornada
    ADD CONSTRAINT nom_tipo_jornada_pkey PRIMARY KEY (id);


--
-- Name: poc_cot_incoterms nombre_empresa; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_incoterms
    ADD CONSTRAINT nombre_empresa UNIQUE (nombre, gral_emp_id);


--
-- Name: erp_ordencompras ordencompras_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_ordencompras
    ADD CONSTRAINT ordencompras_pkey PRIMARY KEY (id);


--
-- Name: erp_parametros_generales parametros_generales_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_parametros_generales
    ADD CONSTRAINT parametros_generales_pkey PRIMARY KEY (id);


--
-- Name: erp_parametros_generales parametros_generales_variable_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_parametros_generales
    ADD CONSTRAINT parametros_generales_variable_key UNIQUE (variable);


--
-- Name: crm_par pk_crm_par; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_par
    ADD CONSTRAINT pk_crm_par PRIMARY KEY (gral_emp_id, gral_suc_id);


--
-- Name: crm_registro_proyecto_competidor pk_crm_registro_proyecto_competidor; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.crm_registro_proyecto_competidor
    ADD CONSTRAINT pk_crm_registro_proyecto_competidor PRIMARY KEY (id);


--
-- Name: ctb_cta_sat pk_ctb_cta_sat; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_cta_sat
    ADD CONSTRAINT pk_ctb_cta_sat PRIMARY KEY (id);


--
-- Name: poc_cot_clie poc_cot_clie_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_clie
    ADD CONSTRAINT poc_cot_clie_pkey PRIMARY KEY (id);


--
-- Name: poc_cot_condiciones_com poc_cot_condiciones_com_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_condiciones_com
    ADD CONSTRAINT poc_cot_condiciones_com_pkey PRIMARY KEY (id);


--
-- Name: poc_cot_detalle poc_cot_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_detalle
    ADD CONSTRAINT poc_cot_detalle_pkey PRIMARY KEY (id);


--
-- Name: poc_cot_incoterm_x_cot poc_cot_incoterm_x_cot_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_incoterm_x_cot
    ADD CONSTRAINT poc_cot_incoterm_x_cot_pkey PRIMARY KEY (id);


--
-- Name: poc_cot_incoterms poc_cot_incoterms_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_incoterms
    ADD CONSTRAINT poc_cot_incoterms_pkey PRIMARY KEY (id);


--
-- Name: poc_cot poc_cot_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot
    ADD CONSTRAINT poc_cot_pkey PRIMARY KEY (id);


--
-- Name: poc_cot_politicas_pago poc_cot_politicas_pago_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_politicas_pago
    ADD CONSTRAINT poc_cot_politicas_pago_pkey PRIMARY KEY (id);


--
-- Name: poc_cot_prospecto poc_cot_prospecto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_prospecto
    ADD CONSTRAINT poc_cot_prospecto_pkey PRIMARY KEY (id);


--
-- Name: poc_cot_saludo_despedida poc_cot_saludo_despedida_pago_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_cot_saludo_despedida
    ADD CONSTRAINT poc_cot_saludo_despedida_pago_pkey PRIMARY KEY (id);


--
-- Name: poc_ped_bo poc_ped_bo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_ped_bo
    ADD CONSTRAINT poc_ped_bo_pkey PRIMARY KEY (id);


--
-- Name: poc_ped_cot poc_ped_cot_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_ped_cot
    ADD CONSTRAINT poc_ped_cot_pkey PRIMARY KEY (id);


--
-- Name: poc_pedidos_detalle poc_pedidos_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_pedidos_detalle
    ADD CONSTRAINT poc_pedidos_detalle_pkey PRIMARY KEY (id);


--
-- Name: poc_pedidos poc_pedidos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.poc_pedidos
    ADD CONSTRAINT poc_pedidos_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_presentaciones presentaciones_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_presentaciones
    ADD CONSTRAINT presentaciones_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_pres_x_prod presentaciones_producto_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_pres_x_prod
    ADD CONSTRAINT presentaciones_producto_pkey PRIMARY KEY (id);


--
-- Name: pro_orden_prod pro_orden_prod_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pro_orden_prod
    ADD CONSTRAINT pro_orden_prod_pkey PRIMARY KEY (id);


--
-- Name: pro_ordenprod_invosal pro_ordenprod_invosal_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pro_ordenprod_invosal
    ADD CONSTRAINT pro_ordenprod_invosal_pkey PRIMARY KEY (id);


--
-- Name: pro_par pro_par_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pro_par
    ADD CONSTRAINT pro_par_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_grupos producto_grupos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_grupos
    ADD CONSTRAINT producto_grupos_pkey PRIMARY KEY (id);


--
-- Name: inv_prod_anterior productos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_anterior
    ADD CONSTRAINT productos_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov2 provedors_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov2
    ADD CONSTRAINT provedors_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_contactos proveedor_contactos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_contactos
    ADD CONSTRAINT proveedor_contactos_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_clases proveedor_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_clases
    ADD CONSTRAINT proveedor_tipos_pkey PRIMARY KEY (id);


--
-- Name: cxp_prov_clases proveedor_tipos_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov_clases
    ADD CONSTRAINT proveedor_tipos_titulo_key UNIQUE (titulo);


--
-- Name: erp_religions religions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_religions
    ADD CONSTRAINT religions_pkey PRIMARY KEY (id);


--
-- Name: erp_religions religions_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_religions
    ADD CONSTRAINT religions_titulo_key UNIQUE (titulo);


--
-- Name: log_rutas_detalle rutas_detalle_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_rutas_detalle
    ADD CONSTRAINT rutas_detalle_pkey PRIMARY KEY (id);


--
-- Name: log_rutas rutas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.log_rutas
    ADD CONSTRAINT rutas_pkey PRIMARY KEY (id);


--
-- Name: erp_sangretipos sangre_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_sangretipos
    ADD CONSTRAINT sangre_tipos_pkey PRIMARY KEY (id);


--
-- Name: erp_sangretipos sangre_tipos_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_sangretipos
    ADD CONSTRAINT sangre_tipos_titulo_key UNIQUE (titulo);


--
-- Name: tes_ban tes_ban_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_ban
    ADD CONSTRAINT tes_ban_pkey PRIMARY KEY (id);


--
-- Name: tes_che tes_che_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_che
    ADD CONSTRAINT tes_che_pkey PRIMARY KEY (id);


--
-- Name: tes_con tes_con_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_con
    ADD CONSTRAINT tes_con_pkey PRIMARY KEY (id);


--
-- Name: tes_mov tes_mov_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_mov
    ADD CONSTRAINT tes_mov_pkey PRIMARY KEY (id);


--
-- Name: tes_mov_tipos tes_mov_tipos_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_mov_tipos
    ADD CONSTRAINT tes_mov_tipos_pkey PRIMARY KEY (id);


--
-- Name: tes_num_che tes_num_che_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tes_num_che
    ADD CONSTRAINT tes_num_che_pkey PRIMARY KEY (id);


--
-- Name: erp_cotizacions_tipos tipo_cotizacions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_cotizacions_tipos
    ADD CONSTRAINT tipo_cotizacions_pkey PRIMARY KEY (id);


--
-- Name: erp_tipos_de_producto tipos_de_formulacion_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_tipos_de_producto
    ADD CONSTRAINT tipos_de_formulacion_pkey PRIMARY KEY (id);


--
-- Name: erp_tipos_de_producto tipos_de_formulacion_titulo_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_tipos_de_producto
    ADD CONSTRAINT tipos_de_formulacion_titulo_key UNIQUE (titulo);


--
-- Name: erp_tipos_de_traspaso tipos_de_traspaso_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_tipos_de_traspaso
    ADD CONSTRAINT tipos_de_traspaso_pkey PRIMARY KEY (id);


--
-- Name: ctb_pol_anios unik_ctb_pol_anios; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_anios
    ADD CONSTRAINT unik_ctb_pol_anios UNIQUE (gral_emp_id, anio);


--
-- Name: ctb_pol_cons unik_ctb_pol_cons; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_cons
    ADD CONSTRAINT unik_ctb_pol_cons UNIQUE (gral_emp_id, gral_suc_id, anio, mes, consecutivo);


--
-- Name: fac_cfdis unique_cfdis; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_cfdis
    ADD CONSTRAINT unique_cfdis UNIQUE (tipo, ref_id, gral_emp_id, gral_suc_id);


--
-- Name: ctb_cta_sat unique_ctb_cta_sat_codigo; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_cta_sat
    ADD CONSTRAINT unique_ctb_cta_sat_codigo UNIQUE (codigo);


--
-- Name: ctb_pol unique_ctb_pol; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol
    ADD CONSTRAINT unique_ctb_pol UNIQUE (gral_suc_id, ano, mes, poliza);


--
-- Name: gral_suc unique_emp_clave_suc; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc
    ADD CONSTRAINT unique_emp_clave_suc UNIQUE (empresa_id, clave, borrado_logico);


--
-- Name: gral_empleado_deduc unique_gral_empleado_deduc; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_deduc
    ADD CONSTRAINT unique_gral_empleado_deduc UNIQUE (gral_empleado_id, nom_deduc_id);


--
-- Name: gral_empleado_percep unique_gral_empleado_percep; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_percep
    ADD CONSTRAINT unique_gral_empleado_percep UNIQUE (gral_empleado_id, nom_percep_id);


--
-- Name: fac_par unique_gral_suc_cxc_mov_tipo; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_par
    ADD CONSTRAINT unique_gral_suc_cxc_mov_tipo UNIQUE (gral_suc_id, cxc_mov_tipo_id);


--
-- Name: cxp_ant_par unique_gral_suc_cxp_mov_tipo; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_ant_par
    ADD CONSTRAINT unique_gral_suc_cxp_mov_tipo UNIQUE (gral_suc_id, cxp_mov_tipo_id);


--
-- Name: gral_usr_suc unique_gral_usr_suc; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr_suc
    ADD CONSTRAINT unique_gral_usr_suc UNIQUE (gral_suc_id, gral_usr_id);


--
-- Name: gral_tc_url unique_institucion; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_tc_url
    ADD CONSTRAINT unique_institucion UNIQUE (institucion);


--
-- Name: inv_exi unique_inv_exi; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi
    ADD CONSTRAINT unique_inv_exi UNIQUE (inv_prod_id, inv_alm_id, ano);


--
-- Name: inv_exi_pres unique_inv_exi_pres; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi_pres
    ADD CONSTRAINT unique_inv_exi_pres UNIQUE (inv_alm_id, inv_prod_id, inv_prod_presentacion_id);


--
-- Name: inv_prod_cost_prom unique_inv_prod_cost_prom; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_cost_prom
    ADD CONSTRAINT unique_inv_prod_cost_prom UNIQUE (inv_prod_id, ano);


--
-- Name: inv_suc_alm unique_inv_suc_alm; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_suc_alm
    ADD CONSTRAINT unique_inv_suc_alm UNIQUE (almacen_id, sucursal_id);


--
-- Name: inv_lote unique_lote_int_alm; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote
    ADD CONSTRAINT unique_lote_int_alm UNIQUE (inv_alm_id, lote_int);


--
-- Name: fac_nomina_det unique_nomina_det_nominaid_empleadoid; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_det
    ADD CONSTRAINT unique_nomina_det_nominaid_empleadoid UNIQUE (fac_nomina_id, gral_empleado_id);


--
-- Name: gral_rol unique_rol_authority; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_rol
    ADD CONSTRAINT unique_rol_authority UNIQUE (authority);


--
-- Name: cxc_clie_adenda_tipo unique_titulo; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_adenda_tipo
    ADD CONSTRAINT unique_titulo UNIQUE (titulo);


--
-- Name: nom_deduc uniquenomdeduc_clave_emp; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_deduc
    ADD CONSTRAINT uniquenomdeduc_clave_emp UNIQUE (clave, gral_emp_id, borrado_logico);


--
-- Name: nom_percep uniquenompercep_clave_emp; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.nom_percep
    ADD CONSTRAINT uniquenompercep_clave_emp UNIQUE (clave, gral_emp_id, borrado_logico);


--
-- Name: fki_00034; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_00034 ON public.gral_edo USING btree (pais_id);


--
-- Name: fki_12314333; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_12314333 ON public.gral_suc_pza USING btree (sucursal_id);


--
-- Name: fki_345345; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_345345 ON public.com_doc_par USING btree (gral_suc_id);


--
-- Name: fki_34tre; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_34tre ON public.gral_plazas USING btree (empresa_id);


--
-- Name: fki_52542; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_52542 ON public.com_doc_par USING btree (inv_alm_id);


--
-- Name: fki_5354; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_5354 ON public.fac_cfds_conf_folios USING btree (fac_cfds_conf_id);


--
-- Name: fki_6756767; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_6756767 ON public.com_doc_par USING btree (cxp_mov_tipo_id);


--
-- Name: fki_905245; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_905245 ON public.gral_suc_pza USING btree (plaza_id);


--
-- Name: fki_emp_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_emp_id ON public.gral_suc USING btree (empresa_id);


--
-- Name: fki_empresa_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_empresa_id ON public.erp_parametros_generales USING btree (empresa_id);


--
-- Name: fki_fk-234243; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX "fki_fk-234243" ON public.gral_emp USING btree (pais_id);


--
-- Name: fki_fk-342352; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX "fki_fk-342352" ON public.cxc_clie USING btree (pais_id);


--
-- Name: fki_fk-3457856; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX "fki_fk-3457856" ON public.gral_emp USING btree (municipio_id);


--
-- Name: fki_fk-4234234; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX "fki_fk-4234234" ON public.gral_emp USING btree (estado_id);


--
-- Name: fki_fk-42376575; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX "fki_fk-42376575" ON public.gral_emp USING btree (estado_id);


--
-- Name: fki_fk-42435435; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX "fki_fk-42435435" ON public.gral_usr_suc USING btree (gral_usr_id);


--
-- Name: fki_fk-8656856; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX "fki_fk-8656856" ON public.gral_usr_suc USING btree (gral_suc_id);


--
-- Name: fki_fk76676776; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk76676776 ON public.cxc_clie USING btree (clasif_3);


--
-- Name: fki_fk8977; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk8977 ON public.cxp_prov USING btree (clasif_1);


--
-- Name: fki_yttr; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_yttr ON public.inv_pre USING btree (inv_prod_id);


--
-- Name: gral_suc_pza 12314333; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc_pza
    ADD CONSTRAINT "12314333" FOREIGN KEY (sucursal_id) REFERENCES public.gral_suc(id);


--
-- Name: com_doc_par 345345; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_doc_par
    ADD CONSTRAINT "345345" FOREIGN KEY (gral_suc_id) REFERENCES public.gral_suc(id);


--
-- Name: gral_plazas 34tre; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_plazas
    ADD CONSTRAINT "34tre" FOREIGN KEY (empresa_id) REFERENCES public.gral_emp(id);


--
-- Name: com_doc_par 52542; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_doc_par
    ADD CONSTRAINT "52542" FOREIGN KEY (inv_alm_id) REFERENCES public.inv_alm(id);


--
-- Name: com_doc_par 6756767; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.com_doc_par
    ADD CONSTRAINT "6756767" FOREIGN KEY (cxp_mov_tipo_id) REFERENCES public.cxp_mov_tipos(id);


--
-- Name: gral_suc_pza 905245; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc_pza
    ADD CONSTRAINT "905245" FOREIGN KEY (plaza_id) REFERENCES public.gral_plazas(id);


--
-- Name: cxc_clie2 clientes_cliente_tipo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie2
    ADD CONSTRAINT clientes_cliente_tipo_id_fkey FOREIGN KEY (clienttipo_id) REFERENCES public.cxc_clie_clases(id);


--
-- Name: cxc_clie clientes_cliente_tipo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie
    ADD CONSTRAINT clientes_cliente_tipo_id_fkey FOREIGN KEY (clienttipo_id) REFERENCES public.cxc_clie_clases(id);


--
-- Name: cxp_prov2 cxp_prov_cxp_prov_zon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov2
    ADD CONSTRAINT cxp_prov_cxp_prov_zon_id_fkey FOREIGN KEY (cxp_prov_zona_id) REFERENCES public.cxp_prov_zonas(id);


--
-- Name: cxp_prov cxp_prov_cxp_prov_zon_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov
    ADD CONSTRAINT cxp_prov_cxp_prov_zon_id_fkey FOREIGN KEY (cxp_prov_zona_id) REFERENCES public.cxp_prov_zonas(id);


--
-- Name: erp_monedavers denominacion_vers_denominacion_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_monedavers
    ADD CONSTRAINT denominacion_vers_denominacion_id_fkey FOREIGN KEY (moneda_id) REFERENCES public.erp_monedas(id);


--
-- Name: erp_emails emails_empleado_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_emails
    ADD CONSTRAINT emails_empleado_id_fkey FOREIGN KEY (empleado_id) REFERENCES public.erp_empleados(id);


--
-- Name: gral_emp fk-234243; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp
    ADD CONSTRAINT "fk-234243" FOREIGN KEY (pais_id) REFERENCES public.gral_pais(id);


--
-- Name: inv_exi fk-3245345; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi
    ADD CONSTRAINT "fk-3245345" FOREIGN KEY (inv_prod_id) REFERENCES public.inv_prod(id);


--
-- Name: cxc_clie2 fk-342352; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie2
    ADD CONSTRAINT "fk-342352" FOREIGN KEY (pais_id) REFERENCES public.gral_pais(id);


--
-- Name: cxc_clie fk-342352; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie
    ADD CONSTRAINT "fk-342352" FOREIGN KEY (pais_id) REFERENCES public.gral_pais(id);


--
-- Name: gral_emp fk-3457856; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp
    ADD CONSTRAINT "fk-3457856" FOREIGN KEY (municipio_id) REFERENCES public.gral_mun(id);


--
-- Name: inv_lote fk-354532; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote
    ADD CONSTRAINT "fk-354532" FOREIGN KEY (inv_prod_id) REFERENCES public.inv_prod(id);


--
-- Name: inv_prod_cost_prom fk-354532; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_cost_prom
    ADD CONSTRAINT "fk-354532" FOREIGN KEY (inv_prod_id) REFERENCES public.inv_prod(id);


--
-- Name: inv_exi_pres fk-354532; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi_pres
    ADD CONSTRAINT "fk-354532" FOREIGN KEY (inv_prod_id) REFERENCES public.inv_prod(id);


--
-- Name: gral_emp fk-4234234; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp
    ADD CONSTRAINT "fk-4234234" FOREIGN KEY (estado_id) REFERENCES public.gral_edo(id);


--
-- Name: gral_usr_suc fk-42435435; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr_suc
    ADD CONSTRAINT "fk-42435435" FOREIGN KEY (gral_usr_id) REFERENCES public.gral_usr(id);


--
-- Name: gral_usr_suc fk-8656856; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr_suc
    ADD CONSTRAINT "fk-8656856" FOREIGN KEY (gral_suc_id) REFERENCES public.gral_suc(id);


--
-- Name: inv_mov fk0009; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mov
    ADD CONSTRAINT fk0009 FOREIGN KEY (gral_app_id) REFERENCES public.gral_app(id);


--
-- Name: cxc_clie2 fk76676776; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie2
    ADD CONSTRAINT fk76676776 FOREIGN KEY (clasif_3) REFERENCES public.cxc_clie_clas3(id);


--
-- Name: cxc_clie fk76676776; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie
    ADD CONSTRAINT fk76676776 FOREIGN KEY (clasif_3) REFERENCES public.cxc_clie_clas3(id);


--
-- Name: cxc_clie2 fk76676777; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie2
    ADD CONSTRAINT fk76676777 FOREIGN KEY (clasif_2) REFERENCES public.cxc_clie_clas2(id);


--
-- Name: cxc_clie fk76676777; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie
    ADD CONSTRAINT fk76676777 FOREIGN KEY (clasif_2) REFERENCES public.cxc_clie_clas2(id);


--
-- Name: cxp_prov2 fk8970a; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov2
    ADD CONSTRAINT fk8970a FOREIGN KEY (clasif_3) REFERENCES public.cxp_prov_clas3(id);


--
-- Name: cxp_prov fk8970a; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov
    ADD CONSTRAINT fk8970a FOREIGN KEY (clasif_3) REFERENCES public.cxp_prov_clas3(id);


--
-- Name: cxp_prov2 fk8970b; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov2
    ADD CONSTRAINT fk8970b FOREIGN KEY (clasif_2) REFERENCES public.cxp_prov_clas2(id);


--
-- Name: cxp_prov fk8970b; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov
    ADD CONSTRAINT fk8970b FOREIGN KEY (clasif_2) REFERENCES public.cxp_prov_clas2(id);


--
-- Name: cxp_prov2 fk8970c; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov2
    ADD CONSTRAINT fk8970c FOREIGN KEY (clasif_1) REFERENCES public.cxp_prov_clas1(id);


--
-- Name: cxp_prov fk8970c; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov
    ADD CONSTRAINT fk8970c FOREIGN KEY (clasif_1) REFERENCES public.cxp_prov_clas1(id);


--
-- Name: cxp_prov2 fk8970x; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov2
    ADD CONSTRAINT fk8970x FOREIGN KEY (dias_credito_id) REFERENCES public.cxp_prov_credias(id);


--
-- Name: cxp_prov fk8970x; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov
    ADD CONSTRAINT fk8970x FOREIGN KEY (dias_credito_id) REFERENCES public.cxp_prov_credias(id);


--
-- Name: gral_impto_cta fk_000001; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_impto_cta
    ADD CONSTRAINT fk_000001 FOREIGN KEY (gral_impto_id) REFERENCES public.gral_imptos(id);


--
-- Name: gral_impto_cta fk_000002; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_impto_cta
    ADD CONSTRAINT fk_000002 FOREIGN KEY (ctb_cta_id) REFERENCES public.ctb_cta(id);


--
-- Name: gral_impto_ret_cta fk_000003; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_impto_ret_cta
    ADD CONSTRAINT fk_000003 FOREIGN KEY (gral_impto_ret_id) REFERENCES public.gral_imptos(id);


--
-- Name: gral_impto_ret_cta fk_000004; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_impto_ret_cta
    ADD CONSTRAINT fk_000004 FOREIGN KEY (ctb_cta_id) REFERENCES public.ctb_cta(id);


--
-- Name: gral_ieps_cta fk_000005; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_ieps_cta
    ADD CONSTRAINT fk_000005 FOREIGN KEY (gral_ieps_id) REFERENCES public.gral_imptos(id);


--
-- Name: gral_ieps_cta fk_000006; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_ieps_cta
    ADD CONSTRAINT fk_000006 FOREIGN KEY (ctb_cta_id) REFERENCES public.ctb_cta(id);


--
-- Name: gral_edo fk_00034; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_edo
    ADD CONSTRAINT fk_00034 FOREIGN KEY (pais_id) REFERENCES public.gral_pais(id);


--
-- Name: fac_cfds_conf_folios fk_5354; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_cfds_conf_folios
    ADD CONSTRAINT fk_5354 FOREIGN KEY (fac_cfds_conf_id) REFERENCES public.fac_cfds_conf(id);


--
-- Name: inv_suc_alm fk_alm00001; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_suc_alm
    ADD CONSTRAINT fk_alm00001 FOREIGN KEY (almacen_id) REFERENCES public.inv_alm(id);


--
-- Name: cxc_clie_descto fk_clie_descto_clie_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxc_clie_descto
    ADD CONSTRAINT fk_clie_descto_clie_id FOREIGN KEY (cxc_clie_id) REFERENCES public.cxc_clie(id);


--
-- Name: ctb_app fk_ctb_app_gral_app_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_app
    ADD CONSTRAINT fk_ctb_app_gral_app_id FOREIGN KEY (gral_app_id) REFERENCES public.gral_app(id);


--
-- Name: ctb_pol_mov fk_ctb_cta_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_mov
    ADD CONSTRAINT fk_ctb_cta_id FOREIGN KEY (ctb_cta_id) REFERENCES public.ctb_cta(id);


--
-- Name: ctb_pol fk_ctb_pol_concepto; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol
    ADD CONSTRAINT fk_ctb_pol_concepto FOREIGN KEY (ctb_con_id) REFERENCES public.ctb_con(id);


--
-- Name: ctb_pol fk_ctb_pol_gral_mon_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol
    ADD CONSTRAINT fk_ctb_pol_gral_mon_id FOREIGN KEY (gral_mon_id) REFERENCES public.gral_mon(id);


--
-- Name: ctb_pol_mov fk_ctb_pol_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol_mov
    ADD CONSTRAINT fk_ctb_pol_id FOREIGN KEY (ctb_pol_id) REFERENCES public.ctb_pol(id);


--
-- Name: ctb_pol fk_ctb_pol_sucursal; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol
    ADD CONSTRAINT fk_ctb_pol_sucursal FOREIGN KEY (gral_suc_id) REFERENCES public.gral_suc(id);


--
-- Name: ctb_pol fk_ctb_pol_tipo; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_pol
    ADD CONSTRAINT fk_ctb_pol_tipo FOREIGN KEY (ctb_tpol_id) REFERENCES public.ctb_tpol(id);


--
-- Name: gral_suc fk_emp_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc
    ADD CONSTRAINT fk_emp_id FOREIGN KEY (empresa_id) REFERENCES public.gral_emp(id);


--
-- Name: gral_empleado_percep fk_empleado_00001; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_percep
    ADD CONSTRAINT fk_empleado_00001 FOREIGN KEY (gral_empleado_id) REFERENCES public.gral_empleados(id);


--
-- Name: gral_empleado_deduc fk_empleado_00002; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_deduc
    ADD CONSTRAINT fk_empleado_00002 FOREIGN KEY (gral_empleado_id) REFERENCES public.gral_empleados(id);


--
-- Name: fac_cfds_conf fk_empresa__id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_cfds_conf
    ADD CONSTRAINT fk_empresa__id FOREIGN KEY (empresa_id) REFERENCES public.gral_emp(id);


--
-- Name: erp_parametros_generales fk_empresa_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_parametros_generales
    ADD CONSTRAINT fk_empresa_id FOREIGN KEY (empresa_id) REFERENCES public.gral_emp(id);


--
-- Name: gral_cons fk_gral_emp_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_cons
    ADD CONSTRAINT fk_gral_emp_id FOREIGN KEY (gral_emp_id) REFERENCES public.gral_emp(id);


--
-- Name: gral_emp_leyenda fk_gral_emp_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp_leyenda
    ADD CONSTRAINT fk_gral_emp_id FOREIGN KEY (gral_emp_id) REFERENCES public.gral_emp(id);


--
-- Name: gral_emails fk_gral_emp_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emails
    ADD CONSTRAINT fk_gral_emp_id FOREIGN KEY (gral_emp_id) REFERENCES public.gral_emp(id);


--
-- Name: gral_emp fk_gral_impto_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emp
    ADD CONSTRAINT fk_gral_impto_id FOREIGN KEY (gral_impto_id) REFERENCES public.gral_imptos(id);


--
-- Name: cxp_ant_par fk_gral_suc; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_ant_par
    ADD CONSTRAINT fk_gral_suc FOREIGN KEY (gral_suc_id) REFERENCES public.gral_suc(id);


--
-- Name: fac_par fk_gral_suc; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_par
    ADD CONSTRAINT fk_gral_suc FOREIGN KEY (gral_suc_id) REFERENCES public.gral_suc(id);


--
-- Name: fac_nomina_par fk_gral_suc; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.fac_nomina_par
    ADD CONSTRAINT fk_gral_suc FOREIGN KEY (gral_suc_id) REFERENCES public.gral_suc(id);


--
-- Name: gral_cons fk_gral_suc_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_cons
    ADD CONSTRAINT fk_gral_suc_id FOREIGN KEY (gral_suc_id) REFERENCES public.gral_suc(id);


--
-- Name: gral_emails fk_gral_suc_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_emails
    ADD CONSTRAINT fk_gral_suc_id FOREIGN KEY (gral_suc_id) REFERENCES public.gral_suc(id);


--
-- Name: inv_fac fk_inv_fac_etiqueta_fac_doc_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_fac
    ADD CONSTRAINT fk_inv_fac_etiqueta_fac_doc_id FOREIGN KEY (fac_doc_id) REFERENCES public.fac_docs(id);


--
-- Name: inv_lote_detalle fk_lote; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_detalle
    ADD CONSTRAINT fk_lote FOREIGN KEY (inv_lote_id) REFERENCES public.inv_lote(id);


--
-- Name: inv_lote_mov_det fk_lote; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_lote_mov_det
    ADD CONSTRAINT fk_lote FOREIGN KEY (inv_lote_id) REFERENCES public.inv_lote(id);


--
-- Name: gral_empleado_deduc fk_nom_deduc_00001; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_deduc
    ADD CONSTRAINT fk_nom_deduc_00001 FOREIGN KEY (nom_deduc_id) REFERENCES public.nom_deduc(id);


--
-- Name: gral_empleado_percep fk_nom_percep_00001; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_empleado_percep
    ADD CONSTRAINT fk_nom_percep_00001 FOREIGN KEY (nom_percep_id) REFERENCES public.nom_percep(id);


--
-- Name: inv_exi_pres fk_pres_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi_pres
    ADD CONSTRAINT fk_pres_id FOREIGN KEY (inv_prod_presentacion_id) REFERENCES public.inv_prod_presentaciones(id);


--
-- Name: ctb_may fk_retyrew; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ctb_may
    ADD CONSTRAINT fk_retyrew FOREIGN KEY (ctb_may_clase_id) REFERENCES public.ctb_may_clases(id);


--
-- Name: gral_usr_rol fk_rol; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr_rol
    ADD CONSTRAINT fk_rol FOREIGN KEY (gral_rol_id) REFERENCES public.gral_rol(id);


--
-- Name: inv_suc_alm fk_suc00001; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_suc_alm
    ADD CONSTRAINT fk_suc00001 FOREIGN KEY (sucursal_id) REFERENCES public.gral_suc(id);


--
-- Name: gral_suc fk_suc_gral_impto_id; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_suc
    ADD CONSTRAINT fk_suc_gral_impto_id FOREIGN KEY (gral_impto_id) REFERENCES public.gral_imptos(id);


--
-- Name: gral_usr_rol fk_usr; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_usr_rol
    ADD CONSTRAINT fk_usr FOREIGN KEY (gral_usr_id) REFERENCES public.gral_usr(id);


--
-- Name: inv_mov_detalle fkeowire; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mov_detalle
    ADD CONSTRAINT fkeowire FOREIGN KEY (inv_mov_id) REFERENCES public.inv_mov(id);


--
-- Name: inv_mov fkrwfdfs43; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_mov
    ADD CONSTRAINT fkrwfdfs43 FOREIGN KEY (gral_usr_id) REFERENCES public.gral_usr(id);


--
-- Name: gral_ano_fiscal gral_ano_fis_sucursal_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.gral_ano_fiscal
    ADD CONSTRAINT gral_ano_fis_sucursal_id_fkey FOREIGN KEY (sucursal_id) REFERENCES public.gral_suc(id);


--
-- Name: inv_exi inv_exi_inv_alm_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi
    ADD CONSTRAINT inv_exi_inv_alm_id_fkey FOREIGN KEY (inv_alm_id) REFERENCES public.inv_alm(id);


--
-- Name: inv_exi_pres inv_exi_inv_alm_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_exi_pres
    ADD CONSTRAINT inv_exi_inv_alm_id_fkey FOREIGN KEY (inv_alm_id) REFERENCES public.inv_alm(id);


--
-- Name: inv_prod_lineas inv_prod_lineas_inv_seccion_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_lineas
    ADD CONSTRAINT inv_prod_lineas_inv_seccion_id_fkey FOREIGN KEY (inv_seccion_id) REFERENCES public.inv_secciones(id);


--
-- Name: inv_prod inv_prod_tipo_de_producto_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod
    ADD CONSTRAINT inv_prod_tipo_de_producto_id_fkey FOREIGN KEY (tipo_de_producto_id) REFERENCES public.inv_prod_tipos(id);


--
-- Name: inv_prod_unidades inv_prod_unidades_cfdi_unidad_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_unidades
    ADD CONSTRAINT inv_prod_unidades_cfdi_unidad_id_fkey FOREIGN KEY (cfdi_unidad_id) REFERENCES public.cfdi_claveunidad(id);


--
-- Name: erp_listasprecios_detallada listasprecios_detalladas_listasprecios_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.erp_listasprecios_detallada
    ADD CONSTRAINT listasprecios_detalladas_listasprecios_id_fkey FOREIGN KEY (listasprecios_id) REFERENCES public.erp_listasprecios(id);


--
-- Name: inv_prod_anterior productos_tipo_de_producto_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_prod_anterior
    ADD CONSTRAINT productos_tipo_de_producto_id_fkey FOREIGN KEY (tipo_de_producto_id) REFERENCES public.erp_tipos_de_producto(id);


--
-- Name: cxp_prov2 proveedors_proveedortipo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov2
    ADD CONSTRAINT proveedors_proveedortipo_id_fkey FOREIGN KEY (proveedortipo_id) REFERENCES public.cxp_prov_clases(id);


--
-- Name: cxp_prov proveedors_proveedortipo_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.cxp_prov
    ADD CONSTRAINT proveedors_proveedortipo_id_fkey FOREIGN KEY (proveedortipo_id) REFERENCES public.cxp_prov_clases(id);


--
-- Name: inv_pre yttr; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_pre
    ADD CONSTRAINT yttr FOREIGN KEY (inv_prod_id) REFERENCES public.inv_prod(id);


--
-- Name: inv_com yttx; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.inv_com
    ADD CONSTRAINT yttx FOREIGN KEY (inv_prod_id) REFERENCES public.inv_prod_anterior(id);


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: -
--

REVOKE ALL ON SCHEMA public FROM rdsadmin;
REVOKE ALL ON SCHEMA public FROM PUBLIC;
GRANT ALL ON SCHEMA public TO kemikal;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- PostgreSQL database dump complete
--

